/*
 * Copyright 2020 RA Consulting
 *
 * RA Consulting GmbH licenses this file under the Apache License, 
 * Version 2.0 (the "License"); you may not use this file except 
 * in compliance with the License. 
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 
#include "ApiClassImplV1_2.h"
#include "OscConstantsV1_2.h"
#include "FileContentMessage.h"
#include "IOpenScenarioModelElement.h"
#include "ErrorLevel.h"
#include "NamedReferenceProxy.h"

namespace NET_ASAM_OPENSCENARIO
{
    namespace v1_2
    {

        IOpenScenarioFlexElement* AbsoluteSpeedImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double AbsoluteSpeedImpl::GetValue() const
        {
        	  return _value;
        }
        std::shared_ptr<ISteadyState> AbsoluteSpeedImpl::GetSteadyState() const
        {
        	  return _steadyState;
        }


        void AbsoluteSpeedImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        void AbsoluteSpeedImpl::SetSteadyState(std::shared_ptr<ISteadyStateWriter> steadyState)
        {
            _steadyState = steadyState;
			// set the indicator to true
            isSetSteadyState = true;          
        }

        std::shared_ptr<void> AbsoluteSpeedImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(AbsoluteSpeedImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAbsoluteSpeed).name())
                return std::dynamic_pointer_cast<IAbsoluteSpeed>(shared_from_this());
            else if (classifier == typeid(IAbsoluteSpeedWriter).name())
                return std::dynamic_pointer_cast<IAbsoluteSpeedWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> AbsoluteSpeedImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t AbsoluteSpeedImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int AbsoluteSpeedImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double AbsoluteSpeedImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t AbsoluteSpeedImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool AbsoluteSpeedImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime AbsoluteSpeedImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> AbsoluteSpeedImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string AbsoluteSpeedImpl::GetModelType() const
        {
            return "AbsoluteSpeed";
        }

        void AbsoluteSpeedImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string AbsoluteSpeedImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool AbsoluteSpeedImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<ISteadyStateWriter> AbsoluteSpeedImpl::GetWriterSteadyState() const
        {
            return std::dynamic_pointer_cast<ISteadyStateWriter>(_steadyState);
        }

        AbsoluteSpeedImpl::AbsoluteSpeedImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void AbsoluteSpeedImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType AbsoluteSpeedImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AbsoluteSpeedImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kSteadyState =  GetWriterSteadyState();
                if (kSteadyState)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSteadyState));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AbsoluteSpeedImpl::Clone()
        {
            auto clonedObject = std::make_shared<AbsoluteSpeedImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            const auto kSteadyState =  GetWriterSteadyState();
            if (kSteadyState)
            {
                auto clonedChild = std::dynamic_pointer_cast<SteadyStateImpl>(kSteadyState)->Clone();
                auto clonedChildISteadyState = std::dynamic_pointer_cast<ISteadyState>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSteadyState(std::dynamic_pointer_cast<ISteadyStateWriter>(clonedChildISteadyState));
            }
            return clonedObject;
        }

        std::string AbsoluteSpeedImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AbsoluteSpeedImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__STEADY_STATE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSteadyState());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AbsoluteSpeedImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AbsoluteSpeedImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AbsoluteSpeedImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void AbsoluteSpeedImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void AbsoluteSpeedImpl::ResetSteadyState()
	   {
	   		isSetSteadyState = false; 
			_steadyState = {};
			
	   }
       bool AbsoluteSpeedImpl::IsSetSteadyState() const
	   {
			return isSetSteadyState;
	   }

        IOpenScenarioFlexElement* AbsoluteTargetLaneImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string AbsoluteTargetLaneImpl::GetValue() const
        {
        	  return _value;
        }


        void AbsoluteTargetLaneImpl::SetValue(const std::string value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> AbsoluteTargetLaneImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(AbsoluteTargetLaneImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAbsoluteTargetLane).name())
                return std::dynamic_pointer_cast<IAbsoluteTargetLane>(shared_from_this());
            else if (classifier == typeid(IAbsoluteTargetLaneWriter).name())
                return std::dynamic_pointer_cast<IAbsoluteTargetLaneWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> AbsoluteTargetLaneImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t AbsoluteTargetLaneImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int AbsoluteTargetLaneImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double AbsoluteTargetLaneImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t AbsoluteTargetLaneImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool AbsoluteTargetLaneImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime AbsoluteTargetLaneImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> AbsoluteTargetLaneImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string AbsoluteTargetLaneImpl::GetModelType() const
        {
            return "AbsoluteTargetLane";
        }

        void AbsoluteTargetLaneImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string AbsoluteTargetLaneImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool AbsoluteTargetLaneImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        AbsoluteTargetLaneImpl::AbsoluteTargetLaneImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
        }

        void AbsoluteTargetLaneImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType AbsoluteTargetLaneImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AbsoluteTargetLaneImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AbsoluteTargetLaneImpl::Clone()
        {
            auto clonedObject = std::make_shared<AbsoluteTargetLaneImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string AbsoluteTargetLaneImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AbsoluteTargetLaneImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AbsoluteTargetLaneImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AbsoluteTargetLaneImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AbsoluteTargetLaneImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void AbsoluteTargetLaneImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* AbsoluteTargetLaneOffsetImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double AbsoluteTargetLaneOffsetImpl::GetValue() const
        {
        	  return _value;
        }


        void AbsoluteTargetLaneOffsetImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> AbsoluteTargetLaneOffsetImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(AbsoluteTargetLaneOffsetImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAbsoluteTargetLaneOffset).name())
                return std::dynamic_pointer_cast<IAbsoluteTargetLaneOffset>(shared_from_this());
            else if (classifier == typeid(IAbsoluteTargetLaneOffsetWriter).name())
                return std::dynamic_pointer_cast<IAbsoluteTargetLaneOffsetWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> AbsoluteTargetLaneOffsetImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t AbsoluteTargetLaneOffsetImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int AbsoluteTargetLaneOffsetImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double AbsoluteTargetLaneOffsetImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t AbsoluteTargetLaneOffsetImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool AbsoluteTargetLaneOffsetImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime AbsoluteTargetLaneOffsetImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> AbsoluteTargetLaneOffsetImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string AbsoluteTargetLaneOffsetImpl::GetModelType() const
        {
            return "AbsoluteTargetLaneOffset";
        }

        void AbsoluteTargetLaneOffsetImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string AbsoluteTargetLaneOffsetImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool AbsoluteTargetLaneOffsetImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        AbsoluteTargetLaneOffsetImpl::AbsoluteTargetLaneOffsetImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void AbsoluteTargetLaneOffsetImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType AbsoluteTargetLaneOffsetImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AbsoluteTargetLaneOffsetImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AbsoluteTargetLaneOffsetImpl::Clone()
        {
            auto clonedObject = std::make_shared<AbsoluteTargetLaneOffsetImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string AbsoluteTargetLaneOffsetImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AbsoluteTargetLaneOffsetImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AbsoluteTargetLaneOffsetImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AbsoluteTargetLaneOffsetImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AbsoluteTargetLaneOffsetImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void AbsoluteTargetLaneOffsetImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* AbsoluteTargetSpeedImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double AbsoluteTargetSpeedImpl::GetValue() const
        {
        	  return _value;
        }


        void AbsoluteTargetSpeedImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> AbsoluteTargetSpeedImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(AbsoluteTargetSpeedImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAbsoluteTargetSpeed).name())
                return std::dynamic_pointer_cast<IAbsoluteTargetSpeed>(shared_from_this());
            else if (classifier == typeid(IAbsoluteTargetSpeedWriter).name())
                return std::dynamic_pointer_cast<IAbsoluteTargetSpeedWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> AbsoluteTargetSpeedImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t AbsoluteTargetSpeedImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int AbsoluteTargetSpeedImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double AbsoluteTargetSpeedImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t AbsoluteTargetSpeedImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool AbsoluteTargetSpeedImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime AbsoluteTargetSpeedImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> AbsoluteTargetSpeedImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string AbsoluteTargetSpeedImpl::GetModelType() const
        {
            return "AbsoluteTargetSpeed";
        }

        void AbsoluteTargetSpeedImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string AbsoluteTargetSpeedImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool AbsoluteTargetSpeedImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        AbsoluteTargetSpeedImpl::AbsoluteTargetSpeedImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void AbsoluteTargetSpeedImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType AbsoluteTargetSpeedImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AbsoluteTargetSpeedImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AbsoluteTargetSpeedImpl::Clone()
        {
            auto clonedObject = std::make_shared<AbsoluteTargetSpeedImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string AbsoluteTargetSpeedImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AbsoluteTargetSpeedImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AbsoluteTargetSpeedImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AbsoluteTargetSpeedImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AbsoluteTargetSpeedImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void AbsoluteTargetSpeedImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* AccelerationConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        DirectionalDimension AccelerationConditionImpl::GetDirection() const
        {
        	  return _direction;
        }
        Rule AccelerationConditionImpl::GetRule() const
        {
        	  return _rule;
        }
        double AccelerationConditionImpl::GetValue() const
        {
        	  return _value;
        }


        void AccelerationConditionImpl::SetDirection(const DirectionalDimension direction)
        {
            _direction = direction;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DIRECTION);
			// set the indicator to true
            isSetDirection = true;          
        }

        void AccelerationConditionImpl::SetRule(const Rule rule)
        {
            _rule = rule;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE);
        }

        void AccelerationConditionImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> AccelerationConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(AccelerationConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAccelerationCondition).name())
                return std::dynamic_pointer_cast<IAccelerationCondition>(shared_from_this());
            else if (classifier == typeid(IAccelerationConditionWriter).name())
                return std::dynamic_pointer_cast<IAccelerationConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> AccelerationConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t AccelerationConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int AccelerationConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double AccelerationConditionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t AccelerationConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool AccelerationConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime AccelerationConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> AccelerationConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string AccelerationConditionImpl::GetModelType() const
        {
            return "AccelerationCondition";
        }

        void AccelerationConditionImpl::WriteParameterToDirection(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DIRECTION, parameterName, nullTextMarker /*no textmarker*/);
            _direction = {};
        }

        void AccelerationConditionImpl::WriteParameterToRule(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE, parameterName, nullTextMarker /*no textmarker*/);
            _rule = {};
        }

        void AccelerationConditionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string AccelerationConditionImpl::GetParameterFromDirection() const
        {
            auto direction = OSC_CONSTANTS::ATTRIBUTE__DIRECTION;
            return GetParameterNameFromAttribute(direction);
        }

        std::string AccelerationConditionImpl::GetParameterFromRule() const
        {
            auto rule = OSC_CONSTANTS::ATTRIBUTE__RULE;
            return GetParameterNameFromAttribute(rule);
        }

        std::string AccelerationConditionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool AccelerationConditionImpl::IsDirectionParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DIRECTION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool AccelerationConditionImpl::IsRuleParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RULE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool AccelerationConditionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        AccelerationConditionImpl::AccelerationConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DIRECTION, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void AccelerationConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DIRECTION)
            {
                // Enumeration Type
                const auto kResult = DirectionalDimension::GetFromLiteral(parameterLiteralValue);
                if (kResult != DirectionalDimension::UNKNOWN)
                {
                    _direction = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType AccelerationConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AccelerationConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AccelerationConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<AccelerationConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kDirection = GetDirection();
            if ( kDirection.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_direction = DirectionalDimension::GetFromLiteral(kDirection.GetLiteral());
            }
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            	clonedObject->isSetDirection = isSetDirection;
            // clone children
            return clonedObject;
        }

        std::string AccelerationConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AccelerationConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AccelerationConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AccelerationConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AccelerationConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__DIRECTION)
            {
                auto direction = GetDirection();
                return direction.GetLiteral() != "UNKNOWN" ? direction.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void AccelerationConditionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void AccelerationConditionImpl::ResetDirection()
	   {
	   		isSetDirection = false; 
			_direction = {};
			
	   }
       bool AccelerationConditionImpl::IsSetDirection() const
	   {
			return isSetDirection;
	   }

        IOpenScenarioFlexElement* AcquirePositionActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IPosition> AcquirePositionActionImpl::GetPosition() const
        {
        	  return _position;
        }


        void AcquirePositionActionImpl::SetPosition(std::shared_ptr<IPositionWriter> position)
        {
            _position = position;
        }

        std::shared_ptr<void> AcquirePositionActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(AcquirePositionActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAcquirePositionAction).name())
                return std::dynamic_pointer_cast<IAcquirePositionAction>(shared_from_this());
            else if (classifier == typeid(IAcquirePositionActionWriter).name())
                return std::dynamic_pointer_cast<IAcquirePositionActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> AcquirePositionActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t AcquirePositionActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int AcquirePositionActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double AcquirePositionActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t AcquirePositionActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool AcquirePositionActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime AcquirePositionActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> AcquirePositionActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string AcquirePositionActionImpl::GetModelType() const
        {
            return "AcquirePositionAction";
        }

            // children
        std::shared_ptr<IPositionWriter> AcquirePositionActionImpl::GetWriterPosition() const
        {
            return std::dynamic_pointer_cast<IPositionWriter>(_position);
        }

        AcquirePositionActionImpl::AcquirePositionActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void AcquirePositionActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType AcquirePositionActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AcquirePositionActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AcquirePositionActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<AcquirePositionActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            return clonedObject;
        }

        std::string AcquirePositionActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AcquirePositionActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AcquirePositionActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AcquirePositionActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AcquirePositionActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ActImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string ActImpl::GetName() const
        {
        	  return _name;
        }
        std::vector<std::shared_ptr<IManeuverGroup>> ActImpl::GetManeuverGroups() const
        {
            std::vector<std::shared_ptr<IManeuverGroup>> temp;
            for(auto&& elm: _maneuverGroups)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IManeuverGroupWriter>> ActImpl::GetWriterManeuverGroups() const
        {
            return _maneuverGroups;
        }

        int ActImpl::GetManeuverGroupsSize() const
        {
            return static_cast<int>(_maneuverGroups.size());
        }

        std::shared_ptr<IManeuverGroup> ActImpl::GetManeuverGroupsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _maneuverGroups.size() > index)
            {
                return _maneuverGroups[index];
            }
            return nullptr;
        }
        std::shared_ptr<ITrigger> ActImpl::GetStartTrigger() const
        {
        	  return _startTrigger;
        }
        std::shared_ptr<ITrigger> ActImpl::GetStopTrigger() const
        {
        	  return _stopTrigger;
        }


        void ActImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void ActImpl::SetManeuverGroups(std::vector<std::shared_ptr<IManeuverGroupWriter>>& maneuverGroups)
        {
            _maneuverGroups = maneuverGroups;
        }

        void ActImpl::SetStartTrigger(std::shared_ptr<ITriggerWriter> startTrigger)
        {
            _startTrigger = startTrigger;
        }

        void ActImpl::SetStopTrigger(std::shared_ptr<ITriggerWriter> stopTrigger)
        {
            _stopTrigger = stopTrigger;
			// set the indicator to true
            isSetStopTrigger = true;          
        }

        std::shared_ptr<void> ActImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ActImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAct).name())
                return std::dynamic_pointer_cast<IAct>(shared_from_this());
            else if (classifier == typeid(IActWriter).name())
                return std::dynamic_pointer_cast<IActWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ActImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ActImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ActImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ActImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ActImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ActImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ActImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ActImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ActImpl::GetModelType() const
        {
            return "Act";
        }

        void ActImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        std::string ActImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        bool ActImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<ITriggerWriter> ActImpl::GetWriterStartTrigger() const
        {
            return std::dynamic_pointer_cast<ITriggerWriter>(_startTrigger);
        }
        std::shared_ptr<ITriggerWriter> ActImpl::GetWriterStopTrigger() const
        {
            return std::dynamic_pointer_cast<ITriggerWriter>(_stopTrigger);
        }

        ActImpl::ActImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        void ActImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ActImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ActImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto maneuverGroups =  GetWriterManeuverGroups();
                if (!maneuverGroups.empty())
                {
                    for(auto&& item : maneuverGroups)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kStartTrigger =  GetWriterStartTrigger();
                if (kStartTrigger)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kStartTrigger));
                }
                const auto kStopTrigger =  GetWriterStopTrigger();
                if (kStopTrigger)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kStopTrigger));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ActImpl::Clone()
        {
            auto clonedObject = std::make_shared<ActImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone indicators
            // clone children
            const auto kManeuverGroups =  GetWriterManeuverGroups();
            if (!kManeuverGroups.empty())
            {
                std::vector<std::shared_ptr<IManeuverGroupWriter>> clonedList;
                for(auto&& kItem : kManeuverGroups)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ManeuverGroupImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IManeuverGroupWriter>(clonedChild));
                }
                clonedObject->SetManeuverGroups(clonedList);
            }
            const auto kStartTrigger =  GetWriterStartTrigger();
            if (kStartTrigger)
            {
                auto clonedChild = std::dynamic_pointer_cast<TriggerImpl>(kStartTrigger)->Clone();
                auto clonedChildITrigger = std::dynamic_pointer_cast<ITrigger>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetStartTrigger(std::dynamic_pointer_cast<ITriggerWriter>(clonedChildITrigger));
            }
            const auto kStopTrigger =  GetWriterStopTrigger();
            if (kStopTrigger)
            {
                auto clonedChild = std::dynamic_pointer_cast<TriggerImpl>(kStopTrigger)->Clone();
                auto clonedChildITrigger = std::dynamic_pointer_cast<ITrigger>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetStopTrigger(std::dynamic_pointer_cast<ITriggerWriter>(clonedChildITrigger));
            }
            return clonedObject;
        }

        std::string ActImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ActImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__START_TRIGGER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetStartTrigger());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__STOP_TRIGGER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetStopTrigger());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ActImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__MANEUVER_GROUP)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetManeuverGroups())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ActImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ActImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ActImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void ActImpl::ResetStopTrigger()
	   {
	   		isSetStopTrigger = false; 
			_stopTrigger = {};
			
	   }
       bool ActImpl::IsSetStopTrigger() const
	   {
			return isSetStopTrigger;
	   }

        IOpenScenarioFlexElement* ActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string ActionImpl::GetName() const
        {
        	  return _name;
        }
        std::shared_ptr<IGlobalAction> ActionImpl::GetGlobalAction() const
        {
        	  return _globalAction;
        }
        std::shared_ptr<IUserDefinedAction> ActionImpl::GetUserDefinedAction() const
        {
        	  return _userDefinedAction;
        }
        std::shared_ptr<IPrivateAction> ActionImpl::GetPrivateAction() const
        {
        	  return _privateAction;
        }


        void ActionImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void ActionImpl::SetGlobalAction(std::shared_ptr<IGlobalActionWriter> globalAction)
        {
            _globalAction = globalAction;
            _userDefinedAction = {};
            _privateAction = {};
			// set the indicator to true
            isSetGlobalAction = true;          
        }

        void ActionImpl::SetUserDefinedAction(std::shared_ptr<IUserDefinedActionWriter> userDefinedAction)
        {
            _userDefinedAction = userDefinedAction;
            _globalAction = {};
            _privateAction = {};
			// set the indicator to true
            isSetUserDefinedAction = true;          
        }

        void ActionImpl::SetPrivateAction(std::shared_ptr<IPrivateActionWriter> privateAction)
        {
            _privateAction = privateAction;
            _globalAction = {};
            _userDefinedAction = {};
			// set the indicator to true
            isSetPrivateAction = true;          
        }

        std::shared_ptr<void> ActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAction).name())
                return std::dynamic_pointer_cast<IAction>(shared_from_this());
            else if (classifier == typeid(IActionWriter).name())
                return std::dynamic_pointer_cast<IActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ActionImpl::GetModelType() const
        {
            return "Action";
        }

        void ActionImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        std::string ActionImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        bool ActionImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IGlobalActionWriter> ActionImpl::GetWriterGlobalAction() const
        {
            return std::dynamic_pointer_cast<IGlobalActionWriter>(_globalAction);
        }
        std::shared_ptr<IUserDefinedActionWriter> ActionImpl::GetWriterUserDefinedAction() const
        {
            return std::dynamic_pointer_cast<IUserDefinedActionWriter>(_userDefinedAction);
        }
        std::shared_ptr<IPrivateActionWriter> ActionImpl::GetWriterPrivateAction() const
        {
            return std::dynamic_pointer_cast<IPrivateActionWriter>(_privateAction);
        }

        ActionImpl::ActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        void ActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kGlobalAction =  GetWriterGlobalAction();
                if (kGlobalAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kGlobalAction));
                }
                const auto kUserDefinedAction =  GetWriterUserDefinedAction();
                if (kUserDefinedAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kUserDefinedAction));
                }
                const auto kPrivateAction =  GetWriterPrivateAction();
                if (kPrivateAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPrivateAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone indicators
            // clone children
            const auto kGlobalAction =  GetWriterGlobalAction();
            if (kGlobalAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<GlobalActionImpl>(kGlobalAction)->Clone();
                auto clonedChildIGlobalAction = std::dynamic_pointer_cast<IGlobalAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetGlobalAction(std::dynamic_pointer_cast<IGlobalActionWriter>(clonedChildIGlobalAction));
            }
            const auto kUserDefinedAction =  GetWriterUserDefinedAction();
            if (kUserDefinedAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<UserDefinedActionImpl>(kUserDefinedAction)->Clone();
                auto clonedChildIUserDefinedAction = std::dynamic_pointer_cast<IUserDefinedAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetUserDefinedAction(std::dynamic_pointer_cast<IUserDefinedActionWriter>(clonedChildIUserDefinedAction));
            }
            const auto kPrivateAction =  GetWriterPrivateAction();
            if (kPrivateAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<PrivateActionImpl>(kPrivateAction)->Clone();
                auto clonedChildIPrivateAction = std::dynamic_pointer_cast<IPrivateAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPrivateAction(std::dynamic_pointer_cast<IPrivateActionWriter>(clonedChildIPrivateAction));
            }
            return clonedObject;
        }

        std::string ActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__GLOBAL_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetGlobalAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__USER_DEFINED_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetUserDefinedAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PRIVATE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPrivateAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ActionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void ActionImpl::ResetGlobalAction()
	   {
	   		isSetGlobalAction = false; 
			_globalAction = {};
			
	   }
       bool ActionImpl::IsSetGlobalAction() const
	   {
			return isSetGlobalAction;
	   }
       void ActionImpl::ResetUserDefinedAction()
	   {
	   		isSetUserDefinedAction = false; 
			_userDefinedAction = {};
			
	   }
       bool ActionImpl::IsSetUserDefinedAction() const
	   {
			return isSetUserDefinedAction;
	   }
       void ActionImpl::ResetPrivateAction()
	   {
	   		isSetPrivateAction = false; 
			_privateAction = {};
			
	   }
       bool ActionImpl::IsSetPrivateAction() const
	   {
			return isSetPrivateAction;
	   }

        IOpenScenarioFlexElement* ActivateControllerActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool ActivateControllerActionImpl::GetAnimation() const
        {
        	  return _animation;
        }
        std::shared_ptr<INamedReference<IController>> ActivateControllerActionImpl::GetControllerRef() const
        {
        	 return _controllerRef;
        }
        bool ActivateControllerActionImpl::GetLateral() const
        {
        	  return _lateral;
        }
        bool ActivateControllerActionImpl::GetLighting() const
        {
        	  return _lighting;
        }
        bool ActivateControllerActionImpl::GetLongitudinal() const
        {
        	  return _longitudinal;
        }


        void ActivateControllerActionImpl::SetAnimation(const bool animation)
        {
            _animation = animation;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ANIMATION);
			// set the indicator to true
            isSetAnimation = true;          
        }

        void ActivateControllerActionImpl::SetControllerRef(std::shared_ptr<INamedReference<IController>> controllerRef)
        {
            _controllerRef = controllerRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONTROLLER_REF);
			// set the indicator to true
            isSetControllerRef = true;          
        }

        void ActivateControllerActionImpl::SetLateral(const bool lateral)
        {
            _lateral = lateral;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LATERAL);
			// set the indicator to true
            isSetLateral = true;          
        }

        void ActivateControllerActionImpl::SetLighting(const bool lighting)
        {
            _lighting = lighting;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LIGHTING);
			// set the indicator to true
            isSetLighting = true;          
        }

        void ActivateControllerActionImpl::SetLongitudinal(const bool longitudinal)
        {
            _longitudinal = longitudinal;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LONGITUDINAL);
			// set the indicator to true
            isSetLongitudinal = true;          
        }

        std::shared_ptr<void> ActivateControllerActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ActivateControllerActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IActivateControllerAction).name())
                return std::dynamic_pointer_cast<IActivateControllerAction>(shared_from_this());
            else if (classifier == typeid(IActivateControllerActionWriter).name())
                return std::dynamic_pointer_cast<IActivateControllerActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ActivateControllerActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ActivateControllerActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ActivateControllerActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ActivateControllerActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ActivateControllerActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ActivateControllerActionImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__ANIMATION)
                {
                    return GetAnimation();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__LATERAL)
                {
                    return GetLateral();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__LIGHTING)
                {
                    return GetLighting();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__LONGITUDINAL)
                {
                    return GetLongitudinal();
                }
                throw KeyNotSupportedException();

        }

        DateTime ActivateControllerActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ActivateControllerActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ActivateControllerActionImpl::GetModelType() const
        {
            return "ActivateControllerAction";
        }

        void ActivateControllerActionImpl::WriteParameterToAnimation(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ANIMATION, parameterName, nullTextMarker /*no textmarker*/);
            _animation = {};
        }

        void ActivateControllerActionImpl::WriteParameterToControllerRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONTROLLER_REF, parameterName, nullTextMarker /*no textmarker*/);
            _controllerRef = {};
        }

        void ActivateControllerActionImpl::WriteParameterToLateral(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LATERAL, parameterName, nullTextMarker /*no textmarker*/);
            _lateral = {};
        }

        void ActivateControllerActionImpl::WriteParameterToLighting(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LIGHTING, parameterName, nullTextMarker /*no textmarker*/);
            _lighting = {};
        }

        void ActivateControllerActionImpl::WriteParameterToLongitudinal(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LONGITUDINAL, parameterName, nullTextMarker /*no textmarker*/);
            _longitudinal = {};
        }

        std::string ActivateControllerActionImpl::GetParameterFromAnimation() const
        {
            auto animation = OSC_CONSTANTS::ATTRIBUTE__ANIMATION;
            return GetParameterNameFromAttribute(animation);
        }

        std::string ActivateControllerActionImpl::GetParameterFromControllerRef() const
        {
            auto controllerRef = OSC_CONSTANTS::ATTRIBUTE__CONTROLLER_REF;
            return GetParameterNameFromAttribute(controllerRef);
        }

        std::string ActivateControllerActionImpl::GetParameterFromLateral() const
        {
            auto lateral = OSC_CONSTANTS::ATTRIBUTE__LATERAL;
            return GetParameterNameFromAttribute(lateral);
        }

        std::string ActivateControllerActionImpl::GetParameterFromLighting() const
        {
            auto lighting = OSC_CONSTANTS::ATTRIBUTE__LIGHTING;
            return GetParameterNameFromAttribute(lighting);
        }

        std::string ActivateControllerActionImpl::GetParameterFromLongitudinal() const
        {
            auto longitudinal = OSC_CONSTANTS::ATTRIBUTE__LONGITUDINAL;
            return GetParameterNameFromAttribute(longitudinal);
        }

        bool ActivateControllerActionImpl::IsAnimationParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ANIMATION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ActivateControllerActionImpl::IsControllerRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CONTROLLER_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ActivateControllerActionImpl::IsLateralParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__LATERAL);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ActivateControllerActionImpl::IsLightingParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__LIGHTING);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ActivateControllerActionImpl::IsLongitudinalParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__LONGITUDINAL);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        ActivateControllerActionImpl::ActivateControllerActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ANIMATION, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CONTROLLER_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LATERAL, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LIGHTING, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LONGITUDINAL, SimpleType::BOOLEAN);
        }

        void ActivateControllerActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ANIMATION)
            {
                // Simple type
                _animation = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTROLLER_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IController>>(parameterLiteralValue);
                _controllerRef = std::dynamic_pointer_cast<INamedReference<IController>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LATERAL)
            {
                // Simple type
                _lateral = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LIGHTING)
            {
                // Simple type
                _lighting = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LONGITUDINAL)
            {
                // Simple type
                _longitudinal = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ActivateControllerActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ActivateControllerActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ActivateControllerActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ActivateControllerActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_animation = GetAnimation();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IController>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IController>>(GetControllerRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_controllerRef = proxy;
            
            // Simple type
            clonedObject->_lateral = GetLateral();
            // Simple type
            clonedObject->_lighting = GetLighting();
            // Simple type
            clonedObject->_longitudinal = GetLongitudinal();
            // clone indicators
            	clonedObject->isSetAnimation = isSetAnimation;
            	clonedObject->isSetControllerRef = isSetControllerRef;
            	clonedObject->isSetLateral = isSetLateral;
            	clonedObject->isSetLighting = isSetLighting;
            	clonedObject->isSetLongitudinal = isSetLongitudinal;
            // clone children
            return clonedObject;
        }

        std::string ActivateControllerActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__CONTROLLER_REF)
            {
                // Get the Proxy
                auto controllerRef = GetControllerRef();
                return controllerRef!= nullptr ? controllerRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ActivateControllerActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ActivateControllerActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ActivateControllerActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__CONTROLLER_REF)
            {
                // Get the Proxy
                auto controllerRef = GetControllerRef();
                return controllerRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(controllerRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string ActivateControllerActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ActivateControllerActionImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ANIMATION)
            {
                // Simple type
                _animation = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LATERAL)
            {
                // Simple type
                _lateral = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LIGHTING)
            {
                // Simple type
                _lighting = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LONGITUDINAL)
            {
                // Simple type
                _longitudinal = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void ActivateControllerActionImpl::ResetAnimation()
	   {
	   		isSetAnimation = false; 
			_animation = {};
			
	   }
       bool ActivateControllerActionImpl::IsSetAnimation() const
	   {
			return isSetAnimation;
	   }
       void ActivateControllerActionImpl::ResetControllerRef()
	   {
	   		isSetControllerRef = false; 
        	_controllerRef = nullptr;
			
	   }
       bool ActivateControllerActionImpl::IsSetControllerRef() const
	   {
			return isSetControllerRef;
	   }
       void ActivateControllerActionImpl::ResetLateral()
	   {
	   		isSetLateral = false; 
			_lateral = {};
			
	   }
       bool ActivateControllerActionImpl::IsSetLateral() const
	   {
			return isSetLateral;
	   }
       void ActivateControllerActionImpl::ResetLighting()
	   {
	   		isSetLighting = false; 
			_lighting = {};
			
	   }
       bool ActivateControllerActionImpl::IsSetLighting() const
	   {
			return isSetLighting;
	   }
       void ActivateControllerActionImpl::ResetLongitudinal()
	   {
	   		isSetLongitudinal = false; 
			_longitudinal = {};
			
	   }
       bool ActivateControllerActionImpl::IsSetLongitudinal() const
	   {
			return isSetLongitudinal;
	   }

        IOpenScenarioFlexElement* ActorsImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool ActorsImpl::GetSelectTriggeringEntities() const
        {
        	  return _selectTriggeringEntities;
        }
        std::vector<std::shared_ptr<IEntityRef>> ActorsImpl::GetEntityRefs() const
        {
            std::vector<std::shared_ptr<IEntityRef>> temp;
            for(auto&& elm: _entityRefs)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IEntityRefWriter>> ActorsImpl::GetWriterEntityRefs() const
        {
            return _entityRefs;
        }

        int ActorsImpl::GetEntityRefsSize() const
        {
            return static_cast<int>(_entityRefs.size());
        }

        std::shared_ptr<IEntityRef> ActorsImpl::GetEntityRefsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _entityRefs.size() > index)
            {
                return _entityRefs[index];
            }
            return nullptr;
        }


        void ActorsImpl::SetSelectTriggeringEntities(const bool selectTriggeringEntities)
        {
            _selectTriggeringEntities = selectTriggeringEntities;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SELECT_TRIGGERING_ENTITIES);
        }

        void ActorsImpl::SetEntityRefs(std::vector<std::shared_ptr<IEntityRefWriter>>& entityRefs)
        {
            _entityRefs = entityRefs;
			// set the indicator to true
            isSetEntityRefs = true;          
        }

        std::shared_ptr<void> ActorsImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ActorsImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IActors).name())
                return std::dynamic_pointer_cast<IActors>(shared_from_this());
            else if (classifier == typeid(IActorsWriter).name())
                return std::dynamic_pointer_cast<IActorsWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ActorsImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ActorsImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ActorsImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ActorsImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ActorsImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ActorsImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__SELECT_TRIGGERING_ENTITIES)
                {
                    return GetSelectTriggeringEntities();
                }
                throw KeyNotSupportedException();

        }

        DateTime ActorsImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ActorsImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ActorsImpl::GetModelType() const
        {
            return "Actors";
        }

        void ActorsImpl::WriteParameterToSelectTriggeringEntities(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SELECT_TRIGGERING_ENTITIES, parameterName, nullTextMarker /*no textmarker*/);
            _selectTriggeringEntities = {};
        }

        std::string ActorsImpl::GetParameterFromSelectTriggeringEntities() const
        {
            auto selectTriggeringEntities = OSC_CONSTANTS::ATTRIBUTE__SELECT_TRIGGERING_ENTITIES;
            return GetParameterNameFromAttribute(selectTriggeringEntities);
        }

        bool ActorsImpl::IsSelectTriggeringEntitiesParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__SELECT_TRIGGERING_ENTITIES);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        ActorsImpl::ActorsImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SELECT_TRIGGERING_ENTITIES, SimpleType::BOOLEAN);
        }

        void ActorsImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SELECT_TRIGGERING_ENTITIES)
            {
                // Simple type
                _selectTriggeringEntities = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ActorsImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ActorsImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto entityRefs =  GetWriterEntityRefs();
                if (!entityRefs.empty())
                {
                    for(auto&& item : entityRefs)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ActorsImpl::Clone()
        {
            auto clonedObject = std::make_shared<ActorsImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_selectTriggeringEntities = GetSelectTriggeringEntities();
            // clone indicators
            // clone children
            const auto kEntityRefs =  GetWriterEntityRefs();
            if (!kEntityRefs.empty())
            {
                std::vector<std::shared_ptr<IEntityRefWriter>> clonedList;
                for(auto&& kItem : kEntityRefs)
                {
                    auto clonedChild = std::dynamic_pointer_cast<EntityRefImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IEntityRefWriter>(clonedChild));
                }
                clonedObject->SetEntityRefs(clonedList);
            }
            return clonedObject;
        }

        std::string ActorsImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ActorsImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ActorsImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_REF)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetEntityRefs())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ActorsImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ActorsImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ActorsImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SELECT_TRIGGERING_ENTITIES)
            {
                // Simple type
                _selectTriggeringEntities = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void ActorsImpl::ResetEntityRefs()
	   {
	   		isSetEntityRefs = false; 
			_entityRefs = {};
			
	   }
       bool ActorsImpl::IsSetEntityRefs() const
	   {
			return isSetEntityRefs;
	   }

        IOpenScenarioFlexElement* AddEntityActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IPosition> AddEntityActionImpl::GetPosition() const
        {
        	  return _position;
        }


        void AddEntityActionImpl::SetPosition(std::shared_ptr<IPositionWriter> position)
        {
            _position = position;
        }

        std::shared_ptr<void> AddEntityActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(AddEntityActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAddEntityAction).name())
                return std::dynamic_pointer_cast<IAddEntityAction>(shared_from_this());
            else if (classifier == typeid(IAddEntityActionWriter).name())
                return std::dynamic_pointer_cast<IAddEntityActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> AddEntityActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t AddEntityActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int AddEntityActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double AddEntityActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t AddEntityActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool AddEntityActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime AddEntityActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> AddEntityActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string AddEntityActionImpl::GetModelType() const
        {
            return "AddEntityAction";
        }

            // children
        std::shared_ptr<IPositionWriter> AddEntityActionImpl::GetWriterPosition() const
        {
            return std::dynamic_pointer_cast<IPositionWriter>(_position);
        }

        AddEntityActionImpl::AddEntityActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void AddEntityActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType AddEntityActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AddEntityActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AddEntityActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<AddEntityActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            return clonedObject;
        }

        std::string AddEntityActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AddEntityActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AddEntityActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AddEntityActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AddEntityActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* AnimationActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double AnimationActionImpl::GetAnimationDuration() const
        {
        	  return _animationDuration;
        }
        bool AnimationActionImpl::GetLoop() const
        {
        	  return _loop;
        }
        std::shared_ptr<IAnimationType> AnimationActionImpl::GetAnimationType() const
        {
        	  return _animationType;
        }
        std::shared_ptr<IAnimationState> AnimationActionImpl::GetAnimationState() const
        {
        	  return _animationState;
        }


        void AnimationActionImpl::SetAnimationDuration(const double animationDuration)
        {
            _animationDuration = animationDuration;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ANIMATION_DURATION);
			// set the indicator to true
            isSetAnimationDuration = true;          
        }

        void AnimationActionImpl::SetLoop(const bool loop)
        {
            _loop = loop;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LOOP);
			// set the indicator to true
            isSetLoop = true;          
        }

        void AnimationActionImpl::SetAnimationType(std::shared_ptr<IAnimationTypeWriter> animationType)
        {
            _animationType = animationType;
        }

        void AnimationActionImpl::SetAnimationState(std::shared_ptr<IAnimationStateWriter> animationState)
        {
            _animationState = animationState;
			// set the indicator to true
            isSetAnimationState = true;          
        }

        std::shared_ptr<void> AnimationActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(AnimationActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAnimationAction).name())
                return std::dynamic_pointer_cast<IAnimationAction>(shared_from_this());
            else if (classifier == typeid(IAnimationActionWriter).name())
                return std::dynamic_pointer_cast<IAnimationActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> AnimationActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t AnimationActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int AnimationActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double AnimationActionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__ANIMATION_DURATION)
                {
                    return GetAnimationDuration();
                }
                throw KeyNotSupportedException();

        }

        uint16_t AnimationActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool AnimationActionImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__LOOP)
                {
                    return GetLoop();
                }
                throw KeyNotSupportedException();

        }

        DateTime AnimationActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> AnimationActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string AnimationActionImpl::GetModelType() const
        {
            return "AnimationAction";
        }

        void AnimationActionImpl::WriteParameterToAnimationDuration(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ANIMATION_DURATION, parameterName, nullTextMarker /*no textmarker*/);
            _animationDuration = {};
        }

        void AnimationActionImpl::WriteParameterToLoop(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LOOP, parameterName, nullTextMarker /*no textmarker*/);
            _loop = {};
        }

        std::string AnimationActionImpl::GetParameterFromAnimationDuration() const
        {
            auto animationDuration = OSC_CONSTANTS::ATTRIBUTE__ANIMATION_DURATION;
            return GetParameterNameFromAttribute(animationDuration);
        }

        std::string AnimationActionImpl::GetParameterFromLoop() const
        {
            auto loop = OSC_CONSTANTS::ATTRIBUTE__LOOP;
            return GetParameterNameFromAttribute(loop);
        }

        bool AnimationActionImpl::IsAnimationDurationParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ANIMATION_DURATION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool AnimationActionImpl::IsLoopParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__LOOP);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IAnimationTypeWriter> AnimationActionImpl::GetWriterAnimationType() const
        {
            return std::dynamic_pointer_cast<IAnimationTypeWriter>(_animationType);
        }
        std::shared_ptr<IAnimationStateWriter> AnimationActionImpl::GetWriterAnimationState() const
        {
            return std::dynamic_pointer_cast<IAnimationStateWriter>(_animationState);
        }

        AnimationActionImpl::AnimationActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ANIMATION_DURATION, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LOOP, SimpleType::BOOLEAN);
        }

        void AnimationActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ANIMATION_DURATION)
            {
                // Simple type
                _animationDuration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LOOP)
            {
                // Simple type
                _loop = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType AnimationActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AnimationActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kAnimationType =  GetWriterAnimationType();
                if (kAnimationType)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAnimationType));
                }
                const auto kAnimationState =  GetWriterAnimationState();
                if (kAnimationState)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAnimationState));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AnimationActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<AnimationActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_animationDuration = GetAnimationDuration();
            // Simple type
            clonedObject->_loop = GetLoop();
            // clone indicators
            	clonedObject->isSetAnimationDuration = isSetAnimationDuration;
            	clonedObject->isSetLoop = isSetLoop;
            // clone children
            const auto kAnimationType =  GetWriterAnimationType();
            if (kAnimationType)
            {
                auto clonedChild = std::dynamic_pointer_cast<AnimationTypeImpl>(kAnimationType)->Clone();
                auto clonedChildIAnimationType = std::dynamic_pointer_cast<IAnimationType>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAnimationType(std::dynamic_pointer_cast<IAnimationTypeWriter>(clonedChildIAnimationType));
            }
            const auto kAnimationState =  GetWriterAnimationState();
            if (kAnimationState)
            {
                auto clonedChild = std::dynamic_pointer_cast<AnimationStateImpl>(kAnimationState)->Clone();
                auto clonedChildIAnimationState = std::dynamic_pointer_cast<IAnimationState>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAnimationState(std::dynamic_pointer_cast<IAnimationStateWriter>(clonedChildIAnimationState));
            }
            return clonedObject;
        }

        std::string AnimationActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AnimationActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ANIMATION_TYPE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAnimationType());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ANIMATION_STATE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAnimationState());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AnimationActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AnimationActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AnimationActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void AnimationActionImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LOOP)
            {
                // Simple type
                _loop = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void AnimationActionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ANIMATION_DURATION)
            {
                // Simple type
                _animationDuration = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void AnimationActionImpl::ResetAnimationDuration()
	   {
	   		isSetAnimationDuration = false; 
			_animationDuration = {};
			
	   }
       bool AnimationActionImpl::IsSetAnimationDuration() const
	   {
			return isSetAnimationDuration;
	   }
       void AnimationActionImpl::ResetLoop()
	   {
	   		isSetLoop = false; 
			_loop = {false};
			
	   }
       bool AnimationActionImpl::IsSetLoop() const
	   {
			return isSetLoop;
	   }
       void AnimationActionImpl::ResetAnimationState()
	   {
	   		isSetAnimationState = false; 
			_animationState = {};
			
	   }
       bool AnimationActionImpl::IsSetAnimationState() const
	   {
			return isSetAnimationState;
	   }

        IOpenScenarioFlexElement* AnimationFileImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double AnimationFileImpl::GetTimeOffset() const
        {
        	  return _timeOffset;
        }
        std::shared_ptr<IFile> AnimationFileImpl::GetFile() const
        {
        	  return _file;
        }


        void AnimationFileImpl::SetTimeOffset(const double timeOffset)
        {
            _timeOffset = timeOffset;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TIME_OFFSET);
			// set the indicator to true
            isSetTimeOffset = true;          
        }

        void AnimationFileImpl::SetFile(std::shared_ptr<IFileWriter> file)
        {
            _file = file;
        }

        std::shared_ptr<void> AnimationFileImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(AnimationFileImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAnimationFile).name())
                return std::dynamic_pointer_cast<IAnimationFile>(shared_from_this());
            else if (classifier == typeid(IAnimationFileWriter).name())
                return std::dynamic_pointer_cast<IAnimationFileWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> AnimationFileImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t AnimationFileImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int AnimationFileImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double AnimationFileImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__TIME_OFFSET)
                {
                    return GetTimeOffset();
                }
                throw KeyNotSupportedException();

        }

        uint16_t AnimationFileImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool AnimationFileImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime AnimationFileImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> AnimationFileImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string AnimationFileImpl::GetModelType() const
        {
            return "AnimationFile";
        }

        void AnimationFileImpl::WriteParameterToTimeOffset(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TIME_OFFSET, parameterName, nullTextMarker /*no textmarker*/);
            _timeOffset = {};
        }

        std::string AnimationFileImpl::GetParameterFromTimeOffset() const
        {
            auto timeOffset = OSC_CONSTANTS::ATTRIBUTE__TIME_OFFSET;
            return GetParameterNameFromAttribute(timeOffset);
        }

        bool AnimationFileImpl::IsTimeOffsetParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TIME_OFFSET);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IFileWriter> AnimationFileImpl::GetWriterFile() const
        {
            return std::dynamic_pointer_cast<IFileWriter>(_file);
        }

        AnimationFileImpl::AnimationFileImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TIME_OFFSET, SimpleType::DOUBLE);
        }

        void AnimationFileImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TIME_OFFSET)
            {
                // Simple type
                _timeOffset = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType AnimationFileImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AnimationFileImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kFile =  GetWriterFile();
                if (kFile)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kFile));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AnimationFileImpl::Clone()
        {
            auto clonedObject = std::make_shared<AnimationFileImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_timeOffset = GetTimeOffset();
            // clone indicators
            	clonedObject->isSetTimeOffset = isSetTimeOffset;
            // clone children
            const auto kFile =  GetWriterFile();
            if (kFile)
            {
                auto clonedChild = std::dynamic_pointer_cast<FileImpl>(kFile)->Clone();
                auto clonedChildIFile = std::dynamic_pointer_cast<IFile>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetFile(std::dynamic_pointer_cast<IFileWriter>(clonedChildIFile));
            }
            return clonedObject;
        }

        std::string AnimationFileImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AnimationFileImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__FILE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetFile());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AnimationFileImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AnimationFileImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AnimationFileImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void AnimationFileImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TIME_OFFSET)
            {
                // Simple type
                _timeOffset = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void AnimationFileImpl::ResetTimeOffset()
	   {
	   		isSetTimeOffset = false; 
			_timeOffset = {};
			
	   }
       bool AnimationFileImpl::IsSetTimeOffset() const
	   {
			return isSetTimeOffset;
	   }

        IOpenScenarioFlexElement* AnimationStateImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double AnimationStateImpl::GetState() const
        {
        	  return _state;
        }


        void AnimationStateImpl::SetState(const double state)
        {
            _state = state;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STATE);
        }

        std::shared_ptr<void> AnimationStateImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(AnimationStateImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAnimationState).name())
                return std::dynamic_pointer_cast<IAnimationState>(shared_from_this());
            else if (classifier == typeid(IAnimationStateWriter).name())
                return std::dynamic_pointer_cast<IAnimationStateWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> AnimationStateImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t AnimationStateImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int AnimationStateImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double AnimationStateImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__STATE)
                {
                    return GetState();
                }
                throw KeyNotSupportedException();

        }

        uint16_t AnimationStateImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool AnimationStateImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime AnimationStateImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> AnimationStateImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string AnimationStateImpl::GetModelType() const
        {
            return "AnimationState";
        }

        void AnimationStateImpl::WriteParameterToState(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STATE, parameterName, nullTextMarker /*no textmarker*/);
            _state = {};
        }

        std::string AnimationStateImpl::GetParameterFromState() const
        {
            auto state = OSC_CONSTANTS::ATTRIBUTE__STATE;
            return GetParameterNameFromAttribute(state);
        }

        bool AnimationStateImpl::IsStateParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__STATE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        AnimationStateImpl::AnimationStateImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__STATE, SimpleType::DOUBLE);
        }

        void AnimationStateImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                // Simple type
                _state = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType AnimationStateImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AnimationStateImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AnimationStateImpl::Clone()
        {
            auto clonedObject = std::make_shared<AnimationStateImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_state = GetState();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string AnimationStateImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AnimationStateImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AnimationStateImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AnimationStateImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AnimationStateImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void AnimationStateImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                // Simple type
                _state = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* AnimationTypeImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IComponentAnimation> AnimationTypeImpl::GetComponentAnimation() const
        {
        	  return _componentAnimation;
        }
        std::shared_ptr<IPedestrianAnimation> AnimationTypeImpl::GetPedestrianAnimation() const
        {
        	  return _pedestrianAnimation;
        }
        std::shared_ptr<IAnimationFile> AnimationTypeImpl::GetAnimationFile() const
        {
        	  return _animationFile;
        }
        std::shared_ptr<IUserDefinedAnimation> AnimationTypeImpl::GetUserDefinedAnimation() const
        {
        	  return _userDefinedAnimation;
        }


        void AnimationTypeImpl::SetComponentAnimation(std::shared_ptr<IComponentAnimationWriter> componentAnimation)
        {
            _componentAnimation = componentAnimation;
            _pedestrianAnimation = {};
            _animationFile = {};
            _userDefinedAnimation = {};
        }

        void AnimationTypeImpl::SetPedestrianAnimation(std::shared_ptr<IPedestrianAnimationWriter> pedestrianAnimation)
        {
            _pedestrianAnimation = pedestrianAnimation;
            _componentAnimation = {};
            _animationFile = {};
            _userDefinedAnimation = {};
        }

        void AnimationTypeImpl::SetAnimationFile(std::shared_ptr<IAnimationFileWriter> animationFile)
        {
            _animationFile = animationFile;
            _componentAnimation = {};
            _pedestrianAnimation = {};
            _userDefinedAnimation = {};
        }

        void AnimationTypeImpl::SetUserDefinedAnimation(std::shared_ptr<IUserDefinedAnimationWriter> userDefinedAnimation)
        {
            _userDefinedAnimation = userDefinedAnimation;
            _componentAnimation = {};
            _pedestrianAnimation = {};
            _animationFile = {};
        }

        std::shared_ptr<void> AnimationTypeImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(AnimationTypeImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAnimationType).name())
                return std::dynamic_pointer_cast<IAnimationType>(shared_from_this());
            else if (classifier == typeid(IAnimationTypeWriter).name())
                return std::dynamic_pointer_cast<IAnimationTypeWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> AnimationTypeImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t AnimationTypeImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int AnimationTypeImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double AnimationTypeImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t AnimationTypeImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool AnimationTypeImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime AnimationTypeImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> AnimationTypeImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string AnimationTypeImpl::GetModelType() const
        {
            return "AnimationType";
        }

            // children
        std::shared_ptr<IComponentAnimationWriter> AnimationTypeImpl::GetWriterComponentAnimation() const
        {
            return std::dynamic_pointer_cast<IComponentAnimationWriter>(_componentAnimation);
        }
        std::shared_ptr<IPedestrianAnimationWriter> AnimationTypeImpl::GetWriterPedestrianAnimation() const
        {
            return std::dynamic_pointer_cast<IPedestrianAnimationWriter>(_pedestrianAnimation);
        }
        std::shared_ptr<IAnimationFileWriter> AnimationTypeImpl::GetWriterAnimationFile() const
        {
            return std::dynamic_pointer_cast<IAnimationFileWriter>(_animationFile);
        }
        std::shared_ptr<IUserDefinedAnimationWriter> AnimationTypeImpl::GetWriterUserDefinedAnimation() const
        {
            return std::dynamic_pointer_cast<IUserDefinedAnimationWriter>(_userDefinedAnimation);
        }

        AnimationTypeImpl::AnimationTypeImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void AnimationTypeImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType AnimationTypeImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AnimationTypeImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kComponentAnimation =  GetWriterComponentAnimation();
                if (kComponentAnimation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kComponentAnimation));
                }
                const auto kPedestrianAnimation =  GetWriterPedestrianAnimation();
                if (kPedestrianAnimation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPedestrianAnimation));
                }
                const auto kAnimationFile =  GetWriterAnimationFile();
                if (kAnimationFile)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAnimationFile));
                }
                const auto kUserDefinedAnimation =  GetWriterUserDefinedAnimation();
                if (kUserDefinedAnimation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kUserDefinedAnimation));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AnimationTypeImpl::Clone()
        {
            auto clonedObject = std::make_shared<AnimationTypeImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kComponentAnimation =  GetWriterComponentAnimation();
            if (kComponentAnimation)
            {
                auto clonedChild = std::dynamic_pointer_cast<ComponentAnimationImpl>(kComponentAnimation)->Clone();
                auto clonedChildIComponentAnimation = std::dynamic_pointer_cast<IComponentAnimation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetComponentAnimation(std::dynamic_pointer_cast<IComponentAnimationWriter>(clonedChildIComponentAnimation));
            }
            const auto kPedestrianAnimation =  GetWriterPedestrianAnimation();
            if (kPedestrianAnimation)
            {
                auto clonedChild = std::dynamic_pointer_cast<PedestrianAnimationImpl>(kPedestrianAnimation)->Clone();
                auto clonedChildIPedestrianAnimation = std::dynamic_pointer_cast<IPedestrianAnimation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPedestrianAnimation(std::dynamic_pointer_cast<IPedestrianAnimationWriter>(clonedChildIPedestrianAnimation));
            }
            const auto kAnimationFile =  GetWriterAnimationFile();
            if (kAnimationFile)
            {
                auto clonedChild = std::dynamic_pointer_cast<AnimationFileImpl>(kAnimationFile)->Clone();
                auto clonedChildIAnimationFile = std::dynamic_pointer_cast<IAnimationFile>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAnimationFile(std::dynamic_pointer_cast<IAnimationFileWriter>(clonedChildIAnimationFile));
            }
            const auto kUserDefinedAnimation =  GetWriterUserDefinedAnimation();
            if (kUserDefinedAnimation)
            {
                auto clonedChild = std::dynamic_pointer_cast<UserDefinedAnimationImpl>(kUserDefinedAnimation)->Clone();
                auto clonedChildIUserDefinedAnimation = std::dynamic_pointer_cast<IUserDefinedAnimation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetUserDefinedAnimation(std::dynamic_pointer_cast<IUserDefinedAnimationWriter>(clonedChildIUserDefinedAnimation));
            }
            return clonedObject;
        }

        std::string AnimationTypeImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AnimationTypeImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__COMPONENT_ANIMATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetComponentAnimation());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PEDESTRIAN_ANIMATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPedestrianAnimation());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ANIMATION_FILE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAnimationFile());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__USER_DEFINED_ANIMATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetUserDefinedAnimation());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AnimationTypeImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AnimationTypeImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AnimationTypeImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* AppearanceActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<ILightStateAction> AppearanceActionImpl::GetLightStateAction() const
        {
        	  return _lightStateAction;
        }
        std::shared_ptr<IAnimationAction> AppearanceActionImpl::GetAnimationAction() const
        {
        	  return _animationAction;
        }


        void AppearanceActionImpl::SetLightStateAction(std::shared_ptr<ILightStateActionWriter> lightStateAction)
        {
            _lightStateAction = lightStateAction;
            _animationAction = {};
        }

        void AppearanceActionImpl::SetAnimationAction(std::shared_ptr<IAnimationActionWriter> animationAction)
        {
            _animationAction = animationAction;
            _lightStateAction = {};
        }

        std::shared_ptr<void> AppearanceActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(AppearanceActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAppearanceAction).name())
                return std::dynamic_pointer_cast<IAppearanceAction>(shared_from_this());
            else if (classifier == typeid(IAppearanceActionWriter).name())
                return std::dynamic_pointer_cast<IAppearanceActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> AppearanceActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t AppearanceActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int AppearanceActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double AppearanceActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t AppearanceActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool AppearanceActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime AppearanceActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> AppearanceActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string AppearanceActionImpl::GetModelType() const
        {
            return "AppearanceAction";
        }

            // children
        std::shared_ptr<ILightStateActionWriter> AppearanceActionImpl::GetWriterLightStateAction() const
        {
            return std::dynamic_pointer_cast<ILightStateActionWriter>(_lightStateAction);
        }
        std::shared_ptr<IAnimationActionWriter> AppearanceActionImpl::GetWriterAnimationAction() const
        {
            return std::dynamic_pointer_cast<IAnimationActionWriter>(_animationAction);
        }

        AppearanceActionImpl::AppearanceActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void AppearanceActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType AppearanceActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AppearanceActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kLightStateAction =  GetWriterLightStateAction();
                if (kLightStateAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLightStateAction));
                }
                const auto kAnimationAction =  GetWriterAnimationAction();
                if (kAnimationAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAnimationAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AppearanceActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<AppearanceActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kLightStateAction =  GetWriterLightStateAction();
            if (kLightStateAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<LightStateActionImpl>(kLightStateAction)->Clone();
                auto clonedChildILightStateAction = std::dynamic_pointer_cast<ILightStateAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLightStateAction(std::dynamic_pointer_cast<ILightStateActionWriter>(clonedChildILightStateAction));
            }
            const auto kAnimationAction =  GetWriterAnimationAction();
            if (kAnimationAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<AnimationActionImpl>(kAnimationAction)->Clone();
                auto clonedChildIAnimationAction = std::dynamic_pointer_cast<IAnimationAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAnimationAction(std::dynamic_pointer_cast<IAnimationActionWriter>(clonedChildIAnimationAction));
            }
            return clonedObject;
        }

        std::string AppearanceActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AppearanceActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LIGHT_STATE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLightStateAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ANIMATION_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAnimationAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AppearanceActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AppearanceActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AppearanceActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* AssignControllerActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool AssignControllerActionImpl::GetActivateAnimation() const
        {
        	  return _activateAnimation;
        }
        bool AssignControllerActionImpl::GetActivateLateral() const
        {
        	  return _activateLateral;
        }
        bool AssignControllerActionImpl::GetActivateLighting() const
        {
        	  return _activateLighting;
        }
        bool AssignControllerActionImpl::GetActivateLongitudinal() const
        {
        	  return _activateLongitudinal;
        }
        std::shared_ptr<IController> AssignControllerActionImpl::GetController() const
        {
        	  return _controller;
        }
        std::shared_ptr<ICatalogReference> AssignControllerActionImpl::GetCatalogReference() const
        {
        	  return _catalogReference;
        }


        void AssignControllerActionImpl::SetActivateAnimation(const bool activateAnimation)
        {
            _activateAnimation = activateAnimation;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_ANIMATION);
			// set the indicator to true
            isSetActivateAnimation = true;          
        }

        void AssignControllerActionImpl::SetActivateLateral(const bool activateLateral)
        {
            _activateLateral = activateLateral;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LATERAL);
			// set the indicator to true
            isSetActivateLateral = true;          
        }

        void AssignControllerActionImpl::SetActivateLighting(const bool activateLighting)
        {
            _activateLighting = activateLighting;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LIGHTING);
			// set the indicator to true
            isSetActivateLighting = true;          
        }

        void AssignControllerActionImpl::SetActivateLongitudinal(const bool activateLongitudinal)
        {
            _activateLongitudinal = activateLongitudinal;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LONGITUDINAL);
			// set the indicator to true
            isSetActivateLongitudinal = true;          
        }

        void AssignControllerActionImpl::SetController(std::shared_ptr<IControllerWriter> controller)
        {
            _controller = controller;
            _catalogReference = {};
			// set the indicator to true
            isSetController = true;          
        }

        void AssignControllerActionImpl::SetCatalogReference(std::shared_ptr<ICatalogReferenceWriter> catalogReference)
        {
            _catalogReference = catalogReference;
            _controller = {};
			// set the indicator to true
            isSetCatalogReference = true;          
        }

        std::shared_ptr<void> AssignControllerActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(AssignControllerActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAssignControllerAction).name())
                return std::dynamic_pointer_cast<IAssignControllerAction>(shared_from_this());
            else if (classifier == typeid(IAssignControllerActionWriter).name())
                return std::dynamic_pointer_cast<IAssignControllerActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> AssignControllerActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t AssignControllerActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int AssignControllerActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double AssignControllerActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t AssignControllerActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool AssignControllerActionImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_ANIMATION)
                {
                    return GetActivateAnimation();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LATERAL)
                {
                    return GetActivateLateral();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LIGHTING)
                {
                    return GetActivateLighting();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LONGITUDINAL)
                {
                    return GetActivateLongitudinal();
                }
                throw KeyNotSupportedException();

        }

        DateTime AssignControllerActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> AssignControllerActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string AssignControllerActionImpl::GetModelType() const
        {
            return "AssignControllerAction";
        }

        void AssignControllerActionImpl::WriteParameterToActivateAnimation(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_ANIMATION, parameterName, nullTextMarker /*no textmarker*/);
            _activateAnimation = {};
        }

        void AssignControllerActionImpl::WriteParameterToActivateLateral(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LATERAL, parameterName, nullTextMarker /*no textmarker*/);
            _activateLateral = {};
        }

        void AssignControllerActionImpl::WriteParameterToActivateLighting(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LIGHTING, parameterName, nullTextMarker /*no textmarker*/);
            _activateLighting = {};
        }

        void AssignControllerActionImpl::WriteParameterToActivateLongitudinal(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LONGITUDINAL, parameterName, nullTextMarker /*no textmarker*/);
            _activateLongitudinal = {};
        }

        std::string AssignControllerActionImpl::GetParameterFromActivateAnimation() const
        {
            auto activateAnimation = OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_ANIMATION;
            return GetParameterNameFromAttribute(activateAnimation);
        }

        std::string AssignControllerActionImpl::GetParameterFromActivateLateral() const
        {
            auto activateLateral = OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LATERAL;
            return GetParameterNameFromAttribute(activateLateral);
        }

        std::string AssignControllerActionImpl::GetParameterFromActivateLighting() const
        {
            auto activateLighting = OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LIGHTING;
            return GetParameterNameFromAttribute(activateLighting);
        }

        std::string AssignControllerActionImpl::GetParameterFromActivateLongitudinal() const
        {
            auto activateLongitudinal = OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LONGITUDINAL;
            return GetParameterNameFromAttribute(activateLongitudinal);
        }

        bool AssignControllerActionImpl::IsActivateAnimationParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_ANIMATION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool AssignControllerActionImpl::IsActivateLateralParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LATERAL);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool AssignControllerActionImpl::IsActivateLightingParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LIGHTING);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool AssignControllerActionImpl::IsActivateLongitudinalParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LONGITUDINAL);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IControllerWriter> AssignControllerActionImpl::GetWriterController() const
        {
            return std::dynamic_pointer_cast<IControllerWriter>(_controller);
        }
        std::shared_ptr<ICatalogReferenceWriter> AssignControllerActionImpl::GetWriterCatalogReference() const
        {
            return std::dynamic_pointer_cast<ICatalogReferenceWriter>(_catalogReference);
        }

        AssignControllerActionImpl::AssignControllerActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_ANIMATION, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LATERAL, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LIGHTING, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LONGITUDINAL, SimpleType::BOOLEAN);
        }

        void AssignControllerActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_ANIMATION)
            {
                // Simple type
                _activateAnimation = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LATERAL)
            {
                // Simple type
                _activateLateral = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LIGHTING)
            {
                // Simple type
                _activateLighting = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LONGITUDINAL)
            {
                // Simple type
                _activateLongitudinal = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType AssignControllerActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AssignControllerActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kController =  GetWriterController();
                if (kController)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kController));
                }
                const auto kCatalogReference =  GetWriterCatalogReference();
                if (kCatalogReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogReference));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AssignControllerActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<AssignControllerActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_activateAnimation = GetActivateAnimation();
            // Simple type
            clonedObject->_activateLateral = GetActivateLateral();
            // Simple type
            clonedObject->_activateLighting = GetActivateLighting();
            // Simple type
            clonedObject->_activateLongitudinal = GetActivateLongitudinal();
            // clone indicators
            	clonedObject->isSetActivateAnimation = isSetActivateAnimation;
            	clonedObject->isSetActivateLateral = isSetActivateLateral;
            	clonedObject->isSetActivateLighting = isSetActivateLighting;
            	clonedObject->isSetActivateLongitudinal = isSetActivateLongitudinal;
            // clone children
            const auto kController =  GetWriterController();
            if (kController)
            {
                auto clonedChild = std::dynamic_pointer_cast<ControllerImpl>(kController)->Clone();
                auto clonedChildIController = std::dynamic_pointer_cast<IController>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetController(std::dynamic_pointer_cast<IControllerWriter>(clonedChildIController));
            }
            const auto kCatalogReference =  GetWriterCatalogReference();
            if (kCatalogReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kCatalogReference)->Clone();
                auto clonedChildICatalogReference = std::dynamic_pointer_cast<ICatalogReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogReference(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChildICatalogReference));
            }
            return clonedObject;
        }

        std::string AssignControllerActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AssignControllerActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CONTROLLER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetController());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogReference());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AssignControllerActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AssignControllerActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AssignControllerActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void AssignControllerActionImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_ANIMATION)
            {
                // Simple type
                _activateAnimation = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LATERAL)
            {
                // Simple type
                _activateLateral = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LIGHTING)
            {
                // Simple type
                _activateLighting = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVATE_LONGITUDINAL)
            {
                // Simple type
                _activateLongitudinal = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void AssignControllerActionImpl::ResetActivateAnimation()
	   {
	   		isSetActivateAnimation = false; 
			_activateAnimation = {};
			
	   }
       bool AssignControllerActionImpl::IsSetActivateAnimation() const
	   {
			return isSetActivateAnimation;
	   }
       void AssignControllerActionImpl::ResetActivateLateral()
	   {
	   		isSetActivateLateral = false; 
			_activateLateral = {};
			
	   }
       bool AssignControllerActionImpl::IsSetActivateLateral() const
	   {
			return isSetActivateLateral;
	   }
       void AssignControllerActionImpl::ResetActivateLighting()
	   {
	   		isSetActivateLighting = false; 
			_activateLighting = {};
			
	   }
       bool AssignControllerActionImpl::IsSetActivateLighting() const
	   {
			return isSetActivateLighting;
	   }
       void AssignControllerActionImpl::ResetActivateLongitudinal()
	   {
	   		isSetActivateLongitudinal = false; 
			_activateLongitudinal = {};
			
	   }
       bool AssignControllerActionImpl::IsSetActivateLongitudinal() const
	   {
			return isSetActivateLongitudinal;
	   }
       void AssignControllerActionImpl::ResetController()
	   {
	   		isSetController = false; 
			_controller = {};
			
	   }
       bool AssignControllerActionImpl::IsSetController() const
	   {
			return isSetController;
	   }
       void AssignControllerActionImpl::ResetCatalogReference()
	   {
	   		isSetCatalogReference = false; 
			_catalogReference = {};
			
	   }
       bool AssignControllerActionImpl::IsSetCatalogReference() const
	   {
			return isSetCatalogReference;
	   }

        IOpenScenarioFlexElement* AssignRouteActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IRoute> AssignRouteActionImpl::GetRoute() const
        {
        	  return _route;
        }
        std::shared_ptr<ICatalogReference> AssignRouteActionImpl::GetCatalogReference() const
        {
        	  return _catalogReference;
        }


        void AssignRouteActionImpl::SetRoute(std::shared_ptr<IRouteWriter> route)
        {
            _route = route;
            _catalogReference = {};
			// set the indicator to true
            isSetRoute = true;          
        }

        void AssignRouteActionImpl::SetCatalogReference(std::shared_ptr<ICatalogReferenceWriter> catalogReference)
        {
            _catalogReference = catalogReference;
            _route = {};
			// set the indicator to true
            isSetCatalogReference = true;          
        }

        std::shared_ptr<void> AssignRouteActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(AssignRouteActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAssignRouteAction).name())
                return std::dynamic_pointer_cast<IAssignRouteAction>(shared_from_this());
            else if (classifier == typeid(IAssignRouteActionWriter).name())
                return std::dynamic_pointer_cast<IAssignRouteActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> AssignRouteActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t AssignRouteActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int AssignRouteActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double AssignRouteActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t AssignRouteActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool AssignRouteActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime AssignRouteActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> AssignRouteActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string AssignRouteActionImpl::GetModelType() const
        {
            return "AssignRouteAction";
        }

            // children
        std::shared_ptr<IRouteWriter> AssignRouteActionImpl::GetWriterRoute() const
        {
            return std::dynamic_pointer_cast<IRouteWriter>(_route);
        }
        std::shared_ptr<ICatalogReferenceWriter> AssignRouteActionImpl::GetWriterCatalogReference() const
        {
            return std::dynamic_pointer_cast<ICatalogReferenceWriter>(_catalogReference);
        }

        AssignRouteActionImpl::AssignRouteActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void AssignRouteActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType AssignRouteActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AssignRouteActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRoute =  GetWriterRoute();
                if (kRoute)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRoute));
                }
                const auto kCatalogReference =  GetWriterCatalogReference();
                if (kCatalogReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogReference));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AssignRouteActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<AssignRouteActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kRoute =  GetWriterRoute();
            if (kRoute)
            {
                auto clonedChild = std::dynamic_pointer_cast<RouteImpl>(kRoute)->Clone();
                auto clonedChildIRoute = std::dynamic_pointer_cast<IRoute>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRoute(std::dynamic_pointer_cast<IRouteWriter>(clonedChildIRoute));
            }
            const auto kCatalogReference =  GetWriterCatalogReference();
            if (kCatalogReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kCatalogReference)->Clone();
                auto clonedChildICatalogReference = std::dynamic_pointer_cast<ICatalogReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogReference(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChildICatalogReference));
            }
            return clonedObject;
        }

        std::string AssignRouteActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AssignRouteActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ROUTE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRoute());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogReference());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AssignRouteActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AssignRouteActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AssignRouteActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void AssignRouteActionImpl::ResetRoute()
	   {
	   		isSetRoute = false; 
			_route = {};
			
	   }
       bool AssignRouteActionImpl::IsSetRoute() const
	   {
			return isSetRoute;
	   }
       void AssignRouteActionImpl::ResetCatalogReference()
	   {
	   		isSetCatalogReference = false; 
			_catalogReference = {};
			
	   }
       bool AssignRouteActionImpl::IsSetCatalogReference() const
	   {
			return isSetCatalogReference;
	   }

        IOpenScenarioFlexElement* AutomaticGearImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        AutomaticGearType AutomaticGearImpl::GetGear() const
        {
        	  return _gear;
        }


        void AutomaticGearImpl::SetGear(const AutomaticGearType gear)
        {
            _gear = gear;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__GEAR);
        }

        std::shared_ptr<void> AutomaticGearImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(AutomaticGearImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAutomaticGear).name())
                return std::dynamic_pointer_cast<IAutomaticGear>(shared_from_this());
            else if (classifier == typeid(IAutomaticGearWriter).name())
                return std::dynamic_pointer_cast<IAutomaticGearWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> AutomaticGearImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t AutomaticGearImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int AutomaticGearImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double AutomaticGearImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t AutomaticGearImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool AutomaticGearImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime AutomaticGearImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> AutomaticGearImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string AutomaticGearImpl::GetModelType() const
        {
            return "AutomaticGear";
        }

        void AutomaticGearImpl::WriteParameterToGear(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__GEAR, parameterName, nullTextMarker /*no textmarker*/);
            _gear = {};
        }

        std::string AutomaticGearImpl::GetParameterFromGear() const
        {
            auto gear = OSC_CONSTANTS::ATTRIBUTE__GEAR;
            return GetParameterNameFromAttribute(gear);
        }

        bool AutomaticGearImpl::IsGearParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__GEAR);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        AutomaticGearImpl::AutomaticGearImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__GEAR, SimpleType::ENUM_TYPE);
        }

        void AutomaticGearImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__GEAR)
            {
                // Enumeration Type
                const auto kResult = AutomaticGearType::GetFromLiteral(parameterLiteralValue);
                if (kResult != AutomaticGearType::UNKNOWN)
                {
                    _gear = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType AutomaticGearImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AutomaticGearImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AutomaticGearImpl::Clone()
        {
            auto clonedObject = std::make_shared<AutomaticGearImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kGear = GetGear();
            if ( kGear.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_gear = AutomaticGearType::GetFromLiteral(kGear.GetLiteral());
            }
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string AutomaticGearImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AutomaticGearImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AutomaticGearImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AutomaticGearImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AutomaticGearImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__GEAR)
            {
                auto gear = GetGear();
                return gear.GetLiteral() != "UNKNOWN" ? gear.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* AxleImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double AxleImpl::GetMaxSteering() const
        {
        	  return _maxSteering;
        }
        double AxleImpl::GetPositionX() const
        {
        	  return _positionX;
        }
        double AxleImpl::GetPositionZ() const
        {
        	  return _positionZ;
        }
        double AxleImpl::GetTrackWidth() const
        {
        	  return _trackWidth;
        }
        double AxleImpl::GetWheelDiameter() const
        {
        	  return _wheelDiameter;
        }


        void AxleImpl::SetMaxSteering(const double maxSteering)
        {
            _maxSteering = maxSteering;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_STEERING);
        }

        void AxleImpl::SetPositionX(const double positionX)
        {
            _positionX = positionX;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__POSITION_X);
        }

        void AxleImpl::SetPositionZ(const double positionZ)
        {
            _positionZ = positionZ;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__POSITION_Z);
        }

        void AxleImpl::SetTrackWidth(const double trackWidth)
        {
            _trackWidth = trackWidth;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TRACK_WIDTH);
        }

        void AxleImpl::SetWheelDiameter(const double wheelDiameter)
        {
            _wheelDiameter = wheelDiameter;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__WHEEL_DIAMETER);
        }

        std::shared_ptr<void> AxleImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(AxleImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAxle).name())
                return std::dynamic_pointer_cast<IAxle>(shared_from_this());
            else if (classifier == typeid(IAxleWriter).name())
                return std::dynamic_pointer_cast<IAxleWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> AxleImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t AxleImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int AxleImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double AxleImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAX_STEERING)
                {
                    return GetMaxSteering();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__POSITION_X)
                {
                    return GetPositionX();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__POSITION_Z)
                {
                    return GetPositionZ();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__TRACK_WIDTH)
                {
                    return GetTrackWidth();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__WHEEL_DIAMETER)
                {
                    return GetWheelDiameter();
                }
                throw KeyNotSupportedException();

        }

        uint16_t AxleImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool AxleImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime AxleImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> AxleImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string AxleImpl::GetModelType() const
        {
            return "Axle";
        }

        void AxleImpl::WriteParameterToMaxSteering(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_STEERING, parameterName, nullTextMarker /*no textmarker*/);
            _maxSteering = {};
        }

        void AxleImpl::WriteParameterToPositionX(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__POSITION_X, parameterName, nullTextMarker /*no textmarker*/);
            _positionX = {};
        }

        void AxleImpl::WriteParameterToPositionZ(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__POSITION_Z, parameterName, nullTextMarker /*no textmarker*/);
            _positionZ = {};
        }

        void AxleImpl::WriteParameterToTrackWidth(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TRACK_WIDTH, parameterName, nullTextMarker /*no textmarker*/);
            _trackWidth = {};
        }

        void AxleImpl::WriteParameterToWheelDiameter(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__WHEEL_DIAMETER, parameterName, nullTextMarker /*no textmarker*/);
            _wheelDiameter = {};
        }

        std::string AxleImpl::GetParameterFromMaxSteering() const
        {
            auto maxSteering = OSC_CONSTANTS::ATTRIBUTE__MAX_STEERING;
            return GetParameterNameFromAttribute(maxSteering);
        }

        std::string AxleImpl::GetParameterFromPositionX() const
        {
            auto positionX = OSC_CONSTANTS::ATTRIBUTE__POSITION_X;
            return GetParameterNameFromAttribute(positionX);
        }

        std::string AxleImpl::GetParameterFromPositionZ() const
        {
            auto positionZ = OSC_CONSTANTS::ATTRIBUTE__POSITION_Z;
            return GetParameterNameFromAttribute(positionZ);
        }

        std::string AxleImpl::GetParameterFromTrackWidth() const
        {
            auto trackWidth = OSC_CONSTANTS::ATTRIBUTE__TRACK_WIDTH;
            return GetParameterNameFromAttribute(trackWidth);
        }

        std::string AxleImpl::GetParameterFromWheelDiameter() const
        {
            auto wheelDiameter = OSC_CONSTANTS::ATTRIBUTE__WHEEL_DIAMETER;
            return GetParameterNameFromAttribute(wheelDiameter);
        }

        bool AxleImpl::IsMaxSteeringParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAX_STEERING);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool AxleImpl::IsPositionXParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__POSITION_X);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool AxleImpl::IsPositionZParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__POSITION_Z);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool AxleImpl::IsTrackWidthParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TRACK_WIDTH);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool AxleImpl::IsWheelDiameterParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__WHEEL_DIAMETER);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        AxleImpl::AxleImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_STEERING, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__POSITION_X, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__POSITION_Z, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TRACK_WIDTH, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__WHEEL_DIAMETER, SimpleType::DOUBLE);
        }

        void AxleImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_STEERING)
            {
                // Simple type
                _maxSteering = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__POSITION_X)
            {
                // Simple type
                _positionX = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__POSITION_Z)
            {
                // Simple type
                _positionZ = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRACK_WIDTH)
            {
                // Simple type
                _trackWidth = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WHEEL_DIAMETER)
            {
                // Simple type
                _wheelDiameter = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType AxleImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AxleImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AxleImpl::Clone()
        {
            auto clonedObject = std::make_shared<AxleImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_maxSteering = GetMaxSteering();
            // Simple type
            clonedObject->_positionX = GetPositionX();
            // Simple type
            clonedObject->_positionZ = GetPositionZ();
            // Simple type
            clonedObject->_trackWidth = GetTrackWidth();
            // Simple type
            clonedObject->_wheelDiameter = GetWheelDiameter();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string AxleImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AxleImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AxleImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AxleImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AxleImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void AxleImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_STEERING)
            {
                // Simple type
                _maxSteering = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__POSITION_X)
            {
                // Simple type
                _positionX = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__POSITION_Z)
            {
                // Simple type
                _positionZ = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRACK_WIDTH)
            {
                // Simple type
                _trackWidth = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WHEEL_DIAMETER)
            {
                // Simple type
                _wheelDiameter = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* AxlesImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IAxle> AxlesImpl::GetFrontAxle() const
        {
        	  return _frontAxle;
        }
        std::shared_ptr<IAxle> AxlesImpl::GetRearAxle() const
        {
        	  return _rearAxle;
        }
        std::vector<std::shared_ptr<IAxle>> AxlesImpl::GetAdditionalAxles() const
        {
            std::vector<std::shared_ptr<IAxle>> temp;
            for(auto&& elm: _additionalAxles)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IAxleWriter>> AxlesImpl::GetWriterAdditionalAxles() const
        {
            return _additionalAxles;
        }

        int AxlesImpl::GetAdditionalAxlesSize() const
        {
            return static_cast<int>(_additionalAxles.size());
        }

        std::shared_ptr<IAxle> AxlesImpl::GetAdditionalAxlesAtIndex(unsigned int index) const
        {
            if (index >= 0 && _additionalAxles.size() > index)
            {
                return _additionalAxles[index];
            }
            return nullptr;
        }


        void AxlesImpl::SetFrontAxle(std::shared_ptr<IAxleWriter> frontAxle)
        {
            _frontAxle = frontAxle;
        }

        void AxlesImpl::SetRearAxle(std::shared_ptr<IAxleWriter> rearAxle)
        {
            _rearAxle = rearAxle;
        }

        void AxlesImpl::SetAdditionalAxles(std::vector<std::shared_ptr<IAxleWriter>>& additionalAxles)
        {
            _additionalAxles = additionalAxles;
			// set the indicator to true
            isSetAdditionalAxles = true;          
        }

        std::shared_ptr<void> AxlesImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(AxlesImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IAxles).name())
                return std::dynamic_pointer_cast<IAxles>(shared_from_this());
            else if (classifier == typeid(IAxlesWriter).name())
                return std::dynamic_pointer_cast<IAxlesWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> AxlesImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t AxlesImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int AxlesImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double AxlesImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t AxlesImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool AxlesImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime AxlesImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> AxlesImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string AxlesImpl::GetModelType() const
        {
            return "Axles";
        }

            // children
        std::shared_ptr<IAxleWriter> AxlesImpl::GetWriterFrontAxle() const
        {
            return std::dynamic_pointer_cast<IAxleWriter>(_frontAxle);
        }
        std::shared_ptr<IAxleWriter> AxlesImpl::GetWriterRearAxle() const
        {
            return std::dynamic_pointer_cast<IAxleWriter>(_rearAxle);
        }

        AxlesImpl::AxlesImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void AxlesImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType AxlesImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AxlesImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kFrontAxle =  GetWriterFrontAxle();
                if (kFrontAxle)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kFrontAxle));
                }
                const auto kRearAxle =  GetWriterRearAxle();
                if (kRearAxle)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRearAxle));
                }
                auto additionalAxles =  GetWriterAdditionalAxles();
                if (!additionalAxles.empty())
                {
                    for(auto&& item : additionalAxles)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AxlesImpl::Clone()
        {
            auto clonedObject = std::make_shared<AxlesImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kFrontAxle =  GetWriterFrontAxle();
            if (kFrontAxle)
            {
                auto clonedChild = std::dynamic_pointer_cast<AxleImpl>(kFrontAxle)->Clone();
                auto clonedChildIAxle = std::dynamic_pointer_cast<IAxle>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetFrontAxle(std::dynamic_pointer_cast<IAxleWriter>(clonedChildIAxle));
            }
            const auto kRearAxle =  GetWriterRearAxle();
            if (kRearAxle)
            {
                auto clonedChild = std::dynamic_pointer_cast<AxleImpl>(kRearAxle)->Clone();
                auto clonedChildIAxle = std::dynamic_pointer_cast<IAxle>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRearAxle(std::dynamic_pointer_cast<IAxleWriter>(clonedChildIAxle));
            }
            const auto kAdditionalAxles =  GetWriterAdditionalAxles();
            if (!kAdditionalAxles.empty())
            {
                std::vector<std::shared_ptr<IAxleWriter>> clonedList;
                for(auto&& kItem : kAdditionalAxles)
                {
                    auto clonedChild = std::dynamic_pointer_cast<AxleImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IAxleWriter>(clonedChild));
                }
                clonedObject->SetAdditionalAxles(clonedList);
            }
            return clonedObject;
        }

        std::string AxlesImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AxlesImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__FRONT_AXLE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetFrontAxle());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__REAR_AXLE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRearAxle());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AxlesImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__ADDITIONAL_AXLE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetAdditionalAxles())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AxlesImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AxlesImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void AxlesImpl::ResetAdditionalAxles()
	   {
	   		isSetAdditionalAxles = false; 
			_additionalAxles = {};
			
	   }
       bool AxlesImpl::IsSetAdditionalAxles() const
	   {
			return isSetAdditionalAxles;
	   }

        IOpenScenarioFlexElement* BoundingBoxImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<ICenter> BoundingBoxImpl::GetCenter() const
        {
        	  return _center;
        }
        std::shared_ptr<IDimensions> BoundingBoxImpl::GetDimensions() const
        {
        	  return _dimensions;
        }


        void BoundingBoxImpl::SetCenter(std::shared_ptr<ICenterWriter> center)
        {
            _center = center;
        }

        void BoundingBoxImpl::SetDimensions(std::shared_ptr<IDimensionsWriter> dimensions)
        {
            _dimensions = dimensions;
        }

        std::shared_ptr<void> BoundingBoxImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(BoundingBoxImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IBoundingBox).name())
                return std::dynamic_pointer_cast<IBoundingBox>(shared_from_this());
            else if (classifier == typeid(IBoundingBoxWriter).name())
                return std::dynamic_pointer_cast<IBoundingBoxWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> BoundingBoxImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t BoundingBoxImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int BoundingBoxImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double BoundingBoxImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t BoundingBoxImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool BoundingBoxImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime BoundingBoxImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> BoundingBoxImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string BoundingBoxImpl::GetModelType() const
        {
            return "BoundingBox";
        }

            // children
        std::shared_ptr<ICenterWriter> BoundingBoxImpl::GetWriterCenter() const
        {
            return std::dynamic_pointer_cast<ICenterWriter>(_center);
        }
        std::shared_ptr<IDimensionsWriter> BoundingBoxImpl::GetWriterDimensions() const
        {
            return std::dynamic_pointer_cast<IDimensionsWriter>(_dimensions);
        }

        BoundingBoxImpl::BoundingBoxImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void BoundingBoxImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType BoundingBoxImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> BoundingBoxImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kCenter =  GetWriterCenter();
                if (kCenter)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCenter));
                }
                const auto kDimensions =  GetWriterDimensions();
                if (kDimensions)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDimensions));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> BoundingBoxImpl::Clone()
        {
            auto clonedObject = std::make_shared<BoundingBoxImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kCenter =  GetWriterCenter();
            if (kCenter)
            {
                auto clonedChild = std::dynamic_pointer_cast<CenterImpl>(kCenter)->Clone();
                auto clonedChildICenter = std::dynamic_pointer_cast<ICenter>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCenter(std::dynamic_pointer_cast<ICenterWriter>(clonedChildICenter));
            }
            const auto kDimensions =  GetWriterDimensions();
            if (kDimensions)
            {
                auto clonedChild = std::dynamic_pointer_cast<DimensionsImpl>(kDimensions)->Clone();
                auto clonedChildIDimensions = std::dynamic_pointer_cast<IDimensions>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDimensions(std::dynamic_pointer_cast<IDimensionsWriter>(clonedChildIDimensions));
            }
            return clonedObject;
        }

        std::string BoundingBoxImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> BoundingBoxImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CENTER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCenter());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIMENSIONS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDimensions());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> BoundingBoxImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> BoundingBoxImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string BoundingBoxImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* BrakeImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double BrakeImpl::GetMaxRate() const
        {
        	  return _maxRate;
        }
        double BrakeImpl::GetValue() const
        {
        	  return _value;
        }


        void BrakeImpl::SetMaxRate(const double maxRate)
        {
            _maxRate = maxRate;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_RATE);
			// set the indicator to true
            isSetMaxRate = true;          
        }

        void BrakeImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> BrakeImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(BrakeImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IBrake).name())
                return std::dynamic_pointer_cast<IBrake>(shared_from_this());
            else if (classifier == typeid(IBrakeWriter).name())
                return std::dynamic_pointer_cast<IBrakeWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> BrakeImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t BrakeImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int BrakeImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double BrakeImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAX_RATE)
                {
                    return GetMaxRate();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t BrakeImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool BrakeImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime BrakeImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> BrakeImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string BrakeImpl::GetModelType() const
        {
            return "Brake";
        }

        void BrakeImpl::WriteParameterToMaxRate(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_RATE, parameterName, nullTextMarker /*no textmarker*/);
            _maxRate = {};
        }

        void BrakeImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string BrakeImpl::GetParameterFromMaxRate() const
        {
            auto maxRate = OSC_CONSTANTS::ATTRIBUTE__MAX_RATE;
            return GetParameterNameFromAttribute(maxRate);
        }

        std::string BrakeImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool BrakeImpl::IsMaxRateParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAX_RATE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool BrakeImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        BrakeImpl::BrakeImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_RATE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void BrakeImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_RATE)
            {
                // Simple type
                _maxRate = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType BrakeImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> BrakeImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> BrakeImpl::Clone()
        {
            auto clonedObject = std::make_shared<BrakeImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_maxRate = GetMaxRate();
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            	clonedObject->isSetMaxRate = isSetMaxRate;
            // clone children
            return clonedObject;
        }

        std::string BrakeImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> BrakeImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> BrakeImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> BrakeImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string BrakeImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void BrakeImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_RATE)
            {
                // Simple type
                _maxRate = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void BrakeImpl::ResetMaxRate()
	   {
	   		isSetMaxRate = false; 
			_maxRate = {};
			
	   }
       bool BrakeImpl::IsSetMaxRate() const
	   {
			return isSetMaxRate;
	   }

        IOpenScenarioFlexElement* BrakeInputImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IBrake> BrakeInputImpl::GetBrakePercent() const
        {
        	  return _brakePercent;
        }
        std::shared_ptr<IBrake> BrakeInputImpl::GetBrakeForce() const
        {
        	  return _brakeForce;
        }


        void BrakeInputImpl::SetBrakePercent(std::shared_ptr<IBrakeWriter> brakePercent)
        {
            _brakePercent = brakePercent;
            _brakeForce = {};
        }

        void BrakeInputImpl::SetBrakeForce(std::shared_ptr<IBrakeWriter> brakeForce)
        {
            _brakeForce = brakeForce;
            _brakePercent = {};
        }

        std::shared_ptr<void> BrakeInputImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(BrakeInputImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IBrakeInput).name())
                return std::dynamic_pointer_cast<IBrakeInput>(shared_from_this());
            else if (classifier == typeid(IBrakeInputWriter).name())
                return std::dynamic_pointer_cast<IBrakeInputWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> BrakeInputImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t BrakeInputImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int BrakeInputImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double BrakeInputImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t BrakeInputImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool BrakeInputImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime BrakeInputImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> BrakeInputImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string BrakeInputImpl::GetModelType() const
        {
            return "BrakeInput";
        }

            // children
        std::shared_ptr<IBrakeWriter> BrakeInputImpl::GetWriterBrakePercent() const
        {
            return std::dynamic_pointer_cast<IBrakeWriter>(_brakePercent);
        }
        std::shared_ptr<IBrakeWriter> BrakeInputImpl::GetWriterBrakeForce() const
        {
            return std::dynamic_pointer_cast<IBrakeWriter>(_brakeForce);
        }

        BrakeInputImpl::BrakeInputImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void BrakeInputImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType BrakeInputImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> BrakeInputImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kBrakePercent =  GetWriterBrakePercent();
                if (kBrakePercent)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kBrakePercent));
                }
                const auto kBrakeForce =  GetWriterBrakeForce();
                if (kBrakeForce)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kBrakeForce));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> BrakeInputImpl::Clone()
        {
            auto clonedObject = std::make_shared<BrakeInputImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kBrakePercent =  GetWriterBrakePercent();
            if (kBrakePercent)
            {
                auto clonedChild = std::dynamic_pointer_cast<BrakeImpl>(kBrakePercent)->Clone();
                auto clonedChildIBrake = std::dynamic_pointer_cast<IBrake>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetBrakePercent(std::dynamic_pointer_cast<IBrakeWriter>(clonedChildIBrake));
            }
            const auto kBrakeForce =  GetWriterBrakeForce();
            if (kBrakeForce)
            {
                auto clonedChild = std::dynamic_pointer_cast<BrakeImpl>(kBrakeForce)->Clone();
                auto clonedChildIBrake = std::dynamic_pointer_cast<IBrake>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetBrakeForce(std::dynamic_pointer_cast<IBrakeWriter>(clonedChildIBrake));
            }
            return clonedObject;
        }

        std::string BrakeInputImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> BrakeInputImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BRAKE_PERCENT)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetBrakePercent());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BRAKE_FORCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetBrakeForce());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> BrakeInputImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> BrakeInputImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string BrakeInputImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ByEntityConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<ITriggeringEntities> ByEntityConditionImpl::GetTriggeringEntities() const
        {
        	  return _triggeringEntities;
        }
        std::shared_ptr<IEntityCondition> ByEntityConditionImpl::GetEntityCondition() const
        {
        	  return _entityCondition;
        }


        void ByEntityConditionImpl::SetTriggeringEntities(std::shared_ptr<ITriggeringEntitiesWriter> triggeringEntities)
        {
            _triggeringEntities = triggeringEntities;
        }

        void ByEntityConditionImpl::SetEntityCondition(std::shared_ptr<IEntityConditionWriter> entityCondition)
        {
            _entityCondition = entityCondition;
        }

        std::shared_ptr<void> ByEntityConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ByEntityConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IByEntityCondition).name())
                return std::dynamic_pointer_cast<IByEntityCondition>(shared_from_this());
            else if (classifier == typeid(IByEntityConditionWriter).name())
                return std::dynamic_pointer_cast<IByEntityConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ByEntityConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ByEntityConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ByEntityConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ByEntityConditionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ByEntityConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ByEntityConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ByEntityConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ByEntityConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ByEntityConditionImpl::GetModelType() const
        {
            return "ByEntityCondition";
        }

            // children
        std::shared_ptr<ITriggeringEntitiesWriter> ByEntityConditionImpl::GetWriterTriggeringEntities() const
        {
            return std::dynamic_pointer_cast<ITriggeringEntitiesWriter>(_triggeringEntities);
        }
        std::shared_ptr<IEntityConditionWriter> ByEntityConditionImpl::GetWriterEntityCondition() const
        {
            return std::dynamic_pointer_cast<IEntityConditionWriter>(_entityCondition);
        }

        ByEntityConditionImpl::ByEntityConditionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ByEntityConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ByEntityConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ByEntityConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kTriggeringEntities =  GetWriterTriggeringEntities();
                if (kTriggeringEntities)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTriggeringEntities));
                }
                const auto kEntityCondition =  GetWriterEntityCondition();
                if (kEntityCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEntityCondition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ByEntityConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ByEntityConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kTriggeringEntities =  GetWriterTriggeringEntities();
            if (kTriggeringEntities)
            {
                auto clonedChild = std::dynamic_pointer_cast<TriggeringEntitiesImpl>(kTriggeringEntities)->Clone();
                auto clonedChildITriggeringEntities = std::dynamic_pointer_cast<ITriggeringEntities>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTriggeringEntities(std::dynamic_pointer_cast<ITriggeringEntitiesWriter>(clonedChildITriggeringEntities));
            }
            const auto kEntityCondition =  GetWriterEntityCondition();
            if (kEntityCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<EntityConditionImpl>(kEntityCondition)->Clone();
                auto clonedChildIEntityCondition = std::dynamic_pointer_cast<IEntityCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEntityCondition(std::dynamic_pointer_cast<IEntityConditionWriter>(clonedChildIEntityCondition));
            }
            return clonedObject;
        }

        std::string ByEntityConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ByEntityConditionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRIGGERING_ENTITIES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTriggeringEntities());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEntityCondition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ByEntityConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ByEntityConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ByEntityConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ByObjectTypeImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        ObjectType ByObjectTypeImpl::GetType() const
        {
        	  return _type;
        }


        void ByObjectTypeImpl::SetType(const ObjectType type)
        {
            _type = type;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TYPE);
        }

        std::shared_ptr<void> ByObjectTypeImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ByObjectTypeImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IByObjectType).name())
                return std::dynamic_pointer_cast<IByObjectType>(shared_from_this());
            else if (classifier == typeid(IByObjectTypeWriter).name())
                return std::dynamic_pointer_cast<IByObjectTypeWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ByObjectTypeImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ByObjectTypeImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ByObjectTypeImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ByObjectTypeImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ByObjectTypeImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ByObjectTypeImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ByObjectTypeImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ByObjectTypeImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ByObjectTypeImpl::GetModelType() const
        {
            return "ByObjectType";
        }

        void ByObjectTypeImpl::WriteParameterToType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _type = {};
        }

        std::string ByObjectTypeImpl::GetParameterFromType() const
        {
            auto type = OSC_CONSTANTS::ATTRIBUTE__TYPE;
            return GetParameterNameFromAttribute(type);
        }

        bool ByObjectTypeImpl::IsTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        ByObjectTypeImpl::ByObjectTypeImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TYPE, SimpleType::ENUM_TYPE);
        }

        void ByObjectTypeImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TYPE)
            {
                // Enumeration Type
                const auto kResult = ObjectType::GetFromLiteral(parameterLiteralValue);
                if (kResult != ObjectType::UNKNOWN)
                {
                    _type = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType ByObjectTypeImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ByObjectTypeImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ByObjectTypeImpl::Clone()
        {
            auto clonedObject = std::make_shared<ByObjectTypeImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kType = GetType();
            if ( kType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_type = ObjectType::GetFromLiteral(kType.GetLiteral());
            }
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string ByObjectTypeImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ByObjectTypeImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ByObjectTypeImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ByObjectTypeImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ByObjectTypeImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__TYPE)
            {
                auto type = GetType();
                return type.GetLiteral() != "UNKNOWN" ? type.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ByTypeImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        ObjectType ByTypeImpl::GetObjectType() const
        {
        	  return _objectType;
        }


        void ByTypeImpl::SetObjectType(const ObjectType objectType)
        {
            _objectType = objectType;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__OBJECT_TYPE);
        }

        std::shared_ptr<void> ByTypeImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ByTypeImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IByType).name())
                return std::dynamic_pointer_cast<IByType>(shared_from_this());
            else if (classifier == typeid(IByTypeWriter).name())
                return std::dynamic_pointer_cast<IByTypeWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ByTypeImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ByTypeImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ByTypeImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ByTypeImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ByTypeImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ByTypeImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ByTypeImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ByTypeImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ByTypeImpl::GetModelType() const
        {
            return "ByType";
        }

        void ByTypeImpl::WriteParameterToObjectType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__OBJECT_TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _objectType = {};
        }

        std::string ByTypeImpl::GetParameterFromObjectType() const
        {
            auto objectType = OSC_CONSTANTS::ATTRIBUTE__OBJECT_TYPE;
            return GetParameterNameFromAttribute(objectType);
        }

        bool ByTypeImpl::IsObjectTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__OBJECT_TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        ByTypeImpl::ByTypeImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__OBJECT_TYPE, SimpleType::ENUM_TYPE);
        }

        void ByTypeImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__OBJECT_TYPE)
            {
                // Enumeration Type
                const auto kResult = ObjectType::GetFromLiteral(parameterLiteralValue);
                if (kResult != ObjectType::UNKNOWN)
                {
                    _objectType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType ByTypeImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ByTypeImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ByTypeImpl::Clone()
        {
            auto clonedObject = std::make_shared<ByTypeImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kObjectType = GetObjectType();
            if ( kObjectType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_objectType = ObjectType::GetFromLiteral(kObjectType.GetLiteral());
            }
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string ByTypeImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ByTypeImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ByTypeImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ByTypeImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ByTypeImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__OBJECT_TYPE)
            {
                auto objectType = GetObjectType();
                return objectType.GetLiteral() != "UNKNOWN" ? objectType.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ByValueConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IParameterCondition> ByValueConditionImpl::GetParameterCondition() const
        {
        	  return _parameterCondition;
        }
        std::shared_ptr<ITimeOfDayCondition> ByValueConditionImpl::GetTimeOfDayCondition() const
        {
        	  return _timeOfDayCondition;
        }
        std::shared_ptr<ISimulationTimeCondition> ByValueConditionImpl::GetSimulationTimeCondition() const
        {
        	  return _simulationTimeCondition;
        }
        std::shared_ptr<IStoryboardElementStateCondition> ByValueConditionImpl::GetStoryboardElementStateCondition() const
        {
        	  return _storyboardElementStateCondition;
        }
        std::shared_ptr<IUserDefinedValueCondition> ByValueConditionImpl::GetUserDefinedValueCondition() const
        {
        	  return _userDefinedValueCondition;
        }
        std::shared_ptr<ITrafficSignalCondition> ByValueConditionImpl::GetTrafficSignalCondition() const
        {
        	  return _trafficSignalCondition;
        }
        std::shared_ptr<ITrafficSignalControllerCondition> ByValueConditionImpl::GetTrafficSignalControllerCondition() const
        {
        	  return _trafficSignalControllerCondition;
        }
        std::shared_ptr<IVariableCondition> ByValueConditionImpl::GetVariableCondition() const
        {
        	  return _variableCondition;
        }


        void ByValueConditionImpl::SetParameterCondition(std::shared_ptr<IParameterConditionWriter> parameterCondition)
        {
            _parameterCondition = parameterCondition;
            _timeOfDayCondition = {};
            _simulationTimeCondition = {};
            _storyboardElementStateCondition = {};
            _userDefinedValueCondition = {};
            _trafficSignalCondition = {};
            _trafficSignalControllerCondition = {};
            _variableCondition = {};
			// set the indicator to true
            isSetParameterCondition = true;          
        }

        void ByValueConditionImpl::SetTimeOfDayCondition(std::shared_ptr<ITimeOfDayConditionWriter> timeOfDayCondition)
        {
            _timeOfDayCondition = timeOfDayCondition;
            _parameterCondition = {};
            _simulationTimeCondition = {};
            _storyboardElementStateCondition = {};
            _userDefinedValueCondition = {};
            _trafficSignalCondition = {};
            _trafficSignalControllerCondition = {};
            _variableCondition = {};
			// set the indicator to true
            isSetTimeOfDayCondition = true;          
        }

        void ByValueConditionImpl::SetSimulationTimeCondition(std::shared_ptr<ISimulationTimeConditionWriter> simulationTimeCondition)
        {
            _simulationTimeCondition = simulationTimeCondition;
            _parameterCondition = {};
            _timeOfDayCondition = {};
            _storyboardElementStateCondition = {};
            _userDefinedValueCondition = {};
            _trafficSignalCondition = {};
            _trafficSignalControllerCondition = {};
            _variableCondition = {};
			// set the indicator to true
            isSetSimulationTimeCondition = true;          
        }

        void ByValueConditionImpl::SetStoryboardElementStateCondition(std::shared_ptr<IStoryboardElementStateConditionWriter> storyboardElementStateCondition)
        {
            _storyboardElementStateCondition = storyboardElementStateCondition;
            _parameterCondition = {};
            _timeOfDayCondition = {};
            _simulationTimeCondition = {};
            _userDefinedValueCondition = {};
            _trafficSignalCondition = {};
            _trafficSignalControllerCondition = {};
            _variableCondition = {};
			// set the indicator to true
            isSetStoryboardElementStateCondition = true;          
        }

        void ByValueConditionImpl::SetUserDefinedValueCondition(std::shared_ptr<IUserDefinedValueConditionWriter> userDefinedValueCondition)
        {
            _userDefinedValueCondition = userDefinedValueCondition;
            _parameterCondition = {};
            _timeOfDayCondition = {};
            _simulationTimeCondition = {};
            _storyboardElementStateCondition = {};
            _trafficSignalCondition = {};
            _trafficSignalControllerCondition = {};
            _variableCondition = {};
			// set the indicator to true
            isSetUserDefinedValueCondition = true;          
        }

        void ByValueConditionImpl::SetTrafficSignalCondition(std::shared_ptr<ITrafficSignalConditionWriter> trafficSignalCondition)
        {
            _trafficSignalCondition = trafficSignalCondition;
            _parameterCondition = {};
            _timeOfDayCondition = {};
            _simulationTimeCondition = {};
            _storyboardElementStateCondition = {};
            _userDefinedValueCondition = {};
            _trafficSignalControllerCondition = {};
            _variableCondition = {};
			// set the indicator to true
            isSetTrafficSignalCondition = true;          
        }

        void ByValueConditionImpl::SetTrafficSignalControllerCondition(std::shared_ptr<ITrafficSignalControllerConditionWriter> trafficSignalControllerCondition)
        {
            _trafficSignalControllerCondition = trafficSignalControllerCondition;
            _parameterCondition = {};
            _timeOfDayCondition = {};
            _simulationTimeCondition = {};
            _storyboardElementStateCondition = {};
            _userDefinedValueCondition = {};
            _trafficSignalCondition = {};
            _variableCondition = {};
			// set the indicator to true
            isSetTrafficSignalControllerCondition = true;          
        }

        void ByValueConditionImpl::SetVariableCondition(std::shared_ptr<IVariableConditionWriter> variableCondition)
        {
            _variableCondition = variableCondition;
            _parameterCondition = {};
            _timeOfDayCondition = {};
            _simulationTimeCondition = {};
            _storyboardElementStateCondition = {};
            _userDefinedValueCondition = {};
            _trafficSignalCondition = {};
            _trafficSignalControllerCondition = {};
			// set the indicator to true
            isSetVariableCondition = true;          
        }

        std::shared_ptr<void> ByValueConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ByValueConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IByValueCondition).name())
                return std::dynamic_pointer_cast<IByValueCondition>(shared_from_this());
            else if (classifier == typeid(IByValueConditionWriter).name())
                return std::dynamic_pointer_cast<IByValueConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ByValueConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ByValueConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ByValueConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ByValueConditionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ByValueConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ByValueConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ByValueConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ByValueConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ByValueConditionImpl::GetModelType() const
        {
            return "ByValueCondition";
        }

            // children
        std::shared_ptr<IParameterConditionWriter> ByValueConditionImpl::GetWriterParameterCondition() const
        {
            return std::dynamic_pointer_cast<IParameterConditionWriter>(_parameterCondition);
        }
        std::shared_ptr<ITimeOfDayConditionWriter> ByValueConditionImpl::GetWriterTimeOfDayCondition() const
        {
            return std::dynamic_pointer_cast<ITimeOfDayConditionWriter>(_timeOfDayCondition);
        }
        std::shared_ptr<ISimulationTimeConditionWriter> ByValueConditionImpl::GetWriterSimulationTimeCondition() const
        {
            return std::dynamic_pointer_cast<ISimulationTimeConditionWriter>(_simulationTimeCondition);
        }
        std::shared_ptr<IStoryboardElementStateConditionWriter> ByValueConditionImpl::GetWriterStoryboardElementStateCondition() const
        {
            return std::dynamic_pointer_cast<IStoryboardElementStateConditionWriter>(_storyboardElementStateCondition);
        }
        std::shared_ptr<IUserDefinedValueConditionWriter> ByValueConditionImpl::GetWriterUserDefinedValueCondition() const
        {
            return std::dynamic_pointer_cast<IUserDefinedValueConditionWriter>(_userDefinedValueCondition);
        }
        std::shared_ptr<ITrafficSignalConditionWriter> ByValueConditionImpl::GetWriterTrafficSignalCondition() const
        {
            return std::dynamic_pointer_cast<ITrafficSignalConditionWriter>(_trafficSignalCondition);
        }
        std::shared_ptr<ITrafficSignalControllerConditionWriter> ByValueConditionImpl::GetWriterTrafficSignalControllerCondition() const
        {
            return std::dynamic_pointer_cast<ITrafficSignalControllerConditionWriter>(_trafficSignalControllerCondition);
        }
        std::shared_ptr<IVariableConditionWriter> ByValueConditionImpl::GetWriterVariableCondition() const
        {
            return std::dynamic_pointer_cast<IVariableConditionWriter>(_variableCondition);
        }

        ByValueConditionImpl::ByValueConditionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ByValueConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ByValueConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ByValueConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kParameterCondition =  GetWriterParameterCondition();
                if (kParameterCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kParameterCondition));
                }
                const auto kTimeOfDayCondition =  GetWriterTimeOfDayCondition();
                if (kTimeOfDayCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTimeOfDayCondition));
                }
                const auto kSimulationTimeCondition =  GetWriterSimulationTimeCondition();
                if (kSimulationTimeCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSimulationTimeCondition));
                }
                const auto kStoryboardElementStateCondition =  GetWriterStoryboardElementStateCondition();
                if (kStoryboardElementStateCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kStoryboardElementStateCondition));
                }
                const auto kUserDefinedValueCondition =  GetWriterUserDefinedValueCondition();
                if (kUserDefinedValueCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kUserDefinedValueCondition));
                }
                const auto kTrafficSignalCondition =  GetWriterTrafficSignalCondition();
                if (kTrafficSignalCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficSignalCondition));
                }
                const auto kTrafficSignalControllerCondition =  GetWriterTrafficSignalControllerCondition();
                if (kTrafficSignalControllerCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficSignalControllerCondition));
                }
                const auto kVariableCondition =  GetWriterVariableCondition();
                if (kVariableCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kVariableCondition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ByValueConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ByValueConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kParameterCondition =  GetWriterParameterCondition();
            if (kParameterCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<ParameterConditionImpl>(kParameterCondition)->Clone();
                auto clonedChildIParameterCondition = std::dynamic_pointer_cast<IParameterCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetParameterCondition(std::dynamic_pointer_cast<IParameterConditionWriter>(clonedChildIParameterCondition));
            }
            const auto kTimeOfDayCondition =  GetWriterTimeOfDayCondition();
            if (kTimeOfDayCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TimeOfDayConditionImpl>(kTimeOfDayCondition)->Clone();
                auto clonedChildITimeOfDayCondition = std::dynamic_pointer_cast<ITimeOfDayCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTimeOfDayCondition(std::dynamic_pointer_cast<ITimeOfDayConditionWriter>(clonedChildITimeOfDayCondition));
            }
            const auto kSimulationTimeCondition =  GetWriterSimulationTimeCondition();
            if (kSimulationTimeCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<SimulationTimeConditionImpl>(kSimulationTimeCondition)->Clone();
                auto clonedChildISimulationTimeCondition = std::dynamic_pointer_cast<ISimulationTimeCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSimulationTimeCondition(std::dynamic_pointer_cast<ISimulationTimeConditionWriter>(clonedChildISimulationTimeCondition));
            }
            const auto kStoryboardElementStateCondition =  GetWriterStoryboardElementStateCondition();
            if (kStoryboardElementStateCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<StoryboardElementStateConditionImpl>(kStoryboardElementStateCondition)->Clone();
                auto clonedChildIStoryboardElementStateCondition = std::dynamic_pointer_cast<IStoryboardElementStateCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetStoryboardElementStateCondition(std::dynamic_pointer_cast<IStoryboardElementStateConditionWriter>(clonedChildIStoryboardElementStateCondition));
            }
            const auto kUserDefinedValueCondition =  GetWriterUserDefinedValueCondition();
            if (kUserDefinedValueCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<UserDefinedValueConditionImpl>(kUserDefinedValueCondition)->Clone();
                auto clonedChildIUserDefinedValueCondition = std::dynamic_pointer_cast<IUserDefinedValueCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetUserDefinedValueCondition(std::dynamic_pointer_cast<IUserDefinedValueConditionWriter>(clonedChildIUserDefinedValueCondition));
            }
            const auto kTrafficSignalCondition =  GetWriterTrafficSignalCondition();
            if (kTrafficSignalCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficSignalConditionImpl>(kTrafficSignalCondition)->Clone();
                auto clonedChildITrafficSignalCondition = std::dynamic_pointer_cast<ITrafficSignalCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficSignalCondition(std::dynamic_pointer_cast<ITrafficSignalConditionWriter>(clonedChildITrafficSignalCondition));
            }
            const auto kTrafficSignalControllerCondition =  GetWriterTrafficSignalControllerCondition();
            if (kTrafficSignalControllerCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficSignalControllerConditionImpl>(kTrafficSignalControllerCondition)->Clone();
                auto clonedChildITrafficSignalControllerCondition = std::dynamic_pointer_cast<ITrafficSignalControllerCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficSignalControllerCondition(std::dynamic_pointer_cast<ITrafficSignalControllerConditionWriter>(clonedChildITrafficSignalControllerCondition));
            }
            const auto kVariableCondition =  GetWriterVariableCondition();
            if (kVariableCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<VariableConditionImpl>(kVariableCondition)->Clone();
                auto clonedChildIVariableCondition = std::dynamic_pointer_cast<IVariableCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetVariableCondition(std::dynamic_pointer_cast<IVariableConditionWriter>(clonedChildIVariableCondition));
            }
            return clonedObject;
        }

        std::string ByValueConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ByValueConditionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParameterCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TIME_OF_DAY_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTimeOfDayCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SIMULATION_TIME_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSimulationTimeCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__STORYBOARD_ELEMENT_STATE_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetStoryboardElementStateCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__USER_DEFINED_VALUE_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetUserDefinedValueCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SIGNAL_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficSignalCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SIGNAL_CONTROLLER_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficSignalControllerCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__VARIABLE_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetVariableCondition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ByValueConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ByValueConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ByValueConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void ByValueConditionImpl::ResetParameterCondition()
	   {
	   		isSetParameterCondition = false; 
			_parameterCondition = {};
			
	   }
       bool ByValueConditionImpl::IsSetParameterCondition() const
	   {
			return isSetParameterCondition;
	   }
       void ByValueConditionImpl::ResetTimeOfDayCondition()
	   {
	   		isSetTimeOfDayCondition = false; 
			_timeOfDayCondition = {};
			
	   }
       bool ByValueConditionImpl::IsSetTimeOfDayCondition() const
	   {
			return isSetTimeOfDayCondition;
	   }
       void ByValueConditionImpl::ResetSimulationTimeCondition()
	   {
	   		isSetSimulationTimeCondition = false; 
			_simulationTimeCondition = {};
			
	   }
       bool ByValueConditionImpl::IsSetSimulationTimeCondition() const
	   {
			return isSetSimulationTimeCondition;
	   }
       void ByValueConditionImpl::ResetStoryboardElementStateCondition()
	   {
	   		isSetStoryboardElementStateCondition = false; 
			_storyboardElementStateCondition = {};
			
	   }
       bool ByValueConditionImpl::IsSetStoryboardElementStateCondition() const
	   {
			return isSetStoryboardElementStateCondition;
	   }
       void ByValueConditionImpl::ResetUserDefinedValueCondition()
	   {
	   		isSetUserDefinedValueCondition = false; 
			_userDefinedValueCondition = {};
			
	   }
       bool ByValueConditionImpl::IsSetUserDefinedValueCondition() const
	   {
			return isSetUserDefinedValueCondition;
	   }
       void ByValueConditionImpl::ResetTrafficSignalCondition()
	   {
	   		isSetTrafficSignalCondition = false; 
			_trafficSignalCondition = {};
			
	   }
       bool ByValueConditionImpl::IsSetTrafficSignalCondition() const
	   {
			return isSetTrafficSignalCondition;
	   }
       void ByValueConditionImpl::ResetTrafficSignalControllerCondition()
	   {
	   		isSetTrafficSignalControllerCondition = false; 
			_trafficSignalControllerCondition = {};
			
	   }
       bool ByValueConditionImpl::IsSetTrafficSignalControllerCondition() const
	   {
			return isSetTrafficSignalControllerCondition;
	   }
       void ByValueConditionImpl::ResetVariableCondition()
	   {
	   		isSetVariableCondition = false; 
			_variableCondition = {};
			
	   }
       bool ByValueConditionImpl::IsSetVariableCondition() const
	   {
			return isSetVariableCondition;
	   }

        IOpenScenarioFlexElement* CatalogImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string CatalogImpl::GetName() const
        {
        	  return _name;
        }
        std::vector<std::shared_ptr<IVehicle>> CatalogImpl::GetVehicles() const
        {
            std::vector<std::shared_ptr<IVehicle>> temp;
            for(auto&& elm: _vehicles)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IVehicleWriter>> CatalogImpl::GetWriterVehicles() const
        {
            return _vehicles;
        }

        int CatalogImpl::GetVehiclesSize() const
        {
            return static_cast<int>(_vehicles.size());
        }

        std::shared_ptr<IVehicle> CatalogImpl::GetVehiclesAtIndex(unsigned int index) const
        {
            if (index >= 0 && _vehicles.size() > index)
            {
                return _vehicles[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<IController>> CatalogImpl::GetControllers() const
        {
            std::vector<std::shared_ptr<IController>> temp;
            for(auto&& elm: _controllers)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IControllerWriter>> CatalogImpl::GetWriterControllers() const
        {
            return _controllers;
        }

        int CatalogImpl::GetControllersSize() const
        {
            return static_cast<int>(_controllers.size());
        }

        std::shared_ptr<IController> CatalogImpl::GetControllersAtIndex(unsigned int index) const
        {
            if (index >= 0 && _controllers.size() > index)
            {
                return _controllers[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<IPedestrian>> CatalogImpl::GetPedestrians() const
        {
            std::vector<std::shared_ptr<IPedestrian>> temp;
            for(auto&& elm: _pedestrians)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IPedestrianWriter>> CatalogImpl::GetWriterPedestrians() const
        {
            return _pedestrians;
        }

        int CatalogImpl::GetPedestriansSize() const
        {
            return static_cast<int>(_pedestrians.size());
        }

        std::shared_ptr<IPedestrian> CatalogImpl::GetPedestriansAtIndex(unsigned int index) const
        {
            if (index >= 0 && _pedestrians.size() > index)
            {
                return _pedestrians[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<IMiscObject>> CatalogImpl::GetMiscObjects() const
        {
            std::vector<std::shared_ptr<IMiscObject>> temp;
            for(auto&& elm: _miscObjects)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IMiscObjectWriter>> CatalogImpl::GetWriterMiscObjects() const
        {
            return _miscObjects;
        }

        int CatalogImpl::GetMiscObjectsSize() const
        {
            return static_cast<int>(_miscObjects.size());
        }

        std::shared_ptr<IMiscObject> CatalogImpl::GetMiscObjectsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _miscObjects.size() > index)
            {
                return _miscObjects[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<IEnvironment>> CatalogImpl::GetEnvironments() const
        {
            std::vector<std::shared_ptr<IEnvironment>> temp;
            for(auto&& elm: _environments)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IEnvironmentWriter>> CatalogImpl::GetWriterEnvironments() const
        {
            return _environments;
        }

        int CatalogImpl::GetEnvironmentsSize() const
        {
            return static_cast<int>(_environments.size());
        }

        std::shared_ptr<IEnvironment> CatalogImpl::GetEnvironmentsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _environments.size() > index)
            {
                return _environments[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<IManeuver>> CatalogImpl::GetManeuvers() const
        {
            std::vector<std::shared_ptr<IManeuver>> temp;
            for(auto&& elm: _maneuvers)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IManeuverWriter>> CatalogImpl::GetWriterManeuvers() const
        {
            return _maneuvers;
        }

        int CatalogImpl::GetManeuversSize() const
        {
            return static_cast<int>(_maneuvers.size());
        }

        std::shared_ptr<IManeuver> CatalogImpl::GetManeuversAtIndex(unsigned int index) const
        {
            if (index >= 0 && _maneuvers.size() > index)
            {
                return _maneuvers[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<ITrajectory>> CatalogImpl::GetTrajectories() const
        {
            std::vector<std::shared_ptr<ITrajectory>> temp;
            for(auto&& elm: _trajectories)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<ITrajectoryWriter>> CatalogImpl::GetWriterTrajectories() const
        {
            return _trajectories;
        }

        int CatalogImpl::GetTrajectoriesSize() const
        {
            return static_cast<int>(_trajectories.size());
        }

        std::shared_ptr<ITrajectory> CatalogImpl::GetTrajectoriesAtIndex(unsigned int index) const
        {
            if (index >= 0 && _trajectories.size() > index)
            {
                return _trajectories[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<IRoute>> CatalogImpl::GetRoutes() const
        {
            std::vector<std::shared_ptr<IRoute>> temp;
            for(auto&& elm: _routes)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IRouteWriter>> CatalogImpl::GetWriterRoutes() const
        {
            return _routes;
        }

        int CatalogImpl::GetRoutesSize() const
        {
            return static_cast<int>(_routes.size());
        }

        std::shared_ptr<IRoute> CatalogImpl::GetRoutesAtIndex(unsigned int index) const
        {
            if (index >= 0 && _routes.size() > index)
            {
                return _routes[index];
            }
            return nullptr;
        }


        void CatalogImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
			// set the indicator to true
            isSetName = true;          
        }

        void CatalogImpl::SetVehicles(std::vector<std::shared_ptr<IVehicleWriter>>& vehicles)
        {
            _vehicles = vehicles;
			// set the indicator to true
            isSetVehicles = true;          
        }

        void CatalogImpl::SetControllers(std::vector<std::shared_ptr<IControllerWriter>>& controllers)
        {
            _controllers = controllers;
			// set the indicator to true
            isSetControllers = true;          
        }

        void CatalogImpl::SetPedestrians(std::vector<std::shared_ptr<IPedestrianWriter>>& pedestrians)
        {
            _pedestrians = pedestrians;
			// set the indicator to true
            isSetPedestrians = true;          
        }

        void CatalogImpl::SetMiscObjects(std::vector<std::shared_ptr<IMiscObjectWriter>>& miscObjects)
        {
            _miscObjects = miscObjects;
			// set the indicator to true
            isSetMiscObjects = true;          
        }

        void CatalogImpl::SetEnvironments(std::vector<std::shared_ptr<IEnvironmentWriter>>& environments)
        {
            _environments = environments;
			// set the indicator to true
            isSetEnvironments = true;          
        }

        void CatalogImpl::SetManeuvers(std::vector<std::shared_ptr<IManeuverWriter>>& maneuvers)
        {
            _maneuvers = maneuvers;
			// set the indicator to true
            isSetManeuvers = true;          
        }

        void CatalogImpl::SetTrajectories(std::vector<std::shared_ptr<ITrajectoryWriter>>& trajectories)
        {
            _trajectories = trajectories;
			// set the indicator to true
            isSetTrajectories = true;          
        }

        void CatalogImpl::SetRoutes(std::vector<std::shared_ptr<IRouteWriter>>& routes)
        {
            _routes = routes;
			// set the indicator to true
            isSetRoutes = true;          
        }

        std::shared_ptr<void> CatalogImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(CatalogImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ICatalog).name())
                return std::dynamic_pointer_cast<ICatalog>(shared_from_this());
            else if (classifier == typeid(ICatalogWriter).name())
                return std::dynamic_pointer_cast<ICatalogWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> CatalogImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t CatalogImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int CatalogImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double CatalogImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t CatalogImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool CatalogImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime CatalogImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> CatalogImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string CatalogImpl::GetModelType() const
        {
            return "Catalog";
        }

        void CatalogImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        std::string CatalogImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        bool CatalogImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        CatalogImpl::CatalogImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        void CatalogImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType CatalogImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> CatalogImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto vehicles =  GetWriterVehicles();
                if (!vehicles.empty())
                {
                    for(auto&& item : vehicles)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto controllers =  GetWriterControllers();
                if (!controllers.empty())
                {
                    for(auto&& item : controllers)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto pedestrians =  GetWriterPedestrians();
                if (!pedestrians.empty())
                {
                    for(auto&& item : pedestrians)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto miscObjects =  GetWriterMiscObjects();
                if (!miscObjects.empty())
                {
                    for(auto&& item : miscObjects)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto environments =  GetWriterEnvironments();
                if (!environments.empty())
                {
                    for(auto&& item : environments)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto maneuvers =  GetWriterManeuvers();
                if (!maneuvers.empty())
                {
                    for(auto&& item : maneuvers)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto trajectories =  GetWriterTrajectories();
                if (!trajectories.empty())
                {
                    for(auto&& item : trajectories)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto routes =  GetWriterRoutes();
                if (!routes.empty())
                {
                    for(auto&& item : routes)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> CatalogImpl::Clone()
        {
            auto clonedObject = std::make_shared<CatalogImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone indicators
            	clonedObject->isSetName = isSetName;
            // clone children
            const auto kVehicles =  GetWriterVehicles();
            if (!kVehicles.empty())
            {
                std::vector<std::shared_ptr<IVehicleWriter>> clonedList;
                for(auto&& kItem : kVehicles)
                {
                    auto clonedChild = std::dynamic_pointer_cast<VehicleImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IVehicleWriter>(clonedChild));
                }
                clonedObject->SetVehicles(clonedList);
            }
            const auto kControllers =  GetWriterControllers();
            if (!kControllers.empty())
            {
                std::vector<std::shared_ptr<IControllerWriter>> clonedList;
                for(auto&& kItem : kControllers)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ControllerImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IControllerWriter>(clonedChild));
                }
                clonedObject->SetControllers(clonedList);
            }
            const auto kPedestrians =  GetWriterPedestrians();
            if (!kPedestrians.empty())
            {
                std::vector<std::shared_ptr<IPedestrianWriter>> clonedList;
                for(auto&& kItem : kPedestrians)
                {
                    auto clonedChild = std::dynamic_pointer_cast<PedestrianImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IPedestrianWriter>(clonedChild));
                }
                clonedObject->SetPedestrians(clonedList);
            }
            const auto kMiscObjects =  GetWriterMiscObjects();
            if (!kMiscObjects.empty())
            {
                std::vector<std::shared_ptr<IMiscObjectWriter>> clonedList;
                for(auto&& kItem : kMiscObjects)
                {
                    auto clonedChild = std::dynamic_pointer_cast<MiscObjectImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IMiscObjectWriter>(clonedChild));
                }
                clonedObject->SetMiscObjects(clonedList);
            }
            const auto kEnvironments =  GetWriterEnvironments();
            if (!kEnvironments.empty())
            {
                std::vector<std::shared_ptr<IEnvironmentWriter>> clonedList;
                for(auto&& kItem : kEnvironments)
                {
                    auto clonedChild = std::dynamic_pointer_cast<EnvironmentImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IEnvironmentWriter>(clonedChild));
                }
                clonedObject->SetEnvironments(clonedList);
            }
            const auto kManeuvers =  GetWriterManeuvers();
            if (!kManeuvers.empty())
            {
                std::vector<std::shared_ptr<IManeuverWriter>> clonedList;
                for(auto&& kItem : kManeuvers)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ManeuverImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IManeuverWriter>(clonedChild));
                }
                clonedObject->SetManeuvers(clonedList);
            }
            const auto kTrajectories =  GetWriterTrajectories();
            if (!kTrajectories.empty())
            {
                std::vector<std::shared_ptr<ITrajectoryWriter>> clonedList;
                for(auto&& kItem : kTrajectories)
                {
                    auto clonedChild = std::dynamic_pointer_cast<TrajectoryImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<ITrajectoryWriter>(clonedChild));
                }
                clonedObject->SetTrajectories(clonedList);
            }
            const auto kRoutes =  GetWriterRoutes();
            if (!kRoutes.empty())
            {
                std::vector<std::shared_ptr<IRouteWriter>> clonedList;
                for(auto&& kItem : kRoutes)
                {
                    auto clonedChild = std::dynamic_pointer_cast<RouteImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IRouteWriter>(clonedChild));
                }
                clonedObject->SetRoutes(clonedList);
            }
            return clonedObject;
        }

        std::string CatalogImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CatalogImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> CatalogImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__VEHICLE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetVehicles())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__CONTROLLER)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetControllers())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__PEDESTRIAN)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetPedestrians())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__MISC_OBJECT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetMiscObjects())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__ENVIRONMENT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetEnvironments())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__MANEUVER)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetManeuvers())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__TRAJECTORY)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetTrajectories())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__ROUTE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetRoutes())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CatalogImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string CatalogImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void CatalogImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void CatalogImpl::ResetName()
	   {
	   		isSetName = false; 
			_name = {};
			
	   }
       bool CatalogImpl::IsSetName() const
	   {
			return isSetName;
	   }
       void CatalogImpl::ResetVehicles()
	   {
	   		isSetVehicles = false; 
			_vehicles = {};
			
	   }
       bool CatalogImpl::IsSetVehicles() const
	   {
			return isSetVehicles;
	   }
       void CatalogImpl::ResetControllers()
	   {
	   		isSetControllers = false; 
			_controllers = {};
			
	   }
       bool CatalogImpl::IsSetControllers() const
	   {
			return isSetControllers;
	   }
       void CatalogImpl::ResetPedestrians()
	   {
	   		isSetPedestrians = false; 
			_pedestrians = {};
			
	   }
       bool CatalogImpl::IsSetPedestrians() const
	   {
			return isSetPedestrians;
	   }
       void CatalogImpl::ResetMiscObjects()
	   {
	   		isSetMiscObjects = false; 
			_miscObjects = {};
			
	   }
       bool CatalogImpl::IsSetMiscObjects() const
	   {
			return isSetMiscObjects;
	   }
       void CatalogImpl::ResetEnvironments()
	   {
	   		isSetEnvironments = false; 
			_environments = {};
			
	   }
       bool CatalogImpl::IsSetEnvironments() const
	   {
			return isSetEnvironments;
	   }
       void CatalogImpl::ResetManeuvers()
	   {
	   		isSetManeuvers = false; 
			_maneuvers = {};
			
	   }
       bool CatalogImpl::IsSetManeuvers() const
	   {
			return isSetManeuvers;
	   }
       void CatalogImpl::ResetTrajectories()
	   {
	   		isSetTrajectories = false; 
			_trajectories = {};
			
	   }
       bool CatalogImpl::IsSetTrajectories() const
	   {
			return isSetTrajectories;
	   }
       void CatalogImpl::ResetRoutes()
	   {
	   		isSetRoutes = false; 
			_routes = {};
			
	   }
       bool CatalogImpl::IsSetRoutes() const
	   {
			return isSetRoutes;
	   }

        IOpenScenarioFlexElement* CatalogDefinitionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<ICatalog> CatalogDefinitionImpl::GetCatalog() const
        {
        	  return _catalog;
        }


        void CatalogDefinitionImpl::SetCatalog(std::shared_ptr<ICatalogWriter> catalog)
        {
            _catalog = catalog;
        }

        std::shared_ptr<void> CatalogDefinitionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(CatalogDefinitionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ICatalogDefinition).name())
                return std::dynamic_pointer_cast<ICatalogDefinition>(shared_from_this());
            else if (classifier == typeid(ICatalogDefinitionWriter).name())
                return std::dynamic_pointer_cast<ICatalogDefinitionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> CatalogDefinitionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t CatalogDefinitionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int CatalogDefinitionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double CatalogDefinitionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t CatalogDefinitionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool CatalogDefinitionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime CatalogDefinitionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> CatalogDefinitionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string CatalogDefinitionImpl::GetModelType() const
        {
            return "CatalogDefinition";
        }

            // children
        std::shared_ptr<ICatalogWriter> CatalogDefinitionImpl::GetWriterCatalog() const
        {
            return std::dynamic_pointer_cast<ICatalogWriter>(_catalog);
        }

        CatalogDefinitionImpl::CatalogDefinitionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void CatalogDefinitionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType CatalogDefinitionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> CatalogDefinitionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kCatalog =  GetWriterCatalog();
                if (kCatalog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalog));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> CatalogDefinitionImpl::Clone()
        {
            auto clonedObject = std::make_shared<CatalogDefinitionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kCatalog =  GetWriterCatalog();
            if (kCatalog)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogImpl>(kCatalog)->Clone();
                auto clonedChildICatalog = std::dynamic_pointer_cast<ICatalog>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalog(std::dynamic_pointer_cast<ICatalogWriter>(clonedChildICatalog));
            }
            return clonedObject;
        }

        std::string CatalogDefinitionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CatalogDefinitionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalog());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> CatalogDefinitionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CatalogDefinitionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string CatalogDefinitionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* CatalogLocationsImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IVehicleCatalogLocation> CatalogLocationsImpl::GetVehicleCatalog() const
        {
        	  return _vehicleCatalog;
        }
        std::shared_ptr<IControllerCatalogLocation> CatalogLocationsImpl::GetControllerCatalog() const
        {
        	  return _controllerCatalog;
        }
        std::shared_ptr<IPedestrianCatalogLocation> CatalogLocationsImpl::GetPedestrianCatalog() const
        {
        	  return _pedestrianCatalog;
        }
        std::shared_ptr<IMiscObjectCatalogLocation> CatalogLocationsImpl::GetMiscObjectCatalog() const
        {
        	  return _miscObjectCatalog;
        }
        std::shared_ptr<IEnvironmentCatalogLocation> CatalogLocationsImpl::GetEnvironmentCatalog() const
        {
        	  return _environmentCatalog;
        }
        std::shared_ptr<IManeuverCatalogLocation> CatalogLocationsImpl::GetManeuverCatalog() const
        {
        	  return _maneuverCatalog;
        }
        std::shared_ptr<ITrajectoryCatalogLocation> CatalogLocationsImpl::GetTrajectoryCatalog() const
        {
        	  return _trajectoryCatalog;
        }
        std::shared_ptr<IRouteCatalogLocation> CatalogLocationsImpl::GetRouteCatalog() const
        {
        	  return _routeCatalog;
        }


        void CatalogLocationsImpl::SetVehicleCatalog(std::shared_ptr<IVehicleCatalogLocationWriter> vehicleCatalog)
        {
            _vehicleCatalog = vehicleCatalog;
			// set the indicator to true
            isSetVehicleCatalog = true;          
        }

        void CatalogLocationsImpl::SetControllerCatalog(std::shared_ptr<IControllerCatalogLocationWriter> controllerCatalog)
        {
            _controllerCatalog = controllerCatalog;
			// set the indicator to true
            isSetControllerCatalog = true;          
        }

        void CatalogLocationsImpl::SetPedestrianCatalog(std::shared_ptr<IPedestrianCatalogLocationWriter> pedestrianCatalog)
        {
            _pedestrianCatalog = pedestrianCatalog;
			// set the indicator to true
            isSetPedestrianCatalog = true;          
        }

        void CatalogLocationsImpl::SetMiscObjectCatalog(std::shared_ptr<IMiscObjectCatalogLocationWriter> miscObjectCatalog)
        {
            _miscObjectCatalog = miscObjectCatalog;
			// set the indicator to true
            isSetMiscObjectCatalog = true;          
        }

        void CatalogLocationsImpl::SetEnvironmentCatalog(std::shared_ptr<IEnvironmentCatalogLocationWriter> environmentCatalog)
        {
            _environmentCatalog = environmentCatalog;
			// set the indicator to true
            isSetEnvironmentCatalog = true;          
        }

        void CatalogLocationsImpl::SetManeuverCatalog(std::shared_ptr<IManeuverCatalogLocationWriter> maneuverCatalog)
        {
            _maneuverCatalog = maneuverCatalog;
			// set the indicator to true
            isSetManeuverCatalog = true;          
        }

        void CatalogLocationsImpl::SetTrajectoryCatalog(std::shared_ptr<ITrajectoryCatalogLocationWriter> trajectoryCatalog)
        {
            _trajectoryCatalog = trajectoryCatalog;
			// set the indicator to true
            isSetTrajectoryCatalog = true;          
        }

        void CatalogLocationsImpl::SetRouteCatalog(std::shared_ptr<IRouteCatalogLocationWriter> routeCatalog)
        {
            _routeCatalog = routeCatalog;
			// set the indicator to true
            isSetRouteCatalog = true;          
        }

        std::shared_ptr<void> CatalogLocationsImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(CatalogLocationsImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ICatalogLocations).name())
                return std::dynamic_pointer_cast<ICatalogLocations>(shared_from_this());
            else if (classifier == typeid(ICatalogLocationsWriter).name())
                return std::dynamic_pointer_cast<ICatalogLocationsWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> CatalogLocationsImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t CatalogLocationsImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int CatalogLocationsImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double CatalogLocationsImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t CatalogLocationsImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool CatalogLocationsImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime CatalogLocationsImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> CatalogLocationsImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string CatalogLocationsImpl::GetModelType() const
        {
            return "CatalogLocations";
        }

            // children
        std::shared_ptr<IVehicleCatalogLocationWriter> CatalogLocationsImpl::GetWriterVehicleCatalog() const
        {
            return std::dynamic_pointer_cast<IVehicleCatalogLocationWriter>(_vehicleCatalog);
        }
        std::shared_ptr<IControllerCatalogLocationWriter> CatalogLocationsImpl::GetWriterControllerCatalog() const
        {
            return std::dynamic_pointer_cast<IControllerCatalogLocationWriter>(_controllerCatalog);
        }
        std::shared_ptr<IPedestrianCatalogLocationWriter> CatalogLocationsImpl::GetWriterPedestrianCatalog() const
        {
            return std::dynamic_pointer_cast<IPedestrianCatalogLocationWriter>(_pedestrianCatalog);
        }
        std::shared_ptr<IMiscObjectCatalogLocationWriter> CatalogLocationsImpl::GetWriterMiscObjectCatalog() const
        {
            return std::dynamic_pointer_cast<IMiscObjectCatalogLocationWriter>(_miscObjectCatalog);
        }
        std::shared_ptr<IEnvironmentCatalogLocationWriter> CatalogLocationsImpl::GetWriterEnvironmentCatalog() const
        {
            return std::dynamic_pointer_cast<IEnvironmentCatalogLocationWriter>(_environmentCatalog);
        }
        std::shared_ptr<IManeuverCatalogLocationWriter> CatalogLocationsImpl::GetWriterManeuverCatalog() const
        {
            return std::dynamic_pointer_cast<IManeuverCatalogLocationWriter>(_maneuverCatalog);
        }
        std::shared_ptr<ITrajectoryCatalogLocationWriter> CatalogLocationsImpl::GetWriterTrajectoryCatalog() const
        {
            return std::dynamic_pointer_cast<ITrajectoryCatalogLocationWriter>(_trajectoryCatalog);
        }
        std::shared_ptr<IRouteCatalogLocationWriter> CatalogLocationsImpl::GetWriterRouteCatalog() const
        {
            return std::dynamic_pointer_cast<IRouteCatalogLocationWriter>(_routeCatalog);
        }

        CatalogLocationsImpl::CatalogLocationsImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void CatalogLocationsImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType CatalogLocationsImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> CatalogLocationsImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kVehicleCatalog =  GetWriterVehicleCatalog();
                if (kVehicleCatalog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kVehicleCatalog));
                }
                const auto kControllerCatalog =  GetWriterControllerCatalog();
                if (kControllerCatalog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kControllerCatalog));
                }
                const auto kPedestrianCatalog =  GetWriterPedestrianCatalog();
                if (kPedestrianCatalog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPedestrianCatalog));
                }
                const auto kMiscObjectCatalog =  GetWriterMiscObjectCatalog();
                if (kMiscObjectCatalog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kMiscObjectCatalog));
                }
                const auto kEnvironmentCatalog =  GetWriterEnvironmentCatalog();
                if (kEnvironmentCatalog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEnvironmentCatalog));
                }
                const auto kManeuverCatalog =  GetWriterManeuverCatalog();
                if (kManeuverCatalog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kManeuverCatalog));
                }
                const auto kTrajectoryCatalog =  GetWriterTrajectoryCatalog();
                if (kTrajectoryCatalog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrajectoryCatalog));
                }
                const auto kRouteCatalog =  GetWriterRouteCatalog();
                if (kRouteCatalog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRouteCatalog));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> CatalogLocationsImpl::Clone()
        {
            auto clonedObject = std::make_shared<CatalogLocationsImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kVehicleCatalog =  GetWriterVehicleCatalog();
            if (kVehicleCatalog)
            {
                auto clonedChild = std::dynamic_pointer_cast<VehicleCatalogLocationImpl>(kVehicleCatalog)->Clone();
                auto clonedChildIVehicleCatalogLocation = std::dynamic_pointer_cast<IVehicleCatalogLocation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetVehicleCatalog(std::dynamic_pointer_cast<IVehicleCatalogLocationWriter>(clonedChildIVehicleCatalogLocation));
            }
            const auto kControllerCatalog =  GetWriterControllerCatalog();
            if (kControllerCatalog)
            {
                auto clonedChild = std::dynamic_pointer_cast<ControllerCatalogLocationImpl>(kControllerCatalog)->Clone();
                auto clonedChildIControllerCatalogLocation = std::dynamic_pointer_cast<IControllerCatalogLocation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetControllerCatalog(std::dynamic_pointer_cast<IControllerCatalogLocationWriter>(clonedChildIControllerCatalogLocation));
            }
            const auto kPedestrianCatalog =  GetWriterPedestrianCatalog();
            if (kPedestrianCatalog)
            {
                auto clonedChild = std::dynamic_pointer_cast<PedestrianCatalogLocationImpl>(kPedestrianCatalog)->Clone();
                auto clonedChildIPedestrianCatalogLocation = std::dynamic_pointer_cast<IPedestrianCatalogLocation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPedestrianCatalog(std::dynamic_pointer_cast<IPedestrianCatalogLocationWriter>(clonedChildIPedestrianCatalogLocation));
            }
            const auto kMiscObjectCatalog =  GetWriterMiscObjectCatalog();
            if (kMiscObjectCatalog)
            {
                auto clonedChild = std::dynamic_pointer_cast<MiscObjectCatalogLocationImpl>(kMiscObjectCatalog)->Clone();
                auto clonedChildIMiscObjectCatalogLocation = std::dynamic_pointer_cast<IMiscObjectCatalogLocation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetMiscObjectCatalog(std::dynamic_pointer_cast<IMiscObjectCatalogLocationWriter>(clonedChildIMiscObjectCatalogLocation));
            }
            const auto kEnvironmentCatalog =  GetWriterEnvironmentCatalog();
            if (kEnvironmentCatalog)
            {
                auto clonedChild = std::dynamic_pointer_cast<EnvironmentCatalogLocationImpl>(kEnvironmentCatalog)->Clone();
                auto clonedChildIEnvironmentCatalogLocation = std::dynamic_pointer_cast<IEnvironmentCatalogLocation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEnvironmentCatalog(std::dynamic_pointer_cast<IEnvironmentCatalogLocationWriter>(clonedChildIEnvironmentCatalogLocation));
            }
            const auto kManeuverCatalog =  GetWriterManeuverCatalog();
            if (kManeuverCatalog)
            {
                auto clonedChild = std::dynamic_pointer_cast<ManeuverCatalogLocationImpl>(kManeuverCatalog)->Clone();
                auto clonedChildIManeuverCatalogLocation = std::dynamic_pointer_cast<IManeuverCatalogLocation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetManeuverCatalog(std::dynamic_pointer_cast<IManeuverCatalogLocationWriter>(clonedChildIManeuverCatalogLocation));
            }
            const auto kTrajectoryCatalog =  GetWriterTrajectoryCatalog();
            if (kTrajectoryCatalog)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrajectoryCatalogLocationImpl>(kTrajectoryCatalog)->Clone();
                auto clonedChildITrajectoryCatalogLocation = std::dynamic_pointer_cast<ITrajectoryCatalogLocation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrajectoryCatalog(std::dynamic_pointer_cast<ITrajectoryCatalogLocationWriter>(clonedChildITrajectoryCatalogLocation));
            }
            const auto kRouteCatalog =  GetWriterRouteCatalog();
            if (kRouteCatalog)
            {
                auto clonedChild = std::dynamic_pointer_cast<RouteCatalogLocationImpl>(kRouteCatalog)->Clone();
                auto clonedChildIRouteCatalogLocation = std::dynamic_pointer_cast<IRouteCatalogLocation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRouteCatalog(std::dynamic_pointer_cast<IRouteCatalogLocationWriter>(clonedChildIRouteCatalogLocation));
            }
            return clonedObject;
        }

        std::string CatalogLocationsImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CatalogLocationsImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__VEHICLE_CATALOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetVehicleCatalog());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CONTROLLER_CATALOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetControllerCatalog());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PEDESTRIAN_CATALOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPedestrianCatalog());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__MISC_OBJECT_CATALOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetMiscObjectCatalog());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ENVIRONMENT_CATALOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEnvironmentCatalog());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__MANEUVER_CATALOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetManeuverCatalog());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAJECTORY_CATALOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrajectoryCatalog());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ROUTE_CATALOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRouteCatalog());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> CatalogLocationsImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CatalogLocationsImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string CatalogLocationsImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void CatalogLocationsImpl::ResetVehicleCatalog()
	   {
	   		isSetVehicleCatalog = false; 
			_vehicleCatalog = {};
			
	   }
       bool CatalogLocationsImpl::IsSetVehicleCatalog() const
	   {
			return isSetVehicleCatalog;
	   }
       void CatalogLocationsImpl::ResetControllerCatalog()
	   {
	   		isSetControllerCatalog = false; 
			_controllerCatalog = {};
			
	   }
       bool CatalogLocationsImpl::IsSetControllerCatalog() const
	   {
			return isSetControllerCatalog;
	   }
       void CatalogLocationsImpl::ResetPedestrianCatalog()
	   {
	   		isSetPedestrianCatalog = false; 
			_pedestrianCatalog = {};
			
	   }
       bool CatalogLocationsImpl::IsSetPedestrianCatalog() const
	   {
			return isSetPedestrianCatalog;
	   }
       void CatalogLocationsImpl::ResetMiscObjectCatalog()
	   {
	   		isSetMiscObjectCatalog = false; 
			_miscObjectCatalog = {};
			
	   }
       bool CatalogLocationsImpl::IsSetMiscObjectCatalog() const
	   {
			return isSetMiscObjectCatalog;
	   }
       void CatalogLocationsImpl::ResetEnvironmentCatalog()
	   {
	   		isSetEnvironmentCatalog = false; 
			_environmentCatalog = {};
			
	   }
       bool CatalogLocationsImpl::IsSetEnvironmentCatalog() const
	   {
			return isSetEnvironmentCatalog;
	   }
       void CatalogLocationsImpl::ResetManeuverCatalog()
	   {
	   		isSetManeuverCatalog = false; 
			_maneuverCatalog = {};
			
	   }
       bool CatalogLocationsImpl::IsSetManeuverCatalog() const
	   {
			return isSetManeuverCatalog;
	   }
       void CatalogLocationsImpl::ResetTrajectoryCatalog()
	   {
	   		isSetTrajectoryCatalog = false; 
			_trajectoryCatalog = {};
			
	   }
       bool CatalogLocationsImpl::IsSetTrajectoryCatalog() const
	   {
			return isSetTrajectoryCatalog;
	   }
       void CatalogLocationsImpl::ResetRouteCatalog()
	   {
	   		isSetRouteCatalog = false; 
			_routeCatalog = {};
			
	   }
       bool CatalogLocationsImpl::IsSetRouteCatalog() const
	   {
			return isSetRouteCatalog;
	   }

        IOpenScenarioFlexElement* CatalogReferenceImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string CatalogReferenceImpl::GetCatalogName() const
        {
        	  return _catalogName;
        }
        std::string CatalogReferenceImpl::GetEntryName() const
        {
        	  return _entryName;
        }
        std::vector<std::shared_ptr<IParameterAssignment>> CatalogReferenceImpl::GetParameterAssignments() const
        {
            std::vector<std::shared_ptr<IParameterAssignment>> temp;
            for(auto&& elm: _parameterAssignments)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IParameterAssignmentWriter>> CatalogReferenceImpl::GetWriterParameterAssignments() const
        {
            return _parameterAssignments;
        }

        int CatalogReferenceImpl::GetParameterAssignmentsSize() const
        {
            return static_cast<int>(_parameterAssignments.size());
        }

        std::shared_ptr<IParameterAssignment> CatalogReferenceImpl::GetParameterAssignmentsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _parameterAssignments.size() > index)
            {
                return _parameterAssignments[index];
            }
            return nullptr;
        }
        std::shared_ptr<ICatalogElement> CatalogReferenceImpl::GetRef() const
        {
        	  return _ref;
        }


        void CatalogReferenceImpl::SetCatalogName(const std::string catalogName)
        {
            _catalogName = catalogName;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CATALOG_NAME);
        }

        void CatalogReferenceImpl::SetEntryName(const std::string entryName)
        {
            _entryName = entryName;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTRY_NAME);
        }

        void CatalogReferenceImpl::SetParameterAssignments(std::vector<std::shared_ptr<IParameterAssignmentWriter>>& parameterAssignments)
        {
            _parameterAssignments = parameterAssignments;
			// set the indicator to true
            isSetParameterAssignments = true;          
        }

        void CatalogReferenceImpl::SetRef(const std::shared_ptr<ICatalogElement> ref)
        {
            _ref = ref;
        }

        std::shared_ptr<void> CatalogReferenceImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(CatalogReferenceImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ICatalogReference).name())
                return std::dynamic_pointer_cast<ICatalogReference>(shared_from_this());
            else if (classifier == typeid(ICatalogReferenceWriter).name())
                return std::dynamic_pointer_cast<ICatalogReferenceWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> CatalogReferenceImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t CatalogReferenceImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int CatalogReferenceImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double CatalogReferenceImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t CatalogReferenceImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool CatalogReferenceImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime CatalogReferenceImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> CatalogReferenceImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string CatalogReferenceImpl::GetModelType() const
        {
            return "CatalogReference";
        }

        void CatalogReferenceImpl::WriteParameterToCatalogName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CATALOG_NAME, parameterName, nullTextMarker /*no textmarker*/);
            _catalogName = {};
        }

        void CatalogReferenceImpl::WriteParameterToEntryName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTRY_NAME, parameterName, nullTextMarker /*no textmarker*/);
            _entryName = {};
        }

        std::string CatalogReferenceImpl::GetParameterFromCatalogName() const
        {
            auto catalogName = OSC_CONSTANTS::ATTRIBUTE__CATALOG_NAME;
            return GetParameterNameFromAttribute(catalogName);
        }

        std::string CatalogReferenceImpl::GetParameterFromEntryName() const
        {
            auto entryName = OSC_CONSTANTS::ATTRIBUTE__ENTRY_NAME;
            return GetParameterNameFromAttribute(entryName);
        }

        bool CatalogReferenceImpl::IsCatalogNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CATALOG_NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool CatalogReferenceImpl::IsEntryNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTRY_NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        CatalogReferenceImpl::CatalogReferenceImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CATALOG_NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTRY_NAME, SimpleType::STRING);
        }

        void CatalogReferenceImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CATALOG_NAME)
            {
                // Simple type
                _catalogName = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTRY_NAME)
            {
                // Simple type
                _entryName = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType CatalogReferenceImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> CatalogReferenceImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterAssignments =  GetWriterParameterAssignments();
                if (!parameterAssignments.empty())
                {
                    for(auto&& item : parameterAssignments)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> CatalogReferenceImpl::Clone()
        {
            auto clonedObject = std::make_shared<CatalogReferenceImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_catalogName = GetCatalogName();
            // Simple type
            clonedObject->_entryName = GetEntryName();
            // clone indicators
            // clone children
            const auto kParameterAssignments =  GetWriterParameterAssignments();
            if (!kParameterAssignments.empty())
            {
                std::vector<std::shared_ptr<IParameterAssignmentWriter>> clonedList;
                for(auto&& kItem : kParameterAssignments)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterAssignmentImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterAssignmentWriter>(clonedChild));
                }
                clonedObject->SetParameterAssignments(clonedList);
            }
            return clonedObject;
        }

        std::string CatalogReferenceImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__CATALOG_NAME)
            {
                return GetCatalogName();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTRY_NAME)
            {
                return GetEntryName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CatalogReferenceImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> CatalogReferenceImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_ASSIGNMENT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterAssignments())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CatalogReferenceImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string CatalogReferenceImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void CatalogReferenceImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CATALOG_NAME)
            {
                // Simple type
                _catalogName = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTRY_NAME)
            {
                // Simple type
                _entryName = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void CatalogReferenceImpl::ResetParameterAssignments()
	   {
	   		isSetParameterAssignments = false; 
			_parameterAssignments = {};
			
	   }
       bool CatalogReferenceImpl::IsSetParameterAssignments() const
	   {
			return isSetParameterAssignments;
	   }

        IOpenScenarioFlexElement* CenterImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double CenterImpl::GetX() const
        {
        	  return _x;
        }
        double CenterImpl::GetY() const
        {
        	  return _y;
        }
        double CenterImpl::GetZ() const
        {
        	  return _z;
        }


        void CenterImpl::SetX(const double x)
        {
            _x = x;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__X);
        }

        void CenterImpl::SetY(const double y)
        {
            _y = y;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__Y);
        }

        void CenterImpl::SetZ(const double z)
        {
            _z = z;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__Z);
        }

        std::shared_ptr<void> CenterImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(CenterImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ICenter).name())
                return std::dynamic_pointer_cast<ICenter>(shared_from_this());
            else if (classifier == typeid(ICenterWriter).name())
                return std::dynamic_pointer_cast<ICenterWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> CenterImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t CenterImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int CenterImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double CenterImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__X)
                {
                    return GetX();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__Y)
                {
                    return GetY();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__Z)
                {
                    return GetZ();
                }
                throw KeyNotSupportedException();

        }

        uint16_t CenterImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool CenterImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime CenterImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> CenterImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string CenterImpl::GetModelType() const
        {
            return "Center";
        }

        void CenterImpl::WriteParameterToX(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__X, parameterName, nullTextMarker /*no textmarker*/);
            _x = {};
        }

        void CenterImpl::WriteParameterToY(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__Y, parameterName, nullTextMarker /*no textmarker*/);
            _y = {};
        }

        void CenterImpl::WriteParameterToZ(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__Z, parameterName, nullTextMarker /*no textmarker*/);
            _z = {};
        }

        std::string CenterImpl::GetParameterFromX() const
        {
            auto x = OSC_CONSTANTS::ATTRIBUTE__X;
            return GetParameterNameFromAttribute(x);
        }

        std::string CenterImpl::GetParameterFromY() const
        {
            auto y = OSC_CONSTANTS::ATTRIBUTE__Y;
            return GetParameterNameFromAttribute(y);
        }

        std::string CenterImpl::GetParameterFromZ() const
        {
            auto z = OSC_CONSTANTS::ATTRIBUTE__Z;
            return GetParameterNameFromAttribute(z);
        }

        bool CenterImpl::IsXParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__X);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool CenterImpl::IsYParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__Y);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool CenterImpl::IsZParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__Z);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        CenterImpl::CenterImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__X, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__Y, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__Z, SimpleType::DOUBLE);
        }

        void CenterImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__X)
            {
                // Simple type
                _x = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__Y)
            {
                // Simple type
                _y = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__Z)
            {
                // Simple type
                _z = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType CenterImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> CenterImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> CenterImpl::Clone()
        {
            auto clonedObject = std::make_shared<CenterImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_x = GetX();
            // Simple type
            clonedObject->_y = GetY();
            // Simple type
            clonedObject->_z = GetZ();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string CenterImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CenterImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> CenterImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CenterImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string CenterImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void CenterImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__X)
            {
                // Simple type
                _x = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__Y)
            {
                // Simple type
                _y = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__Z)
            {
                // Simple type
                _z = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* CentralSwarmObjectImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<INamedReference<IEntity>> CentralSwarmObjectImpl::GetEntityRef() const
        {
        	 return _entityRef;
        }


        void CentralSwarmObjectImpl::SetEntityRef(std::shared_ptr<INamedReference<IEntity>> entityRef)
        {
            _entityRef = entityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
        }

        std::shared_ptr<void> CentralSwarmObjectImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(CentralSwarmObjectImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ICentralSwarmObject).name())
                return std::dynamic_pointer_cast<ICentralSwarmObject>(shared_from_this());
            else if (classifier == typeid(ICentralSwarmObjectWriter).name())
                return std::dynamic_pointer_cast<ICentralSwarmObjectWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> CentralSwarmObjectImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t CentralSwarmObjectImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int CentralSwarmObjectImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double CentralSwarmObjectImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t CentralSwarmObjectImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool CentralSwarmObjectImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime CentralSwarmObjectImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> CentralSwarmObjectImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string CentralSwarmObjectImpl::GetModelType() const
        {
            return "CentralSwarmObject";
        }

        void CentralSwarmObjectImpl::WriteParameterToEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _entityRef = {};
        }

        std::string CentralSwarmObjectImpl::GetParameterFromEntityRef() const
        {
            auto entityRef = OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF;
            return GetParameterNameFromAttribute(entityRef);
        }

        bool CentralSwarmObjectImpl::IsEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        CentralSwarmObjectImpl::CentralSwarmObjectImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
        }

        void CentralSwarmObjectImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType CentralSwarmObjectImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> CentralSwarmObjectImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> CentralSwarmObjectImpl::Clone()
        {
            auto clonedObject = std::make_shared<CentralSwarmObjectImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string CentralSwarmObjectImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CentralSwarmObjectImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> CentralSwarmObjectImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CentralSwarmObjectImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string CentralSwarmObjectImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ClothoidImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double ClothoidImpl::GetCurvature() const
        {
        	  return _curvature;
        }
        double ClothoidImpl::GetCurvatureDot() const
        {
        	  return _curvatureDot;
        }
        double ClothoidImpl::GetCurvaturePrime() const
        {
        	  return _curvaturePrime;
        }
        double ClothoidImpl::GetLength() const
        {
        	  return _length;
        }
        double ClothoidImpl::GetStartTime() const
        {
        	  return _startTime;
        }
        double ClothoidImpl::GetStopTime() const
        {
        	  return _stopTime;
        }
        std::shared_ptr<IPosition> ClothoidImpl::GetPosition() const
        {
        	  return _position;
        }


        void ClothoidImpl::SetCurvature(const double curvature)
        {
            _curvature = curvature;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CURVATURE);
        }

        void ClothoidImpl::SetCurvatureDot(const double curvatureDot)
        {
            _curvatureDot = curvatureDot;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CURVATURE_DOT);
			// set the indicator to true
            isSetCurvatureDot = true;          
        }

        void ClothoidImpl::SetCurvaturePrime(const double curvaturePrime)
        {
            _curvaturePrime = curvaturePrime;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CURVATURE_PRIME);
			// set the indicator to true
            isSetCurvaturePrime = true;          
        }

        void ClothoidImpl::SetLength(const double length)
        {
            _length = length;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LENGTH);
        }

        void ClothoidImpl::SetStartTime(const double startTime)
        {
            _startTime = startTime;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__START_TIME);
			// set the indicator to true
            isSetStartTime = true;          
        }

        void ClothoidImpl::SetStopTime(const double stopTime)
        {
            _stopTime = stopTime;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STOP_TIME);
			// set the indicator to true
            isSetStopTime = true;          
        }

        void ClothoidImpl::SetPosition(std::shared_ptr<IPositionWriter> position)
        {
            _position = position;
        }

        std::shared_ptr<void> ClothoidImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ClothoidImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IClothoid).name())
                return std::dynamic_pointer_cast<IClothoid>(shared_from_this());
            else if (classifier == typeid(IClothoidWriter).name())
                return std::dynamic_pointer_cast<IClothoidWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ClothoidImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ClothoidImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ClothoidImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ClothoidImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__CURVATURE)
                {
                    return GetCurvature();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__CURVATURE_DOT)
                {
                    return GetCurvatureDot();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__CURVATURE_PRIME)
                {
                    return GetCurvaturePrime();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__LENGTH)
                {
                    return GetLength();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__START_TIME)
                {
                    return GetStartTime();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__STOP_TIME)
                {
                    return GetStopTime();
                }
                throw KeyNotSupportedException();

        }

        uint16_t ClothoidImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ClothoidImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ClothoidImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ClothoidImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ClothoidImpl::GetModelType() const
        {
            return "Clothoid";
        }

        void ClothoidImpl::WriteParameterToCurvature(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CURVATURE, parameterName, nullTextMarker /*no textmarker*/);
            _curvature = {};
        }

        void ClothoidImpl::WriteParameterToCurvatureDot(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CURVATURE_DOT, parameterName, nullTextMarker /*no textmarker*/);
            _curvatureDot = {};
        }

        void ClothoidImpl::WriteParameterToCurvaturePrime(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CURVATURE_PRIME, parameterName, nullTextMarker /*no textmarker*/);
            _curvaturePrime = {};
        }

        void ClothoidImpl::WriteParameterToLength(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LENGTH, parameterName, nullTextMarker /*no textmarker*/);
            _length = {};
        }

        void ClothoidImpl::WriteParameterToStartTime(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__START_TIME, parameterName, nullTextMarker /*no textmarker*/);
            _startTime = {};
        }

        void ClothoidImpl::WriteParameterToStopTime(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STOP_TIME, parameterName, nullTextMarker /*no textmarker*/);
            _stopTime = {};
        }

        std::string ClothoidImpl::GetParameterFromCurvature() const
        {
            auto curvature = OSC_CONSTANTS::ATTRIBUTE__CURVATURE;
            return GetParameterNameFromAttribute(curvature);
        }

        std::string ClothoidImpl::GetParameterFromCurvatureDot() const
        {
            auto curvatureDot = OSC_CONSTANTS::ATTRIBUTE__CURVATURE_DOT;
            return GetParameterNameFromAttribute(curvatureDot);
        }

        std::string ClothoidImpl::GetParameterFromCurvaturePrime() const
        {
            auto curvaturePrime = OSC_CONSTANTS::ATTRIBUTE__CURVATURE_PRIME;
            return GetParameterNameFromAttribute(curvaturePrime);
        }

        std::string ClothoidImpl::GetParameterFromLength() const
        {
            auto length = OSC_CONSTANTS::ATTRIBUTE__LENGTH;
            return GetParameterNameFromAttribute(length);
        }

        std::string ClothoidImpl::GetParameterFromStartTime() const
        {
            auto startTime = OSC_CONSTANTS::ATTRIBUTE__START_TIME;
            return GetParameterNameFromAttribute(startTime);
        }

        std::string ClothoidImpl::GetParameterFromStopTime() const
        {
            auto stopTime = OSC_CONSTANTS::ATTRIBUTE__STOP_TIME;
            return GetParameterNameFromAttribute(stopTime);
        }

        bool ClothoidImpl::IsCurvatureParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CURVATURE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ClothoidImpl::IsCurvatureDotParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CURVATURE_DOT);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ClothoidImpl::IsCurvaturePrimeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CURVATURE_PRIME);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ClothoidImpl::IsLengthParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__LENGTH);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ClothoidImpl::IsStartTimeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__START_TIME);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ClothoidImpl::IsStopTimeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__STOP_TIME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IPositionWriter> ClothoidImpl::GetWriterPosition() const
        {
            return std::dynamic_pointer_cast<IPositionWriter>(_position);
        }

        ClothoidImpl::ClothoidImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CURVATURE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CURVATURE_DOT, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CURVATURE_PRIME, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LENGTH, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__START_TIME, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__STOP_TIME, SimpleType::DOUBLE);
        }

        void ClothoidImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CURVATURE)
            {
                // Simple type
                _curvature = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CURVATURE_DOT)
            {
                // Simple type
                _curvatureDot = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CURVATURE_PRIME)
            {
                // Simple type
                _curvaturePrime = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LENGTH)
            {
                // Simple type
                _length = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__START_TIME)
            {
                // Simple type
                _startTime = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STOP_TIME)
            {
                // Simple type
                _stopTime = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ClothoidImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ClothoidImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ClothoidImpl::Clone()
        {
            auto clonedObject = std::make_shared<ClothoidImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_curvature = GetCurvature();
            // Simple type
            clonedObject->_curvatureDot = GetCurvatureDot();
            // Simple type
            clonedObject->_curvaturePrime = GetCurvaturePrime();
            // Simple type
            clonedObject->_length = GetLength();
            // Simple type
            clonedObject->_startTime = GetStartTime();
            // Simple type
            clonedObject->_stopTime = GetStopTime();
            // clone indicators
            	clonedObject->isSetCurvatureDot = isSetCurvatureDot;
            	clonedObject->isSetCurvaturePrime = isSetCurvaturePrime;
            	clonedObject->isSetStartTime = isSetStartTime;
            	clonedObject->isSetStopTime = isSetStopTime;
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            return clonedObject;
        }

        std::string ClothoidImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ClothoidImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ClothoidImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ClothoidImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ClothoidImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ClothoidImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CURVATURE)
            {
                // Simple type
                _curvature = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CURVATURE_DOT)
            {
                // Simple type
                _curvatureDot = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CURVATURE_PRIME)
            {
                // Simple type
                _curvaturePrime = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LENGTH)
            {
                // Simple type
                _length = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__START_TIME)
            {
                // Simple type
                _startTime = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STOP_TIME)
            {
                // Simple type
                _stopTime = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void ClothoidImpl::ResetCurvatureDot()
	   {
	   		isSetCurvatureDot = false; 
			_curvatureDot = {};
			
	   }
       bool ClothoidImpl::IsSetCurvatureDot() const
	   {
			return isSetCurvatureDot;
	   }
       void ClothoidImpl::ResetCurvaturePrime()
	   {
	   		isSetCurvaturePrime = false; 
			_curvaturePrime = {};
			
	   }
       bool ClothoidImpl::IsSetCurvaturePrime() const
	   {
			return isSetCurvaturePrime;
	   }
       void ClothoidImpl::ResetStartTime()
	   {
	   		isSetStartTime = false; 
			_startTime = {};
			
	   }
       bool ClothoidImpl::IsSetStartTime() const
	   {
			return isSetStartTime;
	   }
       void ClothoidImpl::ResetStopTime()
	   {
	   		isSetStopTime = false; 
			_stopTime = {};
			
	   }
       bool ClothoidImpl::IsSetStopTime() const
	   {
			return isSetStopTime;
	   }

        IOpenScenarioFlexElement* CollisionConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IEntityRef> CollisionConditionImpl::GetEntityRef() const
        {
        	  return _entityRef;
        }
        std::shared_ptr<IByObjectType> CollisionConditionImpl::GetByType() const
        {
        	  return _byType;
        }


        void CollisionConditionImpl::SetEntityRef(std::shared_ptr<IEntityRefWriter> entityRef)
        {
            _entityRef = entityRef;
            _byType = {};
			// set the indicator to true
            isSetEntityRef = true;          
        }

        void CollisionConditionImpl::SetByType(std::shared_ptr<IByObjectTypeWriter> byType)
        {
            _byType = byType;
            _entityRef = {};
			// set the indicator to true
            isSetByType = true;          
        }

        std::shared_ptr<void> CollisionConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(CollisionConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ICollisionCondition).name())
                return std::dynamic_pointer_cast<ICollisionCondition>(shared_from_this());
            else if (classifier == typeid(ICollisionConditionWriter).name())
                return std::dynamic_pointer_cast<ICollisionConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> CollisionConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t CollisionConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int CollisionConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double CollisionConditionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t CollisionConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool CollisionConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime CollisionConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> CollisionConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string CollisionConditionImpl::GetModelType() const
        {
            return "CollisionCondition";
        }

            // children
        std::shared_ptr<IEntityRefWriter> CollisionConditionImpl::GetWriterEntityRef() const
        {
            return std::dynamic_pointer_cast<IEntityRefWriter>(_entityRef);
        }
        std::shared_ptr<IByObjectTypeWriter> CollisionConditionImpl::GetWriterByType() const
        {
            return std::dynamic_pointer_cast<IByObjectTypeWriter>(_byType);
        }

        CollisionConditionImpl::CollisionConditionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void CollisionConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType CollisionConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> CollisionConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kEntityRef =  GetWriterEntityRef();
                if (kEntityRef)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEntityRef));
                }
                const auto kByType =  GetWriterByType();
                if (kByType)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kByType));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> CollisionConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<CollisionConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kEntityRef =  GetWriterEntityRef();
            if (kEntityRef)
            {
                auto clonedChild = std::dynamic_pointer_cast<EntityRefImpl>(kEntityRef)->Clone();
                auto clonedChildIEntityRef = std::dynamic_pointer_cast<IEntityRef>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEntityRef(std::dynamic_pointer_cast<IEntityRefWriter>(clonedChildIEntityRef));
            }
            const auto kByType =  GetWriterByType();
            if (kByType)
            {
                auto clonedChild = std::dynamic_pointer_cast<ByObjectTypeImpl>(kByType)->Clone();
                auto clonedChildIByObjectType = std::dynamic_pointer_cast<IByObjectType>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetByType(std::dynamic_pointer_cast<IByObjectTypeWriter>(clonedChildIByObjectType));
            }
            return clonedObject;
        }

        std::string CollisionConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CollisionConditionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_REF)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEntityRef());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BY_TYPE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetByType());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> CollisionConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CollisionConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string CollisionConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void CollisionConditionImpl::ResetEntityRef()
	   {
	   		isSetEntityRef = false; 
			_entityRef = {};
			
	   }
       bool CollisionConditionImpl::IsSetEntityRef() const
	   {
			return isSetEntityRef;
	   }
       void CollisionConditionImpl::ResetByType()
	   {
	   		isSetByType = false; 
			_byType = {};
			
	   }
       bool CollisionConditionImpl::IsSetByType() const
	   {
			return isSetByType;
	   }

        IOpenScenarioFlexElement* ColorImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        ColorType ColorImpl::GetColorType() const
        {
        	  return _colorType;
        }
        std::shared_ptr<IColorRgb> ColorImpl::GetColorRgb() const
        {
        	  return _colorRgb;
        }
        std::shared_ptr<IColorCmyk> ColorImpl::GetColorCmyk() const
        {
        	  return _colorCmyk;
        }


        void ColorImpl::SetColorType(const ColorType colorType)
        {
            _colorType = colorType;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__COLOR_TYPE);
        }

        void ColorImpl::SetColorRgb(std::shared_ptr<IColorRgbWriter> colorRgb)
        {
            _colorRgb = colorRgb;
            _colorCmyk = {};
        }

        void ColorImpl::SetColorCmyk(std::shared_ptr<IColorCmykWriter> colorCmyk)
        {
            _colorCmyk = colorCmyk;
            _colorRgb = {};
        }

        std::shared_ptr<void> ColorImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ColorImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IColor).name())
                return std::dynamic_pointer_cast<IColor>(shared_from_this());
            else if (classifier == typeid(IColorWriter).name())
                return std::dynamic_pointer_cast<IColorWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ColorImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ColorImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ColorImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ColorImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ColorImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ColorImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ColorImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ColorImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ColorImpl::GetModelType() const
        {
            return "Color";
        }

        void ColorImpl::WriteParameterToColorType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__COLOR_TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _colorType = {};
        }

        std::string ColorImpl::GetParameterFromColorType() const
        {
            auto colorType = OSC_CONSTANTS::ATTRIBUTE__COLOR_TYPE;
            return GetParameterNameFromAttribute(colorType);
        }

        bool ColorImpl::IsColorTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__COLOR_TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IColorRgbWriter> ColorImpl::GetWriterColorRgb() const
        {
            return std::dynamic_pointer_cast<IColorRgbWriter>(_colorRgb);
        }
        std::shared_ptr<IColorCmykWriter> ColorImpl::GetWriterColorCmyk() const
        {
            return std::dynamic_pointer_cast<IColorCmykWriter>(_colorCmyk);
        }

        ColorImpl::ColorImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__COLOR_TYPE, SimpleType::ENUM_TYPE);
        }

        void ColorImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__COLOR_TYPE)
            {
                // Enumeration Type
                const auto kResult = ColorType::GetFromLiteral(parameterLiteralValue);
                if (kResult != ColorType::UNKNOWN)
                {
                    _colorType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType ColorImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ColorImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kColorRgb =  GetWriterColorRgb();
                if (kColorRgb)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kColorRgb));
                }
                const auto kColorCmyk =  GetWriterColorCmyk();
                if (kColorCmyk)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kColorCmyk));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ColorImpl::Clone()
        {
            auto clonedObject = std::make_shared<ColorImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kColorType = GetColorType();
            if ( kColorType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_colorType = ColorType::GetFromLiteral(kColorType.GetLiteral());
            }
            // clone indicators
            // clone children
            const auto kColorRgb =  GetWriterColorRgb();
            if (kColorRgb)
            {
                auto clonedChild = std::dynamic_pointer_cast<ColorRgbImpl>(kColorRgb)->Clone();
                auto clonedChildIColorRgb = std::dynamic_pointer_cast<IColorRgb>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetColorRgb(std::dynamic_pointer_cast<IColorRgbWriter>(clonedChildIColorRgb));
            }
            const auto kColorCmyk =  GetWriterColorCmyk();
            if (kColorCmyk)
            {
                auto clonedChild = std::dynamic_pointer_cast<ColorCmykImpl>(kColorCmyk)->Clone();
                auto clonedChildIColorCmyk = std::dynamic_pointer_cast<IColorCmyk>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetColorCmyk(std::dynamic_pointer_cast<IColorCmykWriter>(clonedChildIColorCmyk));
            }
            return clonedObject;
        }

        std::string ColorImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ColorImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__COLOR_RGB)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetColorRgb());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__COLOR_CMYK)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetColorCmyk());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ColorImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ColorImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ColorImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__COLOR_TYPE)
            {
                auto colorType = GetColorType();
                return colorType.GetLiteral() != "UNKNOWN" ? colorType.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ColorCmykImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double ColorCmykImpl::GetCyan() const
        {
        	  return _cyan;
        }
        double ColorCmykImpl::GetKey() const
        {
        	  return _key;
        }
        double ColorCmykImpl::GetMagenta() const
        {
        	  return _magenta;
        }
        double ColorCmykImpl::GetYellow() const
        {
        	  return _yellow;
        }


        void ColorCmykImpl::SetCyan(const double cyan)
        {
            _cyan = cyan;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CYAN);
        }

        void ColorCmykImpl::SetKey(const double key)
        {
            _key = key;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__KEY);
        }

        void ColorCmykImpl::SetMagenta(const double magenta)
        {
            _magenta = magenta;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAGENTA);
        }

        void ColorCmykImpl::SetYellow(const double yellow)
        {
            _yellow = yellow;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__YELLOW);
        }

        std::shared_ptr<void> ColorCmykImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ColorCmykImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IColorCmyk).name())
                return std::dynamic_pointer_cast<IColorCmyk>(shared_from_this());
            else if (classifier == typeid(IColorCmykWriter).name())
                return std::dynamic_pointer_cast<IColorCmykWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ColorCmykImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ColorCmykImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ColorCmykImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ColorCmykImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__CYAN)
                {
                    return GetCyan();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__KEY)
                {
                    return GetKey();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAGENTA)
                {
                    return GetMagenta();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__YELLOW)
                {
                    return GetYellow();
                }
                throw KeyNotSupportedException();

        }

        uint16_t ColorCmykImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ColorCmykImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ColorCmykImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ColorCmykImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ColorCmykImpl::GetModelType() const
        {
            return "ColorCmyk";
        }

        void ColorCmykImpl::WriteParameterToCyan(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CYAN, parameterName, nullTextMarker /*no textmarker*/);
            _cyan = {};
        }

        void ColorCmykImpl::WriteParameterToKey(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__KEY, parameterName, nullTextMarker /*no textmarker*/);
            _key = {};
        }

        void ColorCmykImpl::WriteParameterToMagenta(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAGENTA, parameterName, nullTextMarker /*no textmarker*/);
            _magenta = {};
        }

        void ColorCmykImpl::WriteParameterToYellow(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__YELLOW, parameterName, nullTextMarker /*no textmarker*/);
            _yellow = {};
        }

        std::string ColorCmykImpl::GetParameterFromCyan() const
        {
            auto cyan = OSC_CONSTANTS::ATTRIBUTE__CYAN;
            return GetParameterNameFromAttribute(cyan);
        }

        std::string ColorCmykImpl::GetParameterFromKey() const
        {
            auto key = OSC_CONSTANTS::ATTRIBUTE__KEY;
            return GetParameterNameFromAttribute(key);
        }

        std::string ColorCmykImpl::GetParameterFromMagenta() const
        {
            auto magenta = OSC_CONSTANTS::ATTRIBUTE__MAGENTA;
            return GetParameterNameFromAttribute(magenta);
        }

        std::string ColorCmykImpl::GetParameterFromYellow() const
        {
            auto yellow = OSC_CONSTANTS::ATTRIBUTE__YELLOW;
            return GetParameterNameFromAttribute(yellow);
        }

        bool ColorCmykImpl::IsCyanParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CYAN);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ColorCmykImpl::IsKeyParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__KEY);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ColorCmykImpl::IsMagentaParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAGENTA);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ColorCmykImpl::IsYellowParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__YELLOW);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        ColorCmykImpl::ColorCmykImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CYAN, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__KEY, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAGENTA, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__YELLOW, SimpleType::DOUBLE);
        }

        void ColorCmykImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CYAN)
            {
                // Simple type
                _cyan = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__KEY)
            {
                // Simple type
                _key = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAGENTA)
            {
                // Simple type
                _magenta = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__YELLOW)
            {
                // Simple type
                _yellow = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ColorCmykImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ColorCmykImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ColorCmykImpl::Clone()
        {
            auto clonedObject = std::make_shared<ColorCmykImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_cyan = GetCyan();
            // Simple type
            clonedObject->_key = GetKey();
            // Simple type
            clonedObject->_magenta = GetMagenta();
            // Simple type
            clonedObject->_yellow = GetYellow();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string ColorCmykImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ColorCmykImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ColorCmykImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ColorCmykImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ColorCmykImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ColorCmykImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CYAN)
            {
                // Simple type
                _cyan = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__KEY)
            {
                // Simple type
                _key = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAGENTA)
            {
                // Simple type
                _magenta = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__YELLOW)
            {
                // Simple type
                _yellow = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* ColorRgbImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double ColorRgbImpl::GetBlue() const
        {
        	  return _blue;
        }
        double ColorRgbImpl::GetGreen() const
        {
        	  return _green;
        }
        double ColorRgbImpl::GetRed() const
        {
        	  return _red;
        }


        void ColorRgbImpl::SetBlue(const double blue)
        {
            _blue = blue;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__BLUE);
        }

        void ColorRgbImpl::SetGreen(const double green)
        {
            _green = green;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__GREEN);
        }

        void ColorRgbImpl::SetRed(const double red)
        {
            _red = red;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RED);
        }

        std::shared_ptr<void> ColorRgbImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ColorRgbImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IColorRgb).name())
                return std::dynamic_pointer_cast<IColorRgb>(shared_from_this());
            else if (classifier == typeid(IColorRgbWriter).name())
                return std::dynamic_pointer_cast<IColorRgbWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ColorRgbImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ColorRgbImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ColorRgbImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ColorRgbImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__BLUE)
                {
                    return GetBlue();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__GREEN)
                {
                    return GetGreen();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__RED)
                {
                    return GetRed();
                }
                throw KeyNotSupportedException();

        }

        uint16_t ColorRgbImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ColorRgbImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ColorRgbImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ColorRgbImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ColorRgbImpl::GetModelType() const
        {
            return "ColorRgb";
        }

        void ColorRgbImpl::WriteParameterToBlue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__BLUE, parameterName, nullTextMarker /*no textmarker*/);
            _blue = {};
        }

        void ColorRgbImpl::WriteParameterToGreen(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__GREEN, parameterName, nullTextMarker /*no textmarker*/);
            _green = {};
        }

        void ColorRgbImpl::WriteParameterToRed(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RED, parameterName, nullTextMarker /*no textmarker*/);
            _red = {};
        }

        std::string ColorRgbImpl::GetParameterFromBlue() const
        {
            auto blue = OSC_CONSTANTS::ATTRIBUTE__BLUE;
            return GetParameterNameFromAttribute(blue);
        }

        std::string ColorRgbImpl::GetParameterFromGreen() const
        {
            auto green = OSC_CONSTANTS::ATTRIBUTE__GREEN;
            return GetParameterNameFromAttribute(green);
        }

        std::string ColorRgbImpl::GetParameterFromRed() const
        {
            auto red = OSC_CONSTANTS::ATTRIBUTE__RED;
            return GetParameterNameFromAttribute(red);
        }

        bool ColorRgbImpl::IsBlueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__BLUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ColorRgbImpl::IsGreenParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__GREEN);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ColorRgbImpl::IsRedParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RED);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        ColorRgbImpl::ColorRgbImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__BLUE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__GREEN, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RED, SimpleType::DOUBLE);
        }

        void ColorRgbImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__BLUE)
            {
                // Simple type
                _blue = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__GREEN)
            {
                // Simple type
                _green = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RED)
            {
                // Simple type
                _red = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ColorRgbImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ColorRgbImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ColorRgbImpl::Clone()
        {
            auto clonedObject = std::make_shared<ColorRgbImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_blue = GetBlue();
            // Simple type
            clonedObject->_green = GetGreen();
            // Simple type
            clonedObject->_red = GetRed();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string ColorRgbImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ColorRgbImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ColorRgbImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ColorRgbImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ColorRgbImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ColorRgbImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__BLUE)
            {
                // Simple type
                _blue = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__GREEN)
            {
                // Simple type
                _green = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RED)
            {
                // Simple type
                _red = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* ComponentAnimationImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IVehicleComponent> ComponentAnimationImpl::GetVehicleComponent() const
        {
        	  return _vehicleComponent;
        }
        std::shared_ptr<IUserDefinedComponent> ComponentAnimationImpl::GetUserDefinedComponent() const
        {
        	  return _userDefinedComponent;
        }


        void ComponentAnimationImpl::SetVehicleComponent(std::shared_ptr<IVehicleComponentWriter> vehicleComponent)
        {
            _vehicleComponent = vehicleComponent;
            _userDefinedComponent = {};
        }

        void ComponentAnimationImpl::SetUserDefinedComponent(std::shared_ptr<IUserDefinedComponentWriter> userDefinedComponent)
        {
            _userDefinedComponent = userDefinedComponent;
            _vehicleComponent = {};
        }

        std::shared_ptr<void> ComponentAnimationImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ComponentAnimationImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IComponentAnimation).name())
                return std::dynamic_pointer_cast<IComponentAnimation>(shared_from_this());
            else if (classifier == typeid(IComponentAnimationWriter).name())
                return std::dynamic_pointer_cast<IComponentAnimationWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ComponentAnimationImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ComponentAnimationImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ComponentAnimationImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ComponentAnimationImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ComponentAnimationImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ComponentAnimationImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ComponentAnimationImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ComponentAnimationImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ComponentAnimationImpl::GetModelType() const
        {
            return "ComponentAnimation";
        }

            // children
        std::shared_ptr<IVehicleComponentWriter> ComponentAnimationImpl::GetWriterVehicleComponent() const
        {
            return std::dynamic_pointer_cast<IVehicleComponentWriter>(_vehicleComponent);
        }
        std::shared_ptr<IUserDefinedComponentWriter> ComponentAnimationImpl::GetWriterUserDefinedComponent() const
        {
            return std::dynamic_pointer_cast<IUserDefinedComponentWriter>(_userDefinedComponent);
        }

        ComponentAnimationImpl::ComponentAnimationImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ComponentAnimationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ComponentAnimationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ComponentAnimationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kVehicleComponent =  GetWriterVehicleComponent();
                if (kVehicleComponent)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kVehicleComponent));
                }
                const auto kUserDefinedComponent =  GetWriterUserDefinedComponent();
                if (kUserDefinedComponent)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kUserDefinedComponent));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ComponentAnimationImpl::Clone()
        {
            auto clonedObject = std::make_shared<ComponentAnimationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kVehicleComponent =  GetWriterVehicleComponent();
            if (kVehicleComponent)
            {
                auto clonedChild = std::dynamic_pointer_cast<VehicleComponentImpl>(kVehicleComponent)->Clone();
                auto clonedChildIVehicleComponent = std::dynamic_pointer_cast<IVehicleComponent>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetVehicleComponent(std::dynamic_pointer_cast<IVehicleComponentWriter>(clonedChildIVehicleComponent));
            }
            const auto kUserDefinedComponent =  GetWriterUserDefinedComponent();
            if (kUserDefinedComponent)
            {
                auto clonedChild = std::dynamic_pointer_cast<UserDefinedComponentImpl>(kUserDefinedComponent)->Clone();
                auto clonedChildIUserDefinedComponent = std::dynamic_pointer_cast<IUserDefinedComponent>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetUserDefinedComponent(std::dynamic_pointer_cast<IUserDefinedComponentWriter>(clonedChildIUserDefinedComponent));
            }
            return clonedObject;
        }

        std::string ComponentAnimationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ComponentAnimationImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__VEHICLE_COMPONENT)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetVehicleComponent());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__USER_DEFINED_COMPONENT)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetUserDefinedComponent());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ComponentAnimationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ComponentAnimationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ComponentAnimationImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        ConditionEdge ConditionImpl::GetConditionEdge() const
        {
        	  return _conditionEdge;
        }
        double ConditionImpl::GetDelay() const
        {
        	  return _delay;
        }
        std::string ConditionImpl::GetName() const
        {
        	  return _name;
        }
        std::shared_ptr<IByEntityCondition> ConditionImpl::GetByEntityCondition() const
        {
        	  return _byEntityCondition;
        }
        std::shared_ptr<IByValueCondition> ConditionImpl::GetByValueCondition() const
        {
        	  return _byValueCondition;
        }


        void ConditionImpl::SetConditionEdge(const ConditionEdge conditionEdge)
        {
            _conditionEdge = conditionEdge;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONDITION_EDGE);
        }

        void ConditionImpl::SetDelay(const double delay)
        {
            _delay = delay;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DELAY);
        }

        void ConditionImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void ConditionImpl::SetByEntityCondition(std::shared_ptr<IByEntityConditionWriter> byEntityCondition)
        {
            _byEntityCondition = byEntityCondition;
            _byValueCondition = {};
			// set the indicator to true
            isSetByEntityCondition = true;          
        }

        void ConditionImpl::SetByValueCondition(std::shared_ptr<IByValueConditionWriter> byValueCondition)
        {
            _byValueCondition = byValueCondition;
            _byEntityCondition = {};
			// set the indicator to true
            isSetByValueCondition = true;          
        }

        std::shared_ptr<void> ConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ICondition).name())
                return std::dynamic_pointer_cast<ICondition>(shared_from_this());
            else if (classifier == typeid(IConditionWriter).name())
                return std::dynamic_pointer_cast<IConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ConditionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__DELAY)
                {
                    return GetDelay();
                }
                throw KeyNotSupportedException();

        }

        uint16_t ConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ConditionImpl::GetModelType() const
        {
            return "Condition";
        }

        void ConditionImpl::WriteParameterToConditionEdge(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONDITION_EDGE, parameterName, nullTextMarker /*no textmarker*/);
            _conditionEdge = {};
        }

        void ConditionImpl::WriteParameterToDelay(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DELAY, parameterName, nullTextMarker /*no textmarker*/);
            _delay = {};
        }

        void ConditionImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        std::string ConditionImpl::GetParameterFromConditionEdge() const
        {
            auto conditionEdge = OSC_CONSTANTS::ATTRIBUTE__CONDITION_EDGE;
            return GetParameterNameFromAttribute(conditionEdge);
        }

        std::string ConditionImpl::GetParameterFromDelay() const
        {
            auto delay = OSC_CONSTANTS::ATTRIBUTE__DELAY;
            return GetParameterNameFromAttribute(delay);
        }

        std::string ConditionImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        bool ConditionImpl::IsConditionEdgeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CONDITION_EDGE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ConditionImpl::IsDelayParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DELAY);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ConditionImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IByEntityConditionWriter> ConditionImpl::GetWriterByEntityCondition() const
        {
            return std::dynamic_pointer_cast<IByEntityConditionWriter>(_byEntityCondition);
        }
        std::shared_ptr<IByValueConditionWriter> ConditionImpl::GetWriterByValueCondition() const
        {
            return std::dynamic_pointer_cast<IByValueConditionWriter>(_byValueCondition);
        }

        ConditionImpl::ConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CONDITION_EDGE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DELAY, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        void ConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONDITION_EDGE)
            {
                // Enumeration Type
                const auto kResult = ConditionEdge::GetFromLiteral(parameterLiteralValue);
                if (kResult != ConditionEdge::UNKNOWN)
                {
                    _conditionEdge = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DELAY)
            {
                // Simple type
                _delay = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kByEntityCondition =  GetWriterByEntityCondition();
                if (kByEntityCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kByEntityCondition));
                }
                const auto kByValueCondition =  GetWriterByValueCondition();
                if (kByValueCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kByValueCondition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kConditionEdge = GetConditionEdge();
            if ( kConditionEdge.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_conditionEdge = ConditionEdge::GetFromLiteral(kConditionEdge.GetLiteral());
            }
            // Simple type
            clonedObject->_delay = GetDelay();
            // Simple type
            clonedObject->_name = GetName();
            // clone indicators
            // clone children
            const auto kByEntityCondition =  GetWriterByEntityCondition();
            if (kByEntityCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<ByEntityConditionImpl>(kByEntityCondition)->Clone();
                auto clonedChildIByEntityCondition = std::dynamic_pointer_cast<IByEntityCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetByEntityCondition(std::dynamic_pointer_cast<IByEntityConditionWriter>(clonedChildIByEntityCondition));
            }
            const auto kByValueCondition =  GetWriterByValueCondition();
            if (kByValueCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<ByValueConditionImpl>(kByValueCondition)->Clone();
                auto clonedChildIByValueCondition = std::dynamic_pointer_cast<IByValueCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetByValueCondition(std::dynamic_pointer_cast<IByValueConditionWriter>(clonedChildIByValueCondition));
            }
            return clonedObject;
        }

        std::string ConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ConditionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BY_ENTITY_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetByEntityCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BY_VALUE_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetByValueCondition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__CONDITION_EDGE)
            {
                auto conditionEdge = GetConditionEdge();
                return conditionEdge.GetLiteral() != "UNKNOWN" ? conditionEdge.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void ConditionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void ConditionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DELAY)
            {
                // Simple type
                _delay = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void ConditionImpl::ResetByEntityCondition()
	   {
	   		isSetByEntityCondition = false; 
			_byEntityCondition = {};
			
	   }
       bool ConditionImpl::IsSetByEntityCondition() const
	   {
			return isSetByEntityCondition;
	   }
       void ConditionImpl::ResetByValueCondition()
	   {
	   		isSetByValueCondition = false; 
			_byValueCondition = {};
			
	   }
       bool ConditionImpl::IsSetByValueCondition() const
	   {
			return isSetByValueCondition;
	   }

        IOpenScenarioFlexElement* ConditionGroupImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<ICondition>> ConditionGroupImpl::GetConditions() const
        {
            std::vector<std::shared_ptr<ICondition>> temp;
            for(auto&& elm: _conditions)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IConditionWriter>> ConditionGroupImpl::GetWriterConditions() const
        {
            return _conditions;
        }

        int ConditionGroupImpl::GetConditionsSize() const
        {
            return static_cast<int>(_conditions.size());
        }

        std::shared_ptr<ICondition> ConditionGroupImpl::GetConditionsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _conditions.size() > index)
            {
                return _conditions[index];
            }
            return nullptr;
        }


        void ConditionGroupImpl::SetConditions(std::vector<std::shared_ptr<IConditionWriter>>& conditions)
        {
            _conditions = conditions;
        }

        std::shared_ptr<void> ConditionGroupImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ConditionGroupImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IConditionGroup).name())
                return std::dynamic_pointer_cast<IConditionGroup>(shared_from_this());
            else if (classifier == typeid(IConditionGroupWriter).name())
                return std::dynamic_pointer_cast<IConditionGroupWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ConditionGroupImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ConditionGroupImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ConditionGroupImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ConditionGroupImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ConditionGroupImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ConditionGroupImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ConditionGroupImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ConditionGroupImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ConditionGroupImpl::GetModelType() const
        {
            return "ConditionGroup";
        }

            // children

        ConditionGroupImpl::ConditionGroupImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ConditionGroupImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ConditionGroupImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ConditionGroupImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto conditions =  GetWriterConditions();
                if (!conditions.empty())
                {
                    for(auto&& item : conditions)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ConditionGroupImpl::Clone()
        {
            auto clonedObject = std::make_shared<ConditionGroupImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kConditions =  GetWriterConditions();
            if (!kConditions.empty())
            {
                std::vector<std::shared_ptr<IConditionWriter>> clonedList;
                for(auto&& kItem : kConditions)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ConditionImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IConditionWriter>(clonedChild));
                }
                clonedObject->SetConditions(clonedList);
            }
            return clonedObject;
        }

        std::string ConditionGroupImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ConditionGroupImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ConditionGroupImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__CONDITION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetConditions())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ConditionGroupImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ConditionGroupImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ControlPointImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double ControlPointImpl::GetTime() const
        {
        	  return _time;
        }
        double ControlPointImpl::GetWeight() const
        {
        	  return _weight;
        }
        std::shared_ptr<IPosition> ControlPointImpl::GetPosition() const
        {
        	  return _position;
        }


        void ControlPointImpl::SetTime(const double time)
        {
            _time = time;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TIME);
			// set the indicator to true
            isSetTime = true;          
        }

        void ControlPointImpl::SetWeight(const double weight)
        {
            _weight = weight;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__WEIGHT);
			// set the indicator to true
            isSetWeight = true;          
        }

        void ControlPointImpl::SetPosition(std::shared_ptr<IPositionWriter> position)
        {
            _position = position;
        }

        std::shared_ptr<void> ControlPointImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ControlPointImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IControlPoint).name())
                return std::dynamic_pointer_cast<IControlPoint>(shared_from_this());
            else if (classifier == typeid(IControlPointWriter).name())
                return std::dynamic_pointer_cast<IControlPointWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ControlPointImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ControlPointImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ControlPointImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ControlPointImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__TIME)
                {
                    return GetTime();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
                {
                    return GetWeight();
                }
                throw KeyNotSupportedException();

        }

        uint16_t ControlPointImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ControlPointImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ControlPointImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ControlPointImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ControlPointImpl::GetModelType() const
        {
            return "ControlPoint";
        }

        void ControlPointImpl::WriteParameterToTime(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TIME, parameterName, nullTextMarker /*no textmarker*/);
            _time = {};
        }

        void ControlPointImpl::WriteParameterToWeight(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__WEIGHT, parameterName, nullTextMarker /*no textmarker*/);
            _weight = {};
        }

        std::string ControlPointImpl::GetParameterFromTime() const
        {
            auto time = OSC_CONSTANTS::ATTRIBUTE__TIME;
            return GetParameterNameFromAttribute(time);
        }

        std::string ControlPointImpl::GetParameterFromWeight() const
        {
            auto weight = OSC_CONSTANTS::ATTRIBUTE__WEIGHT;
            return GetParameterNameFromAttribute(weight);
        }

        bool ControlPointImpl::IsTimeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TIME);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ControlPointImpl::IsWeightParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__WEIGHT);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IPositionWriter> ControlPointImpl::GetWriterPosition() const
        {
            return std::dynamic_pointer_cast<IPositionWriter>(_position);
        }

        ControlPointImpl::ControlPointImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TIME, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__WEIGHT, SimpleType::DOUBLE);
        }

        void ControlPointImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TIME)
            {
                // Simple type
                _time = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
            {
                // Simple type
                _weight = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ControlPointImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ControlPointImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ControlPointImpl::Clone()
        {
            auto clonedObject = std::make_shared<ControlPointImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_time = GetTime();
            // Simple type
            clonedObject->_weight = GetWeight();
            // clone indicators
            	clonedObject->isSetTime = isSetTime;
            	clonedObject->isSetWeight = isSetWeight;
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            return clonedObject;
        }

        std::string ControlPointImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControlPointImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ControlPointImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControlPointImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ControlPointImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ControlPointImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TIME)
            {
                // Simple type
                _time = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
            {
                // Simple type
                _weight = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void ControlPointImpl::ResetTime()
	   {
	   		isSetTime = false; 
			_time = {};
			
	   }
       bool ControlPointImpl::IsSetTime() const
	   {
			return isSetTime;
	   }
       void ControlPointImpl::ResetWeight()
	   {
	   		isSetWeight = false; 
			_weight = {};
			
	   }
       bool ControlPointImpl::IsSetWeight() const
	   {
			return isSetWeight;
	   }

        IOpenScenarioFlexElement* ControllerImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        ControllerType ControllerImpl::GetControllerType() const
        {
        	  return _controllerType;
        }
        std::string ControllerImpl::GetName() const
        {
        	  return _name;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> ControllerImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IParameterDeclarationWriter>> ControllerImpl::GetWriterParameterDeclarations() const
        {
            return _parameterDeclarations;
        }

        int ControllerImpl::GetParameterDeclarationsSize() const
        {
            return static_cast<int>(_parameterDeclarations.size());
        }

        std::shared_ptr<IParameterDeclaration> ControllerImpl::GetParameterDeclarationsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _parameterDeclarations.size() > index)
            {
                return _parameterDeclarations[index];
            }
            return nullptr;
        }
        std::shared_ptr<IProperties> ControllerImpl::GetProperties() const
        {
        	  return _properties;
        }


        void ControllerImpl::SetControllerType(const ControllerType controllerType)
        {
            _controllerType = controllerType;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONTROLLER_TYPE);
			// set the indicator to true
            isSetControllerType = true;          
        }

        void ControllerImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void ControllerImpl::SetParameterDeclarations(std::vector<std::shared_ptr<IParameterDeclarationWriter>>& parameterDeclarations)
        {
            _parameterDeclarations = parameterDeclarations;
			// set the indicator to true
            isSetParameterDeclarations = true;          
        }

        void ControllerImpl::SetProperties(std::shared_ptr<IPropertiesWriter> properties)
        {
            _properties = properties;
        }

        std::shared_ptr<void> ControllerImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ControllerImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IController).name())
                return std::dynamic_pointer_cast<IController>(shared_from_this());
            else if (classifier == typeid(IControllerWriter).name())
                return std::dynamic_pointer_cast<IControllerWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ControllerImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ControllerImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ControllerImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ControllerImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ControllerImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ControllerImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ControllerImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ControllerImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ControllerImpl::GetModelType() const
        {
            return "Controller";
        }

        void ControllerImpl::WriteParameterToControllerType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONTROLLER_TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _controllerType = {};
        }

        void ControllerImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        std::string ControllerImpl::GetParameterFromControllerType() const
        {
            auto controllerType = OSC_CONSTANTS::ATTRIBUTE__CONTROLLER_TYPE;
            return GetParameterNameFromAttribute(controllerType);
        }

        std::string ControllerImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        bool ControllerImpl::IsControllerTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CONTROLLER_TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ControllerImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IPropertiesWriter> ControllerImpl::GetWriterProperties() const
        {
            return std::dynamic_pointer_cast<IPropertiesWriter>(_properties);
        }

        ControllerImpl::ControllerImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CONTROLLER_TYPE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        void ControllerImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTROLLER_TYPE)
            {
                // Enumeration Type
                const auto kResult = ControllerType::GetFromLiteral(parameterLiteralValue);
                if (kResult != ControllerType::UNKNOWN)
                {
                    _controllerType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ControllerImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool ControllerImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> ControllerImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ControllerImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kProperties =  GetWriterProperties();
                if (kProperties)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kProperties));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ControllerImpl::Clone()
        {
            auto clonedObject = std::make_shared<ControllerImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kControllerType = GetControllerType();
            if ( kControllerType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_controllerType = ControllerType::GetFromLiteral(kControllerType.GetLiteral());
            }
            // Simple type
            clonedObject->_name = GetName();
            // clone indicators
            	clonedObject->isSetControllerType = isSetControllerType;
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kProperties =  GetWriterProperties();
            if (kProperties)
            {
                auto clonedChild = std::dynamic_pointer_cast<PropertiesImpl>(kProperties)->Clone();
                auto clonedChildIProperties = std::dynamic_pointer_cast<IProperties>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetProperties(std::dynamic_pointer_cast<IPropertiesWriter>(clonedChildIProperties));
            }
            return clonedObject;
        }

        std::string ControllerImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PROPERTIES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetProperties());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ControllerImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ControllerImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__CONTROLLER_TYPE)
            {
                auto controllerType = GetControllerType();
                return controllerType.GetLiteral() != "UNKNOWN" ? controllerType.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void ControllerImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void ControllerImpl::ResetControllerType()
	   {
	   		isSetControllerType = false; 
			_controllerType = {ControllerType::ControllerTypeEnum::MOVEMENT};
			
	   }
       bool ControllerImpl::IsSetControllerType() const
	   {
			return isSetControllerType;
	   }
       void ControllerImpl::ResetParameterDeclarations()
	   {
	   		isSetParameterDeclarations = false; 
			_parameterDeclarations = {};
			
	   }
       bool ControllerImpl::IsSetParameterDeclarations() const
	   {
			return isSetParameterDeclarations;
	   }

        IOpenScenarioFlexElement* ControllerActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IAssignControllerAction> ControllerActionImpl::GetAssignControllerAction() const
        {
        	  return _assignControllerAction;
        }
        std::shared_ptr<IOverrideControllerValueAction> ControllerActionImpl::GetOverrideControllerValueAction() const
        {
        	  return _overrideControllerValueAction;
        }
        std::shared_ptr<IActivateControllerAction> ControllerActionImpl::GetActivateControllerAction() const
        {
        	  return _activateControllerAction;
        }


        void ControllerActionImpl::SetAssignControllerAction(std::shared_ptr<IAssignControllerActionWriter> assignControllerAction)
        {
            _assignControllerAction = assignControllerAction;
			// set the indicator to true
            isSetAssignControllerAction = true;          
        }

        void ControllerActionImpl::SetOverrideControllerValueAction(std::shared_ptr<IOverrideControllerValueActionWriter> overrideControllerValueAction)
        {
            _overrideControllerValueAction = overrideControllerValueAction;
			// set the indicator to true
            isSetOverrideControllerValueAction = true;          
        }

        void ControllerActionImpl::SetActivateControllerAction(std::shared_ptr<IActivateControllerActionWriter> activateControllerAction)
        {
            _activateControllerAction = activateControllerAction;
			// set the indicator to true
            isSetActivateControllerAction = true;          
        }

        std::shared_ptr<void> ControllerActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ControllerActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IControllerAction).name())
                return std::dynamic_pointer_cast<IControllerAction>(shared_from_this());
            else if (classifier == typeid(IControllerActionWriter).name())
                return std::dynamic_pointer_cast<IControllerActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ControllerActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ControllerActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ControllerActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ControllerActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ControllerActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ControllerActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ControllerActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ControllerActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ControllerActionImpl::GetModelType() const
        {
            return "ControllerAction";
        }

            // children
        std::shared_ptr<IAssignControllerActionWriter> ControllerActionImpl::GetWriterAssignControllerAction() const
        {
            return std::dynamic_pointer_cast<IAssignControllerActionWriter>(_assignControllerAction);
        }
        std::shared_ptr<IOverrideControllerValueActionWriter> ControllerActionImpl::GetWriterOverrideControllerValueAction() const
        {
            return std::dynamic_pointer_cast<IOverrideControllerValueActionWriter>(_overrideControllerValueAction);
        }
        std::shared_ptr<IActivateControllerActionWriter> ControllerActionImpl::GetWriterActivateControllerAction() const
        {
            return std::dynamic_pointer_cast<IActivateControllerActionWriter>(_activateControllerAction);
        }

        ControllerActionImpl::ControllerActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ControllerActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ControllerActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ControllerActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kAssignControllerAction =  GetWriterAssignControllerAction();
                if (kAssignControllerAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAssignControllerAction));
                }
                const auto kOverrideControllerValueAction =  GetWriterOverrideControllerValueAction();
                if (kOverrideControllerValueAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOverrideControllerValueAction));
                }
                const auto kActivateControllerAction =  GetWriterActivateControllerAction();
                if (kActivateControllerAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kActivateControllerAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ControllerActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ControllerActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kAssignControllerAction =  GetWriterAssignControllerAction();
            if (kAssignControllerAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<AssignControllerActionImpl>(kAssignControllerAction)->Clone();
                auto clonedChildIAssignControllerAction = std::dynamic_pointer_cast<IAssignControllerAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAssignControllerAction(std::dynamic_pointer_cast<IAssignControllerActionWriter>(clonedChildIAssignControllerAction));
            }
            const auto kOverrideControllerValueAction =  GetWriterOverrideControllerValueAction();
            if (kOverrideControllerValueAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<OverrideControllerValueActionImpl>(kOverrideControllerValueAction)->Clone();
                auto clonedChildIOverrideControllerValueAction = std::dynamic_pointer_cast<IOverrideControllerValueAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOverrideControllerValueAction(std::dynamic_pointer_cast<IOverrideControllerValueActionWriter>(clonedChildIOverrideControllerValueAction));
            }
            const auto kActivateControllerAction =  GetWriterActivateControllerAction();
            if (kActivateControllerAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<ActivateControllerActionImpl>(kActivateControllerAction)->Clone();
                auto clonedChildIActivateControllerAction = std::dynamic_pointer_cast<IActivateControllerAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetActivateControllerAction(std::dynamic_pointer_cast<IActivateControllerActionWriter>(clonedChildIActivateControllerAction));
            }
            return clonedObject;
        }

        std::string ControllerActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ASSIGN_CONTROLLER_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAssignControllerAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__OVERRIDE_CONTROLLER_VALUE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOverrideControllerValueAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ACTIVATE_CONTROLLER_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetActivateControllerAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ControllerActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ControllerActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void ControllerActionImpl::ResetAssignControllerAction()
	   {
	   		isSetAssignControllerAction = false; 
			_assignControllerAction = {};
			
	   }
       bool ControllerActionImpl::IsSetAssignControllerAction() const
	   {
			return isSetAssignControllerAction;
	   }
       void ControllerActionImpl::ResetOverrideControllerValueAction()
	   {
	   		isSetOverrideControllerValueAction = false; 
			_overrideControllerValueAction = {};
			
	   }
       bool ControllerActionImpl::IsSetOverrideControllerValueAction() const
	   {
			return isSetOverrideControllerValueAction;
	   }
       void ControllerActionImpl::ResetActivateControllerAction()
	   {
	   		isSetActivateControllerAction = false; 
			_activateControllerAction = {};
			
	   }
       bool ControllerActionImpl::IsSetActivateControllerAction() const
	   {
			return isSetActivateControllerAction;
	   }

        IOpenScenarioFlexElement* ControllerCatalogLocationImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IDirectory> ControllerCatalogLocationImpl::GetDirectory() const
        {
        	  return _directory;
        }


        void ControllerCatalogLocationImpl::SetDirectory(std::shared_ptr<IDirectoryWriter> directory)
        {
            _directory = directory;
        }

        std::shared_ptr<void> ControllerCatalogLocationImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ControllerCatalogLocationImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IControllerCatalogLocation).name())
                return std::dynamic_pointer_cast<IControllerCatalogLocation>(shared_from_this());
            else if (classifier == typeid(IControllerCatalogLocationWriter).name())
                return std::dynamic_pointer_cast<IControllerCatalogLocationWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ControllerCatalogLocationImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ControllerCatalogLocationImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ControllerCatalogLocationImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ControllerCatalogLocationImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ControllerCatalogLocationImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ControllerCatalogLocationImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ControllerCatalogLocationImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ControllerCatalogLocationImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ControllerCatalogLocationImpl::GetModelType() const
        {
            return "ControllerCatalogLocation";
        }

            // children
        std::shared_ptr<IDirectoryWriter> ControllerCatalogLocationImpl::GetWriterDirectory() const
        {
            return std::dynamic_pointer_cast<IDirectoryWriter>(_directory);
        }

        ControllerCatalogLocationImpl::ControllerCatalogLocationImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ControllerCatalogLocationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ControllerCatalogLocationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ControllerCatalogLocationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDirectory =  GetWriterDirectory();
                if (kDirectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDirectory));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ControllerCatalogLocationImpl::Clone()
        {
            auto clonedObject = std::make_shared<ControllerCatalogLocationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kDirectory =  GetWriterDirectory();
            if (kDirectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<DirectoryImpl>(kDirectory)->Clone();
                auto clonedChildIDirectory = std::dynamic_pointer_cast<IDirectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDirectory(std::dynamic_pointer_cast<IDirectoryWriter>(clonedChildIDirectory));
            }
            return clonedObject;
        }

        std::string ControllerCatalogLocationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerCatalogLocationImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIRECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDirectory());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ControllerCatalogLocationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerCatalogLocationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ControllerCatalogLocationImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ControllerDistributionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<IControllerDistributionEntry>> ControllerDistributionImpl::GetControllerDistributionEntries() const
        {
            std::vector<std::shared_ptr<IControllerDistributionEntry>> temp;
            for(auto&& elm: _controllerDistributionEntries)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IControllerDistributionEntryWriter>> ControllerDistributionImpl::GetWriterControllerDistributionEntries() const
        {
            return _controllerDistributionEntries;
        }

        int ControllerDistributionImpl::GetControllerDistributionEntriesSize() const
        {
            return static_cast<int>(_controllerDistributionEntries.size());
        }

        std::shared_ptr<IControllerDistributionEntry> ControllerDistributionImpl::GetControllerDistributionEntriesAtIndex(unsigned int index) const
        {
            if (index >= 0 && _controllerDistributionEntries.size() > index)
            {
                return _controllerDistributionEntries[index];
            }
            return nullptr;
        }


        void ControllerDistributionImpl::SetControllerDistributionEntries(std::vector<std::shared_ptr<IControllerDistributionEntryWriter>>& controllerDistributionEntries)
        {
            _controllerDistributionEntries = controllerDistributionEntries;
        }

        std::shared_ptr<void> ControllerDistributionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ControllerDistributionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IControllerDistribution).name())
                return std::dynamic_pointer_cast<IControllerDistribution>(shared_from_this());
            else if (classifier == typeid(IControllerDistributionWriter).name())
                return std::dynamic_pointer_cast<IControllerDistributionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ControllerDistributionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ControllerDistributionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ControllerDistributionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ControllerDistributionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ControllerDistributionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ControllerDistributionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ControllerDistributionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ControllerDistributionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ControllerDistributionImpl::GetModelType() const
        {
            return "ControllerDistribution";
        }

            // children

        ControllerDistributionImpl::ControllerDistributionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ControllerDistributionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ControllerDistributionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ControllerDistributionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto controllerDistributionEntries =  GetWriterControllerDistributionEntries();
                if (!controllerDistributionEntries.empty())
                {
                    for(auto&& item : controllerDistributionEntries)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ControllerDistributionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ControllerDistributionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kControllerDistributionEntries =  GetWriterControllerDistributionEntries();
            if (!kControllerDistributionEntries.empty())
            {
                std::vector<std::shared_ptr<IControllerDistributionEntryWriter>> clonedList;
                for(auto&& kItem : kControllerDistributionEntries)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ControllerDistributionEntryImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IControllerDistributionEntryWriter>(clonedChild));
                }
                clonedObject->SetControllerDistributionEntries(clonedList);
            }
            return clonedObject;
        }

        std::string ControllerDistributionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerDistributionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ControllerDistributionImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__CONTROLLER_DISTRIBUTION_ENTRY)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetControllerDistributionEntries())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerDistributionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ControllerDistributionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ControllerDistributionEntryImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double ControllerDistributionEntryImpl::GetWeight() const
        {
        	  return _weight;
        }
        std::shared_ptr<IController> ControllerDistributionEntryImpl::GetController() const
        {
        	  return _controller;
        }
        std::shared_ptr<ICatalogReference> ControllerDistributionEntryImpl::GetCatalogReference() const
        {
        	  return _catalogReference;
        }


        void ControllerDistributionEntryImpl::SetWeight(const double weight)
        {
            _weight = weight;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__WEIGHT);
        }

        void ControllerDistributionEntryImpl::SetController(std::shared_ptr<IControllerWriter> controller)
        {
            _controller = controller;
            _catalogReference = {};
			// set the indicator to true
            isSetController = true;          
        }

        void ControllerDistributionEntryImpl::SetCatalogReference(std::shared_ptr<ICatalogReferenceWriter> catalogReference)
        {
            _catalogReference = catalogReference;
            _controller = {};
			// set the indicator to true
            isSetCatalogReference = true;          
        }

        std::shared_ptr<void> ControllerDistributionEntryImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ControllerDistributionEntryImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IControllerDistributionEntry).name())
                return std::dynamic_pointer_cast<IControllerDistributionEntry>(shared_from_this());
            else if (classifier == typeid(IControllerDistributionEntryWriter).name())
                return std::dynamic_pointer_cast<IControllerDistributionEntryWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ControllerDistributionEntryImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ControllerDistributionEntryImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ControllerDistributionEntryImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ControllerDistributionEntryImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
                {
                    return GetWeight();
                }
                throw KeyNotSupportedException();

        }

        uint16_t ControllerDistributionEntryImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ControllerDistributionEntryImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ControllerDistributionEntryImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ControllerDistributionEntryImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ControllerDistributionEntryImpl::GetModelType() const
        {
            return "ControllerDistributionEntry";
        }

        void ControllerDistributionEntryImpl::WriteParameterToWeight(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__WEIGHT, parameterName, nullTextMarker /*no textmarker*/);
            _weight = {};
        }

        std::string ControllerDistributionEntryImpl::GetParameterFromWeight() const
        {
            auto weight = OSC_CONSTANTS::ATTRIBUTE__WEIGHT;
            return GetParameterNameFromAttribute(weight);
        }

        bool ControllerDistributionEntryImpl::IsWeightParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__WEIGHT);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IControllerWriter> ControllerDistributionEntryImpl::GetWriterController() const
        {
            return std::dynamic_pointer_cast<IControllerWriter>(_controller);
        }
        std::shared_ptr<ICatalogReferenceWriter> ControllerDistributionEntryImpl::GetWriterCatalogReference() const
        {
            return std::dynamic_pointer_cast<ICatalogReferenceWriter>(_catalogReference);
        }

        ControllerDistributionEntryImpl::ControllerDistributionEntryImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__WEIGHT, SimpleType::DOUBLE);
        }

        void ControllerDistributionEntryImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
            {
                // Simple type
                _weight = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ControllerDistributionEntryImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ControllerDistributionEntryImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kController =  GetWriterController();
                if (kController)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kController));
                }
                const auto kCatalogReference =  GetWriterCatalogReference();
                if (kCatalogReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogReference));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ControllerDistributionEntryImpl::Clone()
        {
            auto clonedObject = std::make_shared<ControllerDistributionEntryImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_weight = GetWeight();
            // clone indicators
            // clone children
            const auto kController =  GetWriterController();
            if (kController)
            {
                auto clonedChild = std::dynamic_pointer_cast<ControllerImpl>(kController)->Clone();
                auto clonedChildIController = std::dynamic_pointer_cast<IController>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetController(std::dynamic_pointer_cast<IControllerWriter>(clonedChildIController));
            }
            const auto kCatalogReference =  GetWriterCatalogReference();
            if (kCatalogReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kCatalogReference)->Clone();
                auto clonedChildICatalogReference = std::dynamic_pointer_cast<ICatalogReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogReference(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChildICatalogReference));
            }
            return clonedObject;
        }

        std::string ControllerDistributionEntryImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerDistributionEntryImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CONTROLLER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetController());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogReference());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ControllerDistributionEntryImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerDistributionEntryImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ControllerDistributionEntryImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ControllerDistributionEntryImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
            {
                // Simple type
                _weight = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void ControllerDistributionEntryImpl::ResetController()
	   {
	   		isSetController = false; 
			_controller = {};
			
	   }
       bool ControllerDistributionEntryImpl::IsSetController() const
	   {
			return isSetController;
	   }
       void ControllerDistributionEntryImpl::ResetCatalogReference()
	   {
	   		isSetCatalogReference = false; 
			_catalogReference = {};
			
	   }
       bool ControllerDistributionEntryImpl::IsSetCatalogReference() const
	   {
			return isSetCatalogReference;
	   }

        IOpenScenarioFlexElement* CustomCommandActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string CustomCommandActionImpl::GetContent() const
        {
        	  return _content;
        }
        std::string CustomCommandActionImpl::GetType() const
        {
        	  return _type;
        }


        void CustomCommandActionImpl::SetContent(const std::string content)
        {
            _content = content;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONTENT);
        }

        void CustomCommandActionImpl::SetType(const std::string type)
        {
            _type = type;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TYPE);
        }

        std::shared_ptr<void> CustomCommandActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(CustomCommandActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ICustomCommandAction).name())
                return std::dynamic_pointer_cast<ICustomCommandAction>(shared_from_this());
            else if (classifier == typeid(ICustomCommandActionWriter).name())
                return std::dynamic_pointer_cast<ICustomCommandActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> CustomCommandActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t CustomCommandActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int CustomCommandActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double CustomCommandActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t CustomCommandActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool CustomCommandActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime CustomCommandActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> CustomCommandActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string CustomCommandActionImpl::GetModelType() const
        {
            return "CustomCommandAction";
        }

        void CustomCommandActionImpl::WriteParameterToContent(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONTENT, parameterName, nullTextMarker /*no textmarker*/);
            _content = {};
        }

        void CustomCommandActionImpl::WriteParameterToType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _type = {};
        }

        std::string CustomCommandActionImpl::GetParameterFromContent() const
        {
            auto content = OSC_CONSTANTS::ATTRIBUTE__CONTENT;
            return GetParameterNameFromAttribute(content);
        }

        std::string CustomCommandActionImpl::GetParameterFromType() const
        {
            auto type = OSC_CONSTANTS::ATTRIBUTE__TYPE;
            return GetParameterNameFromAttribute(type);
        }

        bool CustomCommandActionImpl::IsContentParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CONTENT);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool CustomCommandActionImpl::IsTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        CustomCommandActionImpl::CustomCommandActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CONTENT, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TYPE, SimpleType::STRING);
        }

        void CustomCommandActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTENT)
            {
                // Simple type
                _content = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TYPE)
            {
                // Simple type
                _type = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType CustomCommandActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> CustomCommandActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> CustomCommandActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<CustomCommandActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_type = GetType();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string CustomCommandActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__CONTENT)
            {
                return GetContent();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__TYPE)
            {
                return GetType();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CustomCommandActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> CustomCommandActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CustomCommandActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string CustomCommandActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void CustomCommandActionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTENT)
            {
                // Simple type
                _content = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TYPE)
            {
                // Simple type
                _type = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* CustomContentImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string CustomContentImpl::GetContent() const
        {
        	  return _content;
        }


        void CustomContentImpl::SetContent(const std::string content)
        {
            _content = content;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONTENT);
        }

        std::shared_ptr<void> CustomContentImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(CustomContentImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ICustomContent).name())
                return std::dynamic_pointer_cast<ICustomContent>(shared_from_this());
            else if (classifier == typeid(ICustomContentWriter).name())
                return std::dynamic_pointer_cast<ICustomContentWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> CustomContentImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t CustomContentImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int CustomContentImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double CustomContentImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t CustomContentImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool CustomContentImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime CustomContentImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> CustomContentImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string CustomContentImpl::GetModelType() const
        {
            return "CustomContent";
        }

        void CustomContentImpl::WriteParameterToContent(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONTENT, parameterName, nullTextMarker /*no textmarker*/);
            _content = {};
        }

        std::string CustomContentImpl::GetParameterFromContent() const
        {
            auto content = OSC_CONSTANTS::ATTRIBUTE__CONTENT;
            return GetParameterNameFromAttribute(content);
        }

        bool CustomContentImpl::IsContentParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CONTENT);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        CustomContentImpl::CustomContentImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CONTENT, SimpleType::STRING);
        }

        void CustomContentImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTENT)
            {
                // Simple type
                _content = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType CustomContentImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> CustomContentImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> CustomContentImpl::Clone()
        {
            auto clonedObject = std::make_shared<CustomContentImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string CustomContentImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__CONTENT)
            {
                return GetContent();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CustomContentImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> CustomContentImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CustomContentImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string CustomContentImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void CustomContentImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTENT)
            {
                // Simple type
                _content = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* DeleteEntityActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }


        std::shared_ptr<void> DeleteEntityActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(DeleteEntityActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IDeleteEntityAction).name())
                return std::dynamic_pointer_cast<IDeleteEntityAction>(shared_from_this());
            else if (classifier == typeid(IDeleteEntityActionWriter).name())
                return std::dynamic_pointer_cast<IDeleteEntityActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> DeleteEntityActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t DeleteEntityActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int DeleteEntityActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double DeleteEntityActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t DeleteEntityActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool DeleteEntityActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime DeleteEntityActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> DeleteEntityActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string DeleteEntityActionImpl::GetModelType() const
        {
            return "DeleteEntityAction";
        }

            // children

        DeleteEntityActionImpl::DeleteEntityActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void DeleteEntityActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType DeleteEntityActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DeleteEntityActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DeleteEntityActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<DeleteEntityActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string DeleteEntityActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DeleteEntityActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DeleteEntityActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DeleteEntityActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DeleteEntityActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* DeterministicImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<IDeterministicParameterDistribution>> DeterministicImpl::GetDeterministicParameterDistributions() const
        {
            std::vector<std::shared_ptr<IDeterministicParameterDistribution>> temp;
            for(auto&& elm: _deterministicParameterDistributions)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IDeterministicParameterDistributionWriter>> DeterministicImpl::GetWriterDeterministicParameterDistributions() const
        {
            return _deterministicParameterDistributions;
        }

        int DeterministicImpl::GetDeterministicParameterDistributionsSize() const
        {
            return static_cast<int>(_deterministicParameterDistributions.size());
        }

        std::shared_ptr<IDeterministicParameterDistribution> DeterministicImpl::GetDeterministicParameterDistributionsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _deterministicParameterDistributions.size() > index)
            {
                return _deterministicParameterDistributions[index];
            }
            return nullptr;
        }


        void DeterministicImpl::SetDeterministicParameterDistributions(std::vector<std::shared_ptr<IDeterministicParameterDistributionWriter>>& deterministicParameterDistributions)
        {
            _deterministicParameterDistributions = deterministicParameterDistributions;
			// set the indicator to true
            isSetDeterministicParameterDistributions = true;          
        }

        std::shared_ptr<void> DeterministicImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(DeterministicImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IDeterministic).name())
                return std::dynamic_pointer_cast<IDeterministic>(shared_from_this());
            else if (classifier == typeid(IDeterministicWriter).name())
                return std::dynamic_pointer_cast<IDeterministicWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> DeterministicImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t DeterministicImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int DeterministicImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double DeterministicImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t DeterministicImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool DeterministicImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime DeterministicImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> DeterministicImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string DeterministicImpl::GetModelType() const
        {
            return "Deterministic";
        }

            // children

        DeterministicImpl::DeterministicImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void DeterministicImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType DeterministicImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DeterministicImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto deterministicParameterDistributions =  GetWriterDeterministicParameterDistributions();
                if (!deterministicParameterDistributions.empty())
                {
                    for(auto&& item : deterministicParameterDistributions)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DeterministicImpl::Clone()
        {
            auto clonedObject = std::make_shared<DeterministicImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kDeterministicParameterDistributions =  GetWriterDeterministicParameterDistributions();
            if (!kDeterministicParameterDistributions.empty())
            {
                std::vector<std::shared_ptr<IDeterministicParameterDistributionWriter>> clonedList;
                for(auto&& kItem : kDeterministicParameterDistributions)
                {
                    auto clonedChild = std::dynamic_pointer_cast<DeterministicParameterDistributionImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IDeterministicParameterDistributionWriter>(clonedChild));
                }
                clonedObject->SetDeterministicParameterDistributions(clonedList);
            }
            return clonedObject;
        }

        std::string DeterministicImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DeterministicImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DeterministicImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__DETERMINISTIC_PARAMETER_DISTRIBUTIONS)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetDeterministicParameterDistributions())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DeterministicImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DeterministicImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void DeterministicImpl::ResetDeterministicParameterDistributions()
	   {
	   		isSetDeterministicParameterDistributions = false; 
			_deterministicParameterDistributions = {};
			
	   }
       bool DeterministicImpl::IsSetDeterministicParameterDistributions() const
	   {
			return isSetDeterministicParameterDistributions;
	   }

        IOpenScenarioFlexElement* DeterministicMultiParameterDistributionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IDeterministicMultiParameterDistributionType> DeterministicMultiParameterDistributionImpl::GetDeterministicMultiParameterDistributionType() const
        {
        	  return _deterministicMultiParameterDistributionType;
        }


        void DeterministicMultiParameterDistributionImpl::SetDeterministicMultiParameterDistributionType(std::shared_ptr<IDeterministicMultiParameterDistributionTypeWriter> deterministicMultiParameterDistributionType)
        {
            _deterministicMultiParameterDistributionType = deterministicMultiParameterDistributionType;
        }

        std::shared_ptr<void> DeterministicMultiParameterDistributionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(DeterministicMultiParameterDistributionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IDeterministicMultiParameterDistribution).name())
                return std::dynamic_pointer_cast<IDeterministicMultiParameterDistribution>(shared_from_this());
            else if (classifier == typeid(IDeterministicMultiParameterDistributionWriter).name())
                return std::dynamic_pointer_cast<IDeterministicMultiParameterDistributionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> DeterministicMultiParameterDistributionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t DeterministicMultiParameterDistributionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int DeterministicMultiParameterDistributionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double DeterministicMultiParameterDistributionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t DeterministicMultiParameterDistributionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool DeterministicMultiParameterDistributionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime DeterministicMultiParameterDistributionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> DeterministicMultiParameterDistributionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string DeterministicMultiParameterDistributionImpl::GetModelType() const
        {
            return "DeterministicMultiParameterDistribution";
        }

            // children
        std::shared_ptr<IDeterministicMultiParameterDistributionTypeWriter> DeterministicMultiParameterDistributionImpl::GetWriterDeterministicMultiParameterDistributionType() const
        {
            return std::dynamic_pointer_cast<IDeterministicMultiParameterDistributionTypeWriter>(_deterministicMultiParameterDistributionType);
        }

        DeterministicMultiParameterDistributionImpl::DeterministicMultiParameterDistributionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void DeterministicMultiParameterDistributionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType DeterministicMultiParameterDistributionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DeterministicMultiParameterDistributionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDeterministicMultiParameterDistributionType =  GetWriterDeterministicMultiParameterDistributionType();
                if (kDeterministicMultiParameterDistributionType)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDeterministicMultiParameterDistributionType));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DeterministicMultiParameterDistributionImpl::Clone()
        {
            auto clonedObject = std::make_shared<DeterministicMultiParameterDistributionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kDeterministicMultiParameterDistributionType =  GetWriterDeterministicMultiParameterDistributionType();
            if (kDeterministicMultiParameterDistributionType)
            {
                auto clonedChild = std::dynamic_pointer_cast<DeterministicMultiParameterDistributionTypeImpl>(kDeterministicMultiParameterDistributionType)->Clone();
                auto clonedChildIDeterministicMultiParameterDistributionType = std::dynamic_pointer_cast<IDeterministicMultiParameterDistributionType>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDeterministicMultiParameterDistributionType(std::dynamic_pointer_cast<IDeterministicMultiParameterDistributionTypeWriter>(clonedChildIDeterministicMultiParameterDistributionType));
            }
            return clonedObject;
        }

        std::string DeterministicMultiParameterDistributionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DeterministicMultiParameterDistributionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DETERMINISTIC_MULTI_PARAMETER_DISTRIBUTION_TYPE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDeterministicMultiParameterDistributionType());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DeterministicMultiParameterDistributionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DeterministicMultiParameterDistributionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DeterministicMultiParameterDistributionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* DeterministicMultiParameterDistributionTypeImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IValueSetDistribution> DeterministicMultiParameterDistributionTypeImpl::GetValueSetDistribution() const
        {
        	  return _valueSetDistribution;
        }


        void DeterministicMultiParameterDistributionTypeImpl::SetValueSetDistribution(std::shared_ptr<IValueSetDistributionWriter> valueSetDistribution)
        {
            _valueSetDistribution = valueSetDistribution;
        }

        std::shared_ptr<void> DeterministicMultiParameterDistributionTypeImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(DeterministicMultiParameterDistributionTypeImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IDeterministicMultiParameterDistributionType).name())
                return std::dynamic_pointer_cast<IDeterministicMultiParameterDistributionType>(shared_from_this());
            else if (classifier == typeid(IDeterministicMultiParameterDistributionTypeWriter).name())
                return std::dynamic_pointer_cast<IDeterministicMultiParameterDistributionTypeWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> DeterministicMultiParameterDistributionTypeImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t DeterministicMultiParameterDistributionTypeImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int DeterministicMultiParameterDistributionTypeImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double DeterministicMultiParameterDistributionTypeImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t DeterministicMultiParameterDistributionTypeImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool DeterministicMultiParameterDistributionTypeImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime DeterministicMultiParameterDistributionTypeImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> DeterministicMultiParameterDistributionTypeImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string DeterministicMultiParameterDistributionTypeImpl::GetModelType() const
        {
            return "DeterministicMultiParameterDistributionType";
        }

            // children
        std::shared_ptr<IValueSetDistributionWriter> DeterministicMultiParameterDistributionTypeImpl::GetWriterValueSetDistribution() const
        {
            return std::dynamic_pointer_cast<IValueSetDistributionWriter>(_valueSetDistribution);
        }

        DeterministicMultiParameterDistributionTypeImpl::DeterministicMultiParameterDistributionTypeImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void DeterministicMultiParameterDistributionTypeImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType DeterministicMultiParameterDistributionTypeImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DeterministicMultiParameterDistributionTypeImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kValueSetDistribution =  GetWriterValueSetDistribution();
                if (kValueSetDistribution)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kValueSetDistribution));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DeterministicMultiParameterDistributionTypeImpl::Clone()
        {
            auto clonedObject = std::make_shared<DeterministicMultiParameterDistributionTypeImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kValueSetDistribution =  GetWriterValueSetDistribution();
            if (kValueSetDistribution)
            {
                auto clonedChild = std::dynamic_pointer_cast<ValueSetDistributionImpl>(kValueSetDistribution)->Clone();
                auto clonedChildIValueSetDistribution = std::dynamic_pointer_cast<IValueSetDistribution>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetValueSetDistribution(std::dynamic_pointer_cast<IValueSetDistributionWriter>(clonedChildIValueSetDistribution));
            }
            return clonedObject;
        }

        std::string DeterministicMultiParameterDistributionTypeImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DeterministicMultiParameterDistributionTypeImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__VALUE_SET_DISTRIBUTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetValueSetDistribution());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DeterministicMultiParameterDistributionTypeImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DeterministicMultiParameterDistributionTypeImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DeterministicMultiParameterDistributionTypeImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* DeterministicParameterDistributionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IDeterministicMultiParameterDistribution> DeterministicParameterDistributionImpl::GetDeterministicMultiParameterDistribution() const
        {
        	  return _deterministicMultiParameterDistribution;
        }
        std::shared_ptr<IDeterministicSingleParameterDistribution> DeterministicParameterDistributionImpl::GetDeterministicSingleParameterDistribution() const
        {
        	  return _deterministicSingleParameterDistribution;
        }


        void DeterministicParameterDistributionImpl::SetDeterministicMultiParameterDistribution(std::shared_ptr<IDeterministicMultiParameterDistributionWriter> deterministicMultiParameterDistribution)
        {
            _deterministicMultiParameterDistribution = deterministicMultiParameterDistribution;
            _deterministicSingleParameterDistribution = {};
        }

        void DeterministicParameterDistributionImpl::SetDeterministicSingleParameterDistribution(std::shared_ptr<IDeterministicSingleParameterDistributionWriter> deterministicSingleParameterDistribution)
        {
            _deterministicSingleParameterDistribution = deterministicSingleParameterDistribution;
            _deterministicMultiParameterDistribution = {};
        }

        std::shared_ptr<void> DeterministicParameterDistributionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(DeterministicParameterDistributionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IDeterministicParameterDistribution).name())
                return std::dynamic_pointer_cast<IDeterministicParameterDistribution>(shared_from_this());
            else if (classifier == typeid(IDeterministicParameterDistributionWriter).name())
                return std::dynamic_pointer_cast<IDeterministicParameterDistributionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> DeterministicParameterDistributionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t DeterministicParameterDistributionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int DeterministicParameterDistributionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double DeterministicParameterDistributionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t DeterministicParameterDistributionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool DeterministicParameterDistributionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime DeterministicParameterDistributionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> DeterministicParameterDistributionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string DeterministicParameterDistributionImpl::GetModelType() const
        {
            return "DeterministicParameterDistribution";
        }

            // children
        std::shared_ptr<IDeterministicMultiParameterDistributionWriter> DeterministicParameterDistributionImpl::GetWriterDeterministicMultiParameterDistribution() const
        {
            return std::dynamic_pointer_cast<IDeterministicMultiParameterDistributionWriter>(_deterministicMultiParameterDistribution);
        }
        std::shared_ptr<IDeterministicSingleParameterDistributionWriter> DeterministicParameterDistributionImpl::GetWriterDeterministicSingleParameterDistribution() const
        {
            return std::dynamic_pointer_cast<IDeterministicSingleParameterDistributionWriter>(_deterministicSingleParameterDistribution);
        }

        DeterministicParameterDistributionImpl::DeterministicParameterDistributionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void DeterministicParameterDistributionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType DeterministicParameterDistributionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DeterministicParameterDistributionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDeterministicMultiParameterDistribution =  GetWriterDeterministicMultiParameterDistribution();
                if (kDeterministicMultiParameterDistribution)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDeterministicMultiParameterDistribution));
                }
                const auto kDeterministicSingleParameterDistribution =  GetWriterDeterministicSingleParameterDistribution();
                if (kDeterministicSingleParameterDistribution)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDeterministicSingleParameterDistribution));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DeterministicParameterDistributionImpl::Clone()
        {
            auto clonedObject = std::make_shared<DeterministicParameterDistributionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kDeterministicMultiParameterDistribution =  GetWriterDeterministicMultiParameterDistribution();
            if (kDeterministicMultiParameterDistribution)
            {
                auto clonedChild = std::dynamic_pointer_cast<DeterministicMultiParameterDistributionImpl>(kDeterministicMultiParameterDistribution)->Clone();
                auto clonedChildIDeterministicMultiParameterDistribution = std::dynamic_pointer_cast<IDeterministicMultiParameterDistribution>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDeterministicMultiParameterDistribution(std::dynamic_pointer_cast<IDeterministicMultiParameterDistributionWriter>(clonedChildIDeterministicMultiParameterDistribution));
            }
            const auto kDeterministicSingleParameterDistribution =  GetWriterDeterministicSingleParameterDistribution();
            if (kDeterministicSingleParameterDistribution)
            {
                auto clonedChild = std::dynamic_pointer_cast<DeterministicSingleParameterDistributionImpl>(kDeterministicSingleParameterDistribution)->Clone();
                auto clonedChildIDeterministicSingleParameterDistribution = std::dynamic_pointer_cast<IDeterministicSingleParameterDistribution>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDeterministicSingleParameterDistribution(std::dynamic_pointer_cast<IDeterministicSingleParameterDistributionWriter>(clonedChildIDeterministicSingleParameterDistribution));
            }
            return clonedObject;
        }

        std::string DeterministicParameterDistributionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DeterministicParameterDistributionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DETERMINISTIC_MULTI_PARAMETER_DISTRIBUTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDeterministicMultiParameterDistribution());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DETERMINISTIC_SINGLE_PARAMETER_DISTRIBUTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDeterministicSingleParameterDistribution());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DeterministicParameterDistributionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DeterministicParameterDistributionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DeterministicParameterDistributionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* DeterministicSingleParameterDistributionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string DeterministicSingleParameterDistributionImpl::GetParameterName() const
        {
        	  return _parameterName;
        }
        std::shared_ptr<IDeterministicSingleParameterDistributionType> DeterministicSingleParameterDistributionImpl::GetDeterministicSingleParameterDistributionType() const
        {
        	  return _deterministicSingleParameterDistributionType;
        }


        void DeterministicSingleParameterDistributionImpl::SetParameterName(const std::string parameterName)
        {
            _parameterName = parameterName;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_NAME);
        }

        void DeterministicSingleParameterDistributionImpl::SetDeterministicSingleParameterDistributionType(std::shared_ptr<IDeterministicSingleParameterDistributionTypeWriter> deterministicSingleParameterDistributionType)
        {
            _deterministicSingleParameterDistributionType = deterministicSingleParameterDistributionType;
        }

        std::shared_ptr<void> DeterministicSingleParameterDistributionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(DeterministicSingleParameterDistributionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IDeterministicSingleParameterDistribution).name())
                return std::dynamic_pointer_cast<IDeterministicSingleParameterDistribution>(shared_from_this());
            else if (classifier == typeid(IDeterministicSingleParameterDistributionWriter).name())
                return std::dynamic_pointer_cast<IDeterministicSingleParameterDistributionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> DeterministicSingleParameterDistributionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t DeterministicSingleParameterDistributionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int DeterministicSingleParameterDistributionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double DeterministicSingleParameterDistributionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t DeterministicSingleParameterDistributionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool DeterministicSingleParameterDistributionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime DeterministicSingleParameterDistributionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> DeterministicSingleParameterDistributionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string DeterministicSingleParameterDistributionImpl::GetModelType() const
        {
            return "DeterministicSingleParameterDistribution";
        }

        void DeterministicSingleParameterDistributionImpl::WriteParameterToParameterName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_NAME, parameterName, nullTextMarker /*no textmarker*/);
            _parameterName = {};
        }

        std::string DeterministicSingleParameterDistributionImpl::GetParameterFromParameterName() const
        {
            auto parameterName = OSC_CONSTANTS::ATTRIBUTE__PARAMETER_NAME;
            return GetParameterNameFromAttribute(parameterName);
        }

        bool DeterministicSingleParameterDistributionImpl::IsParameterNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__PARAMETER_NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IDeterministicSingleParameterDistributionTypeWriter> DeterministicSingleParameterDistributionImpl::GetWriterDeterministicSingleParameterDistributionType() const
        {
            return std::dynamic_pointer_cast<IDeterministicSingleParameterDistributionTypeWriter>(_deterministicSingleParameterDistributionType);
        }

        DeterministicSingleParameterDistributionImpl::DeterministicSingleParameterDistributionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_NAME, SimpleType::STRING);
        }

        void DeterministicSingleParameterDistributionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_NAME)
            {
                // Simple type
                _parameterName = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType DeterministicSingleParameterDistributionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DeterministicSingleParameterDistributionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDeterministicSingleParameterDistributionType =  GetWriterDeterministicSingleParameterDistributionType();
                if (kDeterministicSingleParameterDistributionType)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDeterministicSingleParameterDistributionType));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DeterministicSingleParameterDistributionImpl::Clone()
        {
            auto clonedObject = std::make_shared<DeterministicSingleParameterDistributionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_parameterName = GetParameterName();
            // clone indicators
            // clone children
            const auto kDeterministicSingleParameterDistributionType =  GetWriterDeterministicSingleParameterDistributionType();
            if (kDeterministicSingleParameterDistributionType)
            {
                auto clonedChild = std::dynamic_pointer_cast<DeterministicSingleParameterDistributionTypeImpl>(kDeterministicSingleParameterDistributionType)->Clone();
                auto clonedChildIDeterministicSingleParameterDistributionType = std::dynamic_pointer_cast<IDeterministicSingleParameterDistributionType>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDeterministicSingleParameterDistributionType(std::dynamic_pointer_cast<IDeterministicSingleParameterDistributionTypeWriter>(clonedChildIDeterministicSingleParameterDistributionType));
            }
            return clonedObject;
        }

        std::string DeterministicSingleParameterDistributionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_NAME)
            {
                return GetParameterName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DeterministicSingleParameterDistributionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DETERMINISTIC_SINGLE_PARAMETER_DISTRIBUTION_TYPE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDeterministicSingleParameterDistributionType());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DeterministicSingleParameterDistributionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DeterministicSingleParameterDistributionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DeterministicSingleParameterDistributionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void DeterministicSingleParameterDistributionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_NAME)
            {
                // Simple type
                _parameterName = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* DeterministicSingleParameterDistributionTypeImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IDistributionSet> DeterministicSingleParameterDistributionTypeImpl::GetDistributionSet() const
        {
        	  return _distributionSet;
        }
        std::shared_ptr<IDistributionRange> DeterministicSingleParameterDistributionTypeImpl::GetDistributionRange() const
        {
        	  return _distributionRange;
        }
        std::shared_ptr<IUserDefinedDistribution> DeterministicSingleParameterDistributionTypeImpl::GetUserDefinedDistribution() const
        {
        	  return _userDefinedDistribution;
        }


        void DeterministicSingleParameterDistributionTypeImpl::SetDistributionSet(std::shared_ptr<IDistributionSetWriter> distributionSet)
        {
            _distributionSet = distributionSet;
            _distributionRange = {};
            _userDefinedDistribution = {};
        }

        void DeterministicSingleParameterDistributionTypeImpl::SetDistributionRange(std::shared_ptr<IDistributionRangeWriter> distributionRange)
        {
            _distributionRange = distributionRange;
            _distributionSet = {};
            _userDefinedDistribution = {};
        }

        void DeterministicSingleParameterDistributionTypeImpl::SetUserDefinedDistribution(std::shared_ptr<IUserDefinedDistributionWriter> userDefinedDistribution)
        {
            _userDefinedDistribution = userDefinedDistribution;
            _distributionSet = {};
            _distributionRange = {};
        }

        std::shared_ptr<void> DeterministicSingleParameterDistributionTypeImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(DeterministicSingleParameterDistributionTypeImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IDeterministicSingleParameterDistributionType).name())
                return std::dynamic_pointer_cast<IDeterministicSingleParameterDistributionType>(shared_from_this());
            else if (classifier == typeid(IDeterministicSingleParameterDistributionTypeWriter).name())
                return std::dynamic_pointer_cast<IDeterministicSingleParameterDistributionTypeWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> DeterministicSingleParameterDistributionTypeImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t DeterministicSingleParameterDistributionTypeImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int DeterministicSingleParameterDistributionTypeImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double DeterministicSingleParameterDistributionTypeImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t DeterministicSingleParameterDistributionTypeImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool DeterministicSingleParameterDistributionTypeImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime DeterministicSingleParameterDistributionTypeImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> DeterministicSingleParameterDistributionTypeImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string DeterministicSingleParameterDistributionTypeImpl::GetModelType() const
        {
            return "DeterministicSingleParameterDistributionType";
        }

            // children
        std::shared_ptr<IDistributionSetWriter> DeterministicSingleParameterDistributionTypeImpl::GetWriterDistributionSet() const
        {
            return std::dynamic_pointer_cast<IDistributionSetWriter>(_distributionSet);
        }
        std::shared_ptr<IDistributionRangeWriter> DeterministicSingleParameterDistributionTypeImpl::GetWriterDistributionRange() const
        {
            return std::dynamic_pointer_cast<IDistributionRangeWriter>(_distributionRange);
        }
        std::shared_ptr<IUserDefinedDistributionWriter> DeterministicSingleParameterDistributionTypeImpl::GetWriterUserDefinedDistribution() const
        {
            return std::dynamic_pointer_cast<IUserDefinedDistributionWriter>(_userDefinedDistribution);
        }

        DeterministicSingleParameterDistributionTypeImpl::DeterministicSingleParameterDistributionTypeImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void DeterministicSingleParameterDistributionTypeImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType DeterministicSingleParameterDistributionTypeImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DeterministicSingleParameterDistributionTypeImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDistributionSet =  GetWriterDistributionSet();
                if (kDistributionSet)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDistributionSet));
                }
                const auto kDistributionRange =  GetWriterDistributionRange();
                if (kDistributionRange)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDistributionRange));
                }
                const auto kUserDefinedDistribution =  GetWriterUserDefinedDistribution();
                if (kUserDefinedDistribution)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kUserDefinedDistribution));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DeterministicSingleParameterDistributionTypeImpl::Clone()
        {
            auto clonedObject = std::make_shared<DeterministicSingleParameterDistributionTypeImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kDistributionSet =  GetWriterDistributionSet();
            if (kDistributionSet)
            {
                auto clonedChild = std::dynamic_pointer_cast<DistributionSetImpl>(kDistributionSet)->Clone();
                auto clonedChildIDistributionSet = std::dynamic_pointer_cast<IDistributionSet>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDistributionSet(std::dynamic_pointer_cast<IDistributionSetWriter>(clonedChildIDistributionSet));
            }
            const auto kDistributionRange =  GetWriterDistributionRange();
            if (kDistributionRange)
            {
                auto clonedChild = std::dynamic_pointer_cast<DistributionRangeImpl>(kDistributionRange)->Clone();
                auto clonedChildIDistributionRange = std::dynamic_pointer_cast<IDistributionRange>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDistributionRange(std::dynamic_pointer_cast<IDistributionRangeWriter>(clonedChildIDistributionRange));
            }
            const auto kUserDefinedDistribution =  GetWriterUserDefinedDistribution();
            if (kUserDefinedDistribution)
            {
                auto clonedChild = std::dynamic_pointer_cast<UserDefinedDistributionImpl>(kUserDefinedDistribution)->Clone();
                auto clonedChildIUserDefinedDistribution = std::dynamic_pointer_cast<IUserDefinedDistribution>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetUserDefinedDistribution(std::dynamic_pointer_cast<IUserDefinedDistributionWriter>(clonedChildIUserDefinedDistribution));
            }
            return clonedObject;
        }

        std::string DeterministicSingleParameterDistributionTypeImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DeterministicSingleParameterDistributionTypeImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DISTRIBUTION_SET)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDistributionSet());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DISTRIBUTION_RANGE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDistributionRange());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__USER_DEFINED_DISTRIBUTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetUserDefinedDistribution());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DeterministicSingleParameterDistributionTypeImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DeterministicSingleParameterDistributionTypeImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DeterministicSingleParameterDistributionTypeImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* DimensionsImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double DimensionsImpl::GetHeight() const
        {
        	  return _height;
        }
        double DimensionsImpl::GetLength() const
        {
        	  return _length;
        }
        double DimensionsImpl::GetWidth() const
        {
        	  return _width;
        }


        void DimensionsImpl::SetHeight(const double height)
        {
            _height = height;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__HEIGHT);
        }

        void DimensionsImpl::SetLength(const double length)
        {
            _length = length;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LENGTH);
        }

        void DimensionsImpl::SetWidth(const double width)
        {
            _width = width;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__WIDTH);
        }

        std::shared_ptr<void> DimensionsImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(DimensionsImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IDimensions).name())
                return std::dynamic_pointer_cast<IDimensions>(shared_from_this());
            else if (classifier == typeid(IDimensionsWriter).name())
                return std::dynamic_pointer_cast<IDimensionsWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> DimensionsImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t DimensionsImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int DimensionsImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double DimensionsImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__HEIGHT)
                {
                    return GetHeight();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__LENGTH)
                {
                    return GetLength();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__WIDTH)
                {
                    return GetWidth();
                }
                throw KeyNotSupportedException();

        }

        uint16_t DimensionsImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool DimensionsImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime DimensionsImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> DimensionsImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string DimensionsImpl::GetModelType() const
        {
            return "Dimensions";
        }

        void DimensionsImpl::WriteParameterToHeight(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__HEIGHT, parameterName, nullTextMarker /*no textmarker*/);
            _height = {};
        }

        void DimensionsImpl::WriteParameterToLength(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LENGTH, parameterName, nullTextMarker /*no textmarker*/);
            _length = {};
        }

        void DimensionsImpl::WriteParameterToWidth(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__WIDTH, parameterName, nullTextMarker /*no textmarker*/);
            _width = {};
        }

        std::string DimensionsImpl::GetParameterFromHeight() const
        {
            auto height = OSC_CONSTANTS::ATTRIBUTE__HEIGHT;
            return GetParameterNameFromAttribute(height);
        }

        std::string DimensionsImpl::GetParameterFromLength() const
        {
            auto length = OSC_CONSTANTS::ATTRIBUTE__LENGTH;
            return GetParameterNameFromAttribute(length);
        }

        std::string DimensionsImpl::GetParameterFromWidth() const
        {
            auto width = OSC_CONSTANTS::ATTRIBUTE__WIDTH;
            return GetParameterNameFromAttribute(width);
        }

        bool DimensionsImpl::IsHeightParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__HEIGHT);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool DimensionsImpl::IsLengthParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__LENGTH);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool DimensionsImpl::IsWidthParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__WIDTH);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        DimensionsImpl::DimensionsImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__HEIGHT, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LENGTH, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__WIDTH, SimpleType::DOUBLE);
        }

        void DimensionsImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__HEIGHT)
            {
                // Simple type
                _height = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LENGTH)
            {
                // Simple type
                _length = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WIDTH)
            {
                // Simple type
                _width = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType DimensionsImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DimensionsImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DimensionsImpl::Clone()
        {
            auto clonedObject = std::make_shared<DimensionsImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_height = GetHeight();
            // Simple type
            clonedObject->_length = GetLength();
            // Simple type
            clonedObject->_width = GetWidth();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string DimensionsImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DimensionsImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DimensionsImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DimensionsImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DimensionsImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void DimensionsImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__HEIGHT)
            {
                // Simple type
                _height = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LENGTH)
            {
                // Simple type
                _length = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WIDTH)
            {
                // Simple type
                _width = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* DirectionOfTravelDistributionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double DirectionOfTravelDistributionImpl::GetOpposite() const
        {
        	  return _opposite;
        }
        double DirectionOfTravelDistributionImpl::GetSame() const
        {
        	  return _same;
        }


        void DirectionOfTravelDistributionImpl::SetOpposite(const double opposite)
        {
            _opposite = opposite;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__OPPOSITE);
        }

        void DirectionOfTravelDistributionImpl::SetSame(const double same)
        {
            _same = same;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SAME);
        }

        std::shared_ptr<void> DirectionOfTravelDistributionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(DirectionOfTravelDistributionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IDirectionOfTravelDistribution).name())
                return std::dynamic_pointer_cast<IDirectionOfTravelDistribution>(shared_from_this());
            else if (classifier == typeid(IDirectionOfTravelDistributionWriter).name())
                return std::dynamic_pointer_cast<IDirectionOfTravelDistributionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> DirectionOfTravelDistributionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t DirectionOfTravelDistributionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int DirectionOfTravelDistributionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double DirectionOfTravelDistributionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__OPPOSITE)
                {
                    return GetOpposite();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__SAME)
                {
                    return GetSame();
                }
                throw KeyNotSupportedException();

        }

        uint16_t DirectionOfTravelDistributionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool DirectionOfTravelDistributionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime DirectionOfTravelDistributionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> DirectionOfTravelDistributionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string DirectionOfTravelDistributionImpl::GetModelType() const
        {
            return "DirectionOfTravelDistribution";
        }

        void DirectionOfTravelDistributionImpl::WriteParameterToOpposite(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__OPPOSITE, parameterName, nullTextMarker /*no textmarker*/);
            _opposite = {};
        }

        void DirectionOfTravelDistributionImpl::WriteParameterToSame(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SAME, parameterName, nullTextMarker /*no textmarker*/);
            _same = {};
        }

        std::string DirectionOfTravelDistributionImpl::GetParameterFromOpposite() const
        {
            auto opposite = OSC_CONSTANTS::ATTRIBUTE__OPPOSITE;
            return GetParameterNameFromAttribute(opposite);
        }

        std::string DirectionOfTravelDistributionImpl::GetParameterFromSame() const
        {
            auto same = OSC_CONSTANTS::ATTRIBUTE__SAME;
            return GetParameterNameFromAttribute(same);
        }

        bool DirectionOfTravelDistributionImpl::IsOppositeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__OPPOSITE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool DirectionOfTravelDistributionImpl::IsSameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__SAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        DirectionOfTravelDistributionImpl::DirectionOfTravelDistributionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__OPPOSITE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SAME, SimpleType::DOUBLE);
        }

        void DirectionOfTravelDistributionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__OPPOSITE)
            {
                // Simple type
                _opposite = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SAME)
            {
                // Simple type
                _same = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType DirectionOfTravelDistributionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DirectionOfTravelDistributionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DirectionOfTravelDistributionImpl::Clone()
        {
            auto clonedObject = std::make_shared<DirectionOfTravelDistributionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_opposite = GetOpposite();
            // Simple type
            clonedObject->_same = GetSame();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string DirectionOfTravelDistributionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DirectionOfTravelDistributionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DirectionOfTravelDistributionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DirectionOfTravelDistributionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DirectionOfTravelDistributionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void DirectionOfTravelDistributionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__OPPOSITE)
            {
                // Simple type
                _opposite = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SAME)
            {
                // Simple type
                _same = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* DirectoryImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string DirectoryImpl::GetPath() const
        {
        	  return _path;
        }


        void DirectoryImpl::SetPath(const std::string path)
        {
            _path = path;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PATH);
        }

        std::shared_ptr<void> DirectoryImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(DirectoryImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IDirectory).name())
                return std::dynamic_pointer_cast<IDirectory>(shared_from_this());
            else if (classifier == typeid(IDirectoryWriter).name())
                return std::dynamic_pointer_cast<IDirectoryWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> DirectoryImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t DirectoryImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int DirectoryImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double DirectoryImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t DirectoryImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool DirectoryImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime DirectoryImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> DirectoryImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string DirectoryImpl::GetModelType() const
        {
            return "Directory";
        }

        void DirectoryImpl::WriteParameterToPath(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PATH, parameterName, nullTextMarker /*no textmarker*/);
            _path = {};
        }

        std::string DirectoryImpl::GetParameterFromPath() const
        {
            auto path = OSC_CONSTANTS::ATTRIBUTE__PATH;
            return GetParameterNameFromAttribute(path);
        }

        bool DirectoryImpl::IsPathParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__PATH);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        DirectoryImpl::DirectoryImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PATH, SimpleType::STRING);
        }

        void DirectoryImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PATH)
            {
                // Simple type
                _path = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType DirectoryImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DirectoryImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DirectoryImpl::Clone()
        {
            auto clonedObject = std::make_shared<DirectoryImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_path = GetPath();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string DirectoryImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PATH)
            {
                return GetPath();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DirectoryImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DirectoryImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DirectoryImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DirectoryImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void DirectoryImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PATH)
            {
                // Simple type
                _path = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* DistanceConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool DistanceConditionImpl::GetAlongRoute() const
        {
        	  return _alongRoute;
        }
        CoordinateSystem DistanceConditionImpl::GetCoordinateSystem() const
        {
        	  return _coordinateSystem;
        }
        bool DistanceConditionImpl::GetFreespace() const
        {
        	  return _freespace;
        }
        RelativeDistanceType DistanceConditionImpl::GetRelativeDistanceType() const
        {
        	  return _relativeDistanceType;
        }
        RoutingAlgorithm DistanceConditionImpl::GetRoutingAlgorithm() const
        {
        	  return _routingAlgorithm;
        }
        Rule DistanceConditionImpl::GetRule() const
        {
        	  return _rule;
        }
        double DistanceConditionImpl::GetValue() const
        {
        	  return _value;
        }
        std::shared_ptr<IPosition> DistanceConditionImpl::GetPosition() const
        {
        	  return _position;
        }


        void DistanceConditionImpl::SetAlongRoute(const bool alongRoute)
        {
            _alongRoute = alongRoute;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE);
			// set the indicator to true
            isSetAlongRoute = true;          
        }

        void DistanceConditionImpl::SetCoordinateSystem(const CoordinateSystem coordinateSystem)
        {
            _coordinateSystem = coordinateSystem;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM);
			// set the indicator to true
            isSetCoordinateSystem = true;          
        }

        void DistanceConditionImpl::SetFreespace(const bool freespace)
        {
            _freespace = freespace;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FREESPACE);
        }

        void DistanceConditionImpl::SetRelativeDistanceType(const RelativeDistanceType relativeDistanceType)
        {
            _relativeDistanceType = relativeDistanceType;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE);
			// set the indicator to true
            isSetRelativeDistanceType = true;          
        }

        void DistanceConditionImpl::SetRoutingAlgorithm(const RoutingAlgorithm routingAlgorithm)
        {
            _routingAlgorithm = routingAlgorithm;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM);
			// set the indicator to true
            isSetRoutingAlgorithm = true;          
        }

        void DistanceConditionImpl::SetRule(const Rule rule)
        {
            _rule = rule;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE);
        }

        void DistanceConditionImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        void DistanceConditionImpl::SetPosition(std::shared_ptr<IPositionWriter> position)
        {
            _position = position;
        }

        std::shared_ptr<void> DistanceConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(DistanceConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IDistanceCondition).name())
                return std::dynamic_pointer_cast<IDistanceCondition>(shared_from_this());
            else if (classifier == typeid(IDistanceConditionWriter).name())
                return std::dynamic_pointer_cast<IDistanceConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> DistanceConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t DistanceConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int DistanceConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double DistanceConditionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t DistanceConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool DistanceConditionImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE)
                {
                    return GetAlongRoute();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
                {
                    return GetFreespace();
                }
                throw KeyNotSupportedException();

        }

        DateTime DistanceConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> DistanceConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string DistanceConditionImpl::GetModelType() const
        {
            return "DistanceCondition";
        }

        void DistanceConditionImpl::WriteParameterToAlongRoute(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE, parameterName, nullTextMarker /*no textmarker*/);
            _alongRoute = {};
        }

        void DistanceConditionImpl::WriteParameterToCoordinateSystem(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM, parameterName, nullTextMarker /*no textmarker*/);
            _coordinateSystem = {};
        }

        void DistanceConditionImpl::WriteParameterToFreespace(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FREESPACE, parameterName, nullTextMarker /*no textmarker*/);
            _freespace = {};
        }

        void DistanceConditionImpl::WriteParameterToRelativeDistanceType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _relativeDistanceType = {};
        }

        void DistanceConditionImpl::WriteParameterToRoutingAlgorithm(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM, parameterName, nullTextMarker /*no textmarker*/);
            _routingAlgorithm = {};
        }

        void DistanceConditionImpl::WriteParameterToRule(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE, parameterName, nullTextMarker /*no textmarker*/);
            _rule = {};
        }

        void DistanceConditionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string DistanceConditionImpl::GetParameterFromAlongRoute() const
        {
            auto alongRoute = OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE;
            return GetParameterNameFromAttribute(alongRoute);
        }

        std::string DistanceConditionImpl::GetParameterFromCoordinateSystem() const
        {
            auto coordinateSystem = OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM;
            return GetParameterNameFromAttribute(coordinateSystem);
        }

        std::string DistanceConditionImpl::GetParameterFromFreespace() const
        {
            auto freespace = OSC_CONSTANTS::ATTRIBUTE__FREESPACE;
            return GetParameterNameFromAttribute(freespace);
        }

        std::string DistanceConditionImpl::GetParameterFromRelativeDistanceType() const
        {
            auto relativeDistanceType = OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE;
            return GetParameterNameFromAttribute(relativeDistanceType);
        }

        std::string DistanceConditionImpl::GetParameterFromRoutingAlgorithm() const
        {
            auto routingAlgorithm = OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM;
            return GetParameterNameFromAttribute(routingAlgorithm);
        }

        std::string DistanceConditionImpl::GetParameterFromRule() const
        {
            auto rule = OSC_CONSTANTS::ATTRIBUTE__RULE;
            return GetParameterNameFromAttribute(rule);
        }

        std::string DistanceConditionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool DistanceConditionImpl::IsAlongRouteParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool DistanceConditionImpl::IsCoordinateSystemParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool DistanceConditionImpl::IsFreespaceParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__FREESPACE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool DistanceConditionImpl::IsRelativeDistanceTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool DistanceConditionImpl::IsRoutingAlgorithmParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool DistanceConditionImpl::IsRuleParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RULE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool DistanceConditionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IPositionWriter> DistanceConditionImpl::GetWriterPosition() const
        {
            return std::dynamic_pointer_cast<IPositionWriter>(_position);
        }

        DistanceConditionImpl::DistanceConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FREESPACE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void DistanceConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE)
            {
                // Simple type
                _alongRoute = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM)
            {
                // Enumeration Type
                const auto kResult = CoordinateSystem::GetFromLiteral(parameterLiteralValue);
                if (kResult != CoordinateSystem::UNKNOWN)
                {
                    _coordinateSystem = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
            {
                // Simple type
                _freespace = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE)
            {
                // Enumeration Type
                const auto kResult = RelativeDistanceType::GetFromLiteral(parameterLiteralValue);
                if (kResult != RelativeDistanceType::UNKNOWN)
                {
                    _relativeDistanceType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM)
            {
                // Enumeration Type
                const auto kResult = RoutingAlgorithm::GetFromLiteral(parameterLiteralValue);
                if (kResult != RoutingAlgorithm::UNKNOWN)
                {
                    _routingAlgorithm = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType DistanceConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DistanceConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DistanceConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<DistanceConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_alongRoute = GetAlongRoute();
            // Enumeration Type
            const auto kCoordinateSystem = GetCoordinateSystem();
            if ( kCoordinateSystem.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_coordinateSystem = CoordinateSystem::GetFromLiteral(kCoordinateSystem.GetLiteral());
            }
            // Simple type
            clonedObject->_freespace = GetFreespace();
            // Enumeration Type
            const auto kRelativeDistanceType = GetRelativeDistanceType();
            if ( kRelativeDistanceType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_relativeDistanceType = RelativeDistanceType::GetFromLiteral(kRelativeDistanceType.GetLiteral());
            }
            // Enumeration Type
            const auto kRoutingAlgorithm = GetRoutingAlgorithm();
            if ( kRoutingAlgorithm.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_routingAlgorithm = RoutingAlgorithm::GetFromLiteral(kRoutingAlgorithm.GetLiteral());
            }
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            	clonedObject->isSetAlongRoute = isSetAlongRoute;
            	clonedObject->isSetCoordinateSystem = isSetCoordinateSystem;
            	clonedObject->isSetRelativeDistanceType = isSetRelativeDistanceType;
            	clonedObject->isSetRoutingAlgorithm = isSetRoutingAlgorithm;
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            return clonedObject;
        }

        std::string DistanceConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DistanceConditionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DistanceConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DistanceConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DistanceConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM)
            {
                auto coordinateSystem = GetCoordinateSystem();
                return coordinateSystem.GetLiteral() != "UNKNOWN" ? coordinateSystem.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE)
            {
                auto relativeDistanceType = GetRelativeDistanceType();
                return relativeDistanceType.GetLiteral() != "UNKNOWN" ? relativeDistanceType.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM)
            {
                auto routingAlgorithm = GetRoutingAlgorithm();
                return routingAlgorithm.GetLiteral() != "UNKNOWN" ? routingAlgorithm.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void DistanceConditionImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE)
            {
                // Simple type
                _alongRoute = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
            {
                // Simple type
                _freespace = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void DistanceConditionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void DistanceConditionImpl::ResetAlongRoute()
	   {
	   		isSetAlongRoute = false; 
			_alongRoute = {};
			
	   }
       bool DistanceConditionImpl::IsSetAlongRoute() const
	   {
			return isSetAlongRoute;
	   }
       void DistanceConditionImpl::ResetCoordinateSystem()
	   {
	   		isSetCoordinateSystem = false; 
			_coordinateSystem = {CoordinateSystem::CoordinateSystemEnum::ENTITY};
			
	   }
       bool DistanceConditionImpl::IsSetCoordinateSystem() const
	   {
			return isSetCoordinateSystem;
	   }
       void DistanceConditionImpl::ResetRelativeDistanceType()
	   {
	   		isSetRelativeDistanceType = false; 
			_relativeDistanceType = {RelativeDistanceType::RelativeDistanceTypeEnum::EUCLIDIAN_DISTANCE};
			
	   }
       bool DistanceConditionImpl::IsSetRelativeDistanceType() const
	   {
			return isSetRelativeDistanceType;
	   }
       void DistanceConditionImpl::ResetRoutingAlgorithm()
	   {
	   		isSetRoutingAlgorithm = false; 
			_routingAlgorithm = {RoutingAlgorithm::RoutingAlgorithmEnum::UNDEFINED};
			
	   }
       bool DistanceConditionImpl::IsSetRoutingAlgorithm() const
	   {
			return isSetRoutingAlgorithm;
	   }

        IOpenScenarioFlexElement* DistributionDefinitionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IDeterministic> DistributionDefinitionImpl::GetDeterministic() const
        {
        	  return _deterministic;
        }
        std::shared_ptr<IStochastic> DistributionDefinitionImpl::GetStochastic() const
        {
        	  return _stochastic;
        }


        void DistributionDefinitionImpl::SetDeterministic(std::shared_ptr<IDeterministicWriter> deterministic)
        {
            _deterministic = deterministic;
            _stochastic = {};
        }

        void DistributionDefinitionImpl::SetStochastic(std::shared_ptr<IStochasticWriter> stochastic)
        {
            _stochastic = stochastic;
            _deterministic = {};
        }

        std::shared_ptr<void> DistributionDefinitionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(DistributionDefinitionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IDistributionDefinition).name())
                return std::dynamic_pointer_cast<IDistributionDefinition>(shared_from_this());
            else if (classifier == typeid(IDistributionDefinitionWriter).name())
                return std::dynamic_pointer_cast<IDistributionDefinitionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> DistributionDefinitionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t DistributionDefinitionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int DistributionDefinitionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double DistributionDefinitionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t DistributionDefinitionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool DistributionDefinitionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime DistributionDefinitionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> DistributionDefinitionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string DistributionDefinitionImpl::GetModelType() const
        {
            return "DistributionDefinition";
        }

            // children
        std::shared_ptr<IDeterministicWriter> DistributionDefinitionImpl::GetWriterDeterministic() const
        {
            return std::dynamic_pointer_cast<IDeterministicWriter>(_deterministic);
        }
        std::shared_ptr<IStochasticWriter> DistributionDefinitionImpl::GetWriterStochastic() const
        {
            return std::dynamic_pointer_cast<IStochasticWriter>(_stochastic);
        }

        DistributionDefinitionImpl::DistributionDefinitionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void DistributionDefinitionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType DistributionDefinitionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DistributionDefinitionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDeterministic =  GetWriterDeterministic();
                if (kDeterministic)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDeterministic));
                }
                const auto kStochastic =  GetWriterStochastic();
                if (kStochastic)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kStochastic));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DistributionDefinitionImpl::Clone()
        {
            auto clonedObject = std::make_shared<DistributionDefinitionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kDeterministic =  GetWriterDeterministic();
            if (kDeterministic)
            {
                auto clonedChild = std::dynamic_pointer_cast<DeterministicImpl>(kDeterministic)->Clone();
                auto clonedChildIDeterministic = std::dynamic_pointer_cast<IDeterministic>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDeterministic(std::dynamic_pointer_cast<IDeterministicWriter>(clonedChildIDeterministic));
            }
            const auto kStochastic =  GetWriterStochastic();
            if (kStochastic)
            {
                auto clonedChild = std::dynamic_pointer_cast<StochasticImpl>(kStochastic)->Clone();
                auto clonedChildIStochastic = std::dynamic_pointer_cast<IStochastic>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetStochastic(std::dynamic_pointer_cast<IStochasticWriter>(clonedChildIStochastic));
            }
            return clonedObject;
        }

        std::string DistributionDefinitionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DistributionDefinitionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DETERMINISTIC)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDeterministic());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__STOCHASTIC)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetStochastic());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DistributionDefinitionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DistributionDefinitionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DistributionDefinitionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* DistributionRangeImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double DistributionRangeImpl::GetStepWidth() const
        {
        	  return _stepWidth;
        }
        std::shared_ptr<IRange> DistributionRangeImpl::GetRange() const
        {
        	  return _range;
        }


        void DistributionRangeImpl::SetStepWidth(const double stepWidth)
        {
            _stepWidth = stepWidth;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STEP_WIDTH);
        }

        void DistributionRangeImpl::SetRange(std::shared_ptr<IRangeWriter> range)
        {
            _range = range;
        }

        std::shared_ptr<void> DistributionRangeImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(DistributionRangeImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IDistributionRange).name())
                return std::dynamic_pointer_cast<IDistributionRange>(shared_from_this());
            else if (classifier == typeid(IDistributionRangeWriter).name())
                return std::dynamic_pointer_cast<IDistributionRangeWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> DistributionRangeImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t DistributionRangeImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int DistributionRangeImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double DistributionRangeImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__STEP_WIDTH)
                {
                    return GetStepWidth();
                }
                throw KeyNotSupportedException();

        }

        uint16_t DistributionRangeImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool DistributionRangeImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime DistributionRangeImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> DistributionRangeImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string DistributionRangeImpl::GetModelType() const
        {
            return "DistributionRange";
        }

        void DistributionRangeImpl::WriteParameterToStepWidth(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STEP_WIDTH, parameterName, nullTextMarker /*no textmarker*/);
            _stepWidth = {};
        }

        std::string DistributionRangeImpl::GetParameterFromStepWidth() const
        {
            auto stepWidth = OSC_CONSTANTS::ATTRIBUTE__STEP_WIDTH;
            return GetParameterNameFromAttribute(stepWidth);
        }

        bool DistributionRangeImpl::IsStepWidthParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__STEP_WIDTH);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IRangeWriter> DistributionRangeImpl::GetWriterRange() const
        {
            return std::dynamic_pointer_cast<IRangeWriter>(_range);
        }

        DistributionRangeImpl::DistributionRangeImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__STEP_WIDTH, SimpleType::DOUBLE);
        }

        void DistributionRangeImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STEP_WIDTH)
            {
                // Simple type
                _stepWidth = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType DistributionRangeImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DistributionRangeImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRange =  GetWriterRange();
                if (kRange)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRange));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DistributionRangeImpl::Clone()
        {
            auto clonedObject = std::make_shared<DistributionRangeImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_stepWidth = GetStepWidth();
            // clone indicators
            // clone children
            const auto kRange =  GetWriterRange();
            if (kRange)
            {
                auto clonedChild = std::dynamic_pointer_cast<RangeImpl>(kRange)->Clone();
                auto clonedChildIRange = std::dynamic_pointer_cast<IRange>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRange(std::dynamic_pointer_cast<IRangeWriter>(clonedChildIRange));
            }
            return clonedObject;
        }

        std::string DistributionRangeImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DistributionRangeImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RANGE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRange());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DistributionRangeImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DistributionRangeImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DistributionRangeImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void DistributionRangeImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STEP_WIDTH)
            {
                // Simple type
                _stepWidth = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* DistributionSetImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<IDistributionSetElement>> DistributionSetImpl::GetElements() const
        {
            std::vector<std::shared_ptr<IDistributionSetElement>> temp;
            for(auto&& elm: _elements)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IDistributionSetElementWriter>> DistributionSetImpl::GetWriterElements() const
        {
            return _elements;
        }

        int DistributionSetImpl::GetElementsSize() const
        {
            return static_cast<int>(_elements.size());
        }

        std::shared_ptr<IDistributionSetElement> DistributionSetImpl::GetElementsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _elements.size() > index)
            {
                return _elements[index];
            }
            return nullptr;
        }


        void DistributionSetImpl::SetElements(std::vector<std::shared_ptr<IDistributionSetElementWriter>>& elements)
        {
            _elements = elements;
        }

        std::shared_ptr<void> DistributionSetImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(DistributionSetImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IDistributionSet).name())
                return std::dynamic_pointer_cast<IDistributionSet>(shared_from_this());
            else if (classifier == typeid(IDistributionSetWriter).name())
                return std::dynamic_pointer_cast<IDistributionSetWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> DistributionSetImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t DistributionSetImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int DistributionSetImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double DistributionSetImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t DistributionSetImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool DistributionSetImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime DistributionSetImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> DistributionSetImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string DistributionSetImpl::GetModelType() const
        {
            return "DistributionSet";
        }

            // children

        DistributionSetImpl::DistributionSetImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void DistributionSetImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType DistributionSetImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DistributionSetImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto elements =  GetWriterElements();
                if (!elements.empty())
                {
                    for(auto&& item : elements)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DistributionSetImpl::Clone()
        {
            auto clonedObject = std::make_shared<DistributionSetImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kElements =  GetWriterElements();
            if (!kElements.empty())
            {
                std::vector<std::shared_ptr<IDistributionSetElementWriter>> clonedList;
                for(auto&& kItem : kElements)
                {
                    auto clonedChild = std::dynamic_pointer_cast<DistributionSetElementImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IDistributionSetElementWriter>(clonedChild));
                }
                clonedObject->SetElements(clonedList);
            }
            return clonedObject;
        }

        std::string DistributionSetImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DistributionSetImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DistributionSetImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__ELEMENT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetElements())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DistributionSetImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DistributionSetImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* DistributionSetElementImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string DistributionSetElementImpl::GetValue() const
        {
        	  return _value;
        }


        void DistributionSetElementImpl::SetValue(const std::string value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> DistributionSetElementImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(DistributionSetElementImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IDistributionSetElement).name())
                return std::dynamic_pointer_cast<IDistributionSetElement>(shared_from_this());
            else if (classifier == typeid(IDistributionSetElementWriter).name())
                return std::dynamic_pointer_cast<IDistributionSetElementWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> DistributionSetElementImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t DistributionSetElementImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int DistributionSetElementImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double DistributionSetElementImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t DistributionSetElementImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool DistributionSetElementImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime DistributionSetElementImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> DistributionSetElementImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string DistributionSetElementImpl::GetModelType() const
        {
            return "DistributionSetElement";
        }

        void DistributionSetElementImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string DistributionSetElementImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool DistributionSetElementImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        DistributionSetElementImpl::DistributionSetElementImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
        }

        void DistributionSetElementImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType DistributionSetElementImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DistributionSetElementImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DistributionSetElementImpl::Clone()
        {
            auto clonedObject = std::make_shared<DistributionSetElementImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string DistributionSetElementImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DistributionSetElementImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DistributionSetElementImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DistributionSetElementImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DistributionSetElementImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void DistributionSetElementImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* DomeImageImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double DomeImageImpl::GetAzimuthOffset() const
        {
        	  return _azimuthOffset;
        }
        std::shared_ptr<IFile> DomeImageImpl::GetDomeFile() const
        {
        	  return _domeFile;
        }


        void DomeImageImpl::SetAzimuthOffset(const double azimuthOffset)
        {
            _azimuthOffset = azimuthOffset;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__AZIMUTH_OFFSET);
			// set the indicator to true
            isSetAzimuthOffset = true;          
        }

        void DomeImageImpl::SetDomeFile(std::shared_ptr<IFileWriter> domeFile)
        {
            _domeFile = domeFile;
        }

        std::shared_ptr<void> DomeImageImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(DomeImageImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IDomeImage).name())
                return std::dynamic_pointer_cast<IDomeImage>(shared_from_this());
            else if (classifier == typeid(IDomeImageWriter).name())
                return std::dynamic_pointer_cast<IDomeImageWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> DomeImageImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t DomeImageImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int DomeImageImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double DomeImageImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__AZIMUTH_OFFSET)
                {
                    return GetAzimuthOffset();
                }
                throw KeyNotSupportedException();

        }

        uint16_t DomeImageImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool DomeImageImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime DomeImageImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> DomeImageImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string DomeImageImpl::GetModelType() const
        {
            return "DomeImage";
        }

        void DomeImageImpl::WriteParameterToAzimuthOffset(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__AZIMUTH_OFFSET, parameterName, nullTextMarker /*no textmarker*/);
            _azimuthOffset = {};
        }

        std::string DomeImageImpl::GetParameterFromAzimuthOffset() const
        {
            auto azimuthOffset = OSC_CONSTANTS::ATTRIBUTE__AZIMUTH_OFFSET;
            return GetParameterNameFromAttribute(azimuthOffset);
        }

        bool DomeImageImpl::IsAzimuthOffsetParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__AZIMUTH_OFFSET);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IFileWriter> DomeImageImpl::GetWriterDomeFile() const
        {
            return std::dynamic_pointer_cast<IFileWriter>(_domeFile);
        }

        DomeImageImpl::DomeImageImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__AZIMUTH_OFFSET, SimpleType::DOUBLE);
        }

        void DomeImageImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__AZIMUTH_OFFSET)
            {
                // Simple type
                _azimuthOffset = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType DomeImageImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DomeImageImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDomeFile =  GetWriterDomeFile();
                if (kDomeFile)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDomeFile));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DomeImageImpl::Clone()
        {
            auto clonedObject = std::make_shared<DomeImageImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_azimuthOffset = GetAzimuthOffset();
            // clone indicators
            	clonedObject->isSetAzimuthOffset = isSetAzimuthOffset;
            // clone children
            const auto kDomeFile =  GetWriterDomeFile();
            if (kDomeFile)
            {
                auto clonedChild = std::dynamic_pointer_cast<FileImpl>(kDomeFile)->Clone();
                auto clonedChildIFile = std::dynamic_pointer_cast<IFile>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDomeFile(std::dynamic_pointer_cast<IFileWriter>(clonedChildIFile));
            }
            return clonedObject;
        }

        std::string DomeImageImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DomeImageImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DOME_FILE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDomeFile());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DomeImageImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DomeImageImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DomeImageImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void DomeImageImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__AZIMUTH_OFFSET)
            {
                // Simple type
                _azimuthOffset = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void DomeImageImpl::ResetAzimuthOffset()
	   {
	   		isSetAzimuthOffset = false; 
			_azimuthOffset = {0};
			
	   }
       bool DomeImageImpl::IsSetAzimuthOffset() const
	   {
			return isSetAzimuthOffset;
	   }

        IOpenScenarioFlexElement* DynamicConstraintsImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double DynamicConstraintsImpl::GetMaxAcceleration() const
        {
        	  return _maxAcceleration;
        }
        double DynamicConstraintsImpl::GetMaxAccelerationRate() const
        {
        	  return _maxAccelerationRate;
        }
        double DynamicConstraintsImpl::GetMaxDeceleration() const
        {
        	  return _maxDeceleration;
        }
        double DynamicConstraintsImpl::GetMaxDecelerationRate() const
        {
        	  return _maxDecelerationRate;
        }
        double DynamicConstraintsImpl::GetMaxSpeed() const
        {
        	  return _maxSpeed;
        }


        void DynamicConstraintsImpl::SetMaxAcceleration(const double maxAcceleration)
        {
            _maxAcceleration = maxAcceleration;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION);
			// set the indicator to true
            isSetMaxAcceleration = true;          
        }

        void DynamicConstraintsImpl::SetMaxAccelerationRate(const double maxAccelerationRate)
        {
            _maxAccelerationRate = maxAccelerationRate;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION_RATE);
			// set the indicator to true
            isSetMaxAccelerationRate = true;          
        }

        void DynamicConstraintsImpl::SetMaxDeceleration(const double maxDeceleration)
        {
            _maxDeceleration = maxDeceleration;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION);
			// set the indicator to true
            isSetMaxDeceleration = true;          
        }

        void DynamicConstraintsImpl::SetMaxDecelerationRate(const double maxDecelerationRate)
        {
            _maxDecelerationRate = maxDecelerationRate;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION_RATE);
			// set the indicator to true
            isSetMaxDecelerationRate = true;          
        }

        void DynamicConstraintsImpl::SetMaxSpeed(const double maxSpeed)
        {
            _maxSpeed = maxSpeed;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED);
			// set the indicator to true
            isSetMaxSpeed = true;          
        }

        std::shared_ptr<void> DynamicConstraintsImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(DynamicConstraintsImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IDynamicConstraints).name())
                return std::dynamic_pointer_cast<IDynamicConstraints>(shared_from_this());
            else if (classifier == typeid(IDynamicConstraintsWriter).name())
                return std::dynamic_pointer_cast<IDynamicConstraintsWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> DynamicConstraintsImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t DynamicConstraintsImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int DynamicConstraintsImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double DynamicConstraintsImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION)
                {
                    return GetMaxAcceleration();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION_RATE)
                {
                    return GetMaxAccelerationRate();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION)
                {
                    return GetMaxDeceleration();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION_RATE)
                {
                    return GetMaxDecelerationRate();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED)
                {
                    return GetMaxSpeed();
                }
                throw KeyNotSupportedException();

        }

        uint16_t DynamicConstraintsImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool DynamicConstraintsImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime DynamicConstraintsImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> DynamicConstraintsImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string DynamicConstraintsImpl::GetModelType() const
        {
            return "DynamicConstraints";
        }

        void DynamicConstraintsImpl::WriteParameterToMaxAcceleration(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION, parameterName, nullTextMarker /*no textmarker*/);
            _maxAcceleration = {};
        }

        void DynamicConstraintsImpl::WriteParameterToMaxAccelerationRate(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION_RATE, parameterName, nullTextMarker /*no textmarker*/);
            _maxAccelerationRate = {};
        }

        void DynamicConstraintsImpl::WriteParameterToMaxDeceleration(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION, parameterName, nullTextMarker /*no textmarker*/);
            _maxDeceleration = {};
        }

        void DynamicConstraintsImpl::WriteParameterToMaxDecelerationRate(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION_RATE, parameterName, nullTextMarker /*no textmarker*/);
            _maxDecelerationRate = {};
        }

        void DynamicConstraintsImpl::WriteParameterToMaxSpeed(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED, parameterName, nullTextMarker /*no textmarker*/);
            _maxSpeed = {};
        }

        std::string DynamicConstraintsImpl::GetParameterFromMaxAcceleration() const
        {
            auto maxAcceleration = OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION;
            return GetParameterNameFromAttribute(maxAcceleration);
        }

        std::string DynamicConstraintsImpl::GetParameterFromMaxAccelerationRate() const
        {
            auto maxAccelerationRate = OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION_RATE;
            return GetParameterNameFromAttribute(maxAccelerationRate);
        }

        std::string DynamicConstraintsImpl::GetParameterFromMaxDeceleration() const
        {
            auto maxDeceleration = OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION;
            return GetParameterNameFromAttribute(maxDeceleration);
        }

        std::string DynamicConstraintsImpl::GetParameterFromMaxDecelerationRate() const
        {
            auto maxDecelerationRate = OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION_RATE;
            return GetParameterNameFromAttribute(maxDecelerationRate);
        }

        std::string DynamicConstraintsImpl::GetParameterFromMaxSpeed() const
        {
            auto maxSpeed = OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED;
            return GetParameterNameFromAttribute(maxSpeed);
        }

        bool DynamicConstraintsImpl::IsMaxAccelerationParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool DynamicConstraintsImpl::IsMaxAccelerationRateParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION_RATE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool DynamicConstraintsImpl::IsMaxDecelerationParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool DynamicConstraintsImpl::IsMaxDecelerationRateParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION_RATE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool DynamicConstraintsImpl::IsMaxSpeedParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        DynamicConstraintsImpl::DynamicConstraintsImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION_RATE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION_RATE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED, SimpleType::DOUBLE);
        }

        void DynamicConstraintsImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION)
            {
                // Simple type
                _maxAcceleration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION_RATE)
            {
                // Simple type
                _maxAccelerationRate = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION)
            {
                // Simple type
                _maxDeceleration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION_RATE)
            {
                // Simple type
                _maxDecelerationRate = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED)
            {
                // Simple type
                _maxSpeed = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType DynamicConstraintsImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DynamicConstraintsImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DynamicConstraintsImpl::Clone()
        {
            auto clonedObject = std::make_shared<DynamicConstraintsImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_maxAcceleration = GetMaxAcceleration();
            // Simple type
            clonedObject->_maxAccelerationRate = GetMaxAccelerationRate();
            // Simple type
            clonedObject->_maxDeceleration = GetMaxDeceleration();
            // Simple type
            clonedObject->_maxDecelerationRate = GetMaxDecelerationRate();
            // Simple type
            clonedObject->_maxSpeed = GetMaxSpeed();
            // clone indicators
            	clonedObject->isSetMaxAcceleration = isSetMaxAcceleration;
            	clonedObject->isSetMaxAccelerationRate = isSetMaxAccelerationRate;
            	clonedObject->isSetMaxDeceleration = isSetMaxDeceleration;
            	clonedObject->isSetMaxDecelerationRate = isSetMaxDecelerationRate;
            	clonedObject->isSetMaxSpeed = isSetMaxSpeed;
            // clone children
            return clonedObject;
        }

        std::string DynamicConstraintsImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DynamicConstraintsImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DynamicConstraintsImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DynamicConstraintsImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DynamicConstraintsImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void DynamicConstraintsImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION)
            {
                // Simple type
                _maxAcceleration = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION_RATE)
            {
                // Simple type
                _maxAccelerationRate = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION)
            {
                // Simple type
                _maxDeceleration = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION_RATE)
            {
                // Simple type
                _maxDecelerationRate = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED)
            {
                // Simple type
                _maxSpeed = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void DynamicConstraintsImpl::ResetMaxAcceleration()
	   {
	   		isSetMaxAcceleration = false; 
			_maxAcceleration = {};
			
	   }
       bool DynamicConstraintsImpl::IsSetMaxAcceleration() const
	   {
			return isSetMaxAcceleration;
	   }
       void DynamicConstraintsImpl::ResetMaxAccelerationRate()
	   {
	   		isSetMaxAccelerationRate = false; 
			_maxAccelerationRate = {};
			
	   }
       bool DynamicConstraintsImpl::IsSetMaxAccelerationRate() const
	   {
			return isSetMaxAccelerationRate;
	   }
       void DynamicConstraintsImpl::ResetMaxDeceleration()
	   {
	   		isSetMaxDeceleration = false; 
			_maxDeceleration = {};
			
	   }
       bool DynamicConstraintsImpl::IsSetMaxDeceleration() const
	   {
			return isSetMaxDeceleration;
	   }
       void DynamicConstraintsImpl::ResetMaxDecelerationRate()
	   {
	   		isSetMaxDecelerationRate = false; 
			_maxDecelerationRate = {};
			
	   }
       bool DynamicConstraintsImpl::IsSetMaxDecelerationRate() const
	   {
			return isSetMaxDecelerationRate;
	   }
       void DynamicConstraintsImpl::ResetMaxSpeed()
	   {
	   		isSetMaxSpeed = false; 
			_maxSpeed = {};
			
	   }
       bool DynamicConstraintsImpl::IsSetMaxSpeed() const
	   {
			return isSetMaxSpeed;
	   }

        IOpenScenarioFlexElement* EndOfRoadConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double EndOfRoadConditionImpl::GetDuration() const
        {
        	  return _duration;
        }


        void EndOfRoadConditionImpl::SetDuration(const double duration)
        {
            _duration = duration;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DURATION);
        }

        std::shared_ptr<void> EndOfRoadConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(EndOfRoadConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IEndOfRoadCondition).name())
                return std::dynamic_pointer_cast<IEndOfRoadCondition>(shared_from_this());
            else if (classifier == typeid(IEndOfRoadConditionWriter).name())
                return std::dynamic_pointer_cast<IEndOfRoadConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> EndOfRoadConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t EndOfRoadConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int EndOfRoadConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double EndOfRoadConditionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__DURATION)
                {
                    return GetDuration();
                }
                throw KeyNotSupportedException();

        }

        uint16_t EndOfRoadConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool EndOfRoadConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime EndOfRoadConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> EndOfRoadConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string EndOfRoadConditionImpl::GetModelType() const
        {
            return "EndOfRoadCondition";
        }

        void EndOfRoadConditionImpl::WriteParameterToDuration(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DURATION, parameterName, nullTextMarker /*no textmarker*/);
            _duration = {};
        }

        std::string EndOfRoadConditionImpl::GetParameterFromDuration() const
        {
            auto duration = OSC_CONSTANTS::ATTRIBUTE__DURATION;
            return GetParameterNameFromAttribute(duration);
        }

        bool EndOfRoadConditionImpl::IsDurationParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DURATION);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        EndOfRoadConditionImpl::EndOfRoadConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DURATION, SimpleType::DOUBLE);
        }

        void EndOfRoadConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DURATION)
            {
                // Simple type
                _duration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType EndOfRoadConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EndOfRoadConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EndOfRoadConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<EndOfRoadConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_duration = GetDuration();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string EndOfRoadConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EndOfRoadConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EndOfRoadConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EndOfRoadConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string EndOfRoadConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void EndOfRoadConditionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DURATION)
            {
                // Simple type
                _duration = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* EntitiesImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<IScenarioObject>> EntitiesImpl::GetScenarioObjects() const
        {
            std::vector<std::shared_ptr<IScenarioObject>> temp;
            for(auto&& elm: _scenarioObjects)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IScenarioObjectWriter>> EntitiesImpl::GetWriterScenarioObjects() const
        {
            return _scenarioObjects;
        }

        int EntitiesImpl::GetScenarioObjectsSize() const
        {
            return static_cast<int>(_scenarioObjects.size());
        }

        std::shared_ptr<IScenarioObject> EntitiesImpl::GetScenarioObjectsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _scenarioObjects.size() > index)
            {
                return _scenarioObjects[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<IEntitySelection>> EntitiesImpl::GetEntitySelections() const
        {
            std::vector<std::shared_ptr<IEntitySelection>> temp;
            for(auto&& elm: _entitySelections)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IEntitySelectionWriter>> EntitiesImpl::GetWriterEntitySelections() const
        {
            return _entitySelections;
        }

        int EntitiesImpl::GetEntitySelectionsSize() const
        {
            return static_cast<int>(_entitySelections.size());
        }

        std::shared_ptr<IEntitySelection> EntitiesImpl::GetEntitySelectionsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _entitySelections.size() > index)
            {
                return _entitySelections[index];
            }
            return nullptr;
        }


        void EntitiesImpl::SetScenarioObjects(std::vector<std::shared_ptr<IScenarioObjectWriter>>& scenarioObjects)
        {
            _scenarioObjects = scenarioObjects;
			// set the indicator to true
            isSetScenarioObjects = true;          
        }

        void EntitiesImpl::SetEntitySelections(std::vector<std::shared_ptr<IEntitySelectionWriter>>& entitySelections)
        {
            _entitySelections = entitySelections;
			// set the indicator to true
            isSetEntitySelections = true;          
        }

        std::shared_ptr<void> EntitiesImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(EntitiesImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IEntities).name())
                return std::dynamic_pointer_cast<IEntities>(shared_from_this());
            else if (classifier == typeid(IEntitiesWriter).name())
                return std::dynamic_pointer_cast<IEntitiesWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> EntitiesImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t EntitiesImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int EntitiesImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double EntitiesImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t EntitiesImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool EntitiesImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime EntitiesImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> EntitiesImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string EntitiesImpl::GetModelType() const
        {
            return "Entities";
        }

            // children

        EntitiesImpl::EntitiesImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void EntitiesImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType EntitiesImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EntitiesImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto scenarioObjects =  GetWriterScenarioObjects();
                if (!scenarioObjects.empty())
                {
                    for(auto&& item : scenarioObjects)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto entitySelections =  GetWriterEntitySelections();
                if (!entitySelections.empty())
                {
                    for(auto&& item : entitySelections)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EntitiesImpl::Clone()
        {
            auto clonedObject = std::make_shared<EntitiesImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kScenarioObjects =  GetWriterScenarioObjects();
            if (!kScenarioObjects.empty())
            {
                std::vector<std::shared_ptr<IScenarioObjectWriter>> clonedList;
                for(auto&& kItem : kScenarioObjects)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ScenarioObjectImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IScenarioObjectWriter>(clonedChild));
                }
                clonedObject->SetScenarioObjects(clonedList);
            }
            const auto kEntitySelections =  GetWriterEntitySelections();
            if (!kEntitySelections.empty())
            {
                std::vector<std::shared_ptr<IEntitySelectionWriter>> clonedList;
                for(auto&& kItem : kEntitySelections)
                {
                    auto clonedChild = std::dynamic_pointer_cast<EntitySelectionImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IEntitySelectionWriter>(clonedChild));
                }
                clonedObject->SetEntitySelections(clonedList);
            }
            return clonedObject;
        }

        std::string EntitiesImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntitiesImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EntitiesImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__SCENARIO_OBJECT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetScenarioObjects())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_SELECTION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetEntitySelections())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntitiesImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string EntitiesImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void EntitiesImpl::ResetScenarioObjects()
	   {
	   		isSetScenarioObjects = false; 
			_scenarioObjects = {};
			
	   }
       bool EntitiesImpl::IsSetScenarioObjects() const
	   {
			return isSetScenarioObjects;
	   }
       void EntitiesImpl::ResetEntitySelections()
	   {
	   		isSetEntitySelections = false; 
			_entitySelections = {};
			
	   }
       bool EntitiesImpl::IsSetEntitySelections() const
	   {
			return isSetEntitySelections;
	   }

        IOpenScenarioFlexElement* EntityActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<INamedReference<IEntity>> EntityActionImpl::GetEntityRef() const
        {
        	 return _entityRef;
        }
        std::shared_ptr<IAddEntityAction> EntityActionImpl::GetAddEntityAction() const
        {
        	  return _addEntityAction;
        }
        std::shared_ptr<IDeleteEntityAction> EntityActionImpl::GetDeleteEntityAction() const
        {
        	  return _deleteEntityAction;
        }


        void EntityActionImpl::SetEntityRef(std::shared_ptr<INamedReference<IEntity>> entityRef)
        {
            _entityRef = entityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
        }

        void EntityActionImpl::SetAddEntityAction(std::shared_ptr<IAddEntityActionWriter> addEntityAction)
        {
            _addEntityAction = addEntityAction;
            _deleteEntityAction = {};
			// set the indicator to true
            isSetAddEntityAction = true;          
        }

        void EntityActionImpl::SetDeleteEntityAction(std::shared_ptr<IDeleteEntityActionWriter> deleteEntityAction)
        {
            _deleteEntityAction = deleteEntityAction;
            _addEntityAction = {};
			// set the indicator to true
            isSetDeleteEntityAction = true;          
        }

        std::shared_ptr<void> EntityActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(EntityActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IEntityAction).name())
                return std::dynamic_pointer_cast<IEntityAction>(shared_from_this());
            else if (classifier == typeid(IEntityActionWriter).name())
                return std::dynamic_pointer_cast<IEntityActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> EntityActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t EntityActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int EntityActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double EntityActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t EntityActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool EntityActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime EntityActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> EntityActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string EntityActionImpl::GetModelType() const
        {
            return "EntityAction";
        }

        void EntityActionImpl::WriteParameterToEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _entityRef = {};
        }

        std::string EntityActionImpl::GetParameterFromEntityRef() const
        {
            auto entityRef = OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF;
            return GetParameterNameFromAttribute(entityRef);
        }

        bool EntityActionImpl::IsEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IAddEntityActionWriter> EntityActionImpl::GetWriterAddEntityAction() const
        {
            return std::dynamic_pointer_cast<IAddEntityActionWriter>(_addEntityAction);
        }
        std::shared_ptr<IDeleteEntityActionWriter> EntityActionImpl::GetWriterDeleteEntityAction() const
        {
            return std::dynamic_pointer_cast<IDeleteEntityActionWriter>(_deleteEntityAction);
        }

        EntityActionImpl::EntityActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
        }

        void EntityActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType EntityActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EntityActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kAddEntityAction =  GetWriterAddEntityAction();
                if (kAddEntityAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAddEntityAction));
                }
                const auto kDeleteEntityAction =  GetWriterDeleteEntityAction();
                if (kDeleteEntityAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDeleteEntityAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EntityActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<EntityActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // clone indicators
            // clone children
            const auto kAddEntityAction =  GetWriterAddEntityAction();
            if (kAddEntityAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<AddEntityActionImpl>(kAddEntityAction)->Clone();
                auto clonedChildIAddEntityAction = std::dynamic_pointer_cast<IAddEntityAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAddEntityAction(std::dynamic_pointer_cast<IAddEntityActionWriter>(clonedChildIAddEntityAction));
            }
            const auto kDeleteEntityAction =  GetWriterDeleteEntityAction();
            if (kDeleteEntityAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<DeleteEntityActionImpl>(kDeleteEntityAction)->Clone();
                auto clonedChildIDeleteEntityAction = std::dynamic_pointer_cast<IDeleteEntityAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDeleteEntityAction(std::dynamic_pointer_cast<IDeleteEntityActionWriter>(clonedChildIDeleteEntityAction));
            }
            return clonedObject;
        }

        std::string EntityActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntityActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ADD_ENTITY_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAddEntityAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DELETE_ENTITY_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDeleteEntityAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EntityActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntityActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string EntityActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void EntityActionImpl::ResetAddEntityAction()
	   {
	   		isSetAddEntityAction = false; 
			_addEntityAction = {};
			
	   }
       bool EntityActionImpl::IsSetAddEntityAction() const
	   {
			return isSetAddEntityAction;
	   }
       void EntityActionImpl::ResetDeleteEntityAction()
	   {
	   		isSetDeleteEntityAction = false; 
			_deleteEntityAction = {};
			
	   }
       bool EntityActionImpl::IsSetDeleteEntityAction() const
	   {
			return isSetDeleteEntityAction;
	   }

        IOpenScenarioFlexElement* EntityConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IEndOfRoadCondition> EntityConditionImpl::GetEndOfRoadCondition() const
        {
        	  return _endOfRoadCondition;
        }
        std::shared_ptr<ICollisionCondition> EntityConditionImpl::GetCollisionCondition() const
        {
        	  return _collisionCondition;
        }
        std::shared_ptr<IOffroadCondition> EntityConditionImpl::GetOffroadCondition() const
        {
        	  return _offroadCondition;
        }
        std::shared_ptr<ITimeHeadwayCondition> EntityConditionImpl::GetTimeHeadwayCondition() const
        {
        	  return _timeHeadwayCondition;
        }
        std::shared_ptr<ITimeToCollisionCondition> EntityConditionImpl::GetTimeToCollisionCondition() const
        {
        	  return _timeToCollisionCondition;
        }
        std::shared_ptr<IAccelerationCondition> EntityConditionImpl::GetAccelerationCondition() const
        {
        	  return _accelerationCondition;
        }
        std::shared_ptr<IStandStillCondition> EntityConditionImpl::GetStandStillCondition() const
        {
        	  return _standStillCondition;
        }
        std::shared_ptr<ISpeedCondition> EntityConditionImpl::GetSpeedCondition() const
        {
        	  return _speedCondition;
        }
        std::shared_ptr<IRelativeSpeedCondition> EntityConditionImpl::GetRelativeSpeedCondition() const
        {
        	  return _relativeSpeedCondition;
        }
        std::shared_ptr<ITraveledDistanceCondition> EntityConditionImpl::GetTraveledDistanceCondition() const
        {
        	  return _traveledDistanceCondition;
        }
        std::shared_ptr<IReachPositionCondition> EntityConditionImpl::GetReachPositionCondition() const
        {
        	  return _reachPositionCondition;
        }
        std::shared_ptr<IDistanceCondition> EntityConditionImpl::GetDistanceCondition() const
        {
        	  return _distanceCondition;
        }
        std::shared_ptr<IRelativeDistanceCondition> EntityConditionImpl::GetRelativeDistanceCondition() const
        {
        	  return _relativeDistanceCondition;
        }
        std::shared_ptr<IRelativeClearanceCondition> EntityConditionImpl::GetRelativeClearanceCondition() const
        {
        	  return _relativeClearanceCondition;
        }


        void EntityConditionImpl::SetEndOfRoadCondition(std::shared_ptr<IEndOfRoadConditionWriter> endOfRoadCondition)
        {
            _endOfRoadCondition = endOfRoadCondition;
            _collisionCondition = {};
            _offroadCondition = {};
            _timeHeadwayCondition = {};
            _timeToCollisionCondition = {};
            _accelerationCondition = {};
            _standStillCondition = {};
            _speedCondition = {};
            _relativeSpeedCondition = {};
            _traveledDistanceCondition = {};
            _reachPositionCondition = {};
            _distanceCondition = {};
            _relativeDistanceCondition = {};
            _relativeClearanceCondition = {};
			// set the indicator to true
            isSetEndOfRoadCondition = true;          
        }

        void EntityConditionImpl::SetCollisionCondition(std::shared_ptr<ICollisionConditionWriter> collisionCondition)
        {
            _collisionCondition = collisionCondition;
            _endOfRoadCondition = {};
            _offroadCondition = {};
            _timeHeadwayCondition = {};
            _timeToCollisionCondition = {};
            _accelerationCondition = {};
            _standStillCondition = {};
            _speedCondition = {};
            _relativeSpeedCondition = {};
            _traveledDistanceCondition = {};
            _reachPositionCondition = {};
            _distanceCondition = {};
            _relativeDistanceCondition = {};
            _relativeClearanceCondition = {};
			// set the indicator to true
            isSetCollisionCondition = true;          
        }

        void EntityConditionImpl::SetOffroadCondition(std::shared_ptr<IOffroadConditionWriter> offroadCondition)
        {
            _offroadCondition = offroadCondition;
            _endOfRoadCondition = {};
            _collisionCondition = {};
            _timeHeadwayCondition = {};
            _timeToCollisionCondition = {};
            _accelerationCondition = {};
            _standStillCondition = {};
            _speedCondition = {};
            _relativeSpeedCondition = {};
            _traveledDistanceCondition = {};
            _reachPositionCondition = {};
            _distanceCondition = {};
            _relativeDistanceCondition = {};
            _relativeClearanceCondition = {};
			// set the indicator to true
            isSetOffroadCondition = true;          
        }

        void EntityConditionImpl::SetTimeHeadwayCondition(std::shared_ptr<ITimeHeadwayConditionWriter> timeHeadwayCondition)
        {
            _timeHeadwayCondition = timeHeadwayCondition;
            _endOfRoadCondition = {};
            _collisionCondition = {};
            _offroadCondition = {};
            _timeToCollisionCondition = {};
            _accelerationCondition = {};
            _standStillCondition = {};
            _speedCondition = {};
            _relativeSpeedCondition = {};
            _traveledDistanceCondition = {};
            _reachPositionCondition = {};
            _distanceCondition = {};
            _relativeDistanceCondition = {};
            _relativeClearanceCondition = {};
			// set the indicator to true
            isSetTimeHeadwayCondition = true;          
        }

        void EntityConditionImpl::SetTimeToCollisionCondition(std::shared_ptr<ITimeToCollisionConditionWriter> timeToCollisionCondition)
        {
            _timeToCollisionCondition = timeToCollisionCondition;
            _endOfRoadCondition = {};
            _collisionCondition = {};
            _offroadCondition = {};
            _timeHeadwayCondition = {};
            _accelerationCondition = {};
            _standStillCondition = {};
            _speedCondition = {};
            _relativeSpeedCondition = {};
            _traveledDistanceCondition = {};
            _reachPositionCondition = {};
            _distanceCondition = {};
            _relativeDistanceCondition = {};
            _relativeClearanceCondition = {};
			// set the indicator to true
            isSetTimeToCollisionCondition = true;          
        }

        void EntityConditionImpl::SetAccelerationCondition(std::shared_ptr<IAccelerationConditionWriter> accelerationCondition)
        {
            _accelerationCondition = accelerationCondition;
            _endOfRoadCondition = {};
            _collisionCondition = {};
            _offroadCondition = {};
            _timeHeadwayCondition = {};
            _timeToCollisionCondition = {};
            _standStillCondition = {};
            _speedCondition = {};
            _relativeSpeedCondition = {};
            _traveledDistanceCondition = {};
            _reachPositionCondition = {};
            _distanceCondition = {};
            _relativeDistanceCondition = {};
            _relativeClearanceCondition = {};
			// set the indicator to true
            isSetAccelerationCondition = true;          
        }

        void EntityConditionImpl::SetStandStillCondition(std::shared_ptr<IStandStillConditionWriter> standStillCondition)
        {
            _standStillCondition = standStillCondition;
            _endOfRoadCondition = {};
            _collisionCondition = {};
            _offroadCondition = {};
            _timeHeadwayCondition = {};
            _timeToCollisionCondition = {};
            _accelerationCondition = {};
            _speedCondition = {};
            _relativeSpeedCondition = {};
            _traveledDistanceCondition = {};
            _reachPositionCondition = {};
            _distanceCondition = {};
            _relativeDistanceCondition = {};
            _relativeClearanceCondition = {};
			// set the indicator to true
            isSetStandStillCondition = true;          
        }

        void EntityConditionImpl::SetSpeedCondition(std::shared_ptr<ISpeedConditionWriter> speedCondition)
        {
            _speedCondition = speedCondition;
            _endOfRoadCondition = {};
            _collisionCondition = {};
            _offroadCondition = {};
            _timeHeadwayCondition = {};
            _timeToCollisionCondition = {};
            _accelerationCondition = {};
            _standStillCondition = {};
            _relativeSpeedCondition = {};
            _traveledDistanceCondition = {};
            _reachPositionCondition = {};
            _distanceCondition = {};
            _relativeDistanceCondition = {};
            _relativeClearanceCondition = {};
			// set the indicator to true
            isSetSpeedCondition = true;          
        }

        void EntityConditionImpl::SetRelativeSpeedCondition(std::shared_ptr<IRelativeSpeedConditionWriter> relativeSpeedCondition)
        {
            _relativeSpeedCondition = relativeSpeedCondition;
            _endOfRoadCondition = {};
            _collisionCondition = {};
            _offroadCondition = {};
            _timeHeadwayCondition = {};
            _timeToCollisionCondition = {};
            _accelerationCondition = {};
            _standStillCondition = {};
            _speedCondition = {};
            _traveledDistanceCondition = {};
            _reachPositionCondition = {};
            _distanceCondition = {};
            _relativeDistanceCondition = {};
            _relativeClearanceCondition = {};
			// set the indicator to true
            isSetRelativeSpeedCondition = true;          
        }

        void EntityConditionImpl::SetTraveledDistanceCondition(std::shared_ptr<ITraveledDistanceConditionWriter> traveledDistanceCondition)
        {
            _traveledDistanceCondition = traveledDistanceCondition;
            _endOfRoadCondition = {};
            _collisionCondition = {};
            _offroadCondition = {};
            _timeHeadwayCondition = {};
            _timeToCollisionCondition = {};
            _accelerationCondition = {};
            _standStillCondition = {};
            _speedCondition = {};
            _relativeSpeedCondition = {};
            _reachPositionCondition = {};
            _distanceCondition = {};
            _relativeDistanceCondition = {};
            _relativeClearanceCondition = {};
			// set the indicator to true
            isSetTraveledDistanceCondition = true;          
        }

        void EntityConditionImpl::SetReachPositionCondition(std::shared_ptr<IReachPositionConditionWriter> reachPositionCondition)
        {
            _reachPositionCondition = reachPositionCondition;
            _endOfRoadCondition = {};
            _collisionCondition = {};
            _offroadCondition = {};
            _timeHeadwayCondition = {};
            _timeToCollisionCondition = {};
            _accelerationCondition = {};
            _standStillCondition = {};
            _speedCondition = {};
            _relativeSpeedCondition = {};
            _traveledDistanceCondition = {};
            _distanceCondition = {};
            _relativeDistanceCondition = {};
            _relativeClearanceCondition = {};
			// set the indicator to true
            isSetReachPositionCondition = true;          
        }

        void EntityConditionImpl::SetDistanceCondition(std::shared_ptr<IDistanceConditionWriter> distanceCondition)
        {
            _distanceCondition = distanceCondition;
            _endOfRoadCondition = {};
            _collisionCondition = {};
            _offroadCondition = {};
            _timeHeadwayCondition = {};
            _timeToCollisionCondition = {};
            _accelerationCondition = {};
            _standStillCondition = {};
            _speedCondition = {};
            _relativeSpeedCondition = {};
            _traveledDistanceCondition = {};
            _reachPositionCondition = {};
            _relativeDistanceCondition = {};
            _relativeClearanceCondition = {};
			// set the indicator to true
            isSetDistanceCondition = true;          
        }

        void EntityConditionImpl::SetRelativeDistanceCondition(std::shared_ptr<IRelativeDistanceConditionWriter> relativeDistanceCondition)
        {
            _relativeDistanceCondition = relativeDistanceCondition;
            _endOfRoadCondition = {};
            _collisionCondition = {};
            _offroadCondition = {};
            _timeHeadwayCondition = {};
            _timeToCollisionCondition = {};
            _accelerationCondition = {};
            _standStillCondition = {};
            _speedCondition = {};
            _relativeSpeedCondition = {};
            _traveledDistanceCondition = {};
            _reachPositionCondition = {};
            _distanceCondition = {};
            _relativeClearanceCondition = {};
			// set the indicator to true
            isSetRelativeDistanceCondition = true;          
        }

        void EntityConditionImpl::SetRelativeClearanceCondition(std::shared_ptr<IRelativeClearanceConditionWriter> relativeClearanceCondition)
        {
            _relativeClearanceCondition = relativeClearanceCondition;
            _endOfRoadCondition = {};
            _collisionCondition = {};
            _offroadCondition = {};
            _timeHeadwayCondition = {};
            _timeToCollisionCondition = {};
            _accelerationCondition = {};
            _standStillCondition = {};
            _speedCondition = {};
            _relativeSpeedCondition = {};
            _traveledDistanceCondition = {};
            _reachPositionCondition = {};
            _distanceCondition = {};
            _relativeDistanceCondition = {};
			// set the indicator to true
            isSetRelativeClearanceCondition = true;          
        }

        std::shared_ptr<void> EntityConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(EntityConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IEntityCondition).name())
                return std::dynamic_pointer_cast<IEntityCondition>(shared_from_this());
            else if (classifier == typeid(IEntityConditionWriter).name())
                return std::dynamic_pointer_cast<IEntityConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> EntityConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t EntityConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int EntityConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double EntityConditionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t EntityConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool EntityConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime EntityConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> EntityConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string EntityConditionImpl::GetModelType() const
        {
            return "EntityCondition";
        }

            // children
        std::shared_ptr<IEndOfRoadConditionWriter> EntityConditionImpl::GetWriterEndOfRoadCondition() const
        {
            return std::dynamic_pointer_cast<IEndOfRoadConditionWriter>(_endOfRoadCondition);
        }
        std::shared_ptr<ICollisionConditionWriter> EntityConditionImpl::GetWriterCollisionCondition() const
        {
            return std::dynamic_pointer_cast<ICollisionConditionWriter>(_collisionCondition);
        }
        std::shared_ptr<IOffroadConditionWriter> EntityConditionImpl::GetWriterOffroadCondition() const
        {
            return std::dynamic_pointer_cast<IOffroadConditionWriter>(_offroadCondition);
        }
        std::shared_ptr<ITimeHeadwayConditionWriter> EntityConditionImpl::GetWriterTimeHeadwayCondition() const
        {
            return std::dynamic_pointer_cast<ITimeHeadwayConditionWriter>(_timeHeadwayCondition);
        }
        std::shared_ptr<ITimeToCollisionConditionWriter> EntityConditionImpl::GetWriterTimeToCollisionCondition() const
        {
            return std::dynamic_pointer_cast<ITimeToCollisionConditionWriter>(_timeToCollisionCondition);
        }
        std::shared_ptr<IAccelerationConditionWriter> EntityConditionImpl::GetWriterAccelerationCondition() const
        {
            return std::dynamic_pointer_cast<IAccelerationConditionWriter>(_accelerationCondition);
        }
        std::shared_ptr<IStandStillConditionWriter> EntityConditionImpl::GetWriterStandStillCondition() const
        {
            return std::dynamic_pointer_cast<IStandStillConditionWriter>(_standStillCondition);
        }
        std::shared_ptr<ISpeedConditionWriter> EntityConditionImpl::GetWriterSpeedCondition() const
        {
            return std::dynamic_pointer_cast<ISpeedConditionWriter>(_speedCondition);
        }
        std::shared_ptr<IRelativeSpeedConditionWriter> EntityConditionImpl::GetWriterRelativeSpeedCondition() const
        {
            return std::dynamic_pointer_cast<IRelativeSpeedConditionWriter>(_relativeSpeedCondition);
        }
        std::shared_ptr<ITraveledDistanceConditionWriter> EntityConditionImpl::GetWriterTraveledDistanceCondition() const
        {
            return std::dynamic_pointer_cast<ITraveledDistanceConditionWriter>(_traveledDistanceCondition);
        }
        std::shared_ptr<IReachPositionConditionWriter> EntityConditionImpl::GetWriterReachPositionCondition() const
        {
            return std::dynamic_pointer_cast<IReachPositionConditionWriter>(_reachPositionCondition);
        }
        std::shared_ptr<IDistanceConditionWriter> EntityConditionImpl::GetWriterDistanceCondition() const
        {
            return std::dynamic_pointer_cast<IDistanceConditionWriter>(_distanceCondition);
        }
        std::shared_ptr<IRelativeDistanceConditionWriter> EntityConditionImpl::GetWriterRelativeDistanceCondition() const
        {
            return std::dynamic_pointer_cast<IRelativeDistanceConditionWriter>(_relativeDistanceCondition);
        }
        std::shared_ptr<IRelativeClearanceConditionWriter> EntityConditionImpl::GetWriterRelativeClearanceCondition() const
        {
            return std::dynamic_pointer_cast<IRelativeClearanceConditionWriter>(_relativeClearanceCondition);
        }

        EntityConditionImpl::EntityConditionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void EntityConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType EntityConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EntityConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kEndOfRoadCondition =  GetWriterEndOfRoadCondition();
                if (kEndOfRoadCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEndOfRoadCondition));
                }
                const auto kCollisionCondition =  GetWriterCollisionCondition();
                if (kCollisionCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCollisionCondition));
                }
                const auto kOffroadCondition =  GetWriterOffroadCondition();
                if (kOffroadCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOffroadCondition));
                }
                const auto kTimeHeadwayCondition =  GetWriterTimeHeadwayCondition();
                if (kTimeHeadwayCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTimeHeadwayCondition));
                }
                const auto kTimeToCollisionCondition =  GetWriterTimeToCollisionCondition();
                if (kTimeToCollisionCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTimeToCollisionCondition));
                }
                const auto kAccelerationCondition =  GetWriterAccelerationCondition();
                if (kAccelerationCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAccelerationCondition));
                }
                const auto kStandStillCondition =  GetWriterStandStillCondition();
                if (kStandStillCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kStandStillCondition));
                }
                const auto kSpeedCondition =  GetWriterSpeedCondition();
                if (kSpeedCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSpeedCondition));
                }
                const auto kRelativeSpeedCondition =  GetWriterRelativeSpeedCondition();
                if (kRelativeSpeedCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeSpeedCondition));
                }
                const auto kTraveledDistanceCondition =  GetWriterTraveledDistanceCondition();
                if (kTraveledDistanceCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTraveledDistanceCondition));
                }
                const auto kReachPositionCondition =  GetWriterReachPositionCondition();
                if (kReachPositionCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kReachPositionCondition));
                }
                const auto kDistanceCondition =  GetWriterDistanceCondition();
                if (kDistanceCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDistanceCondition));
                }
                const auto kRelativeDistanceCondition =  GetWriterRelativeDistanceCondition();
                if (kRelativeDistanceCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeDistanceCondition));
                }
                const auto kRelativeClearanceCondition =  GetWriterRelativeClearanceCondition();
                if (kRelativeClearanceCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeClearanceCondition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EntityConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<EntityConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kEndOfRoadCondition =  GetWriterEndOfRoadCondition();
            if (kEndOfRoadCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<EndOfRoadConditionImpl>(kEndOfRoadCondition)->Clone();
                auto clonedChildIEndOfRoadCondition = std::dynamic_pointer_cast<IEndOfRoadCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEndOfRoadCondition(std::dynamic_pointer_cast<IEndOfRoadConditionWriter>(clonedChildIEndOfRoadCondition));
            }
            const auto kCollisionCondition =  GetWriterCollisionCondition();
            if (kCollisionCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<CollisionConditionImpl>(kCollisionCondition)->Clone();
                auto clonedChildICollisionCondition = std::dynamic_pointer_cast<ICollisionCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCollisionCondition(std::dynamic_pointer_cast<ICollisionConditionWriter>(clonedChildICollisionCondition));
            }
            const auto kOffroadCondition =  GetWriterOffroadCondition();
            if (kOffroadCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<OffroadConditionImpl>(kOffroadCondition)->Clone();
                auto clonedChildIOffroadCondition = std::dynamic_pointer_cast<IOffroadCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOffroadCondition(std::dynamic_pointer_cast<IOffroadConditionWriter>(clonedChildIOffroadCondition));
            }
            const auto kTimeHeadwayCondition =  GetWriterTimeHeadwayCondition();
            if (kTimeHeadwayCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TimeHeadwayConditionImpl>(kTimeHeadwayCondition)->Clone();
                auto clonedChildITimeHeadwayCondition = std::dynamic_pointer_cast<ITimeHeadwayCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTimeHeadwayCondition(std::dynamic_pointer_cast<ITimeHeadwayConditionWriter>(clonedChildITimeHeadwayCondition));
            }
            const auto kTimeToCollisionCondition =  GetWriterTimeToCollisionCondition();
            if (kTimeToCollisionCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TimeToCollisionConditionImpl>(kTimeToCollisionCondition)->Clone();
                auto clonedChildITimeToCollisionCondition = std::dynamic_pointer_cast<ITimeToCollisionCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTimeToCollisionCondition(std::dynamic_pointer_cast<ITimeToCollisionConditionWriter>(clonedChildITimeToCollisionCondition));
            }
            const auto kAccelerationCondition =  GetWriterAccelerationCondition();
            if (kAccelerationCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<AccelerationConditionImpl>(kAccelerationCondition)->Clone();
                auto clonedChildIAccelerationCondition = std::dynamic_pointer_cast<IAccelerationCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAccelerationCondition(std::dynamic_pointer_cast<IAccelerationConditionWriter>(clonedChildIAccelerationCondition));
            }
            const auto kStandStillCondition =  GetWriterStandStillCondition();
            if (kStandStillCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<StandStillConditionImpl>(kStandStillCondition)->Clone();
                auto clonedChildIStandStillCondition = std::dynamic_pointer_cast<IStandStillCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetStandStillCondition(std::dynamic_pointer_cast<IStandStillConditionWriter>(clonedChildIStandStillCondition));
            }
            const auto kSpeedCondition =  GetWriterSpeedCondition();
            if (kSpeedCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<SpeedConditionImpl>(kSpeedCondition)->Clone();
                auto clonedChildISpeedCondition = std::dynamic_pointer_cast<ISpeedCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSpeedCondition(std::dynamic_pointer_cast<ISpeedConditionWriter>(clonedChildISpeedCondition));
            }
            const auto kRelativeSpeedCondition =  GetWriterRelativeSpeedCondition();
            if (kRelativeSpeedCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeSpeedConditionImpl>(kRelativeSpeedCondition)->Clone();
                auto clonedChildIRelativeSpeedCondition = std::dynamic_pointer_cast<IRelativeSpeedCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeSpeedCondition(std::dynamic_pointer_cast<IRelativeSpeedConditionWriter>(clonedChildIRelativeSpeedCondition));
            }
            const auto kTraveledDistanceCondition =  GetWriterTraveledDistanceCondition();
            if (kTraveledDistanceCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TraveledDistanceConditionImpl>(kTraveledDistanceCondition)->Clone();
                auto clonedChildITraveledDistanceCondition = std::dynamic_pointer_cast<ITraveledDistanceCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTraveledDistanceCondition(std::dynamic_pointer_cast<ITraveledDistanceConditionWriter>(clonedChildITraveledDistanceCondition));
            }
            const auto kReachPositionCondition =  GetWriterReachPositionCondition();
            if (kReachPositionCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<ReachPositionConditionImpl>(kReachPositionCondition)->Clone();
                auto clonedChildIReachPositionCondition = std::dynamic_pointer_cast<IReachPositionCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetReachPositionCondition(std::dynamic_pointer_cast<IReachPositionConditionWriter>(clonedChildIReachPositionCondition));
            }
            const auto kDistanceCondition =  GetWriterDistanceCondition();
            if (kDistanceCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<DistanceConditionImpl>(kDistanceCondition)->Clone();
                auto clonedChildIDistanceCondition = std::dynamic_pointer_cast<IDistanceCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDistanceCondition(std::dynamic_pointer_cast<IDistanceConditionWriter>(clonedChildIDistanceCondition));
            }
            const auto kRelativeDistanceCondition =  GetWriterRelativeDistanceCondition();
            if (kRelativeDistanceCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeDistanceConditionImpl>(kRelativeDistanceCondition)->Clone();
                auto clonedChildIRelativeDistanceCondition = std::dynamic_pointer_cast<IRelativeDistanceCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeDistanceCondition(std::dynamic_pointer_cast<IRelativeDistanceConditionWriter>(clonedChildIRelativeDistanceCondition));
            }
            const auto kRelativeClearanceCondition =  GetWriterRelativeClearanceCondition();
            if (kRelativeClearanceCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeClearanceConditionImpl>(kRelativeClearanceCondition)->Clone();
                auto clonedChildIRelativeClearanceCondition = std::dynamic_pointer_cast<IRelativeClearanceCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeClearanceCondition(std::dynamic_pointer_cast<IRelativeClearanceConditionWriter>(clonedChildIRelativeClearanceCondition));
            }
            return clonedObject;
        }

        std::string EntityConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntityConditionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__END_OF_ROAD_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEndOfRoadCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__COLLISION_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCollisionCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__OFFROAD_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOffroadCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TIME_HEADWAY_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTimeHeadwayCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TIME_TO_COLLISION_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTimeToCollisionCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ACCELERATION_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAccelerationCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__STAND_STILL_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetStandStillCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SPEED_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSpeedCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_SPEED_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeSpeedCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAVELED_DISTANCE_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTraveledDistanceCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__REACH_POSITION_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetReachPositionCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DISTANCE_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDistanceCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_DISTANCE_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeDistanceCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_CLEARANCE_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeClearanceCondition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EntityConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntityConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string EntityConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void EntityConditionImpl::ResetEndOfRoadCondition()
	   {
	   		isSetEndOfRoadCondition = false; 
			_endOfRoadCondition = {};
			
	   }
       bool EntityConditionImpl::IsSetEndOfRoadCondition() const
	   {
			return isSetEndOfRoadCondition;
	   }
       void EntityConditionImpl::ResetCollisionCondition()
	   {
	   		isSetCollisionCondition = false; 
			_collisionCondition = {};
			
	   }
       bool EntityConditionImpl::IsSetCollisionCondition() const
	   {
			return isSetCollisionCondition;
	   }
       void EntityConditionImpl::ResetOffroadCondition()
	   {
	   		isSetOffroadCondition = false; 
			_offroadCondition = {};
			
	   }
       bool EntityConditionImpl::IsSetOffroadCondition() const
	   {
			return isSetOffroadCondition;
	   }
       void EntityConditionImpl::ResetTimeHeadwayCondition()
	   {
	   		isSetTimeHeadwayCondition = false; 
			_timeHeadwayCondition = {};
			
	   }
       bool EntityConditionImpl::IsSetTimeHeadwayCondition() const
	   {
			return isSetTimeHeadwayCondition;
	   }
       void EntityConditionImpl::ResetTimeToCollisionCondition()
	   {
	   		isSetTimeToCollisionCondition = false; 
			_timeToCollisionCondition = {};
			
	   }
       bool EntityConditionImpl::IsSetTimeToCollisionCondition() const
	   {
			return isSetTimeToCollisionCondition;
	   }
       void EntityConditionImpl::ResetAccelerationCondition()
	   {
	   		isSetAccelerationCondition = false; 
			_accelerationCondition = {};
			
	   }
       bool EntityConditionImpl::IsSetAccelerationCondition() const
	   {
			return isSetAccelerationCondition;
	   }
       void EntityConditionImpl::ResetStandStillCondition()
	   {
	   		isSetStandStillCondition = false; 
			_standStillCondition = {};
			
	   }
       bool EntityConditionImpl::IsSetStandStillCondition() const
	   {
			return isSetStandStillCondition;
	   }
       void EntityConditionImpl::ResetSpeedCondition()
	   {
	   		isSetSpeedCondition = false; 
			_speedCondition = {};
			
	   }
       bool EntityConditionImpl::IsSetSpeedCondition() const
	   {
			return isSetSpeedCondition;
	   }
       void EntityConditionImpl::ResetRelativeSpeedCondition()
	   {
	   		isSetRelativeSpeedCondition = false; 
			_relativeSpeedCondition = {};
			
	   }
       bool EntityConditionImpl::IsSetRelativeSpeedCondition() const
	   {
			return isSetRelativeSpeedCondition;
	   }
       void EntityConditionImpl::ResetTraveledDistanceCondition()
	   {
	   		isSetTraveledDistanceCondition = false; 
			_traveledDistanceCondition = {};
			
	   }
       bool EntityConditionImpl::IsSetTraveledDistanceCondition() const
	   {
			return isSetTraveledDistanceCondition;
	   }
       void EntityConditionImpl::ResetReachPositionCondition()
	   {
	   		isSetReachPositionCondition = false; 
			_reachPositionCondition = {};
			
	   }
       bool EntityConditionImpl::IsSetReachPositionCondition() const
	   {
			return isSetReachPositionCondition;
	   }
       void EntityConditionImpl::ResetDistanceCondition()
	   {
	   		isSetDistanceCondition = false; 
			_distanceCondition = {};
			
	   }
       bool EntityConditionImpl::IsSetDistanceCondition() const
	   {
			return isSetDistanceCondition;
	   }
       void EntityConditionImpl::ResetRelativeDistanceCondition()
	   {
	   		isSetRelativeDistanceCondition = false; 
			_relativeDistanceCondition = {};
			
	   }
       bool EntityConditionImpl::IsSetRelativeDistanceCondition() const
	   {
			return isSetRelativeDistanceCondition;
	   }
       void EntityConditionImpl::ResetRelativeClearanceCondition()
	   {
	   		isSetRelativeClearanceCondition = false; 
			_relativeClearanceCondition = {};
			
	   }
       bool EntityConditionImpl::IsSetRelativeClearanceCondition() const
	   {
			return isSetRelativeClearanceCondition;
	   }

        IOpenScenarioFlexElement* EntityObjectImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<ICatalogReference> EntityObjectImpl::GetCatalogReference() const
        {
        	  return _catalogReference;
        }
        std::shared_ptr<IVehicle> EntityObjectImpl::GetVehicle() const
        {
        	  return _vehicle;
        }
        std::shared_ptr<IPedestrian> EntityObjectImpl::GetPedestrian() const
        {
        	  return _pedestrian;
        }
        std::shared_ptr<IMiscObject> EntityObjectImpl::GetMiscObject() const
        {
        	  return _miscObject;
        }
        std::shared_ptr<IExternalObjectReference> EntityObjectImpl::GetExternalObjectReference() const
        {
        	  return _externalObjectReference;
        }


        void EntityObjectImpl::SetCatalogReference(std::shared_ptr<ICatalogReferenceWriter> catalogReference)
        {
            _catalogReference = catalogReference;
            _vehicle = {};
            _pedestrian = {};
            _miscObject = {};
            _externalObjectReference = {};
			// set the indicator to true
            isSetCatalogReference = true;          
        }

        void EntityObjectImpl::SetVehicle(std::shared_ptr<IVehicleWriter> vehicle)
        {
            _vehicle = vehicle;
            _catalogReference = {};
            _pedestrian = {};
            _miscObject = {};
            _externalObjectReference = {};
			// set the indicator to true
            isSetVehicle = true;          
        }

        void EntityObjectImpl::SetPedestrian(std::shared_ptr<IPedestrianWriter> pedestrian)
        {
            _pedestrian = pedestrian;
            _catalogReference = {};
            _vehicle = {};
            _miscObject = {};
            _externalObjectReference = {};
			// set the indicator to true
            isSetPedestrian = true;          
        }

        void EntityObjectImpl::SetMiscObject(std::shared_ptr<IMiscObjectWriter> miscObject)
        {
            _miscObject = miscObject;
            _catalogReference = {};
            _vehicle = {};
            _pedestrian = {};
            _externalObjectReference = {};
			// set the indicator to true
            isSetMiscObject = true;          
        }

        void EntityObjectImpl::SetExternalObjectReference(std::shared_ptr<IExternalObjectReferenceWriter> externalObjectReference)
        {
            _externalObjectReference = externalObjectReference;
            _catalogReference = {};
            _vehicle = {};
            _pedestrian = {};
            _miscObject = {};
			// set the indicator to true
            isSetExternalObjectReference = true;          
        }

        std::shared_ptr<void> EntityObjectImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(EntityObjectImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IEntityObject).name())
                return std::dynamic_pointer_cast<IEntityObject>(shared_from_this());
            else if (classifier == typeid(IEntityObjectWriter).name())
                return std::dynamic_pointer_cast<IEntityObjectWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> EntityObjectImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t EntityObjectImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int EntityObjectImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double EntityObjectImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t EntityObjectImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool EntityObjectImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime EntityObjectImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> EntityObjectImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string EntityObjectImpl::GetModelType() const
        {
            return "EntityObject";
        }

            // children
        std::shared_ptr<ICatalogReferenceWriter> EntityObjectImpl::GetWriterCatalogReference() const
        {
            return std::dynamic_pointer_cast<ICatalogReferenceWriter>(_catalogReference);
        }
        std::shared_ptr<IVehicleWriter> EntityObjectImpl::GetWriterVehicle() const
        {
            return std::dynamic_pointer_cast<IVehicleWriter>(_vehicle);
        }
        std::shared_ptr<IPedestrianWriter> EntityObjectImpl::GetWriterPedestrian() const
        {
            return std::dynamic_pointer_cast<IPedestrianWriter>(_pedestrian);
        }
        std::shared_ptr<IMiscObjectWriter> EntityObjectImpl::GetWriterMiscObject() const
        {
            return std::dynamic_pointer_cast<IMiscObjectWriter>(_miscObject);
        }
        std::shared_ptr<IExternalObjectReferenceWriter> EntityObjectImpl::GetWriterExternalObjectReference() const
        {
            return std::dynamic_pointer_cast<IExternalObjectReferenceWriter>(_externalObjectReference);
        }

        EntityObjectImpl::EntityObjectImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void EntityObjectImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType EntityObjectImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EntityObjectImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kCatalogReference =  GetWriterCatalogReference();
                if (kCatalogReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogReference));
                }
                const auto kVehicle =  GetWriterVehicle();
                if (kVehicle)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kVehicle));
                }
                const auto kPedestrian =  GetWriterPedestrian();
                if (kPedestrian)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPedestrian));
                }
                const auto kMiscObject =  GetWriterMiscObject();
                if (kMiscObject)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kMiscObject));
                }
                const auto kExternalObjectReference =  GetWriterExternalObjectReference();
                if (kExternalObjectReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kExternalObjectReference));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EntityObjectImpl::Clone()
        {
            auto clonedObject = std::make_shared<EntityObjectImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kCatalogReference =  GetWriterCatalogReference();
            if (kCatalogReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kCatalogReference)->Clone();
                auto clonedChildICatalogReference = std::dynamic_pointer_cast<ICatalogReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogReference(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChildICatalogReference));
            }
            const auto kVehicle =  GetWriterVehicle();
            if (kVehicle)
            {
                auto clonedChild = std::dynamic_pointer_cast<VehicleImpl>(kVehicle)->Clone();
                auto clonedChildIVehicle = std::dynamic_pointer_cast<IVehicle>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetVehicle(std::dynamic_pointer_cast<IVehicleWriter>(clonedChildIVehicle));
            }
            const auto kPedestrian =  GetWriterPedestrian();
            if (kPedestrian)
            {
                auto clonedChild = std::dynamic_pointer_cast<PedestrianImpl>(kPedestrian)->Clone();
                auto clonedChildIPedestrian = std::dynamic_pointer_cast<IPedestrian>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPedestrian(std::dynamic_pointer_cast<IPedestrianWriter>(clonedChildIPedestrian));
            }
            const auto kMiscObject =  GetWriterMiscObject();
            if (kMiscObject)
            {
                auto clonedChild = std::dynamic_pointer_cast<MiscObjectImpl>(kMiscObject)->Clone();
                auto clonedChildIMiscObject = std::dynamic_pointer_cast<IMiscObject>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetMiscObject(std::dynamic_pointer_cast<IMiscObjectWriter>(clonedChildIMiscObject));
            }
            const auto kExternalObjectReference =  GetWriterExternalObjectReference();
            if (kExternalObjectReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<ExternalObjectReferenceImpl>(kExternalObjectReference)->Clone();
                auto clonedChildIExternalObjectReference = std::dynamic_pointer_cast<IExternalObjectReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetExternalObjectReference(std::dynamic_pointer_cast<IExternalObjectReferenceWriter>(clonedChildIExternalObjectReference));
            }
            return clonedObject;
        }

        std::string EntityObjectImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntityObjectImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogReference());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__VEHICLE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetVehicle());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PEDESTRIAN)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPedestrian());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__MISC_OBJECT)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetMiscObject());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__EXTERNAL_OBJECT_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetExternalObjectReference());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EntityObjectImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntityObjectImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string EntityObjectImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void EntityObjectImpl::ResetCatalogReference()
	   {
	   		isSetCatalogReference = false; 
			_catalogReference = {};
			
	   }
       bool EntityObjectImpl::IsSetCatalogReference() const
	   {
			return isSetCatalogReference;
	   }
       void EntityObjectImpl::ResetVehicle()
	   {
	   		isSetVehicle = false; 
			_vehicle = {};
			
	   }
       bool EntityObjectImpl::IsSetVehicle() const
	   {
			return isSetVehicle;
	   }
       void EntityObjectImpl::ResetPedestrian()
	   {
	   		isSetPedestrian = false; 
			_pedestrian = {};
			
	   }
       bool EntityObjectImpl::IsSetPedestrian() const
	   {
			return isSetPedestrian;
	   }
       void EntityObjectImpl::ResetMiscObject()
	   {
	   		isSetMiscObject = false; 
			_miscObject = {};
			
	   }
       bool EntityObjectImpl::IsSetMiscObject() const
	   {
			return isSetMiscObject;
	   }
       void EntityObjectImpl::ResetExternalObjectReference()
	   {
	   		isSetExternalObjectReference = false; 
			_externalObjectReference = {};
			
	   }
       bool EntityObjectImpl::IsSetExternalObjectReference() const
	   {
			return isSetExternalObjectReference;
	   }

        IOpenScenarioFlexElement* EntityRefImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<INamedReference<IEntity>> EntityRefImpl::GetEntityRef() const
        {
        	 return _entityRef;
        }


        void EntityRefImpl::SetEntityRef(std::shared_ptr<INamedReference<IEntity>> entityRef)
        {
            _entityRef = entityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
        }

        std::shared_ptr<void> EntityRefImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(EntityRefImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IEntityRef).name())
                return std::dynamic_pointer_cast<IEntityRef>(shared_from_this());
            else if (classifier == typeid(IEntityRefWriter).name())
                return std::dynamic_pointer_cast<IEntityRefWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> EntityRefImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t EntityRefImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int EntityRefImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double EntityRefImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t EntityRefImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool EntityRefImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime EntityRefImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> EntityRefImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string EntityRefImpl::GetModelType() const
        {
            return "EntityRef";
        }

        void EntityRefImpl::WriteParameterToEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _entityRef = {};
        }

        std::string EntityRefImpl::GetParameterFromEntityRef() const
        {
            auto entityRef = OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF;
            return GetParameterNameFromAttribute(entityRef);
        }

        bool EntityRefImpl::IsEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        EntityRefImpl::EntityRefImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
        }

        void EntityRefImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType EntityRefImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EntityRefImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EntityRefImpl::Clone()
        {
            auto clonedObject = std::make_shared<EntityRefImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string EntityRefImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntityRefImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EntityRefImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntityRefImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string EntityRefImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* EntitySelectionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string EntitySelectionImpl::GetName() const
        {
        	  return _name;
        }
        std::shared_ptr<ISelectedEntities> EntitySelectionImpl::GetMembers() const
        {
        	  return _members;
        }


        void EntitySelectionImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void EntitySelectionImpl::SetMembers(std::shared_ptr<ISelectedEntitiesWriter> members)
        {
            _members = members;
        }

        std::shared_ptr<void> EntitySelectionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(EntitySelectionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IEntitySelection).name())
                return std::dynamic_pointer_cast<IEntitySelection>(shared_from_this());
            else if (classifier == typeid(IEntitySelectionWriter).name())
                return std::dynamic_pointer_cast<IEntitySelectionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> EntitySelectionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t EntitySelectionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int EntitySelectionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double EntitySelectionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t EntitySelectionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool EntitySelectionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime EntitySelectionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> EntitySelectionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string EntitySelectionImpl::GetModelType() const
        {
            return "EntitySelection";
        }

        void EntitySelectionImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        std::string EntitySelectionImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        bool EntitySelectionImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<ISelectedEntitiesWriter> EntitySelectionImpl::GetWriterMembers() const
        {
            return std::dynamic_pointer_cast<ISelectedEntitiesWriter>(_members);
        }

        EntitySelectionImpl::EntitySelectionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        void EntitySelectionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType EntitySelectionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EntitySelectionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kMembers =  GetWriterMembers();
                if (kMembers)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kMembers));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EntitySelectionImpl::Clone()
        {
            auto clonedObject = std::make_shared<EntitySelectionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone indicators
            // clone children
            const auto kMembers =  GetWriterMembers();
            if (kMembers)
            {
                auto clonedChild = std::dynamic_pointer_cast<SelectedEntitiesImpl>(kMembers)->Clone();
                auto clonedChildISelectedEntities = std::dynamic_pointer_cast<ISelectedEntities>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetMembers(std::dynamic_pointer_cast<ISelectedEntitiesWriter>(clonedChildISelectedEntities));
            }
            return clonedObject;
        }

        std::string EntitySelectionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntitySelectionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__MEMBERS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetMembers());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EntitySelectionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntitySelectionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string EntitySelectionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void EntitySelectionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* EnvironmentImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string EnvironmentImpl::GetName() const
        {
        	  return _name;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> EnvironmentImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IParameterDeclarationWriter>> EnvironmentImpl::GetWriterParameterDeclarations() const
        {
            return _parameterDeclarations;
        }

        int EnvironmentImpl::GetParameterDeclarationsSize() const
        {
            return static_cast<int>(_parameterDeclarations.size());
        }

        std::shared_ptr<IParameterDeclaration> EnvironmentImpl::GetParameterDeclarationsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _parameterDeclarations.size() > index)
            {
                return _parameterDeclarations[index];
            }
            return nullptr;
        }
        std::shared_ptr<ITimeOfDay> EnvironmentImpl::GetTimeOfDay() const
        {
        	  return _timeOfDay;
        }
        std::shared_ptr<IWeather> EnvironmentImpl::GetWeather() const
        {
        	  return _weather;
        }
        std::shared_ptr<IRoadCondition> EnvironmentImpl::GetRoadCondition() const
        {
        	  return _roadCondition;
        }


        void EnvironmentImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void EnvironmentImpl::SetParameterDeclarations(std::vector<std::shared_ptr<IParameterDeclarationWriter>>& parameterDeclarations)
        {
            _parameterDeclarations = parameterDeclarations;
			// set the indicator to true
            isSetParameterDeclarations = true;          
        }

        void EnvironmentImpl::SetTimeOfDay(std::shared_ptr<ITimeOfDayWriter> timeOfDay)
        {
            _timeOfDay = timeOfDay;
			// set the indicator to true
            isSetTimeOfDay = true;          
        }

        void EnvironmentImpl::SetWeather(std::shared_ptr<IWeatherWriter> weather)
        {
            _weather = weather;
			// set the indicator to true
            isSetWeather = true;          
        }

        void EnvironmentImpl::SetRoadCondition(std::shared_ptr<IRoadConditionWriter> roadCondition)
        {
            _roadCondition = roadCondition;
			// set the indicator to true
            isSetRoadCondition = true;          
        }

        std::shared_ptr<void> EnvironmentImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(EnvironmentImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IEnvironment).name())
                return std::dynamic_pointer_cast<IEnvironment>(shared_from_this());
            else if (classifier == typeid(IEnvironmentWriter).name())
                return std::dynamic_pointer_cast<IEnvironmentWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> EnvironmentImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t EnvironmentImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int EnvironmentImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double EnvironmentImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t EnvironmentImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool EnvironmentImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime EnvironmentImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> EnvironmentImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string EnvironmentImpl::GetModelType() const
        {
            return "Environment";
        }

        void EnvironmentImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        std::string EnvironmentImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        bool EnvironmentImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<ITimeOfDayWriter> EnvironmentImpl::GetWriterTimeOfDay() const
        {
            return std::dynamic_pointer_cast<ITimeOfDayWriter>(_timeOfDay);
        }
        std::shared_ptr<IWeatherWriter> EnvironmentImpl::GetWriterWeather() const
        {
            return std::dynamic_pointer_cast<IWeatherWriter>(_weather);
        }
        std::shared_ptr<IRoadConditionWriter> EnvironmentImpl::GetWriterRoadCondition() const
        {
            return std::dynamic_pointer_cast<IRoadConditionWriter>(_roadCondition);
        }

        EnvironmentImpl::EnvironmentImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        void EnvironmentImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType EnvironmentImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool EnvironmentImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> EnvironmentImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EnvironmentImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kTimeOfDay =  GetWriterTimeOfDay();
                if (kTimeOfDay)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTimeOfDay));
                }
                const auto kWeather =  GetWriterWeather();
                if (kWeather)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kWeather));
                }
                const auto kRoadCondition =  GetWriterRoadCondition();
                if (kRoadCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRoadCondition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EnvironmentImpl::Clone()
        {
            auto clonedObject = std::make_shared<EnvironmentImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone indicators
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kTimeOfDay =  GetWriterTimeOfDay();
            if (kTimeOfDay)
            {
                auto clonedChild = std::dynamic_pointer_cast<TimeOfDayImpl>(kTimeOfDay)->Clone();
                auto clonedChildITimeOfDay = std::dynamic_pointer_cast<ITimeOfDay>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTimeOfDay(std::dynamic_pointer_cast<ITimeOfDayWriter>(clonedChildITimeOfDay));
            }
            const auto kWeather =  GetWriterWeather();
            if (kWeather)
            {
                auto clonedChild = std::dynamic_pointer_cast<WeatherImpl>(kWeather)->Clone();
                auto clonedChildIWeather = std::dynamic_pointer_cast<IWeather>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetWeather(std::dynamic_pointer_cast<IWeatherWriter>(clonedChildIWeather));
            }
            const auto kRoadCondition =  GetWriterRoadCondition();
            if (kRoadCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RoadConditionImpl>(kRoadCondition)->Clone();
                auto clonedChildIRoadCondition = std::dynamic_pointer_cast<IRoadCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRoadCondition(std::dynamic_pointer_cast<IRoadConditionWriter>(clonedChildIRoadCondition));
            }
            return clonedObject;
        }

        std::string EnvironmentImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EnvironmentImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TIME_OF_DAY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTimeOfDay());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__WEATHER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetWeather());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ROAD_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRoadCondition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EnvironmentImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EnvironmentImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string EnvironmentImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void EnvironmentImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void EnvironmentImpl::ResetParameterDeclarations()
	   {
	   		isSetParameterDeclarations = false; 
			_parameterDeclarations = {};
			
	   }
       bool EnvironmentImpl::IsSetParameterDeclarations() const
	   {
			return isSetParameterDeclarations;
	   }
       void EnvironmentImpl::ResetTimeOfDay()
	   {
	   		isSetTimeOfDay = false; 
			_timeOfDay = {};
			
	   }
       bool EnvironmentImpl::IsSetTimeOfDay() const
	   {
			return isSetTimeOfDay;
	   }
       void EnvironmentImpl::ResetWeather()
	   {
	   		isSetWeather = false; 
			_weather = {};
			
	   }
       bool EnvironmentImpl::IsSetWeather() const
	   {
			return isSetWeather;
	   }
       void EnvironmentImpl::ResetRoadCondition()
	   {
	   		isSetRoadCondition = false; 
			_roadCondition = {};
			
	   }
       bool EnvironmentImpl::IsSetRoadCondition() const
	   {
			return isSetRoadCondition;
	   }

        IOpenScenarioFlexElement* EnvironmentActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IEnvironment> EnvironmentActionImpl::GetEnvironment() const
        {
        	  return _environment;
        }
        std::shared_ptr<ICatalogReference> EnvironmentActionImpl::GetCatalogReference() const
        {
        	  return _catalogReference;
        }


        void EnvironmentActionImpl::SetEnvironment(std::shared_ptr<IEnvironmentWriter> environment)
        {
            _environment = environment;
            _catalogReference = {};
			// set the indicator to true
            isSetEnvironment = true;          
        }

        void EnvironmentActionImpl::SetCatalogReference(std::shared_ptr<ICatalogReferenceWriter> catalogReference)
        {
            _catalogReference = catalogReference;
            _environment = {};
			// set the indicator to true
            isSetCatalogReference = true;          
        }

        std::shared_ptr<void> EnvironmentActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(EnvironmentActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IEnvironmentAction).name())
                return std::dynamic_pointer_cast<IEnvironmentAction>(shared_from_this());
            else if (classifier == typeid(IEnvironmentActionWriter).name())
                return std::dynamic_pointer_cast<IEnvironmentActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> EnvironmentActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t EnvironmentActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int EnvironmentActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double EnvironmentActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t EnvironmentActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool EnvironmentActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime EnvironmentActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> EnvironmentActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string EnvironmentActionImpl::GetModelType() const
        {
            return "EnvironmentAction";
        }

            // children
        std::shared_ptr<IEnvironmentWriter> EnvironmentActionImpl::GetWriterEnvironment() const
        {
            return std::dynamic_pointer_cast<IEnvironmentWriter>(_environment);
        }
        std::shared_ptr<ICatalogReferenceWriter> EnvironmentActionImpl::GetWriterCatalogReference() const
        {
            return std::dynamic_pointer_cast<ICatalogReferenceWriter>(_catalogReference);
        }

        EnvironmentActionImpl::EnvironmentActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void EnvironmentActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType EnvironmentActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EnvironmentActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kEnvironment =  GetWriterEnvironment();
                if (kEnvironment)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEnvironment));
                }
                const auto kCatalogReference =  GetWriterCatalogReference();
                if (kCatalogReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogReference));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EnvironmentActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<EnvironmentActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kEnvironment =  GetWriterEnvironment();
            if (kEnvironment)
            {
                auto clonedChild = std::dynamic_pointer_cast<EnvironmentImpl>(kEnvironment)->Clone();
                auto clonedChildIEnvironment = std::dynamic_pointer_cast<IEnvironment>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEnvironment(std::dynamic_pointer_cast<IEnvironmentWriter>(clonedChildIEnvironment));
            }
            const auto kCatalogReference =  GetWriterCatalogReference();
            if (kCatalogReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kCatalogReference)->Clone();
                auto clonedChildICatalogReference = std::dynamic_pointer_cast<ICatalogReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogReference(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChildICatalogReference));
            }
            return clonedObject;
        }

        std::string EnvironmentActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EnvironmentActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ENVIRONMENT)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEnvironment());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogReference());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EnvironmentActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EnvironmentActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string EnvironmentActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void EnvironmentActionImpl::ResetEnvironment()
	   {
	   		isSetEnvironment = false; 
			_environment = {};
			
	   }
       bool EnvironmentActionImpl::IsSetEnvironment() const
	   {
			return isSetEnvironment;
	   }
       void EnvironmentActionImpl::ResetCatalogReference()
	   {
	   		isSetCatalogReference = false; 
			_catalogReference = {};
			
	   }
       bool EnvironmentActionImpl::IsSetCatalogReference() const
	   {
			return isSetCatalogReference;
	   }

        IOpenScenarioFlexElement* EnvironmentCatalogLocationImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IDirectory> EnvironmentCatalogLocationImpl::GetDirectory() const
        {
        	  return _directory;
        }


        void EnvironmentCatalogLocationImpl::SetDirectory(std::shared_ptr<IDirectoryWriter> directory)
        {
            _directory = directory;
        }

        std::shared_ptr<void> EnvironmentCatalogLocationImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(EnvironmentCatalogLocationImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IEnvironmentCatalogLocation).name())
                return std::dynamic_pointer_cast<IEnvironmentCatalogLocation>(shared_from_this());
            else if (classifier == typeid(IEnvironmentCatalogLocationWriter).name())
                return std::dynamic_pointer_cast<IEnvironmentCatalogLocationWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> EnvironmentCatalogLocationImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t EnvironmentCatalogLocationImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int EnvironmentCatalogLocationImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double EnvironmentCatalogLocationImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t EnvironmentCatalogLocationImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool EnvironmentCatalogLocationImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime EnvironmentCatalogLocationImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> EnvironmentCatalogLocationImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string EnvironmentCatalogLocationImpl::GetModelType() const
        {
            return "EnvironmentCatalogLocation";
        }

            // children
        std::shared_ptr<IDirectoryWriter> EnvironmentCatalogLocationImpl::GetWriterDirectory() const
        {
            return std::dynamic_pointer_cast<IDirectoryWriter>(_directory);
        }

        EnvironmentCatalogLocationImpl::EnvironmentCatalogLocationImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void EnvironmentCatalogLocationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType EnvironmentCatalogLocationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EnvironmentCatalogLocationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDirectory =  GetWriterDirectory();
                if (kDirectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDirectory));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EnvironmentCatalogLocationImpl::Clone()
        {
            auto clonedObject = std::make_shared<EnvironmentCatalogLocationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kDirectory =  GetWriterDirectory();
            if (kDirectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<DirectoryImpl>(kDirectory)->Clone();
                auto clonedChildIDirectory = std::dynamic_pointer_cast<IDirectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDirectory(std::dynamic_pointer_cast<IDirectoryWriter>(clonedChildIDirectory));
            }
            return clonedObject;
        }

        std::string EnvironmentCatalogLocationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EnvironmentCatalogLocationImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIRECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDirectory());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EnvironmentCatalogLocationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EnvironmentCatalogLocationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string EnvironmentCatalogLocationImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* EventImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        uint32_t EventImpl::GetMaximumExecutionCount() const
        {
        	  return _maximumExecutionCount;
        }
        std::string EventImpl::GetName() const
        {
        	  return _name;
        }
        Priority EventImpl::GetPriority() const
        {
        	  return _priority;
        }
        std::vector<std::shared_ptr<IAction>> EventImpl::GetActions() const
        {
            std::vector<std::shared_ptr<IAction>> temp;
            for(auto&& elm: _actions)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IActionWriter>> EventImpl::GetWriterActions() const
        {
            return _actions;
        }

        int EventImpl::GetActionsSize() const
        {
            return static_cast<int>(_actions.size());
        }

        std::shared_ptr<IAction> EventImpl::GetActionsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _actions.size() > index)
            {
                return _actions[index];
            }
            return nullptr;
        }
        std::shared_ptr<ITrigger> EventImpl::GetStartTrigger() const
        {
        	  return _startTrigger;
        }


        void EventImpl::SetMaximumExecutionCount(const uint32_t maximumExecutionCount)
        {
            _maximumExecutionCount = maximumExecutionCount;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT);
			// set the indicator to true
            isSetMaximumExecutionCount = true;          
        }

        void EventImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void EventImpl::SetPriority(const Priority priority)
        {
            _priority = priority;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PRIORITY);
        }

        void EventImpl::SetActions(std::vector<std::shared_ptr<IActionWriter>>& actions)
        {
            _actions = actions;
        }

        void EventImpl::SetStartTrigger(std::shared_ptr<ITriggerWriter> startTrigger)
        {
            _startTrigger = startTrigger;
			// set the indicator to true
            isSetStartTrigger = true;          
        }

        std::shared_ptr<void> EventImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(EventImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IEvent).name())
                return std::dynamic_pointer_cast<IEvent>(shared_from_this());
            else if (classifier == typeid(IEventWriter).name())
                return std::dynamic_pointer_cast<IEventWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> EventImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t EventImpl::GetUnsignedIntProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT)
                {
                    return GetMaximumExecutionCount();
                }
                throw KeyNotSupportedException();

        }

        int EventImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double EventImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t EventImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool EventImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime EventImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> EventImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string EventImpl::GetModelType() const
        {
            return "Event";
        }

        void EventImpl::WriteParameterToMaximumExecutionCount(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT, parameterName, nullTextMarker /*no textmarker*/);
            _maximumExecutionCount = {};
        }

        void EventImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        void EventImpl::WriteParameterToPriority(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PRIORITY, parameterName, nullTextMarker /*no textmarker*/);
            _priority = {};
        }

        std::string EventImpl::GetParameterFromMaximumExecutionCount() const
        {
            auto maximumExecutionCount = OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT;
            return GetParameterNameFromAttribute(maximumExecutionCount);
        }

        std::string EventImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        std::string EventImpl::GetParameterFromPriority() const
        {
            auto priority = OSC_CONSTANTS::ATTRIBUTE__PRIORITY;
            return GetParameterNameFromAttribute(priority);
        }

        bool EventImpl::IsMaximumExecutionCountParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool EventImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool EventImpl::IsPriorityParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__PRIORITY);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<ITriggerWriter> EventImpl::GetWriterStartTrigger() const
        {
            return std::dynamic_pointer_cast<ITriggerWriter>(_startTrigger);
        }

        EventImpl::EventImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT, SimpleType::UNSIGNED_INT);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PRIORITY, SimpleType::ENUM_TYPE);
        }

        void EventImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT)
            {
                // Simple type
                _maximumExecutionCount = ParserHelper::ParseUnsignedInt(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PRIORITY)
            {
                // Enumeration Type
                const auto kResult = Priority::GetFromLiteral(parameterLiteralValue);
                if (kResult != Priority::UNKNOWN)
                {
                    _priority = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType EventImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EventImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto actions =  GetWriterActions();
                if (!actions.empty())
                {
                    for(auto&& item : actions)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kStartTrigger =  GetWriterStartTrigger();
                if (kStartTrigger)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kStartTrigger));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EventImpl::Clone()
        {
            auto clonedObject = std::make_shared<EventImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_maximumExecutionCount = GetMaximumExecutionCount();
            // Simple type
            clonedObject->_name = GetName();
            // Enumeration Type
            const auto kPriority = GetPriority();
            if ( kPriority.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_priority = Priority::GetFromLiteral(kPriority.GetLiteral());
            }
            // clone indicators
            	clonedObject->isSetMaximumExecutionCount = isSetMaximumExecutionCount;
            // clone children
            const auto kActions =  GetWriterActions();
            if (!kActions.empty())
            {
                std::vector<std::shared_ptr<IActionWriter>> clonedList;
                for(auto&& kItem : kActions)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ActionImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IActionWriter>(clonedChild));
                }
                clonedObject->SetActions(clonedList);
            }
            const auto kStartTrigger =  GetWriterStartTrigger();
            if (kStartTrigger)
            {
                auto clonedChild = std::dynamic_pointer_cast<TriggerImpl>(kStartTrigger)->Clone();
                auto clonedChildITrigger = std::dynamic_pointer_cast<ITrigger>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetStartTrigger(std::dynamic_pointer_cast<ITriggerWriter>(clonedChildITrigger));
            }
            return clonedObject;
        }

        std::string EventImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EventImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__START_TRIGGER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetStartTrigger());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EventImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__ACTION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetActions())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EventImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string EventImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PRIORITY)
            {
                auto priority = GetPriority();
                return priority.GetLiteral() != "UNKNOWN" ? priority.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void EventImpl::ResolveUnsignedIntExpression(std::string& attributeKey, unsigned int& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT)
            {
                // Simple type
                _maximumExecutionCount = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void EventImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void EventImpl::ResetMaximumExecutionCount()
	   {
	   		isSetMaximumExecutionCount = false; 
			_maximumExecutionCount = {1};
			
	   }
       bool EventImpl::IsSetMaximumExecutionCount() const
	   {
			return isSetMaximumExecutionCount;
	   }
       void EventImpl::ResetStartTrigger()
	   {
	   		isSetStartTrigger = false; 
			_startTrigger = {};
			
	   }
       bool EventImpl::IsSetStartTrigger() const
	   {
			return isSetStartTrigger;
	   }

        IOpenScenarioFlexElement* ExternalObjectReferenceImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string ExternalObjectReferenceImpl::GetName() const
        {
        	  return _name;
        }


        void ExternalObjectReferenceImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        std::shared_ptr<void> ExternalObjectReferenceImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ExternalObjectReferenceImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IExternalObjectReference).name())
                return std::dynamic_pointer_cast<IExternalObjectReference>(shared_from_this());
            else if (classifier == typeid(IExternalObjectReferenceWriter).name())
                return std::dynamic_pointer_cast<IExternalObjectReferenceWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ExternalObjectReferenceImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ExternalObjectReferenceImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ExternalObjectReferenceImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ExternalObjectReferenceImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ExternalObjectReferenceImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ExternalObjectReferenceImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ExternalObjectReferenceImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ExternalObjectReferenceImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ExternalObjectReferenceImpl::GetModelType() const
        {
            return "ExternalObjectReference";
        }

        void ExternalObjectReferenceImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        std::string ExternalObjectReferenceImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        bool ExternalObjectReferenceImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        ExternalObjectReferenceImpl::ExternalObjectReferenceImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        void ExternalObjectReferenceImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ExternalObjectReferenceImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ExternalObjectReferenceImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ExternalObjectReferenceImpl::Clone()
        {
            auto clonedObject = std::make_shared<ExternalObjectReferenceImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string ExternalObjectReferenceImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ExternalObjectReferenceImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ExternalObjectReferenceImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ExternalObjectReferenceImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ExternalObjectReferenceImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ExternalObjectReferenceImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* FileImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string FileImpl::GetFilepath() const
        {
        	  return _filepath;
        }


        void FileImpl::SetFilepath(const std::string filepath)
        {
            _filepath = filepath;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FILEPATH);
        }

        std::shared_ptr<void> FileImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(FileImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IFile).name())
                return std::dynamic_pointer_cast<IFile>(shared_from_this());
            else if (classifier == typeid(IFileWriter).name())
                return std::dynamic_pointer_cast<IFileWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> FileImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t FileImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int FileImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double FileImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t FileImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool FileImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime FileImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> FileImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string FileImpl::GetModelType() const
        {
            return "File";
        }

        void FileImpl::WriteParameterToFilepath(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FILEPATH, parameterName, nullTextMarker /*no textmarker*/);
            _filepath = {};
        }

        std::string FileImpl::GetParameterFromFilepath() const
        {
            auto filepath = OSC_CONSTANTS::ATTRIBUTE__FILEPATH;
            return GetParameterNameFromAttribute(filepath);
        }

        bool FileImpl::IsFilepathParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__FILEPATH);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        FileImpl::FileImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FILEPATH, SimpleType::STRING);
        }

        void FileImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FILEPATH)
            {
                // Simple type
                _filepath = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType FileImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> FileImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> FileImpl::Clone()
        {
            auto clonedObject = std::make_shared<FileImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_filepath = GetFilepath();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string FileImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__FILEPATH)
            {
                return GetFilepath();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FileImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> FileImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FileImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string FileImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void FileImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FILEPATH)
            {
                // Simple type
                _filepath = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* FileHeaderImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string FileHeaderImpl::GetAuthor() const
        {
        	  return _author;
        }
        DateTime FileHeaderImpl::GetDate() const
        {
        	  return _date;
        }
        std::string FileHeaderImpl::GetDescription() const
        {
        	  return _description;
        }
        uint16_t FileHeaderImpl::GetRevMajor() const
        {
        	  return _revMajor;
        }
        uint16_t FileHeaderImpl::GetRevMinor() const
        {
        	  return _revMinor;
        }
        std::shared_ptr<ILicense> FileHeaderImpl::GetLicense() const
        {
        	  return _license;
        }
        std::shared_ptr<IProperties> FileHeaderImpl::GetProperties() const
        {
        	  return _properties;
        }


        void FileHeaderImpl::SetAuthor(const std::string author)
        {
            _author = author;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__AUTHOR);
        }

        void FileHeaderImpl::SetDate(const DateTime date)
        {
            _date = date;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DATE);
        }

        void FileHeaderImpl::SetDescription(const std::string description)
        {
            _description = description;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DESCRIPTION);
        }

        void FileHeaderImpl::SetRevMajor(const uint16_t revMajor)
        {
            _revMajor = revMajor;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__REV_MAJOR);
        }

        void FileHeaderImpl::SetRevMinor(const uint16_t revMinor)
        {
            _revMinor = revMinor;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__REV_MINOR);
        }

        void FileHeaderImpl::SetLicense(std::shared_ptr<ILicenseWriter> license)
        {
            _license = license;
			// set the indicator to true
            isSetLicense = true;          
        }

        void FileHeaderImpl::SetProperties(std::shared_ptr<IPropertiesWriter> properties)
        {
            _properties = properties;
			// set the indicator to true
            isSetProperties = true;          
        }

        std::shared_ptr<void> FileHeaderImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(FileHeaderImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IFileHeader).name())
                return std::dynamic_pointer_cast<IFileHeader>(shared_from_this());
            else if (classifier == typeid(IFileHeaderWriter).name())
                return std::dynamic_pointer_cast<IFileHeaderWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> FileHeaderImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t FileHeaderImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int FileHeaderImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double FileHeaderImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t FileHeaderImpl::GetUnsignedShortProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__REV_MAJOR)
                {
                    return GetRevMajor();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__REV_MINOR)
                {
                    return GetRevMinor();
                }
                throw KeyNotSupportedException();

            }
 
            bool FileHeaderImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime FileHeaderImpl::GetDateTimeProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__DATE)
                {
                    return GetDate();
                }
                throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> FileHeaderImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string FileHeaderImpl::GetModelType() const
        {
            return "FileHeader";
        }

        void FileHeaderImpl::WriteParameterToAuthor(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__AUTHOR, parameterName, nullTextMarker /*no textmarker*/);
            _author = {};
        }

        void FileHeaderImpl::WriteParameterToDate(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DATE, parameterName, nullTextMarker /*no textmarker*/);
            _date = {};
        }

        void FileHeaderImpl::WriteParameterToDescription(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DESCRIPTION, parameterName, nullTextMarker /*no textmarker*/);
            _description = {};
        }

        void FileHeaderImpl::WriteParameterToRevMajor(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__REV_MAJOR, parameterName, nullTextMarker /*no textmarker*/);
            _revMajor = {};
        }

        void FileHeaderImpl::WriteParameterToRevMinor(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__REV_MINOR, parameterName, nullTextMarker /*no textmarker*/);
            _revMinor = {};
        }

        std::string FileHeaderImpl::GetParameterFromAuthor() const
        {
            auto author = OSC_CONSTANTS::ATTRIBUTE__AUTHOR;
            return GetParameterNameFromAttribute(author);
        }

        std::string FileHeaderImpl::GetParameterFromDate() const
        {
            auto date = OSC_CONSTANTS::ATTRIBUTE__DATE;
            return GetParameterNameFromAttribute(date);
        }

        std::string FileHeaderImpl::GetParameterFromDescription() const
        {
            auto description = OSC_CONSTANTS::ATTRIBUTE__DESCRIPTION;
            return GetParameterNameFromAttribute(description);
        }

        std::string FileHeaderImpl::GetParameterFromRevMajor() const
        {
            auto revMajor = OSC_CONSTANTS::ATTRIBUTE__REV_MAJOR;
            return GetParameterNameFromAttribute(revMajor);
        }

        std::string FileHeaderImpl::GetParameterFromRevMinor() const
        {
            auto revMinor = OSC_CONSTANTS::ATTRIBUTE__REV_MINOR;
            return GetParameterNameFromAttribute(revMinor);
        }

        bool FileHeaderImpl::IsAuthorParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__AUTHOR);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool FileHeaderImpl::IsDateParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DATE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool FileHeaderImpl::IsDescriptionParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DESCRIPTION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool FileHeaderImpl::IsRevMajorParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__REV_MAJOR);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool FileHeaderImpl::IsRevMinorParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__REV_MINOR);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<ILicenseWriter> FileHeaderImpl::GetWriterLicense() const
        {
            return std::dynamic_pointer_cast<ILicenseWriter>(_license);
        }
        std::shared_ptr<IPropertiesWriter> FileHeaderImpl::GetWriterProperties() const
        {
            return std::dynamic_pointer_cast<IPropertiesWriter>(_properties);
        }

        FileHeaderImpl::FileHeaderImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__AUTHOR, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DATE, SimpleType::DATE_TIME);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DESCRIPTION, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__REV_MAJOR, SimpleType::UNSIGNED_SHORT);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__REV_MINOR, SimpleType::UNSIGNED_SHORT);
        }

        void FileHeaderImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__AUTHOR)
            {
                // Simple type
                _author = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DATE)
            {
                // Simple type
                _date = ParserHelper::ParseDateTime(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DESCRIPTION)
            {
                // Simple type
                _description = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__REV_MAJOR)
            {
                // Simple type
                _revMajor = ParserHelper::ParseUnsignedShort(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__REV_MINOR)
            {
                // Simple type
                _revMinor = ParserHelper::ParseUnsignedShort(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType FileHeaderImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> FileHeaderImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kLicense =  GetWriterLicense();
                if (kLicense)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLicense));
                }
                const auto kProperties =  GetWriterProperties();
                if (kProperties)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kProperties));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> FileHeaderImpl::Clone()
        {
            auto clonedObject = std::make_shared<FileHeaderImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_author = GetAuthor();
            // Simple type
            clonedObject->_date = GetDate();
            // Simple type
            clonedObject->_description = GetDescription();
            // Simple type
            clonedObject->_revMajor = GetRevMajor();
            // Simple type
            clonedObject->_revMinor = GetRevMinor();
            // clone indicators
            // clone children
            const auto kLicense =  GetWriterLicense();
            if (kLicense)
            {
                auto clonedChild = std::dynamic_pointer_cast<LicenseImpl>(kLicense)->Clone();
                auto clonedChildILicense = std::dynamic_pointer_cast<ILicense>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLicense(std::dynamic_pointer_cast<ILicenseWriter>(clonedChildILicense));
            }
            const auto kProperties =  GetWriterProperties();
            if (kProperties)
            {
                auto clonedChild = std::dynamic_pointer_cast<PropertiesImpl>(kProperties)->Clone();
                auto clonedChildIProperties = std::dynamic_pointer_cast<IProperties>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetProperties(std::dynamic_pointer_cast<IPropertiesWriter>(clonedChildIProperties));
            }
            return clonedObject;
        }

        std::string FileHeaderImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__AUTHOR)
            {
                return GetAuthor();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__DESCRIPTION)
            {
                return GetDescription();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FileHeaderImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LICENSE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLicense());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PROPERTIES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetProperties());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> FileHeaderImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FileHeaderImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string FileHeaderImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void FileHeaderImpl::ResolveUnsignedShortExpression(std::string& attributeKey, unsigned short& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__REV_MAJOR)
            {
                // Simple type
                _revMajor = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__REV_MINOR)
            {
                // Simple type
                _revMinor = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void FileHeaderImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__AUTHOR)
            {
                // Simple type
                _author = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DESCRIPTION)
            {
                // Simple type
                _description = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void FileHeaderImpl::ResolveDateTimeExpression(std::string& attributeKey, DateTime& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DATE)
            {
                // Simple type
                _date = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void FileHeaderImpl::ResetLicense()
	   {
	   		isSetLicense = false; 
			_license = {};
			
	   }
       bool FileHeaderImpl::IsSetLicense() const
	   {
			return isSetLicense;
	   }
       void FileHeaderImpl::ResetProperties()
	   {
	   		isSetProperties = false; 
			_properties = {};
			
	   }
       bool FileHeaderImpl::IsSetProperties() const
	   {
			return isSetProperties;
	   }

        IOpenScenarioFlexElement* FinalSpeedImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IAbsoluteSpeed> FinalSpeedImpl::GetAbsoluteSpeed() const
        {
        	  return _absoluteSpeed;
        }
        std::shared_ptr<IRelativeSpeedToMaster> FinalSpeedImpl::GetRelativeSpeedToMaster() const
        {
        	  return _relativeSpeedToMaster;
        }


        void FinalSpeedImpl::SetAbsoluteSpeed(std::shared_ptr<IAbsoluteSpeedWriter> absoluteSpeed)
        {
            _absoluteSpeed = absoluteSpeed;
            _relativeSpeedToMaster = {};
			// set the indicator to true
            isSetAbsoluteSpeed = true;          
        }

        void FinalSpeedImpl::SetRelativeSpeedToMaster(std::shared_ptr<IRelativeSpeedToMasterWriter> relativeSpeedToMaster)
        {
            _relativeSpeedToMaster = relativeSpeedToMaster;
            _absoluteSpeed = {};
			// set the indicator to true
            isSetRelativeSpeedToMaster = true;          
        }

        std::shared_ptr<void> FinalSpeedImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(FinalSpeedImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IFinalSpeed).name())
                return std::dynamic_pointer_cast<IFinalSpeed>(shared_from_this());
            else if (classifier == typeid(IFinalSpeedWriter).name())
                return std::dynamic_pointer_cast<IFinalSpeedWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> FinalSpeedImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t FinalSpeedImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int FinalSpeedImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double FinalSpeedImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t FinalSpeedImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool FinalSpeedImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime FinalSpeedImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> FinalSpeedImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string FinalSpeedImpl::GetModelType() const
        {
            return "FinalSpeed";
        }

            // children
        std::shared_ptr<IAbsoluteSpeedWriter> FinalSpeedImpl::GetWriterAbsoluteSpeed() const
        {
            return std::dynamic_pointer_cast<IAbsoluteSpeedWriter>(_absoluteSpeed);
        }
        std::shared_ptr<IRelativeSpeedToMasterWriter> FinalSpeedImpl::GetWriterRelativeSpeedToMaster() const
        {
            return std::dynamic_pointer_cast<IRelativeSpeedToMasterWriter>(_relativeSpeedToMaster);
        }

        FinalSpeedImpl::FinalSpeedImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void FinalSpeedImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType FinalSpeedImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> FinalSpeedImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kAbsoluteSpeed =  GetWriterAbsoluteSpeed();
                if (kAbsoluteSpeed)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAbsoluteSpeed));
                }
                const auto kRelativeSpeedToMaster =  GetWriterRelativeSpeedToMaster();
                if (kRelativeSpeedToMaster)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeSpeedToMaster));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> FinalSpeedImpl::Clone()
        {
            auto clonedObject = std::make_shared<FinalSpeedImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kAbsoluteSpeed =  GetWriterAbsoluteSpeed();
            if (kAbsoluteSpeed)
            {
                auto clonedChild = std::dynamic_pointer_cast<AbsoluteSpeedImpl>(kAbsoluteSpeed)->Clone();
                auto clonedChildIAbsoluteSpeed = std::dynamic_pointer_cast<IAbsoluteSpeed>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAbsoluteSpeed(std::dynamic_pointer_cast<IAbsoluteSpeedWriter>(clonedChildIAbsoluteSpeed));
            }
            const auto kRelativeSpeedToMaster =  GetWriterRelativeSpeedToMaster();
            if (kRelativeSpeedToMaster)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeSpeedToMasterImpl>(kRelativeSpeedToMaster)->Clone();
                auto clonedChildIRelativeSpeedToMaster = std::dynamic_pointer_cast<IRelativeSpeedToMaster>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeSpeedToMaster(std::dynamic_pointer_cast<IRelativeSpeedToMasterWriter>(clonedChildIRelativeSpeedToMaster));
            }
            return clonedObject;
        }

        std::string FinalSpeedImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FinalSpeedImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ABSOLUTE_SPEED)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAbsoluteSpeed());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_SPEED_TO_MASTER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeSpeedToMaster());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> FinalSpeedImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FinalSpeedImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string FinalSpeedImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void FinalSpeedImpl::ResetAbsoluteSpeed()
	   {
	   		isSetAbsoluteSpeed = false; 
			_absoluteSpeed = {};
			
	   }
       bool FinalSpeedImpl::IsSetAbsoluteSpeed() const
	   {
			return isSetAbsoluteSpeed;
	   }
       void FinalSpeedImpl::ResetRelativeSpeedToMaster()
	   {
	   		isSetRelativeSpeedToMaster = false; 
			_relativeSpeedToMaster = {};
			
	   }
       bool FinalSpeedImpl::IsSetRelativeSpeedToMaster() const
	   {
			return isSetRelativeSpeedToMaster;
	   }

        IOpenScenarioFlexElement* FogImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double FogImpl::GetVisualRange() const
        {
        	  return _visualRange;
        }
        std::shared_ptr<IBoundingBox> FogImpl::GetBoundingBox() const
        {
        	  return _boundingBox;
        }


        void FogImpl::SetVisualRange(const double visualRange)
        {
            _visualRange = visualRange;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VISUAL_RANGE);
        }

        void FogImpl::SetBoundingBox(std::shared_ptr<IBoundingBoxWriter> boundingBox)
        {
            _boundingBox = boundingBox;
			// set the indicator to true
            isSetBoundingBox = true;          
        }

        std::shared_ptr<void> FogImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(FogImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IFog).name())
                return std::dynamic_pointer_cast<IFog>(shared_from_this());
            else if (classifier == typeid(IFogWriter).name())
                return std::dynamic_pointer_cast<IFogWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> FogImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t FogImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int FogImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double FogImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VISUAL_RANGE)
                {
                    return GetVisualRange();
                }
                throw KeyNotSupportedException();

        }

        uint16_t FogImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool FogImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime FogImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> FogImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string FogImpl::GetModelType() const
        {
            return "Fog";
        }

        void FogImpl::WriteParameterToVisualRange(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VISUAL_RANGE, parameterName, nullTextMarker /*no textmarker*/);
            _visualRange = {};
        }

        std::string FogImpl::GetParameterFromVisualRange() const
        {
            auto visualRange = OSC_CONSTANTS::ATTRIBUTE__VISUAL_RANGE;
            return GetParameterNameFromAttribute(visualRange);
        }

        bool FogImpl::IsVisualRangeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VISUAL_RANGE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IBoundingBoxWriter> FogImpl::GetWriterBoundingBox() const
        {
            return std::dynamic_pointer_cast<IBoundingBoxWriter>(_boundingBox);
        }

        FogImpl::FogImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VISUAL_RANGE, SimpleType::DOUBLE);
        }

        void FogImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VISUAL_RANGE)
            {
                // Simple type
                _visualRange = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType FogImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> FogImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kBoundingBox =  GetWriterBoundingBox();
                if (kBoundingBox)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kBoundingBox));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> FogImpl::Clone()
        {
            auto clonedObject = std::make_shared<FogImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_visualRange = GetVisualRange();
            // clone indicators
            // clone children
            const auto kBoundingBox =  GetWriterBoundingBox();
            if (kBoundingBox)
            {
                auto clonedChild = std::dynamic_pointer_cast<BoundingBoxImpl>(kBoundingBox)->Clone();
                auto clonedChildIBoundingBox = std::dynamic_pointer_cast<IBoundingBox>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetBoundingBox(std::dynamic_pointer_cast<IBoundingBoxWriter>(clonedChildIBoundingBox));
            }
            return clonedObject;
        }

        std::string FogImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FogImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BOUNDING_BOX)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetBoundingBox());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> FogImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FogImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string FogImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void FogImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VISUAL_RANGE)
            {
                // Simple type
                _visualRange = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void FogImpl::ResetBoundingBox()
	   {
	   		isSetBoundingBox = false; 
			_boundingBox = {};
			
	   }
       bool FogImpl::IsSetBoundingBox() const
	   {
			return isSetBoundingBox;
	   }

        IOpenScenarioFlexElement* FollowTrajectoryActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double FollowTrajectoryActionImpl::GetInitialDistanceOffset() const
        {
        	  return _initialDistanceOffset;
        }
        std::shared_ptr<ITrajectory> FollowTrajectoryActionImpl::GetTrajectory() const
        {
        	  return _trajectory;
        }
        std::shared_ptr<ICatalogReference> FollowTrajectoryActionImpl::GetCatalogReference() const
        {
        	  return _catalogReference;
        }
        std::shared_ptr<ITimeReference> FollowTrajectoryActionImpl::GetTimeReference() const
        {
        	  return _timeReference;
        }
        std::shared_ptr<ITrajectoryFollowingMode> FollowTrajectoryActionImpl::GetTrajectoryFollowingMode() const
        {
        	  return _trajectoryFollowingMode;
        }
        std::shared_ptr<ITrajectoryRef> FollowTrajectoryActionImpl::GetTrajectoryRef() const
        {
        	  return _trajectoryRef;
        }


        void FollowTrajectoryActionImpl::SetInitialDistanceOffset(const double initialDistanceOffset)
        {
            _initialDistanceOffset = initialDistanceOffset;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__INITIAL_DISTANCE_OFFSET);
			// set the indicator to true
            isSetInitialDistanceOffset = true;          
        }

        void FollowTrajectoryActionImpl::SetTrajectory(std::shared_ptr<ITrajectoryWriter> trajectory)
        {
            _trajectory = trajectory;
			// set the indicator to true
            isSetTrajectory = true;          
        }

        void FollowTrajectoryActionImpl::SetCatalogReference(std::shared_ptr<ICatalogReferenceWriter> catalogReference)
        {
            _catalogReference = catalogReference;
			// set the indicator to true
            isSetCatalogReference = true;          
        }

        void FollowTrajectoryActionImpl::SetTimeReference(std::shared_ptr<ITimeReferenceWriter> timeReference)
        {
            _timeReference = timeReference;
        }

        void FollowTrajectoryActionImpl::SetTrajectoryFollowingMode(std::shared_ptr<ITrajectoryFollowingModeWriter> trajectoryFollowingMode)
        {
            _trajectoryFollowingMode = trajectoryFollowingMode;
        }

        void FollowTrajectoryActionImpl::SetTrajectoryRef(std::shared_ptr<ITrajectoryRefWriter> trajectoryRef)
        {
            _trajectoryRef = trajectoryRef;
			// set the indicator to true
            isSetTrajectoryRef = true;          
        }

        std::shared_ptr<void> FollowTrajectoryActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(FollowTrajectoryActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IFollowTrajectoryAction).name())
                return std::dynamic_pointer_cast<IFollowTrajectoryAction>(shared_from_this());
            else if (classifier == typeid(IFollowTrajectoryActionWriter).name())
                return std::dynamic_pointer_cast<IFollowTrajectoryActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> FollowTrajectoryActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t FollowTrajectoryActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int FollowTrajectoryActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double FollowTrajectoryActionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__INITIAL_DISTANCE_OFFSET)
                {
                    return GetInitialDistanceOffset();
                }
                throw KeyNotSupportedException();

        }

        uint16_t FollowTrajectoryActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool FollowTrajectoryActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime FollowTrajectoryActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> FollowTrajectoryActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string FollowTrajectoryActionImpl::GetModelType() const
        {
            return "FollowTrajectoryAction";
        }

        void FollowTrajectoryActionImpl::WriteParameterToInitialDistanceOffset(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__INITIAL_DISTANCE_OFFSET, parameterName, nullTextMarker /*no textmarker*/);
            _initialDistanceOffset = {};
        }

        std::string FollowTrajectoryActionImpl::GetParameterFromInitialDistanceOffset() const
        {
            auto initialDistanceOffset = OSC_CONSTANTS::ATTRIBUTE__INITIAL_DISTANCE_OFFSET;
            return GetParameterNameFromAttribute(initialDistanceOffset);
        }

        bool FollowTrajectoryActionImpl::IsInitialDistanceOffsetParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__INITIAL_DISTANCE_OFFSET);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<ITrajectoryWriter> FollowTrajectoryActionImpl::GetWriterTrajectory() const
        {
            return std::dynamic_pointer_cast<ITrajectoryWriter>(_trajectory);
        }
        std::shared_ptr<ICatalogReferenceWriter> FollowTrajectoryActionImpl::GetWriterCatalogReference() const
        {
            return std::dynamic_pointer_cast<ICatalogReferenceWriter>(_catalogReference);
        }
        std::shared_ptr<ITimeReferenceWriter> FollowTrajectoryActionImpl::GetWriterTimeReference() const
        {
            return std::dynamic_pointer_cast<ITimeReferenceWriter>(_timeReference);
        }
        std::shared_ptr<ITrajectoryFollowingModeWriter> FollowTrajectoryActionImpl::GetWriterTrajectoryFollowingMode() const
        {
            return std::dynamic_pointer_cast<ITrajectoryFollowingModeWriter>(_trajectoryFollowingMode);
        }
        std::shared_ptr<ITrajectoryRefWriter> FollowTrajectoryActionImpl::GetWriterTrajectoryRef() const
        {
            return std::dynamic_pointer_cast<ITrajectoryRefWriter>(_trajectoryRef);
        }

        FollowTrajectoryActionImpl::FollowTrajectoryActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__INITIAL_DISTANCE_OFFSET, SimpleType::DOUBLE);
        }

        void FollowTrajectoryActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__INITIAL_DISTANCE_OFFSET)
            {
                // Simple type
                _initialDistanceOffset = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType FollowTrajectoryActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> FollowTrajectoryActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kTrajectory =  GetWriterTrajectory();
                if (kTrajectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrajectory));
                }
                const auto kCatalogReference =  GetWriterCatalogReference();
                if (kCatalogReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogReference));
                }
                const auto kTimeReference =  GetWriterTimeReference();
                if (kTimeReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTimeReference));
                }
                const auto kTrajectoryFollowingMode =  GetWriterTrajectoryFollowingMode();
                if (kTrajectoryFollowingMode)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrajectoryFollowingMode));
                }
                const auto kTrajectoryRef =  GetWriterTrajectoryRef();
                if (kTrajectoryRef)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrajectoryRef));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> FollowTrajectoryActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<FollowTrajectoryActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_initialDistanceOffset = GetInitialDistanceOffset();
            // clone indicators
            	clonedObject->isSetInitialDistanceOffset = isSetInitialDistanceOffset;
            // clone children
            const auto kTrajectory =  GetWriterTrajectory();
            if (kTrajectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrajectoryImpl>(kTrajectory)->Clone();
                auto clonedChildITrajectory = std::dynamic_pointer_cast<ITrajectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrajectory(std::dynamic_pointer_cast<ITrajectoryWriter>(clonedChildITrajectory));
            }
            const auto kCatalogReference =  GetWriterCatalogReference();
            if (kCatalogReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kCatalogReference)->Clone();
                auto clonedChildICatalogReference = std::dynamic_pointer_cast<ICatalogReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogReference(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChildICatalogReference));
            }
            const auto kTimeReference =  GetWriterTimeReference();
            if (kTimeReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<TimeReferenceImpl>(kTimeReference)->Clone();
                auto clonedChildITimeReference = std::dynamic_pointer_cast<ITimeReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTimeReference(std::dynamic_pointer_cast<ITimeReferenceWriter>(clonedChildITimeReference));
            }
            const auto kTrajectoryFollowingMode =  GetWriterTrajectoryFollowingMode();
            if (kTrajectoryFollowingMode)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrajectoryFollowingModeImpl>(kTrajectoryFollowingMode)->Clone();
                auto clonedChildITrajectoryFollowingMode = std::dynamic_pointer_cast<ITrajectoryFollowingMode>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrajectoryFollowingMode(std::dynamic_pointer_cast<ITrajectoryFollowingModeWriter>(clonedChildITrajectoryFollowingMode));
            }
            const auto kTrajectoryRef =  GetWriterTrajectoryRef();
            if (kTrajectoryRef)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrajectoryRefImpl>(kTrajectoryRef)->Clone();
                auto clonedChildITrajectoryRef = std::dynamic_pointer_cast<ITrajectoryRef>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrajectoryRef(std::dynamic_pointer_cast<ITrajectoryRefWriter>(clonedChildITrajectoryRef));
            }
            return clonedObject;
        }

        std::string FollowTrajectoryActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FollowTrajectoryActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAJECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrajectory());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogReference());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TIME_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTimeReference());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAJECTORY_FOLLOWING_MODE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrajectoryFollowingMode());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAJECTORY_REF)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrajectoryRef());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> FollowTrajectoryActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FollowTrajectoryActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string FollowTrajectoryActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void FollowTrajectoryActionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__INITIAL_DISTANCE_OFFSET)
            {
                // Simple type
                _initialDistanceOffset = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void FollowTrajectoryActionImpl::ResetInitialDistanceOffset()
	   {
	   		isSetInitialDistanceOffset = false; 
			_initialDistanceOffset = {0};
			
	   }
       bool FollowTrajectoryActionImpl::IsSetInitialDistanceOffset() const
	   {
			return isSetInitialDistanceOffset;
	   }
       void FollowTrajectoryActionImpl::ResetTrajectory()
	   {
	   		isSetTrajectory = false; 
			_trajectory = {};
			
	   }
       bool FollowTrajectoryActionImpl::IsSetTrajectory() const
	   {
			return isSetTrajectory;
	   }
       void FollowTrajectoryActionImpl::ResetCatalogReference()
	   {
	   		isSetCatalogReference = false; 
			_catalogReference = {};
			
	   }
       bool FollowTrajectoryActionImpl::IsSetCatalogReference() const
	   {
			return isSetCatalogReference;
	   }
       void FollowTrajectoryActionImpl::ResetTrajectoryRef()
	   {
	   		isSetTrajectoryRef = false; 
			_trajectoryRef = {};
			
	   }
       bool FollowTrajectoryActionImpl::IsSetTrajectoryRef() const
	   {
			return isSetTrajectoryRef;
	   }

        IOpenScenarioFlexElement* GearImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IManualGear> GearImpl::GetManualGear() const
        {
        	  return _manualGear;
        }
        std::shared_ptr<IAutomaticGear> GearImpl::GetAutomaticGear() const
        {
        	  return _automaticGear;
        }


        void GearImpl::SetManualGear(std::shared_ptr<IManualGearWriter> manualGear)
        {
            _manualGear = manualGear;
            _automaticGear = {};
        }

        void GearImpl::SetAutomaticGear(std::shared_ptr<IAutomaticGearWriter> automaticGear)
        {
            _automaticGear = automaticGear;
            _manualGear = {};
        }

        std::shared_ptr<void> GearImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(GearImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IGear).name())
                return std::dynamic_pointer_cast<IGear>(shared_from_this());
            else if (classifier == typeid(IGearWriter).name())
                return std::dynamic_pointer_cast<IGearWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> GearImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t GearImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int GearImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double GearImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t GearImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool GearImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime GearImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> GearImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string GearImpl::GetModelType() const
        {
            return "Gear";
        }

            // children
        std::shared_ptr<IManualGearWriter> GearImpl::GetWriterManualGear() const
        {
            return std::dynamic_pointer_cast<IManualGearWriter>(_manualGear);
        }
        std::shared_ptr<IAutomaticGearWriter> GearImpl::GetWriterAutomaticGear() const
        {
            return std::dynamic_pointer_cast<IAutomaticGearWriter>(_automaticGear);
        }

        GearImpl::GearImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void GearImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType GearImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> GearImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kManualGear =  GetWriterManualGear();
                if (kManualGear)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kManualGear));
                }
                const auto kAutomaticGear =  GetWriterAutomaticGear();
                if (kAutomaticGear)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAutomaticGear));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> GearImpl::Clone()
        {
            auto clonedObject = std::make_shared<GearImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kManualGear =  GetWriterManualGear();
            if (kManualGear)
            {
                auto clonedChild = std::dynamic_pointer_cast<ManualGearImpl>(kManualGear)->Clone();
                auto clonedChildIManualGear = std::dynamic_pointer_cast<IManualGear>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetManualGear(std::dynamic_pointer_cast<IManualGearWriter>(clonedChildIManualGear));
            }
            const auto kAutomaticGear =  GetWriterAutomaticGear();
            if (kAutomaticGear)
            {
                auto clonedChild = std::dynamic_pointer_cast<AutomaticGearImpl>(kAutomaticGear)->Clone();
                auto clonedChildIAutomaticGear = std::dynamic_pointer_cast<IAutomaticGear>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAutomaticGear(std::dynamic_pointer_cast<IAutomaticGearWriter>(clonedChildIAutomaticGear));
            }
            return clonedObject;
        }

        std::string GearImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> GearImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__MANUAL_GEAR)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetManualGear());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__AUTOMATIC_GEAR)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAutomaticGear());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> GearImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> GearImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string GearImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* GeoPositionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double GeoPositionImpl::GetAltitude() const
        {
        	  return _altitude;
        }
        double GeoPositionImpl::GetHeight() const
        {
        	  return _height;
        }
        double GeoPositionImpl::GetLatitude() const
        {
        	  return _latitude;
        }
        double GeoPositionImpl::GetLatitudeDeg() const
        {
        	  return _latitudeDeg;
        }
        double GeoPositionImpl::GetLongitude() const
        {
        	  return _longitude;
        }
        double GeoPositionImpl::GetLongitudeDeg() const
        {
        	  return _longitudeDeg;
        }
        std::shared_ptr<IOrientation> GeoPositionImpl::GetOrientation() const
        {
        	  return _orientation;
        }


        void GeoPositionImpl::SetAltitude(const double altitude)
        {
            _altitude = altitude;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ALTITUDE);
			// set the indicator to true
            isSetAltitude = true;          
        }

        void GeoPositionImpl::SetHeight(const double height)
        {
            _height = height;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__HEIGHT);
			// set the indicator to true
            isSetHeight = true;          
        }

        void GeoPositionImpl::SetLatitude(const double latitude)
        {
            _latitude = latitude;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LATITUDE);
			// set the indicator to true
            isSetLatitude = true;          
        }

        void GeoPositionImpl::SetLatitudeDeg(const double latitudeDeg)
        {
            _latitudeDeg = latitudeDeg;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LATITUDE_DEG);
			// set the indicator to true
            isSetLatitudeDeg = true;          
        }

        void GeoPositionImpl::SetLongitude(const double longitude)
        {
            _longitude = longitude;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LONGITUDE);
			// set the indicator to true
            isSetLongitude = true;          
        }

        void GeoPositionImpl::SetLongitudeDeg(const double longitudeDeg)
        {
            _longitudeDeg = longitudeDeg;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LONGITUDE_DEG);
			// set the indicator to true
            isSetLongitudeDeg = true;          
        }

        void GeoPositionImpl::SetOrientation(std::shared_ptr<IOrientationWriter> orientation)
        {
            _orientation = orientation;
			// set the indicator to true
            isSetOrientation = true;          
        }

        std::shared_ptr<void> GeoPositionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(GeoPositionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IGeoPosition).name())
                return std::dynamic_pointer_cast<IGeoPosition>(shared_from_this());
            else if (classifier == typeid(IGeoPositionWriter).name())
                return std::dynamic_pointer_cast<IGeoPositionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> GeoPositionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t GeoPositionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int GeoPositionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double GeoPositionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__ALTITUDE)
                {
                    return GetAltitude();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__HEIGHT)
                {
                    return GetHeight();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__LATITUDE)
                {
                    return GetLatitude();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__LATITUDE_DEG)
                {
                    return GetLatitudeDeg();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__LONGITUDE)
                {
                    return GetLongitude();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__LONGITUDE_DEG)
                {
                    return GetLongitudeDeg();
                }
                throw KeyNotSupportedException();

        }

        uint16_t GeoPositionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool GeoPositionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime GeoPositionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> GeoPositionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string GeoPositionImpl::GetModelType() const
        {
            return "GeoPosition";
        }

        void GeoPositionImpl::WriteParameterToAltitude(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ALTITUDE, parameterName, nullTextMarker /*no textmarker*/);
            _altitude = {};
        }

        void GeoPositionImpl::WriteParameterToHeight(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__HEIGHT, parameterName, nullTextMarker /*no textmarker*/);
            _height = {};
        }

        void GeoPositionImpl::WriteParameterToLatitude(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LATITUDE, parameterName, nullTextMarker /*no textmarker*/);
            _latitude = {};
        }

        void GeoPositionImpl::WriteParameterToLatitudeDeg(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LATITUDE_DEG, parameterName, nullTextMarker /*no textmarker*/);
            _latitudeDeg = {};
        }

        void GeoPositionImpl::WriteParameterToLongitude(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LONGITUDE, parameterName, nullTextMarker /*no textmarker*/);
            _longitude = {};
        }

        void GeoPositionImpl::WriteParameterToLongitudeDeg(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LONGITUDE_DEG, parameterName, nullTextMarker /*no textmarker*/);
            _longitudeDeg = {};
        }

        std::string GeoPositionImpl::GetParameterFromAltitude() const
        {
            auto altitude = OSC_CONSTANTS::ATTRIBUTE__ALTITUDE;
            return GetParameterNameFromAttribute(altitude);
        }

        std::string GeoPositionImpl::GetParameterFromHeight() const
        {
            auto height = OSC_CONSTANTS::ATTRIBUTE__HEIGHT;
            return GetParameterNameFromAttribute(height);
        }

        std::string GeoPositionImpl::GetParameterFromLatitude() const
        {
            auto latitude = OSC_CONSTANTS::ATTRIBUTE__LATITUDE;
            return GetParameterNameFromAttribute(latitude);
        }

        std::string GeoPositionImpl::GetParameterFromLatitudeDeg() const
        {
            auto latitudeDeg = OSC_CONSTANTS::ATTRIBUTE__LATITUDE_DEG;
            return GetParameterNameFromAttribute(latitudeDeg);
        }

        std::string GeoPositionImpl::GetParameterFromLongitude() const
        {
            auto longitude = OSC_CONSTANTS::ATTRIBUTE__LONGITUDE;
            return GetParameterNameFromAttribute(longitude);
        }

        std::string GeoPositionImpl::GetParameterFromLongitudeDeg() const
        {
            auto longitudeDeg = OSC_CONSTANTS::ATTRIBUTE__LONGITUDE_DEG;
            return GetParameterNameFromAttribute(longitudeDeg);
        }

        bool GeoPositionImpl::IsAltitudeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ALTITUDE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool GeoPositionImpl::IsHeightParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__HEIGHT);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool GeoPositionImpl::IsLatitudeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__LATITUDE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool GeoPositionImpl::IsLatitudeDegParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__LATITUDE_DEG);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool GeoPositionImpl::IsLongitudeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__LONGITUDE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool GeoPositionImpl::IsLongitudeDegParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__LONGITUDE_DEG);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IOrientationWriter> GeoPositionImpl::GetWriterOrientation() const
        {
            return std::dynamic_pointer_cast<IOrientationWriter>(_orientation);
        }

        GeoPositionImpl::GeoPositionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ALTITUDE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__HEIGHT, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LATITUDE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LATITUDE_DEG, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LONGITUDE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LONGITUDE_DEG, SimpleType::DOUBLE);
        }

        void GeoPositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ALTITUDE)
            {
                // Simple type
                _altitude = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__HEIGHT)
            {
                // Simple type
                _height = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LATITUDE)
            {
                // Simple type
                _latitude = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LATITUDE_DEG)
            {
                // Simple type
                _latitudeDeg = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LONGITUDE)
            {
                // Simple type
                _longitude = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LONGITUDE_DEG)
            {
                // Simple type
                _longitudeDeg = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType GeoPositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> GeoPositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kOrientation =  GetWriterOrientation();
                if (kOrientation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOrientation));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> GeoPositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<GeoPositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_altitude = GetAltitude();
            // Simple type
            clonedObject->_height = GetHeight();
            // Simple type
            clonedObject->_latitude = GetLatitude();
            // Simple type
            clonedObject->_latitudeDeg = GetLatitudeDeg();
            // Simple type
            clonedObject->_longitude = GetLongitude();
            // Simple type
            clonedObject->_longitudeDeg = GetLongitudeDeg();
            // clone indicators
            	clonedObject->isSetAltitude = isSetAltitude;
            	clonedObject->isSetHeight = isSetHeight;
            	clonedObject->isSetLatitude = isSetLatitude;
            	clonedObject->isSetLatitudeDeg = isSetLatitudeDeg;
            	clonedObject->isSetLongitude = isSetLongitude;
            	clonedObject->isSetLongitudeDeg = isSetLongitudeDeg;
            // clone children
            const auto kOrientation =  GetWriterOrientation();
            if (kOrientation)
            {
                auto clonedChild = std::dynamic_pointer_cast<OrientationImpl>(kOrientation)->Clone();
                auto clonedChildIOrientation = std::dynamic_pointer_cast<IOrientation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOrientation(std::dynamic_pointer_cast<IOrientationWriter>(clonedChildIOrientation));
            }
            return clonedObject;
        }

        std::string GeoPositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> GeoPositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ORIENTATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOrientation());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> GeoPositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> GeoPositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string GeoPositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void GeoPositionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ALTITUDE)
            {
                // Simple type
                _altitude = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__HEIGHT)
            {
                // Simple type
                _height = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LATITUDE)
            {
                // Simple type
                _latitude = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LATITUDE_DEG)
            {
                // Simple type
                _latitudeDeg = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LONGITUDE)
            {
                // Simple type
                _longitude = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LONGITUDE_DEG)
            {
                // Simple type
                _longitudeDeg = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void GeoPositionImpl::ResetAltitude()
	   {
	   		isSetAltitude = false; 
			_altitude = {0};
			
	   }
       bool GeoPositionImpl::IsSetAltitude() const
	   {
			return isSetAltitude;
	   }
       void GeoPositionImpl::ResetHeight()
	   {
	   		isSetHeight = false; 
			_height = {0};
			
	   }
       bool GeoPositionImpl::IsSetHeight() const
	   {
			return isSetHeight;
	   }
       void GeoPositionImpl::ResetLatitude()
	   {
	   		isSetLatitude = false; 
			_latitude = {0};
			
	   }
       bool GeoPositionImpl::IsSetLatitude() const
	   {
			return isSetLatitude;
	   }
       void GeoPositionImpl::ResetLatitudeDeg()
	   {
	   		isSetLatitudeDeg = false; 
			_latitudeDeg = {};
			
	   }
       bool GeoPositionImpl::IsSetLatitudeDeg() const
	   {
			return isSetLatitudeDeg;
	   }
       void GeoPositionImpl::ResetLongitude()
	   {
	   		isSetLongitude = false; 
			_longitude = {0};
			
	   }
       bool GeoPositionImpl::IsSetLongitude() const
	   {
			return isSetLongitude;
	   }
       void GeoPositionImpl::ResetLongitudeDeg()
	   {
	   		isSetLongitudeDeg = false; 
			_longitudeDeg = {0};
			
	   }
       bool GeoPositionImpl::IsSetLongitudeDeg() const
	   {
			return isSetLongitudeDeg;
	   }
       void GeoPositionImpl::ResetOrientation()
	   {
	   		isSetOrientation = false; 
			_orientation = {};
			
	   }
       bool GeoPositionImpl::IsSetOrientation() const
	   {
			return isSetOrientation;
	   }

        IOpenScenarioFlexElement* GlobalActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IEnvironmentAction> GlobalActionImpl::GetEnvironmentAction() const
        {
        	  return _environmentAction;
        }
        std::shared_ptr<IEntityAction> GlobalActionImpl::GetEntityAction() const
        {
        	  return _entityAction;
        }
        std::shared_ptr<IParameterAction> GlobalActionImpl::GetParameterAction() const
        {
        	  return _parameterAction;
        }
        std::shared_ptr<IInfrastructureAction> GlobalActionImpl::GetInfrastructureAction() const
        {
        	  return _infrastructureAction;
        }
        std::shared_ptr<ITrafficAction> GlobalActionImpl::GetTrafficAction() const
        {
        	  return _trafficAction;
        }
        std::shared_ptr<IVariableAction> GlobalActionImpl::GetVariableAction() const
        {
        	  return _variableAction;
        }


        void GlobalActionImpl::SetEnvironmentAction(std::shared_ptr<IEnvironmentActionWriter> environmentAction)
        {
            _environmentAction = environmentAction;
            _entityAction = {};
            _parameterAction = {};
            _infrastructureAction = {};
            _trafficAction = {};
            _variableAction = {};
			// set the indicator to true
            isSetEnvironmentAction = true;          
        }

        void GlobalActionImpl::SetEntityAction(std::shared_ptr<IEntityActionWriter> entityAction)
        {
            _entityAction = entityAction;
            _environmentAction = {};
            _parameterAction = {};
            _infrastructureAction = {};
            _trafficAction = {};
            _variableAction = {};
			// set the indicator to true
            isSetEntityAction = true;          
        }

        void GlobalActionImpl::SetParameterAction(std::shared_ptr<IParameterActionWriter> parameterAction)
        {
            _parameterAction = parameterAction;
            _environmentAction = {};
            _entityAction = {};
            _infrastructureAction = {};
            _trafficAction = {};
            _variableAction = {};
			// set the indicator to true
            isSetParameterAction = true;          
        }

        void GlobalActionImpl::SetInfrastructureAction(std::shared_ptr<IInfrastructureActionWriter> infrastructureAction)
        {
            _infrastructureAction = infrastructureAction;
            _environmentAction = {};
            _entityAction = {};
            _parameterAction = {};
            _trafficAction = {};
            _variableAction = {};
			// set the indicator to true
            isSetInfrastructureAction = true;          
        }

        void GlobalActionImpl::SetTrafficAction(std::shared_ptr<ITrafficActionWriter> trafficAction)
        {
            _trafficAction = trafficAction;
            _environmentAction = {};
            _entityAction = {};
            _parameterAction = {};
            _infrastructureAction = {};
            _variableAction = {};
			// set the indicator to true
            isSetTrafficAction = true;          
        }

        void GlobalActionImpl::SetVariableAction(std::shared_ptr<IVariableActionWriter> variableAction)
        {
            _variableAction = variableAction;
            _environmentAction = {};
            _entityAction = {};
            _parameterAction = {};
            _infrastructureAction = {};
            _trafficAction = {};
			// set the indicator to true
            isSetVariableAction = true;          
        }

        std::shared_ptr<void> GlobalActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(GlobalActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IGlobalAction).name())
                return std::dynamic_pointer_cast<IGlobalAction>(shared_from_this());
            else if (classifier == typeid(IGlobalActionWriter).name())
                return std::dynamic_pointer_cast<IGlobalActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> GlobalActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t GlobalActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int GlobalActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double GlobalActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t GlobalActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool GlobalActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime GlobalActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> GlobalActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string GlobalActionImpl::GetModelType() const
        {
            return "GlobalAction";
        }

            // children
        std::shared_ptr<IEnvironmentActionWriter> GlobalActionImpl::GetWriterEnvironmentAction() const
        {
            return std::dynamic_pointer_cast<IEnvironmentActionWriter>(_environmentAction);
        }
        std::shared_ptr<IEntityActionWriter> GlobalActionImpl::GetWriterEntityAction() const
        {
            return std::dynamic_pointer_cast<IEntityActionWriter>(_entityAction);
        }
        std::shared_ptr<IParameterActionWriter> GlobalActionImpl::GetWriterParameterAction() const
        {
            return std::dynamic_pointer_cast<IParameterActionWriter>(_parameterAction);
        }
        std::shared_ptr<IInfrastructureActionWriter> GlobalActionImpl::GetWriterInfrastructureAction() const
        {
            return std::dynamic_pointer_cast<IInfrastructureActionWriter>(_infrastructureAction);
        }
        std::shared_ptr<ITrafficActionWriter> GlobalActionImpl::GetWriterTrafficAction() const
        {
            return std::dynamic_pointer_cast<ITrafficActionWriter>(_trafficAction);
        }
        std::shared_ptr<IVariableActionWriter> GlobalActionImpl::GetWriterVariableAction() const
        {
            return std::dynamic_pointer_cast<IVariableActionWriter>(_variableAction);
        }

        GlobalActionImpl::GlobalActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void GlobalActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType GlobalActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> GlobalActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kEnvironmentAction =  GetWriterEnvironmentAction();
                if (kEnvironmentAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEnvironmentAction));
                }
                const auto kEntityAction =  GetWriterEntityAction();
                if (kEntityAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEntityAction));
                }
                const auto kParameterAction =  GetWriterParameterAction();
                if (kParameterAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kParameterAction));
                }
                const auto kInfrastructureAction =  GetWriterInfrastructureAction();
                if (kInfrastructureAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kInfrastructureAction));
                }
                const auto kTrafficAction =  GetWriterTrafficAction();
                if (kTrafficAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficAction));
                }
                const auto kVariableAction =  GetWriterVariableAction();
                if (kVariableAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kVariableAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> GlobalActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<GlobalActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kEnvironmentAction =  GetWriterEnvironmentAction();
            if (kEnvironmentAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<EnvironmentActionImpl>(kEnvironmentAction)->Clone();
                auto clonedChildIEnvironmentAction = std::dynamic_pointer_cast<IEnvironmentAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEnvironmentAction(std::dynamic_pointer_cast<IEnvironmentActionWriter>(clonedChildIEnvironmentAction));
            }
            const auto kEntityAction =  GetWriterEntityAction();
            if (kEntityAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<EntityActionImpl>(kEntityAction)->Clone();
                auto clonedChildIEntityAction = std::dynamic_pointer_cast<IEntityAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEntityAction(std::dynamic_pointer_cast<IEntityActionWriter>(clonedChildIEntityAction));
            }
            const auto kParameterAction =  GetWriterParameterAction();
            if (kParameterAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<ParameterActionImpl>(kParameterAction)->Clone();
                auto clonedChildIParameterAction = std::dynamic_pointer_cast<IParameterAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetParameterAction(std::dynamic_pointer_cast<IParameterActionWriter>(clonedChildIParameterAction));
            }
            const auto kInfrastructureAction =  GetWriterInfrastructureAction();
            if (kInfrastructureAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<InfrastructureActionImpl>(kInfrastructureAction)->Clone();
                auto clonedChildIInfrastructureAction = std::dynamic_pointer_cast<IInfrastructureAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetInfrastructureAction(std::dynamic_pointer_cast<IInfrastructureActionWriter>(clonedChildIInfrastructureAction));
            }
            const auto kTrafficAction =  GetWriterTrafficAction();
            if (kTrafficAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficActionImpl>(kTrafficAction)->Clone();
                auto clonedChildITrafficAction = std::dynamic_pointer_cast<ITrafficAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficAction(std::dynamic_pointer_cast<ITrafficActionWriter>(clonedChildITrafficAction));
            }
            const auto kVariableAction =  GetWriterVariableAction();
            if (kVariableAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<VariableActionImpl>(kVariableAction)->Clone();
                auto clonedChildIVariableAction = std::dynamic_pointer_cast<IVariableAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetVariableAction(std::dynamic_pointer_cast<IVariableActionWriter>(clonedChildIVariableAction));
            }
            return clonedObject;
        }

        std::string GlobalActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> GlobalActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ENVIRONMENT_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEnvironmentAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEntityAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParameterAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__INFRASTRUCTURE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetInfrastructureAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__VARIABLE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetVariableAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> GlobalActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> GlobalActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string GlobalActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void GlobalActionImpl::ResetEnvironmentAction()
	   {
	   		isSetEnvironmentAction = false; 
			_environmentAction = {};
			
	   }
       bool GlobalActionImpl::IsSetEnvironmentAction() const
	   {
			return isSetEnvironmentAction;
	   }
       void GlobalActionImpl::ResetEntityAction()
	   {
	   		isSetEntityAction = false; 
			_entityAction = {};
			
	   }
       bool GlobalActionImpl::IsSetEntityAction() const
	   {
			return isSetEntityAction;
	   }
       void GlobalActionImpl::ResetParameterAction()
	   {
	   		isSetParameterAction = false; 
			_parameterAction = {};
			
	   }
       bool GlobalActionImpl::IsSetParameterAction() const
	   {
			return isSetParameterAction;
	   }
       void GlobalActionImpl::ResetInfrastructureAction()
	   {
	   		isSetInfrastructureAction = false; 
			_infrastructureAction = {};
			
	   }
       bool GlobalActionImpl::IsSetInfrastructureAction() const
	   {
			return isSetInfrastructureAction;
	   }
       void GlobalActionImpl::ResetTrafficAction()
	   {
	   		isSetTrafficAction = false; 
			_trafficAction = {};
			
	   }
       bool GlobalActionImpl::IsSetTrafficAction() const
	   {
			return isSetTrafficAction;
	   }
       void GlobalActionImpl::ResetVariableAction()
	   {
	   		isSetVariableAction = false; 
			_variableAction = {};
			
	   }
       bool GlobalActionImpl::IsSetVariableAction() const
	   {
			return isSetVariableAction;
	   }

        IOpenScenarioFlexElement* HistogramImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<IHistogramBin>> HistogramImpl::GetBins() const
        {
            std::vector<std::shared_ptr<IHistogramBin>> temp;
            for(auto&& elm: _bins)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IHistogramBinWriter>> HistogramImpl::GetWriterBins() const
        {
            return _bins;
        }

        int HistogramImpl::GetBinsSize() const
        {
            return static_cast<int>(_bins.size());
        }

        std::shared_ptr<IHistogramBin> HistogramImpl::GetBinsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _bins.size() > index)
            {
                return _bins[index];
            }
            return nullptr;
        }


        void HistogramImpl::SetBins(std::vector<std::shared_ptr<IHistogramBinWriter>>& bins)
        {
            _bins = bins;
        }

        std::shared_ptr<void> HistogramImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(HistogramImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IHistogram).name())
                return std::dynamic_pointer_cast<IHistogram>(shared_from_this());
            else if (classifier == typeid(IHistogramWriter).name())
                return std::dynamic_pointer_cast<IHistogramWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> HistogramImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t HistogramImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int HistogramImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double HistogramImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t HistogramImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool HistogramImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime HistogramImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> HistogramImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string HistogramImpl::GetModelType() const
        {
            return "Histogram";
        }

            // children

        HistogramImpl::HistogramImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void HistogramImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType HistogramImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> HistogramImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto bins =  GetWriterBins();
                if (!bins.empty())
                {
                    for(auto&& item : bins)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> HistogramImpl::Clone()
        {
            auto clonedObject = std::make_shared<HistogramImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kBins =  GetWriterBins();
            if (!kBins.empty())
            {
                std::vector<std::shared_ptr<IHistogramBinWriter>> clonedList;
                for(auto&& kItem : kBins)
                {
                    auto clonedChild = std::dynamic_pointer_cast<HistogramBinImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IHistogramBinWriter>(clonedChild));
                }
                clonedObject->SetBins(clonedList);
            }
            return clonedObject;
        }

        std::string HistogramImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> HistogramImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> HistogramImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__BIN)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetBins())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> HistogramImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string HistogramImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* HistogramBinImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double HistogramBinImpl::GetWeight() const
        {
        	  return _weight;
        }
        std::shared_ptr<IRange> HistogramBinImpl::GetRange() const
        {
        	  return _range;
        }


        void HistogramBinImpl::SetWeight(const double weight)
        {
            _weight = weight;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__WEIGHT);
        }

        void HistogramBinImpl::SetRange(std::shared_ptr<IRangeWriter> range)
        {
            _range = range;
        }

        std::shared_ptr<void> HistogramBinImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(HistogramBinImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IHistogramBin).name())
                return std::dynamic_pointer_cast<IHistogramBin>(shared_from_this());
            else if (classifier == typeid(IHistogramBinWriter).name())
                return std::dynamic_pointer_cast<IHistogramBinWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> HistogramBinImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t HistogramBinImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int HistogramBinImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double HistogramBinImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
                {
                    return GetWeight();
                }
                throw KeyNotSupportedException();

        }

        uint16_t HistogramBinImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool HistogramBinImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime HistogramBinImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> HistogramBinImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string HistogramBinImpl::GetModelType() const
        {
            return "HistogramBin";
        }

        void HistogramBinImpl::WriteParameterToWeight(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__WEIGHT, parameterName, nullTextMarker /*no textmarker*/);
            _weight = {};
        }

        std::string HistogramBinImpl::GetParameterFromWeight() const
        {
            auto weight = OSC_CONSTANTS::ATTRIBUTE__WEIGHT;
            return GetParameterNameFromAttribute(weight);
        }

        bool HistogramBinImpl::IsWeightParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__WEIGHT);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IRangeWriter> HistogramBinImpl::GetWriterRange() const
        {
            return std::dynamic_pointer_cast<IRangeWriter>(_range);
        }

        HistogramBinImpl::HistogramBinImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__WEIGHT, SimpleType::DOUBLE);
        }

        void HistogramBinImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
            {
                // Simple type
                _weight = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType HistogramBinImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> HistogramBinImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRange =  GetWriterRange();
                if (kRange)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRange));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> HistogramBinImpl::Clone()
        {
            auto clonedObject = std::make_shared<HistogramBinImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_weight = GetWeight();
            // clone indicators
            // clone children
            const auto kRange =  GetWriterRange();
            if (kRange)
            {
                auto clonedChild = std::dynamic_pointer_cast<RangeImpl>(kRange)->Clone();
                auto clonedChildIRange = std::dynamic_pointer_cast<IRange>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRange(std::dynamic_pointer_cast<IRangeWriter>(clonedChildIRange));
            }
            return clonedObject;
        }

        std::string HistogramBinImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> HistogramBinImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RANGE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRange());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> HistogramBinImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> HistogramBinImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string HistogramBinImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void HistogramBinImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
            {
                // Simple type
                _weight = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* InRoutePositionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IPositionOfCurrentEntity> InRoutePositionImpl::GetFromCurrentEntity() const
        {
        	  return _fromCurrentEntity;
        }
        std::shared_ptr<IPositionInRoadCoordinates> InRoutePositionImpl::GetFromRoadCoordinates() const
        {
        	  return _fromRoadCoordinates;
        }
        std::shared_ptr<IPositionInLaneCoordinates> InRoutePositionImpl::GetFromLaneCoordinates() const
        {
        	  return _fromLaneCoordinates;
        }


        void InRoutePositionImpl::SetFromCurrentEntity(std::shared_ptr<IPositionOfCurrentEntityWriter> fromCurrentEntity)
        {
            _fromCurrentEntity = fromCurrentEntity;
            _fromRoadCoordinates = {};
            _fromLaneCoordinates = {};
			// set the indicator to true
            isSetFromCurrentEntity = true;          
        }

        void InRoutePositionImpl::SetFromRoadCoordinates(std::shared_ptr<IPositionInRoadCoordinatesWriter> fromRoadCoordinates)
        {
            _fromRoadCoordinates = fromRoadCoordinates;
            _fromCurrentEntity = {};
            _fromLaneCoordinates = {};
			// set the indicator to true
            isSetFromRoadCoordinates = true;          
        }

        void InRoutePositionImpl::SetFromLaneCoordinates(std::shared_ptr<IPositionInLaneCoordinatesWriter> fromLaneCoordinates)
        {
            _fromLaneCoordinates = fromLaneCoordinates;
            _fromCurrentEntity = {};
            _fromRoadCoordinates = {};
			// set the indicator to true
            isSetFromLaneCoordinates = true;          
        }

        std::shared_ptr<void> InRoutePositionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(InRoutePositionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IInRoutePosition).name())
                return std::dynamic_pointer_cast<IInRoutePosition>(shared_from_this());
            else if (classifier == typeid(IInRoutePositionWriter).name())
                return std::dynamic_pointer_cast<IInRoutePositionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> InRoutePositionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t InRoutePositionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int InRoutePositionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double InRoutePositionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t InRoutePositionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool InRoutePositionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime InRoutePositionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> InRoutePositionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string InRoutePositionImpl::GetModelType() const
        {
            return "InRoutePosition";
        }

            // children
        std::shared_ptr<IPositionOfCurrentEntityWriter> InRoutePositionImpl::GetWriterFromCurrentEntity() const
        {
            return std::dynamic_pointer_cast<IPositionOfCurrentEntityWriter>(_fromCurrentEntity);
        }
        std::shared_ptr<IPositionInRoadCoordinatesWriter> InRoutePositionImpl::GetWriterFromRoadCoordinates() const
        {
            return std::dynamic_pointer_cast<IPositionInRoadCoordinatesWriter>(_fromRoadCoordinates);
        }
        std::shared_ptr<IPositionInLaneCoordinatesWriter> InRoutePositionImpl::GetWriterFromLaneCoordinates() const
        {
            return std::dynamic_pointer_cast<IPositionInLaneCoordinatesWriter>(_fromLaneCoordinates);
        }

        InRoutePositionImpl::InRoutePositionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void InRoutePositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType InRoutePositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> InRoutePositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kFromCurrentEntity =  GetWriterFromCurrentEntity();
                if (kFromCurrentEntity)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kFromCurrentEntity));
                }
                const auto kFromRoadCoordinates =  GetWriterFromRoadCoordinates();
                if (kFromRoadCoordinates)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kFromRoadCoordinates));
                }
                const auto kFromLaneCoordinates =  GetWriterFromLaneCoordinates();
                if (kFromLaneCoordinates)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kFromLaneCoordinates));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> InRoutePositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<InRoutePositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kFromCurrentEntity =  GetWriterFromCurrentEntity();
            if (kFromCurrentEntity)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionOfCurrentEntityImpl>(kFromCurrentEntity)->Clone();
                auto clonedChildIPositionOfCurrentEntity = std::dynamic_pointer_cast<IPositionOfCurrentEntity>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetFromCurrentEntity(std::dynamic_pointer_cast<IPositionOfCurrentEntityWriter>(clonedChildIPositionOfCurrentEntity));
            }
            const auto kFromRoadCoordinates =  GetWriterFromRoadCoordinates();
            if (kFromRoadCoordinates)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionInRoadCoordinatesImpl>(kFromRoadCoordinates)->Clone();
                auto clonedChildIPositionInRoadCoordinates = std::dynamic_pointer_cast<IPositionInRoadCoordinates>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetFromRoadCoordinates(std::dynamic_pointer_cast<IPositionInRoadCoordinatesWriter>(clonedChildIPositionInRoadCoordinates));
            }
            const auto kFromLaneCoordinates =  GetWriterFromLaneCoordinates();
            if (kFromLaneCoordinates)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionInLaneCoordinatesImpl>(kFromLaneCoordinates)->Clone();
                auto clonedChildIPositionInLaneCoordinates = std::dynamic_pointer_cast<IPositionInLaneCoordinates>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetFromLaneCoordinates(std::dynamic_pointer_cast<IPositionInLaneCoordinatesWriter>(clonedChildIPositionInLaneCoordinates));
            }
            return clonedObject;
        }

        std::string InRoutePositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> InRoutePositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__FROM_CURRENT_ENTITY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetFromCurrentEntity());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__FROM_ROAD_COORDINATES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetFromRoadCoordinates());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__FROM_LANE_COORDINATES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetFromLaneCoordinates());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> InRoutePositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> InRoutePositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string InRoutePositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void InRoutePositionImpl::ResetFromCurrentEntity()
	   {
	   		isSetFromCurrentEntity = false; 
			_fromCurrentEntity = {};
			
	   }
       bool InRoutePositionImpl::IsSetFromCurrentEntity() const
	   {
			return isSetFromCurrentEntity;
	   }
       void InRoutePositionImpl::ResetFromRoadCoordinates()
	   {
	   		isSetFromRoadCoordinates = false; 
			_fromRoadCoordinates = {};
			
	   }
       bool InRoutePositionImpl::IsSetFromRoadCoordinates() const
	   {
			return isSetFromRoadCoordinates;
	   }
       void InRoutePositionImpl::ResetFromLaneCoordinates()
	   {
	   		isSetFromLaneCoordinates = false; 
			_fromLaneCoordinates = {};
			
	   }
       bool InRoutePositionImpl::IsSetFromLaneCoordinates() const
	   {
			return isSetFromLaneCoordinates;
	   }

        IOpenScenarioFlexElement* InfrastructureActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<ITrafficSignalAction> InfrastructureActionImpl::GetTrafficSignalAction() const
        {
        	  return _trafficSignalAction;
        }


        void InfrastructureActionImpl::SetTrafficSignalAction(std::shared_ptr<ITrafficSignalActionWriter> trafficSignalAction)
        {
            _trafficSignalAction = trafficSignalAction;
        }

        std::shared_ptr<void> InfrastructureActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(InfrastructureActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IInfrastructureAction).name())
                return std::dynamic_pointer_cast<IInfrastructureAction>(shared_from_this());
            else if (classifier == typeid(IInfrastructureActionWriter).name())
                return std::dynamic_pointer_cast<IInfrastructureActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> InfrastructureActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t InfrastructureActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int InfrastructureActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double InfrastructureActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t InfrastructureActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool InfrastructureActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime InfrastructureActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> InfrastructureActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string InfrastructureActionImpl::GetModelType() const
        {
            return "InfrastructureAction";
        }

            // children
        std::shared_ptr<ITrafficSignalActionWriter> InfrastructureActionImpl::GetWriterTrafficSignalAction() const
        {
            return std::dynamic_pointer_cast<ITrafficSignalActionWriter>(_trafficSignalAction);
        }

        InfrastructureActionImpl::InfrastructureActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void InfrastructureActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType InfrastructureActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> InfrastructureActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kTrafficSignalAction =  GetWriterTrafficSignalAction();
                if (kTrafficSignalAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficSignalAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> InfrastructureActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<InfrastructureActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kTrafficSignalAction =  GetWriterTrafficSignalAction();
            if (kTrafficSignalAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficSignalActionImpl>(kTrafficSignalAction)->Clone();
                auto clonedChildITrafficSignalAction = std::dynamic_pointer_cast<ITrafficSignalAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficSignalAction(std::dynamic_pointer_cast<ITrafficSignalActionWriter>(clonedChildITrafficSignalAction));
            }
            return clonedObject;
        }

        std::string InfrastructureActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> InfrastructureActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SIGNAL_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficSignalAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> InfrastructureActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> InfrastructureActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string InfrastructureActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* InitImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IInitActions> InitImpl::GetActions() const
        {
        	  return _actions;
        }


        void InitImpl::SetActions(std::shared_ptr<IInitActionsWriter> actions)
        {
            _actions = actions;
        }

        std::shared_ptr<void> InitImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(InitImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IInit).name())
                return std::dynamic_pointer_cast<IInit>(shared_from_this());
            else if (classifier == typeid(IInitWriter).name())
                return std::dynamic_pointer_cast<IInitWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> InitImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t InitImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int InitImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double InitImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t InitImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool InitImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime InitImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> InitImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string InitImpl::GetModelType() const
        {
            return "Init";
        }

            // children
        std::shared_ptr<IInitActionsWriter> InitImpl::GetWriterActions() const
        {
            return std::dynamic_pointer_cast<IInitActionsWriter>(_actions);
        }

        InitImpl::InitImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void InitImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType InitImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> InitImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kActions =  GetWriterActions();
                if (kActions)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kActions));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> InitImpl::Clone()
        {
            auto clonedObject = std::make_shared<InitImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kActions =  GetWriterActions();
            if (kActions)
            {
                auto clonedChild = std::dynamic_pointer_cast<InitActionsImpl>(kActions)->Clone();
                auto clonedChildIInitActions = std::dynamic_pointer_cast<IInitActions>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetActions(std::dynamic_pointer_cast<IInitActionsWriter>(clonedChildIInitActions));
            }
            return clonedObject;
        }

        std::string InitImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> InitImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ACTIONS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetActions());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> InitImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> InitImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string InitImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* InitActionsImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<IGlobalAction>> InitActionsImpl::GetGlobalActions() const
        {
            std::vector<std::shared_ptr<IGlobalAction>> temp;
            for(auto&& elm: _globalActions)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IGlobalActionWriter>> InitActionsImpl::GetWriterGlobalActions() const
        {
            return _globalActions;
        }

        int InitActionsImpl::GetGlobalActionsSize() const
        {
            return static_cast<int>(_globalActions.size());
        }

        std::shared_ptr<IGlobalAction> InitActionsImpl::GetGlobalActionsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _globalActions.size() > index)
            {
                return _globalActions[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<IUserDefinedAction>> InitActionsImpl::GetUserDefinedActions() const
        {
            std::vector<std::shared_ptr<IUserDefinedAction>> temp;
            for(auto&& elm: _userDefinedActions)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IUserDefinedActionWriter>> InitActionsImpl::GetWriterUserDefinedActions() const
        {
            return _userDefinedActions;
        }

        int InitActionsImpl::GetUserDefinedActionsSize() const
        {
            return static_cast<int>(_userDefinedActions.size());
        }

        std::shared_ptr<IUserDefinedAction> InitActionsImpl::GetUserDefinedActionsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _userDefinedActions.size() > index)
            {
                return _userDefinedActions[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<IPrivate>> InitActionsImpl::GetPrivates() const
        {
            std::vector<std::shared_ptr<IPrivate>> temp;
            for(auto&& elm: _privates)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IPrivateWriter>> InitActionsImpl::GetWriterPrivates() const
        {
            return _privates;
        }

        int InitActionsImpl::GetPrivatesSize() const
        {
            return static_cast<int>(_privates.size());
        }

        std::shared_ptr<IPrivate> InitActionsImpl::GetPrivatesAtIndex(unsigned int index) const
        {
            if (index >= 0 && _privates.size() > index)
            {
                return _privates[index];
            }
            return nullptr;
        }


        void InitActionsImpl::SetGlobalActions(std::vector<std::shared_ptr<IGlobalActionWriter>>& globalActions)
        {
            _globalActions = globalActions;
			// set the indicator to true
            isSetGlobalActions = true;          
        }

        void InitActionsImpl::SetUserDefinedActions(std::vector<std::shared_ptr<IUserDefinedActionWriter>>& userDefinedActions)
        {
            _userDefinedActions = userDefinedActions;
			// set the indicator to true
            isSetUserDefinedActions = true;          
        }

        void InitActionsImpl::SetPrivates(std::vector<std::shared_ptr<IPrivateWriter>>& privates)
        {
            _privates = privates;
			// set the indicator to true
            isSetPrivates = true;          
        }

        std::shared_ptr<void> InitActionsImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(InitActionsImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IInitActions).name())
                return std::dynamic_pointer_cast<IInitActions>(shared_from_this());
            else if (classifier == typeid(IInitActionsWriter).name())
                return std::dynamic_pointer_cast<IInitActionsWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> InitActionsImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t InitActionsImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int InitActionsImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double InitActionsImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t InitActionsImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool InitActionsImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime InitActionsImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> InitActionsImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string InitActionsImpl::GetModelType() const
        {
            return "InitActions";
        }

            // children

        InitActionsImpl::InitActionsImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void InitActionsImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType InitActionsImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> InitActionsImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto globalActions =  GetWriterGlobalActions();
                if (!globalActions.empty())
                {
                    for(auto&& item : globalActions)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto userDefinedActions =  GetWriterUserDefinedActions();
                if (!userDefinedActions.empty())
                {
                    for(auto&& item : userDefinedActions)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto privates =  GetWriterPrivates();
                if (!privates.empty())
                {
                    for(auto&& item : privates)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> InitActionsImpl::Clone()
        {
            auto clonedObject = std::make_shared<InitActionsImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kGlobalActions =  GetWriterGlobalActions();
            if (!kGlobalActions.empty())
            {
                std::vector<std::shared_ptr<IGlobalActionWriter>> clonedList;
                for(auto&& kItem : kGlobalActions)
                {
                    auto clonedChild = std::dynamic_pointer_cast<GlobalActionImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IGlobalActionWriter>(clonedChild));
                }
                clonedObject->SetGlobalActions(clonedList);
            }
            const auto kUserDefinedActions =  GetWriterUserDefinedActions();
            if (!kUserDefinedActions.empty())
            {
                std::vector<std::shared_ptr<IUserDefinedActionWriter>> clonedList;
                for(auto&& kItem : kUserDefinedActions)
                {
                    auto clonedChild = std::dynamic_pointer_cast<UserDefinedActionImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IUserDefinedActionWriter>(clonedChild));
                }
                clonedObject->SetUserDefinedActions(clonedList);
            }
            const auto kPrivates =  GetWriterPrivates();
            if (!kPrivates.empty())
            {
                std::vector<std::shared_ptr<IPrivateWriter>> clonedList;
                for(auto&& kItem : kPrivates)
                {
                    auto clonedChild = std::dynamic_pointer_cast<PrivateImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IPrivateWriter>(clonedChild));
                }
                clonedObject->SetPrivates(clonedList);
            }
            return clonedObject;
        }

        std::string InitActionsImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> InitActionsImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> InitActionsImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__GLOBAL_ACTION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetGlobalActions())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__USER_DEFINED_ACTION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetUserDefinedActions())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__PRIVATE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetPrivates())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> InitActionsImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string InitActionsImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void InitActionsImpl::ResetGlobalActions()
	   {
	   		isSetGlobalActions = false; 
			_globalActions = {};
			
	   }
       bool InitActionsImpl::IsSetGlobalActions() const
	   {
			return isSetGlobalActions;
	   }
       void InitActionsImpl::ResetUserDefinedActions()
	   {
	   		isSetUserDefinedActions = false; 
			_userDefinedActions = {};
			
	   }
       bool InitActionsImpl::IsSetUserDefinedActions() const
	   {
			return isSetUserDefinedActions;
	   }
       void InitActionsImpl::ResetPrivates()
	   {
	   		isSetPrivates = false; 
			_privates = {};
			
	   }
       bool InitActionsImpl::IsSetPrivates() const
	   {
			return isSetPrivates;
	   }

        IOpenScenarioFlexElement* KnotImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double KnotImpl::GetValue() const
        {
        	  return _value;
        }


        void KnotImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> KnotImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(KnotImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IKnot).name())
                return std::dynamic_pointer_cast<IKnot>(shared_from_this());
            else if (classifier == typeid(IKnotWriter).name())
                return std::dynamic_pointer_cast<IKnotWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> KnotImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t KnotImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int KnotImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double KnotImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t KnotImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool KnotImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime KnotImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> KnotImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string KnotImpl::GetModelType() const
        {
            return "Knot";
        }

        void KnotImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string KnotImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool KnotImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        KnotImpl::KnotImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void KnotImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType KnotImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> KnotImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> KnotImpl::Clone()
        {
            auto clonedObject = std::make_shared<KnotImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string KnotImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> KnotImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> KnotImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> KnotImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string KnotImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void KnotImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* LaneChangeActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double LaneChangeActionImpl::GetTargetLaneOffset() const
        {
        	  return _targetLaneOffset;
        }
        std::shared_ptr<ITransitionDynamics> LaneChangeActionImpl::GetLaneChangeActionDynamics() const
        {
        	  return _laneChangeActionDynamics;
        }
        std::shared_ptr<ILaneChangeTarget> LaneChangeActionImpl::GetLaneChangeTarget() const
        {
        	  return _laneChangeTarget;
        }


        void LaneChangeActionImpl::SetTargetLaneOffset(const double targetLaneOffset)
        {
            _targetLaneOffset = targetLaneOffset;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TARGET_LANE_OFFSET);
			// set the indicator to true
            isSetTargetLaneOffset = true;          
        }

        void LaneChangeActionImpl::SetLaneChangeActionDynamics(std::shared_ptr<ITransitionDynamicsWriter> laneChangeActionDynamics)
        {
            _laneChangeActionDynamics = laneChangeActionDynamics;
        }

        void LaneChangeActionImpl::SetLaneChangeTarget(std::shared_ptr<ILaneChangeTargetWriter> laneChangeTarget)
        {
            _laneChangeTarget = laneChangeTarget;
        }

        std::shared_ptr<void> LaneChangeActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(LaneChangeActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ILaneChangeAction).name())
                return std::dynamic_pointer_cast<ILaneChangeAction>(shared_from_this());
            else if (classifier == typeid(ILaneChangeActionWriter).name())
                return std::dynamic_pointer_cast<ILaneChangeActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> LaneChangeActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t LaneChangeActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int LaneChangeActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double LaneChangeActionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__TARGET_LANE_OFFSET)
                {
                    return GetTargetLaneOffset();
                }
                throw KeyNotSupportedException();

        }

        uint16_t LaneChangeActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool LaneChangeActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime LaneChangeActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> LaneChangeActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string LaneChangeActionImpl::GetModelType() const
        {
            return "LaneChangeAction";
        }

        void LaneChangeActionImpl::WriteParameterToTargetLaneOffset(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TARGET_LANE_OFFSET, parameterName, nullTextMarker /*no textmarker*/);
            _targetLaneOffset = {};
        }

        std::string LaneChangeActionImpl::GetParameterFromTargetLaneOffset() const
        {
            auto targetLaneOffset = OSC_CONSTANTS::ATTRIBUTE__TARGET_LANE_OFFSET;
            return GetParameterNameFromAttribute(targetLaneOffset);
        }

        bool LaneChangeActionImpl::IsTargetLaneOffsetParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TARGET_LANE_OFFSET);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<ITransitionDynamicsWriter> LaneChangeActionImpl::GetWriterLaneChangeActionDynamics() const
        {
            return std::dynamic_pointer_cast<ITransitionDynamicsWriter>(_laneChangeActionDynamics);
        }
        std::shared_ptr<ILaneChangeTargetWriter> LaneChangeActionImpl::GetWriterLaneChangeTarget() const
        {
            return std::dynamic_pointer_cast<ILaneChangeTargetWriter>(_laneChangeTarget);
        }

        LaneChangeActionImpl::LaneChangeActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TARGET_LANE_OFFSET, SimpleType::DOUBLE);
        }

        void LaneChangeActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TARGET_LANE_OFFSET)
            {
                // Simple type
                _targetLaneOffset = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType LaneChangeActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LaneChangeActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kLaneChangeActionDynamics =  GetWriterLaneChangeActionDynamics();
                if (kLaneChangeActionDynamics)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLaneChangeActionDynamics));
                }
                const auto kLaneChangeTarget =  GetWriterLaneChangeTarget();
                if (kLaneChangeTarget)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLaneChangeTarget));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LaneChangeActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<LaneChangeActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_targetLaneOffset = GetTargetLaneOffset();
            // clone indicators
            	clonedObject->isSetTargetLaneOffset = isSetTargetLaneOffset;
            // clone children
            const auto kLaneChangeActionDynamics =  GetWriterLaneChangeActionDynamics();
            if (kLaneChangeActionDynamics)
            {
                auto clonedChild = std::dynamic_pointer_cast<TransitionDynamicsImpl>(kLaneChangeActionDynamics)->Clone();
                auto clonedChildITransitionDynamics = std::dynamic_pointer_cast<ITransitionDynamics>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLaneChangeActionDynamics(std::dynamic_pointer_cast<ITransitionDynamicsWriter>(clonedChildITransitionDynamics));
            }
            const auto kLaneChangeTarget =  GetWriterLaneChangeTarget();
            if (kLaneChangeTarget)
            {
                auto clonedChild = std::dynamic_pointer_cast<LaneChangeTargetImpl>(kLaneChangeTarget)->Clone();
                auto clonedChildILaneChangeTarget = std::dynamic_pointer_cast<ILaneChangeTarget>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLaneChangeTarget(std::dynamic_pointer_cast<ILaneChangeTargetWriter>(clonedChildILaneChangeTarget));
            }
            return clonedObject;
        }

        std::string LaneChangeActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneChangeActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LANE_CHANGE_ACTION_DYNAMICS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLaneChangeActionDynamics());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LANE_CHANGE_TARGET)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLaneChangeTarget());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LaneChangeActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneChangeActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LaneChangeActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void LaneChangeActionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TARGET_LANE_OFFSET)
            {
                // Simple type
                _targetLaneOffset = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void LaneChangeActionImpl::ResetTargetLaneOffset()
	   {
	   		isSetTargetLaneOffset = false; 
			_targetLaneOffset = {0};
			
	   }
       bool LaneChangeActionImpl::IsSetTargetLaneOffset() const
	   {
			return isSetTargetLaneOffset;
	   }

        IOpenScenarioFlexElement* LaneChangeTargetImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IRelativeTargetLane> LaneChangeTargetImpl::GetRelativeTargetLane() const
        {
        	  return _relativeTargetLane;
        }
        std::shared_ptr<IAbsoluteTargetLane> LaneChangeTargetImpl::GetAbsoluteTargetLane() const
        {
        	  return _absoluteTargetLane;
        }


        void LaneChangeTargetImpl::SetRelativeTargetLane(std::shared_ptr<IRelativeTargetLaneWriter> relativeTargetLane)
        {
            _relativeTargetLane = relativeTargetLane;
            _absoluteTargetLane = {};
			// set the indicator to true
            isSetRelativeTargetLane = true;          
        }

        void LaneChangeTargetImpl::SetAbsoluteTargetLane(std::shared_ptr<IAbsoluteTargetLaneWriter> absoluteTargetLane)
        {
            _absoluteTargetLane = absoluteTargetLane;
            _relativeTargetLane = {};
			// set the indicator to true
            isSetAbsoluteTargetLane = true;          
        }

        std::shared_ptr<void> LaneChangeTargetImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(LaneChangeTargetImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ILaneChangeTarget).name())
                return std::dynamic_pointer_cast<ILaneChangeTarget>(shared_from_this());
            else if (classifier == typeid(ILaneChangeTargetWriter).name())
                return std::dynamic_pointer_cast<ILaneChangeTargetWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> LaneChangeTargetImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t LaneChangeTargetImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int LaneChangeTargetImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double LaneChangeTargetImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t LaneChangeTargetImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool LaneChangeTargetImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime LaneChangeTargetImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> LaneChangeTargetImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string LaneChangeTargetImpl::GetModelType() const
        {
            return "LaneChangeTarget";
        }

            // children
        std::shared_ptr<IRelativeTargetLaneWriter> LaneChangeTargetImpl::GetWriterRelativeTargetLane() const
        {
            return std::dynamic_pointer_cast<IRelativeTargetLaneWriter>(_relativeTargetLane);
        }
        std::shared_ptr<IAbsoluteTargetLaneWriter> LaneChangeTargetImpl::GetWriterAbsoluteTargetLane() const
        {
            return std::dynamic_pointer_cast<IAbsoluteTargetLaneWriter>(_absoluteTargetLane);
        }

        LaneChangeTargetImpl::LaneChangeTargetImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void LaneChangeTargetImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType LaneChangeTargetImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LaneChangeTargetImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRelativeTargetLane =  GetWriterRelativeTargetLane();
                if (kRelativeTargetLane)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeTargetLane));
                }
                const auto kAbsoluteTargetLane =  GetWriterAbsoluteTargetLane();
                if (kAbsoluteTargetLane)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAbsoluteTargetLane));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LaneChangeTargetImpl::Clone()
        {
            auto clonedObject = std::make_shared<LaneChangeTargetImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kRelativeTargetLane =  GetWriterRelativeTargetLane();
            if (kRelativeTargetLane)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeTargetLaneImpl>(kRelativeTargetLane)->Clone();
                auto clonedChildIRelativeTargetLane = std::dynamic_pointer_cast<IRelativeTargetLane>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeTargetLane(std::dynamic_pointer_cast<IRelativeTargetLaneWriter>(clonedChildIRelativeTargetLane));
            }
            const auto kAbsoluteTargetLane =  GetWriterAbsoluteTargetLane();
            if (kAbsoluteTargetLane)
            {
                auto clonedChild = std::dynamic_pointer_cast<AbsoluteTargetLaneImpl>(kAbsoluteTargetLane)->Clone();
                auto clonedChildIAbsoluteTargetLane = std::dynamic_pointer_cast<IAbsoluteTargetLane>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAbsoluteTargetLane(std::dynamic_pointer_cast<IAbsoluteTargetLaneWriter>(clonedChildIAbsoluteTargetLane));
            }
            return clonedObject;
        }

        std::string LaneChangeTargetImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneChangeTargetImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_TARGET_LANE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeTargetLane());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ABSOLUTE_TARGET_LANE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAbsoluteTargetLane());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LaneChangeTargetImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneChangeTargetImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LaneChangeTargetImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void LaneChangeTargetImpl::ResetRelativeTargetLane()
	   {
	   		isSetRelativeTargetLane = false; 
			_relativeTargetLane = {};
			
	   }
       bool LaneChangeTargetImpl::IsSetRelativeTargetLane() const
	   {
			return isSetRelativeTargetLane;
	   }
       void LaneChangeTargetImpl::ResetAbsoluteTargetLane()
	   {
	   		isSetAbsoluteTargetLane = false; 
			_absoluteTargetLane = {};
			
	   }
       bool LaneChangeTargetImpl::IsSetAbsoluteTargetLane() const
	   {
			return isSetAbsoluteTargetLane;
	   }

        IOpenScenarioFlexElement* LaneOffsetActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool LaneOffsetActionImpl::GetContinuous() const
        {
        	  return _continuous;
        }
        std::shared_ptr<ILaneOffsetActionDynamics> LaneOffsetActionImpl::GetLaneOffsetActionDynamics() const
        {
        	  return _laneOffsetActionDynamics;
        }
        std::shared_ptr<ILaneOffsetTarget> LaneOffsetActionImpl::GetLaneOffsetTarget() const
        {
        	  return _laneOffsetTarget;
        }


        void LaneOffsetActionImpl::SetContinuous(const bool continuous)
        {
            _continuous = continuous;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS);
        }

        void LaneOffsetActionImpl::SetLaneOffsetActionDynamics(std::shared_ptr<ILaneOffsetActionDynamicsWriter> laneOffsetActionDynamics)
        {
            _laneOffsetActionDynamics = laneOffsetActionDynamics;
        }

        void LaneOffsetActionImpl::SetLaneOffsetTarget(std::shared_ptr<ILaneOffsetTargetWriter> laneOffsetTarget)
        {
            _laneOffsetTarget = laneOffsetTarget;
        }

        std::shared_ptr<void> LaneOffsetActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(LaneOffsetActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ILaneOffsetAction).name())
                return std::dynamic_pointer_cast<ILaneOffsetAction>(shared_from_this());
            else if (classifier == typeid(ILaneOffsetActionWriter).name())
                return std::dynamic_pointer_cast<ILaneOffsetActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> LaneOffsetActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t LaneOffsetActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int LaneOffsetActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double LaneOffsetActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t LaneOffsetActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool LaneOffsetActionImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS)
                {
                    return GetContinuous();
                }
                throw KeyNotSupportedException();

        }

        DateTime LaneOffsetActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> LaneOffsetActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string LaneOffsetActionImpl::GetModelType() const
        {
            return "LaneOffsetAction";
        }

        void LaneOffsetActionImpl::WriteParameterToContinuous(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS, parameterName, nullTextMarker /*no textmarker*/);
            _continuous = {};
        }

        std::string LaneOffsetActionImpl::GetParameterFromContinuous() const
        {
            auto continuous = OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS;
            return GetParameterNameFromAttribute(continuous);
        }

        bool LaneOffsetActionImpl::IsContinuousParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<ILaneOffsetActionDynamicsWriter> LaneOffsetActionImpl::GetWriterLaneOffsetActionDynamics() const
        {
            return std::dynamic_pointer_cast<ILaneOffsetActionDynamicsWriter>(_laneOffsetActionDynamics);
        }
        std::shared_ptr<ILaneOffsetTargetWriter> LaneOffsetActionImpl::GetWriterLaneOffsetTarget() const
        {
            return std::dynamic_pointer_cast<ILaneOffsetTargetWriter>(_laneOffsetTarget);
        }

        LaneOffsetActionImpl::LaneOffsetActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS, SimpleType::BOOLEAN);
        }

        void LaneOffsetActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS)
            {
                // Simple type
                _continuous = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType LaneOffsetActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LaneOffsetActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kLaneOffsetActionDynamics =  GetWriterLaneOffsetActionDynamics();
                if (kLaneOffsetActionDynamics)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLaneOffsetActionDynamics));
                }
                const auto kLaneOffsetTarget =  GetWriterLaneOffsetTarget();
                if (kLaneOffsetTarget)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLaneOffsetTarget));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LaneOffsetActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<LaneOffsetActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_continuous = GetContinuous();
            // clone indicators
            // clone children
            const auto kLaneOffsetActionDynamics =  GetWriterLaneOffsetActionDynamics();
            if (kLaneOffsetActionDynamics)
            {
                auto clonedChild = std::dynamic_pointer_cast<LaneOffsetActionDynamicsImpl>(kLaneOffsetActionDynamics)->Clone();
                auto clonedChildILaneOffsetActionDynamics = std::dynamic_pointer_cast<ILaneOffsetActionDynamics>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLaneOffsetActionDynamics(std::dynamic_pointer_cast<ILaneOffsetActionDynamicsWriter>(clonedChildILaneOffsetActionDynamics));
            }
            const auto kLaneOffsetTarget =  GetWriterLaneOffsetTarget();
            if (kLaneOffsetTarget)
            {
                auto clonedChild = std::dynamic_pointer_cast<LaneOffsetTargetImpl>(kLaneOffsetTarget)->Clone();
                auto clonedChildILaneOffsetTarget = std::dynamic_pointer_cast<ILaneOffsetTarget>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLaneOffsetTarget(std::dynamic_pointer_cast<ILaneOffsetTargetWriter>(clonedChildILaneOffsetTarget));
            }
            return clonedObject;
        }

        std::string LaneOffsetActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneOffsetActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LANE_OFFSET_ACTION_DYNAMICS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLaneOffsetActionDynamics());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LANE_OFFSET_TARGET)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLaneOffsetTarget());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LaneOffsetActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneOffsetActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LaneOffsetActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void LaneOffsetActionImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS)
            {
                // Simple type
                _continuous = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* LaneOffsetActionDynamicsImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        DynamicsShape LaneOffsetActionDynamicsImpl::GetDynamicsShape() const
        {
        	  return _dynamicsShape;
        }
        double LaneOffsetActionDynamicsImpl::GetMaxLateralAcc() const
        {
        	  return _maxLateralAcc;
        }


        void LaneOffsetActionDynamicsImpl::SetDynamicsShape(const DynamicsShape dynamicsShape)
        {
            _dynamicsShape = dynamicsShape;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE);
        }

        void LaneOffsetActionDynamicsImpl::SetMaxLateralAcc(const double maxLateralAcc)
        {
            _maxLateralAcc = maxLateralAcc;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_LATERAL_ACC);
			// set the indicator to true
            isSetMaxLateralAcc = true;          
        }

        std::shared_ptr<void> LaneOffsetActionDynamicsImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(LaneOffsetActionDynamicsImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ILaneOffsetActionDynamics).name())
                return std::dynamic_pointer_cast<ILaneOffsetActionDynamics>(shared_from_this());
            else if (classifier == typeid(ILaneOffsetActionDynamicsWriter).name())
                return std::dynamic_pointer_cast<ILaneOffsetActionDynamicsWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> LaneOffsetActionDynamicsImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t LaneOffsetActionDynamicsImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int LaneOffsetActionDynamicsImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double LaneOffsetActionDynamicsImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAX_LATERAL_ACC)
                {
                    return GetMaxLateralAcc();
                }
                throw KeyNotSupportedException();

        }

        uint16_t LaneOffsetActionDynamicsImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool LaneOffsetActionDynamicsImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime LaneOffsetActionDynamicsImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> LaneOffsetActionDynamicsImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string LaneOffsetActionDynamicsImpl::GetModelType() const
        {
            return "LaneOffsetActionDynamics";
        }

        void LaneOffsetActionDynamicsImpl::WriteParameterToDynamicsShape(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE, parameterName, nullTextMarker /*no textmarker*/);
            _dynamicsShape = {};
        }

        void LaneOffsetActionDynamicsImpl::WriteParameterToMaxLateralAcc(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_LATERAL_ACC, parameterName, nullTextMarker /*no textmarker*/);
            _maxLateralAcc = {};
        }

        std::string LaneOffsetActionDynamicsImpl::GetParameterFromDynamicsShape() const
        {
            auto dynamicsShape = OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE;
            return GetParameterNameFromAttribute(dynamicsShape);
        }

        std::string LaneOffsetActionDynamicsImpl::GetParameterFromMaxLateralAcc() const
        {
            auto maxLateralAcc = OSC_CONSTANTS::ATTRIBUTE__MAX_LATERAL_ACC;
            return GetParameterNameFromAttribute(maxLateralAcc);
        }

        bool LaneOffsetActionDynamicsImpl::IsDynamicsShapeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LaneOffsetActionDynamicsImpl::IsMaxLateralAccParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAX_LATERAL_ACC);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        LaneOffsetActionDynamicsImpl::LaneOffsetActionDynamicsImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_LATERAL_ACC, SimpleType::DOUBLE);
        }

        void LaneOffsetActionDynamicsImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE)
            {
                // Enumeration Type
                const auto kResult = DynamicsShape::GetFromLiteral(parameterLiteralValue);
                if (kResult != DynamicsShape::UNKNOWN)
                {
                    _dynamicsShape = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_LATERAL_ACC)
            {
                // Simple type
                _maxLateralAcc = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType LaneOffsetActionDynamicsImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LaneOffsetActionDynamicsImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LaneOffsetActionDynamicsImpl::Clone()
        {
            auto clonedObject = std::make_shared<LaneOffsetActionDynamicsImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kDynamicsShape = GetDynamicsShape();
            if ( kDynamicsShape.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_dynamicsShape = DynamicsShape::GetFromLiteral(kDynamicsShape.GetLiteral());
            }
            // Simple type
            clonedObject->_maxLateralAcc = GetMaxLateralAcc();
            // clone indicators
            	clonedObject->isSetMaxLateralAcc = isSetMaxLateralAcc;
            // clone children
            return clonedObject;
        }

        std::string LaneOffsetActionDynamicsImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneOffsetActionDynamicsImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LaneOffsetActionDynamicsImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneOffsetActionDynamicsImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LaneOffsetActionDynamicsImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE)
            {
                auto dynamicsShape = GetDynamicsShape();
                return dynamicsShape.GetLiteral() != "UNKNOWN" ? dynamicsShape.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void LaneOffsetActionDynamicsImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_LATERAL_ACC)
            {
                // Simple type
                _maxLateralAcc = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void LaneOffsetActionDynamicsImpl::ResetMaxLateralAcc()
	   {
	   		isSetMaxLateralAcc = false; 
			_maxLateralAcc = {};
			
	   }
       bool LaneOffsetActionDynamicsImpl::IsSetMaxLateralAcc() const
	   {
			return isSetMaxLateralAcc;
	   }

        IOpenScenarioFlexElement* LaneOffsetTargetImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IRelativeTargetLaneOffset> LaneOffsetTargetImpl::GetRelativeTargetLaneOffset() const
        {
        	  return _relativeTargetLaneOffset;
        }
        std::shared_ptr<IAbsoluteTargetLaneOffset> LaneOffsetTargetImpl::GetAbsoluteTargetLaneOffset() const
        {
        	  return _absoluteTargetLaneOffset;
        }


        void LaneOffsetTargetImpl::SetRelativeTargetLaneOffset(std::shared_ptr<IRelativeTargetLaneOffsetWriter> relativeTargetLaneOffset)
        {
            _relativeTargetLaneOffset = relativeTargetLaneOffset;
            _absoluteTargetLaneOffset = {};
			// set the indicator to true
            isSetRelativeTargetLaneOffset = true;          
        }

        void LaneOffsetTargetImpl::SetAbsoluteTargetLaneOffset(std::shared_ptr<IAbsoluteTargetLaneOffsetWriter> absoluteTargetLaneOffset)
        {
            _absoluteTargetLaneOffset = absoluteTargetLaneOffset;
            _relativeTargetLaneOffset = {};
			// set the indicator to true
            isSetAbsoluteTargetLaneOffset = true;          
        }

        std::shared_ptr<void> LaneOffsetTargetImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(LaneOffsetTargetImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ILaneOffsetTarget).name())
                return std::dynamic_pointer_cast<ILaneOffsetTarget>(shared_from_this());
            else if (classifier == typeid(ILaneOffsetTargetWriter).name())
                return std::dynamic_pointer_cast<ILaneOffsetTargetWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> LaneOffsetTargetImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t LaneOffsetTargetImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int LaneOffsetTargetImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double LaneOffsetTargetImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t LaneOffsetTargetImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool LaneOffsetTargetImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime LaneOffsetTargetImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> LaneOffsetTargetImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string LaneOffsetTargetImpl::GetModelType() const
        {
            return "LaneOffsetTarget";
        }

            // children
        std::shared_ptr<IRelativeTargetLaneOffsetWriter> LaneOffsetTargetImpl::GetWriterRelativeTargetLaneOffset() const
        {
            return std::dynamic_pointer_cast<IRelativeTargetLaneOffsetWriter>(_relativeTargetLaneOffset);
        }
        std::shared_ptr<IAbsoluteTargetLaneOffsetWriter> LaneOffsetTargetImpl::GetWriterAbsoluteTargetLaneOffset() const
        {
            return std::dynamic_pointer_cast<IAbsoluteTargetLaneOffsetWriter>(_absoluteTargetLaneOffset);
        }

        LaneOffsetTargetImpl::LaneOffsetTargetImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void LaneOffsetTargetImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType LaneOffsetTargetImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LaneOffsetTargetImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRelativeTargetLaneOffset =  GetWriterRelativeTargetLaneOffset();
                if (kRelativeTargetLaneOffset)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeTargetLaneOffset));
                }
                const auto kAbsoluteTargetLaneOffset =  GetWriterAbsoluteTargetLaneOffset();
                if (kAbsoluteTargetLaneOffset)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAbsoluteTargetLaneOffset));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LaneOffsetTargetImpl::Clone()
        {
            auto clonedObject = std::make_shared<LaneOffsetTargetImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kRelativeTargetLaneOffset =  GetWriterRelativeTargetLaneOffset();
            if (kRelativeTargetLaneOffset)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeTargetLaneOffsetImpl>(kRelativeTargetLaneOffset)->Clone();
                auto clonedChildIRelativeTargetLaneOffset = std::dynamic_pointer_cast<IRelativeTargetLaneOffset>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeTargetLaneOffset(std::dynamic_pointer_cast<IRelativeTargetLaneOffsetWriter>(clonedChildIRelativeTargetLaneOffset));
            }
            const auto kAbsoluteTargetLaneOffset =  GetWriterAbsoluteTargetLaneOffset();
            if (kAbsoluteTargetLaneOffset)
            {
                auto clonedChild = std::dynamic_pointer_cast<AbsoluteTargetLaneOffsetImpl>(kAbsoluteTargetLaneOffset)->Clone();
                auto clonedChildIAbsoluteTargetLaneOffset = std::dynamic_pointer_cast<IAbsoluteTargetLaneOffset>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAbsoluteTargetLaneOffset(std::dynamic_pointer_cast<IAbsoluteTargetLaneOffsetWriter>(clonedChildIAbsoluteTargetLaneOffset));
            }
            return clonedObject;
        }

        std::string LaneOffsetTargetImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneOffsetTargetImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_TARGET_LANE_OFFSET)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeTargetLaneOffset());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ABSOLUTE_TARGET_LANE_OFFSET)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAbsoluteTargetLaneOffset());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LaneOffsetTargetImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneOffsetTargetImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LaneOffsetTargetImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void LaneOffsetTargetImpl::ResetRelativeTargetLaneOffset()
	   {
	   		isSetRelativeTargetLaneOffset = false; 
			_relativeTargetLaneOffset = {};
			
	   }
       bool LaneOffsetTargetImpl::IsSetRelativeTargetLaneOffset() const
	   {
			return isSetRelativeTargetLaneOffset;
	   }
       void LaneOffsetTargetImpl::ResetAbsoluteTargetLaneOffset()
	   {
	   		isSetAbsoluteTargetLaneOffset = false; 
			_absoluteTargetLaneOffset = {};
			
	   }
       bool LaneOffsetTargetImpl::IsSetAbsoluteTargetLaneOffset() const
	   {
			return isSetAbsoluteTargetLaneOffset;
	   }

        IOpenScenarioFlexElement* LanePositionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string LanePositionImpl::GetLaneId() const
        {
        	  return _laneId;
        }
        double LanePositionImpl::GetOffset() const
        {
        	  return _offset;
        }
        std::string LanePositionImpl::GetRoadId() const
        {
        	  return _roadId;
        }
        double LanePositionImpl::GetS() const
        {
        	  return _s;
        }
        std::shared_ptr<IOrientation> LanePositionImpl::GetOrientation() const
        {
        	  return _orientation;
        }


        void LanePositionImpl::SetLaneId(const std::string laneId)
        {
            _laneId = laneId;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LANE_ID);
        }

        void LanePositionImpl::SetOffset(const double offset)
        {
            _offset = offset;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__OFFSET);
			// set the indicator to true
            isSetOffset = true;          
        }

        void LanePositionImpl::SetRoadId(const std::string roadId)
        {
            _roadId = roadId;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROAD_ID);
        }

        void LanePositionImpl::SetS(const double s)
        {
            _s = s;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__S);
        }

        void LanePositionImpl::SetOrientation(std::shared_ptr<IOrientationWriter> orientation)
        {
            _orientation = orientation;
			// set the indicator to true
            isSetOrientation = true;          
        }

        std::shared_ptr<void> LanePositionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(LanePositionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ILanePosition).name())
                return std::dynamic_pointer_cast<ILanePosition>(shared_from_this());
            else if (classifier == typeid(ILanePositionWriter).name())
                return std::dynamic_pointer_cast<ILanePositionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> LanePositionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t LanePositionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int LanePositionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double LanePositionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__OFFSET)
                {
                    return GetOffset();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__S)
                {
                    return GetS();
                }
                throw KeyNotSupportedException();

        }

        uint16_t LanePositionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool LanePositionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime LanePositionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> LanePositionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string LanePositionImpl::GetModelType() const
        {
            return "LanePosition";
        }

        void LanePositionImpl::WriteParameterToLaneId(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LANE_ID, parameterName, nullTextMarker /*no textmarker*/);
            _laneId = {};
        }

        void LanePositionImpl::WriteParameterToOffset(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__OFFSET, parameterName, nullTextMarker /*no textmarker*/);
            _offset = {};
        }

        void LanePositionImpl::WriteParameterToRoadId(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROAD_ID, parameterName, nullTextMarker /*no textmarker*/);
            _roadId = {};
        }

        void LanePositionImpl::WriteParameterToS(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__S, parameterName, nullTextMarker /*no textmarker*/);
            _s = {};
        }

        std::string LanePositionImpl::GetParameterFromLaneId() const
        {
            auto laneId = OSC_CONSTANTS::ATTRIBUTE__LANE_ID;
            return GetParameterNameFromAttribute(laneId);
        }

        std::string LanePositionImpl::GetParameterFromOffset() const
        {
            auto offset = OSC_CONSTANTS::ATTRIBUTE__OFFSET;
            return GetParameterNameFromAttribute(offset);
        }

        std::string LanePositionImpl::GetParameterFromRoadId() const
        {
            auto roadId = OSC_CONSTANTS::ATTRIBUTE__ROAD_ID;
            return GetParameterNameFromAttribute(roadId);
        }

        std::string LanePositionImpl::GetParameterFromS() const
        {
            auto s = OSC_CONSTANTS::ATTRIBUTE__S;
            return GetParameterNameFromAttribute(s);
        }

        bool LanePositionImpl::IsLaneIdParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__LANE_ID);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LanePositionImpl::IsOffsetParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__OFFSET);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LanePositionImpl::IsRoadIdParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ROAD_ID);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LanePositionImpl::IsSParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__S);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IOrientationWriter> LanePositionImpl::GetWriterOrientation() const
        {
            return std::dynamic_pointer_cast<IOrientationWriter>(_orientation);
        }

        LanePositionImpl::LanePositionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LANE_ID, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__OFFSET, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ROAD_ID, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__S, SimpleType::DOUBLE);
        }

        void LanePositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LANE_ID)
            {
                // Simple type
                _laneId = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__OFFSET)
            {
                // Simple type
                _offset = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ROAD_ID)
            {
                // Simple type
                _roadId = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__S)
            {
                // Simple type
                _s = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType LanePositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LanePositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kOrientation =  GetWriterOrientation();
                if (kOrientation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOrientation));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LanePositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<LanePositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_laneId = GetLaneId();
            // Simple type
            clonedObject->_offset = GetOffset();
            // Simple type
            clonedObject->_roadId = GetRoadId();
            // Simple type
            clonedObject->_s = GetS();
            // clone indicators
            	clonedObject->isSetOffset = isSetOffset;
            // clone children
            const auto kOrientation =  GetWriterOrientation();
            if (kOrientation)
            {
                auto clonedChild = std::dynamic_pointer_cast<OrientationImpl>(kOrientation)->Clone();
                auto clonedChildIOrientation = std::dynamic_pointer_cast<IOrientation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOrientation(std::dynamic_pointer_cast<IOrientationWriter>(clonedChildIOrientation));
            }
            return clonedObject;
        }

        std::string LanePositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__LANE_ID)
            {
                return GetLaneId();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__ROAD_ID)
            {
                return GetRoadId();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LanePositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ORIENTATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOrientation());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LanePositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LanePositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LanePositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void LanePositionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LANE_ID)
            {
                // Simple type
                _laneId = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ROAD_ID)
            {
                // Simple type
                _roadId = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void LanePositionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__OFFSET)
            {
                // Simple type
                _offset = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__S)
            {
                // Simple type
                _s = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void LanePositionImpl::ResetOffset()
	   {
	   		isSetOffset = false; 
			_offset = {0};
			
	   }
       bool LanePositionImpl::IsSetOffset() const
	   {
			return isSetOffset;
	   }
       void LanePositionImpl::ResetOrientation()
	   {
	   		isSetOrientation = false; 
			_orientation = {};
			
	   }
       bool LanePositionImpl::IsSetOrientation() const
	   {
			return isSetOrientation;
	   }

        IOpenScenarioFlexElement* LateralActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<ILaneChangeAction> LateralActionImpl::GetLaneChangeAction() const
        {
        	  return _laneChangeAction;
        }
        std::shared_ptr<ILaneOffsetAction> LateralActionImpl::GetLaneOffsetAction() const
        {
        	  return _laneOffsetAction;
        }
        std::shared_ptr<ILateralDistanceAction> LateralActionImpl::GetLateralDistanceAction() const
        {
        	  return _lateralDistanceAction;
        }


        void LateralActionImpl::SetLaneChangeAction(std::shared_ptr<ILaneChangeActionWriter> laneChangeAction)
        {
            _laneChangeAction = laneChangeAction;
            _laneOffsetAction = {};
            _lateralDistanceAction = {};
			// set the indicator to true
            isSetLaneChangeAction = true;          
        }

        void LateralActionImpl::SetLaneOffsetAction(std::shared_ptr<ILaneOffsetActionWriter> laneOffsetAction)
        {
            _laneOffsetAction = laneOffsetAction;
            _laneChangeAction = {};
            _lateralDistanceAction = {};
			// set the indicator to true
            isSetLaneOffsetAction = true;          
        }

        void LateralActionImpl::SetLateralDistanceAction(std::shared_ptr<ILateralDistanceActionWriter> lateralDistanceAction)
        {
            _lateralDistanceAction = lateralDistanceAction;
            _laneChangeAction = {};
            _laneOffsetAction = {};
			// set the indicator to true
            isSetLateralDistanceAction = true;          
        }

        std::shared_ptr<void> LateralActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(LateralActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ILateralAction).name())
                return std::dynamic_pointer_cast<ILateralAction>(shared_from_this());
            else if (classifier == typeid(ILateralActionWriter).name())
                return std::dynamic_pointer_cast<ILateralActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> LateralActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t LateralActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int LateralActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double LateralActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t LateralActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool LateralActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime LateralActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> LateralActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string LateralActionImpl::GetModelType() const
        {
            return "LateralAction";
        }

            // children
        std::shared_ptr<ILaneChangeActionWriter> LateralActionImpl::GetWriterLaneChangeAction() const
        {
            return std::dynamic_pointer_cast<ILaneChangeActionWriter>(_laneChangeAction);
        }
        std::shared_ptr<ILaneOffsetActionWriter> LateralActionImpl::GetWriterLaneOffsetAction() const
        {
            return std::dynamic_pointer_cast<ILaneOffsetActionWriter>(_laneOffsetAction);
        }
        std::shared_ptr<ILateralDistanceActionWriter> LateralActionImpl::GetWriterLateralDistanceAction() const
        {
            return std::dynamic_pointer_cast<ILateralDistanceActionWriter>(_lateralDistanceAction);
        }

        LateralActionImpl::LateralActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void LateralActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType LateralActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LateralActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kLaneChangeAction =  GetWriterLaneChangeAction();
                if (kLaneChangeAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLaneChangeAction));
                }
                const auto kLaneOffsetAction =  GetWriterLaneOffsetAction();
                if (kLaneOffsetAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLaneOffsetAction));
                }
                const auto kLateralDistanceAction =  GetWriterLateralDistanceAction();
                if (kLateralDistanceAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLateralDistanceAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LateralActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<LateralActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kLaneChangeAction =  GetWriterLaneChangeAction();
            if (kLaneChangeAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<LaneChangeActionImpl>(kLaneChangeAction)->Clone();
                auto clonedChildILaneChangeAction = std::dynamic_pointer_cast<ILaneChangeAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLaneChangeAction(std::dynamic_pointer_cast<ILaneChangeActionWriter>(clonedChildILaneChangeAction));
            }
            const auto kLaneOffsetAction =  GetWriterLaneOffsetAction();
            if (kLaneOffsetAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<LaneOffsetActionImpl>(kLaneOffsetAction)->Clone();
                auto clonedChildILaneOffsetAction = std::dynamic_pointer_cast<ILaneOffsetAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLaneOffsetAction(std::dynamic_pointer_cast<ILaneOffsetActionWriter>(clonedChildILaneOffsetAction));
            }
            const auto kLateralDistanceAction =  GetWriterLateralDistanceAction();
            if (kLateralDistanceAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<LateralDistanceActionImpl>(kLateralDistanceAction)->Clone();
                auto clonedChildILateralDistanceAction = std::dynamic_pointer_cast<ILateralDistanceAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLateralDistanceAction(std::dynamic_pointer_cast<ILateralDistanceActionWriter>(clonedChildILateralDistanceAction));
            }
            return clonedObject;
        }

        std::string LateralActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LateralActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LANE_CHANGE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLaneChangeAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LANE_OFFSET_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLaneOffsetAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LATERAL_DISTANCE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLateralDistanceAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LateralActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LateralActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LateralActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void LateralActionImpl::ResetLaneChangeAction()
	   {
	   		isSetLaneChangeAction = false; 
			_laneChangeAction = {};
			
	   }
       bool LateralActionImpl::IsSetLaneChangeAction() const
	   {
			return isSetLaneChangeAction;
	   }
       void LateralActionImpl::ResetLaneOffsetAction()
	   {
	   		isSetLaneOffsetAction = false; 
			_laneOffsetAction = {};
			
	   }
       bool LateralActionImpl::IsSetLaneOffsetAction() const
	   {
			return isSetLaneOffsetAction;
	   }
       void LateralActionImpl::ResetLateralDistanceAction()
	   {
	   		isSetLateralDistanceAction = false; 
			_lateralDistanceAction = {};
			
	   }
       bool LateralActionImpl::IsSetLateralDistanceAction() const
	   {
			return isSetLateralDistanceAction;
	   }

        IOpenScenarioFlexElement* LateralDistanceActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool LateralDistanceActionImpl::GetContinuous() const
        {
        	  return _continuous;
        }
        CoordinateSystem LateralDistanceActionImpl::GetCoordinateSystem() const
        {
        	  return _coordinateSystem;
        }
        LateralDisplacement LateralDistanceActionImpl::GetDisplacement() const
        {
        	  return _displacement;
        }
        double LateralDistanceActionImpl::GetDistance() const
        {
        	  return _distance;
        }
        std::shared_ptr<INamedReference<IEntity>> LateralDistanceActionImpl::GetEntityRef() const
        {
        	 return _entityRef;
        }
        bool LateralDistanceActionImpl::GetFreespace() const
        {
        	  return _freespace;
        }
        std::shared_ptr<IDynamicConstraints> LateralDistanceActionImpl::GetDynamicConstraints() const
        {
        	  return _dynamicConstraints;
        }


        void LateralDistanceActionImpl::SetContinuous(const bool continuous)
        {
            _continuous = continuous;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS);
        }

        void LateralDistanceActionImpl::SetCoordinateSystem(const CoordinateSystem coordinateSystem)
        {
            _coordinateSystem = coordinateSystem;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM);
			// set the indicator to true
            isSetCoordinateSystem = true;          
        }

        void LateralDistanceActionImpl::SetDisplacement(const LateralDisplacement displacement)
        {
            _displacement = displacement;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DISPLACEMENT);
			// set the indicator to true
            isSetDisplacement = true;          
        }

        void LateralDistanceActionImpl::SetDistance(const double distance)
        {
            _distance = distance;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DISTANCE);
			// set the indicator to true
            isSetDistance = true;          
        }

        void LateralDistanceActionImpl::SetEntityRef(std::shared_ptr<INamedReference<IEntity>> entityRef)
        {
            _entityRef = entityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
        }

        void LateralDistanceActionImpl::SetFreespace(const bool freespace)
        {
            _freespace = freespace;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FREESPACE);
        }

        void LateralDistanceActionImpl::SetDynamicConstraints(std::shared_ptr<IDynamicConstraintsWriter> dynamicConstraints)
        {
            _dynamicConstraints = dynamicConstraints;
			// set the indicator to true
            isSetDynamicConstraints = true;          
        }

        std::shared_ptr<void> LateralDistanceActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(LateralDistanceActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ILateralDistanceAction).name())
                return std::dynamic_pointer_cast<ILateralDistanceAction>(shared_from_this());
            else if (classifier == typeid(ILateralDistanceActionWriter).name())
                return std::dynamic_pointer_cast<ILateralDistanceActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> LateralDistanceActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t LateralDistanceActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int LateralDistanceActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double LateralDistanceActionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__DISTANCE)
                {
                    return GetDistance();
                }
                throw KeyNotSupportedException();

        }

        uint16_t LateralDistanceActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool LateralDistanceActionImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS)
                {
                    return GetContinuous();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
                {
                    return GetFreespace();
                }
                throw KeyNotSupportedException();

        }

        DateTime LateralDistanceActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> LateralDistanceActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string LateralDistanceActionImpl::GetModelType() const
        {
            return "LateralDistanceAction";
        }

        void LateralDistanceActionImpl::WriteParameterToContinuous(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS, parameterName, nullTextMarker /*no textmarker*/);
            _continuous = {};
        }

        void LateralDistanceActionImpl::WriteParameterToCoordinateSystem(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM, parameterName, nullTextMarker /*no textmarker*/);
            _coordinateSystem = {};
        }

        void LateralDistanceActionImpl::WriteParameterToDisplacement(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DISPLACEMENT, parameterName, nullTextMarker /*no textmarker*/);
            _displacement = {};
        }

        void LateralDistanceActionImpl::WriteParameterToDistance(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DISTANCE, parameterName, nullTextMarker /*no textmarker*/);
            _distance = {};
        }

        void LateralDistanceActionImpl::WriteParameterToEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _entityRef = {};
        }

        void LateralDistanceActionImpl::WriteParameterToFreespace(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FREESPACE, parameterName, nullTextMarker /*no textmarker*/);
            _freespace = {};
        }

        std::string LateralDistanceActionImpl::GetParameterFromContinuous() const
        {
            auto continuous = OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS;
            return GetParameterNameFromAttribute(continuous);
        }

        std::string LateralDistanceActionImpl::GetParameterFromCoordinateSystem() const
        {
            auto coordinateSystem = OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM;
            return GetParameterNameFromAttribute(coordinateSystem);
        }

        std::string LateralDistanceActionImpl::GetParameterFromDisplacement() const
        {
            auto displacement = OSC_CONSTANTS::ATTRIBUTE__DISPLACEMENT;
            return GetParameterNameFromAttribute(displacement);
        }

        std::string LateralDistanceActionImpl::GetParameterFromDistance() const
        {
            auto distance = OSC_CONSTANTS::ATTRIBUTE__DISTANCE;
            return GetParameterNameFromAttribute(distance);
        }

        std::string LateralDistanceActionImpl::GetParameterFromEntityRef() const
        {
            auto entityRef = OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF;
            return GetParameterNameFromAttribute(entityRef);
        }

        std::string LateralDistanceActionImpl::GetParameterFromFreespace() const
        {
            auto freespace = OSC_CONSTANTS::ATTRIBUTE__FREESPACE;
            return GetParameterNameFromAttribute(freespace);
        }

        bool LateralDistanceActionImpl::IsContinuousParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LateralDistanceActionImpl::IsCoordinateSystemParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LateralDistanceActionImpl::IsDisplacementParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DISPLACEMENT);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LateralDistanceActionImpl::IsDistanceParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DISTANCE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LateralDistanceActionImpl::IsEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LateralDistanceActionImpl::IsFreespaceParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__FREESPACE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IDynamicConstraintsWriter> LateralDistanceActionImpl::GetWriterDynamicConstraints() const
        {
            return std::dynamic_pointer_cast<IDynamicConstraintsWriter>(_dynamicConstraints);
        }

        LateralDistanceActionImpl::LateralDistanceActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DISPLACEMENT, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DISTANCE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FREESPACE, SimpleType::BOOLEAN);
        }

        void LateralDistanceActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS)
            {
                // Simple type
                _continuous = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM)
            {
                // Enumeration Type
                const auto kResult = CoordinateSystem::GetFromLiteral(parameterLiteralValue);
                if (kResult != CoordinateSystem::UNKNOWN)
                {
                    _coordinateSystem = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DISPLACEMENT)
            {
                // Enumeration Type
                const auto kResult = LateralDisplacement::GetFromLiteral(parameterLiteralValue);
                if (kResult != LateralDisplacement::UNKNOWN)
                {
                    _displacement = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DISTANCE)
            {
                // Simple type
                _distance = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
            {
                // Simple type
                _freespace = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType LateralDistanceActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LateralDistanceActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDynamicConstraints =  GetWriterDynamicConstraints();
                if (kDynamicConstraints)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDynamicConstraints));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LateralDistanceActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<LateralDistanceActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_continuous = GetContinuous();
            // Enumeration Type
            const auto kCoordinateSystem = GetCoordinateSystem();
            if ( kCoordinateSystem.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_coordinateSystem = CoordinateSystem::GetFromLiteral(kCoordinateSystem.GetLiteral());
            }
            // Enumeration Type
            const auto kDisplacement = GetDisplacement();
            if ( kDisplacement.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_displacement = LateralDisplacement::GetFromLiteral(kDisplacement.GetLiteral());
            }
            // Simple type
            clonedObject->_distance = GetDistance();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Simple type
            clonedObject->_freespace = GetFreespace();
            // clone indicators
            	clonedObject->isSetCoordinateSystem = isSetCoordinateSystem;
            	clonedObject->isSetDisplacement = isSetDisplacement;
            	clonedObject->isSetDistance = isSetDistance;
            // clone children
            const auto kDynamicConstraints =  GetWriterDynamicConstraints();
            if (kDynamicConstraints)
            {
                auto clonedChild = std::dynamic_pointer_cast<DynamicConstraintsImpl>(kDynamicConstraints)->Clone();
                auto clonedChildIDynamicConstraints = std::dynamic_pointer_cast<IDynamicConstraints>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDynamicConstraints(std::dynamic_pointer_cast<IDynamicConstraintsWriter>(clonedChildIDynamicConstraints));
            }
            return clonedObject;
        }

        std::string LateralDistanceActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LateralDistanceActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DYNAMIC_CONSTRAINTS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDynamicConstraints());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LateralDistanceActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LateralDistanceActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string LateralDistanceActionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM)
            {
                auto coordinateSystem = GetCoordinateSystem();
                return coordinateSystem.GetLiteral() != "UNKNOWN" ? coordinateSystem.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__DISPLACEMENT)
            {
                auto displacement = GetDisplacement();
                return displacement.GetLiteral() != "UNKNOWN" ? displacement.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void LateralDistanceActionImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS)
            {
                // Simple type
                _continuous = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
            {
                // Simple type
                _freespace = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void LateralDistanceActionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DISTANCE)
            {
                // Simple type
                _distance = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void LateralDistanceActionImpl::ResetCoordinateSystem()
	   {
	   		isSetCoordinateSystem = false; 
			_coordinateSystem = {CoordinateSystem::CoordinateSystemEnum::ENTITY};
			
	   }
       bool LateralDistanceActionImpl::IsSetCoordinateSystem() const
	   {
			return isSetCoordinateSystem;
	   }
       void LateralDistanceActionImpl::ResetDisplacement()
	   {
	   		isSetDisplacement = false; 
			_displacement = {LateralDisplacement::LateralDisplacementEnum::ANY};
			
	   }
       bool LateralDistanceActionImpl::IsSetDisplacement() const
	   {
			return isSetDisplacement;
	   }
       void LateralDistanceActionImpl::ResetDistance()
	   {
	   		isSetDistance = false; 
			_distance = {0};
			
	   }
       bool LateralDistanceActionImpl::IsSetDistance() const
	   {
			return isSetDistance;
	   }
       void LateralDistanceActionImpl::ResetDynamicConstraints()
	   {
	   		isSetDynamicConstraints = false; 
			_dynamicConstraints = {};
			
	   }
       bool LateralDistanceActionImpl::IsSetDynamicConstraints() const
	   {
			return isSetDynamicConstraints;
	   }

        IOpenScenarioFlexElement* LicenseImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string LicenseImpl::GetText() const
        {
        	  return _text;
        }
        std::string LicenseImpl::GetName() const
        {
        	  return _name;
        }
        std::string LicenseImpl::GetResource() const
        {
        	  return _resource;
        }
        std::string LicenseImpl::GetSpdxId() const
        {
        	  return _spdxId;
        }


        void LicenseImpl::SetText(const std::string text)
        {
            _text = text;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TEXT);
			// set the indicator to true
            isSetText = true;          
        }

        void LicenseImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void LicenseImpl::SetResource(const std::string resource)
        {
            _resource = resource;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RESOURCE);
			// set the indicator to true
            isSetResource = true;          
        }

        void LicenseImpl::SetSpdxId(const std::string spdxId)
        {
            _spdxId = spdxId;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SPDX_ID);
			// set the indicator to true
            isSetSpdxId = true;          
        }

        std::shared_ptr<void> LicenseImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(LicenseImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ILicense).name())
                return std::dynamic_pointer_cast<ILicense>(shared_from_this());
            else if (classifier == typeid(ILicenseWriter).name())
                return std::dynamic_pointer_cast<ILicenseWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> LicenseImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t LicenseImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int LicenseImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double LicenseImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t LicenseImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool LicenseImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime LicenseImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> LicenseImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string LicenseImpl::GetModelType() const
        {
            return "License";
        }

        void LicenseImpl::WriteParameterToText(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TEXT, parameterName, nullTextMarker /*no textmarker*/);
            _text = {};
        }

        void LicenseImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        void LicenseImpl::WriteParameterToResource(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RESOURCE, parameterName, nullTextMarker /*no textmarker*/);
            _resource = {};
        }

        void LicenseImpl::WriteParameterToSpdxId(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SPDX_ID, parameterName, nullTextMarker /*no textmarker*/);
            _spdxId = {};
        }

        std::string LicenseImpl::GetParameterFromText() const
        {
            auto text = OSC_CONSTANTS::ATTRIBUTE__TEXT;
            return GetParameterNameFromAttribute(text);
        }

        std::string LicenseImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        std::string LicenseImpl::GetParameterFromResource() const
        {
            auto resource = OSC_CONSTANTS::ATTRIBUTE__RESOURCE;
            return GetParameterNameFromAttribute(resource);
        }

        std::string LicenseImpl::GetParameterFromSpdxId() const
        {
            auto spdxId = OSC_CONSTANTS::ATTRIBUTE__SPDX_ID;
            return GetParameterNameFromAttribute(spdxId);
        }

        bool LicenseImpl::IsTextParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TEXT);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LicenseImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LicenseImpl::IsResourceParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RESOURCE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LicenseImpl::IsSpdxIdParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__SPDX_ID);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        LicenseImpl::LicenseImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TEXT, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RESOURCE, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SPDX_ID, SimpleType::STRING);
        }

        void LicenseImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TEXT)
            {
                // Simple type
                _text = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RESOURCE)
            {
                // Simple type
                _resource = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SPDX_ID)
            {
                // Simple type
                _spdxId = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType LicenseImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LicenseImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LicenseImpl::Clone()
        {
            auto clonedObject = std::make_shared<LicenseImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // Simple type
            clonedObject->_resource = GetResource();
            // Simple type
            clonedObject->_spdxId = GetSpdxId();
            // clone indicators
            	clonedObject->isSetResource = isSetResource;
            	clonedObject->isSetSpdxId = isSetSpdxId;
            // clone children
            return clonedObject;
        }

        std::string LicenseImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__TEXT)
            {
                return GetText();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__RESOURCE)
            {
                return GetResource();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__SPDX_ID)
            {
                return GetSpdxId();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LicenseImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LicenseImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LicenseImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LicenseImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void LicenseImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TEXT)
            {
                // Simple type
                _text = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RESOURCE)
            {
                // Simple type
                _resource = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SPDX_ID)
            {
                // Simple type
                _spdxId = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void LicenseImpl::ResetText()
	   {
	   		isSetText = false; 
			_text = {};
			
	   }
       bool LicenseImpl::IsSetText() const
	   {
			return isSetText;
	   }
       void LicenseImpl::ResetResource()
	   {
	   		isSetResource = false; 
			_resource = {};
			
	   }
       bool LicenseImpl::IsSetResource() const
	   {
			return isSetResource;
	   }
       void LicenseImpl::ResetSpdxId()
	   {
	   		isSetSpdxId = false; 
			_spdxId = {};
			
	   }
       bool LicenseImpl::IsSetSpdxId() const
	   {
			return isSetSpdxId;
	   }

        IOpenScenarioFlexElement* LightStateImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double LightStateImpl::GetFlashingOffDuration() const
        {
        	  return _flashingOffDuration;
        }
        double LightStateImpl::GetFlashingOnDuration() const
        {
        	  return _flashingOnDuration;
        }
        double LightStateImpl::GetLuminousIntensity() const
        {
        	  return _luminousIntensity;
        }
        LightMode LightStateImpl::GetMode() const
        {
        	  return _mode;
        }
        std::shared_ptr<IColor> LightStateImpl::GetColor() const
        {
        	  return _color;
        }


        void LightStateImpl::SetFlashingOffDuration(const double flashingOffDuration)
        {
            _flashingOffDuration = flashingOffDuration;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FLASHING_OFF_DURATION);
			// set the indicator to true
            isSetFlashingOffDuration = true;          
        }

        void LightStateImpl::SetFlashingOnDuration(const double flashingOnDuration)
        {
            _flashingOnDuration = flashingOnDuration;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FLASHING_ON_DURATION);
			// set the indicator to true
            isSetFlashingOnDuration = true;          
        }

        void LightStateImpl::SetLuminousIntensity(const double luminousIntensity)
        {
            _luminousIntensity = luminousIntensity;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LUMINOUS_INTENSITY);
			// set the indicator to true
            isSetLuminousIntensity = true;          
        }

        void LightStateImpl::SetMode(const LightMode mode)
        {
            _mode = mode;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MODE);
        }

        void LightStateImpl::SetColor(std::shared_ptr<IColorWriter> color)
        {
            _color = color;
			// set the indicator to true
            isSetColor = true;          
        }

        std::shared_ptr<void> LightStateImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(LightStateImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ILightState).name())
                return std::dynamic_pointer_cast<ILightState>(shared_from_this());
            else if (classifier == typeid(ILightStateWriter).name())
                return std::dynamic_pointer_cast<ILightStateWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> LightStateImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t LightStateImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int LightStateImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double LightStateImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__FLASHING_OFF_DURATION)
                {
                    return GetFlashingOffDuration();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__FLASHING_ON_DURATION)
                {
                    return GetFlashingOnDuration();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__LUMINOUS_INTENSITY)
                {
                    return GetLuminousIntensity();
                }
                throw KeyNotSupportedException();

        }

        uint16_t LightStateImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool LightStateImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime LightStateImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> LightStateImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string LightStateImpl::GetModelType() const
        {
            return "LightState";
        }

        void LightStateImpl::WriteParameterToFlashingOffDuration(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FLASHING_OFF_DURATION, parameterName, nullTextMarker /*no textmarker*/);
            _flashingOffDuration = {};
        }

        void LightStateImpl::WriteParameterToFlashingOnDuration(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FLASHING_ON_DURATION, parameterName, nullTextMarker /*no textmarker*/);
            _flashingOnDuration = {};
        }

        void LightStateImpl::WriteParameterToLuminousIntensity(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LUMINOUS_INTENSITY, parameterName, nullTextMarker /*no textmarker*/);
            _luminousIntensity = {};
        }

        void LightStateImpl::WriteParameterToMode(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MODE, parameterName, nullTextMarker /*no textmarker*/);
            _mode = {};
        }

        std::string LightStateImpl::GetParameterFromFlashingOffDuration() const
        {
            auto flashingOffDuration = OSC_CONSTANTS::ATTRIBUTE__FLASHING_OFF_DURATION;
            return GetParameterNameFromAttribute(flashingOffDuration);
        }

        std::string LightStateImpl::GetParameterFromFlashingOnDuration() const
        {
            auto flashingOnDuration = OSC_CONSTANTS::ATTRIBUTE__FLASHING_ON_DURATION;
            return GetParameterNameFromAttribute(flashingOnDuration);
        }

        std::string LightStateImpl::GetParameterFromLuminousIntensity() const
        {
            auto luminousIntensity = OSC_CONSTANTS::ATTRIBUTE__LUMINOUS_INTENSITY;
            return GetParameterNameFromAttribute(luminousIntensity);
        }

        std::string LightStateImpl::GetParameterFromMode() const
        {
            auto mode = OSC_CONSTANTS::ATTRIBUTE__MODE;
            return GetParameterNameFromAttribute(mode);
        }

        bool LightStateImpl::IsFlashingOffDurationParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__FLASHING_OFF_DURATION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LightStateImpl::IsFlashingOnDurationParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__FLASHING_ON_DURATION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LightStateImpl::IsLuminousIntensityParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__LUMINOUS_INTENSITY);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LightStateImpl::IsModeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MODE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IColorWriter> LightStateImpl::GetWriterColor() const
        {
            return std::dynamic_pointer_cast<IColorWriter>(_color);
        }

        LightStateImpl::LightStateImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FLASHING_OFF_DURATION, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FLASHING_ON_DURATION, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LUMINOUS_INTENSITY, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MODE, SimpleType::ENUM_TYPE);
        }

        void LightStateImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FLASHING_OFF_DURATION)
            {
                // Simple type
                _flashingOffDuration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FLASHING_ON_DURATION)
            {
                // Simple type
                _flashingOnDuration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LUMINOUS_INTENSITY)
            {
                // Simple type
                _luminousIntensity = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MODE)
            {
                // Enumeration Type
                const auto kResult = LightMode::GetFromLiteral(parameterLiteralValue);
                if (kResult != LightMode::UNKNOWN)
                {
                    _mode = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType LightStateImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LightStateImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kColor =  GetWriterColor();
                if (kColor)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kColor));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LightStateImpl::Clone()
        {
            auto clonedObject = std::make_shared<LightStateImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_flashingOffDuration = GetFlashingOffDuration();
            // Simple type
            clonedObject->_flashingOnDuration = GetFlashingOnDuration();
            // Simple type
            clonedObject->_luminousIntensity = GetLuminousIntensity();
            // Enumeration Type
            const auto kMode = GetMode();
            if ( kMode.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_mode = LightMode::GetFromLiteral(kMode.GetLiteral());
            }
            // clone indicators
            	clonedObject->isSetFlashingOffDuration = isSetFlashingOffDuration;
            	clonedObject->isSetFlashingOnDuration = isSetFlashingOnDuration;
            	clonedObject->isSetLuminousIntensity = isSetLuminousIntensity;
            // clone children
            const auto kColor =  GetWriterColor();
            if (kColor)
            {
                auto clonedChild = std::dynamic_pointer_cast<ColorImpl>(kColor)->Clone();
                auto clonedChildIColor = std::dynamic_pointer_cast<IColor>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetColor(std::dynamic_pointer_cast<IColorWriter>(clonedChildIColor));
            }
            return clonedObject;
        }

        std::string LightStateImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LightStateImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__COLOR)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetColor());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LightStateImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LightStateImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LightStateImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__MODE)
            {
                auto mode = GetMode();
                return mode.GetLiteral() != "UNKNOWN" ? mode.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void LightStateImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FLASHING_OFF_DURATION)
            {
                // Simple type
                _flashingOffDuration = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FLASHING_ON_DURATION)
            {
                // Simple type
                _flashingOnDuration = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LUMINOUS_INTENSITY)
            {
                // Simple type
                _luminousIntensity = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void LightStateImpl::ResetFlashingOffDuration()
	   {
	   		isSetFlashingOffDuration = false; 
			_flashingOffDuration = {0.5};
			
	   }
       bool LightStateImpl::IsSetFlashingOffDuration() const
	   {
			return isSetFlashingOffDuration;
	   }
       void LightStateImpl::ResetFlashingOnDuration()
	   {
	   		isSetFlashingOnDuration = false; 
			_flashingOnDuration = {0.5};
			
	   }
       bool LightStateImpl::IsSetFlashingOnDuration() const
	   {
			return isSetFlashingOnDuration;
	   }
       void LightStateImpl::ResetLuminousIntensity()
	   {
	   		isSetLuminousIntensity = false; 
			_luminousIntensity = {};
			
	   }
       bool LightStateImpl::IsSetLuminousIntensity() const
	   {
			return isSetLuminousIntensity;
	   }
       void LightStateImpl::ResetColor()
	   {
	   		isSetColor = false; 
			_color = {};
			
	   }
       bool LightStateImpl::IsSetColor() const
	   {
			return isSetColor;
	   }

        IOpenScenarioFlexElement* LightStateActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double LightStateActionImpl::GetTransitionTime() const
        {
        	  return _transitionTime;
        }
        std::shared_ptr<ILightType> LightStateActionImpl::GetLightType() const
        {
        	  return _lightType;
        }
        std::shared_ptr<ILightState> LightStateActionImpl::GetLightState() const
        {
        	  return _lightState;
        }


        void LightStateActionImpl::SetTransitionTime(const double transitionTime)
        {
            _transitionTime = transitionTime;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TRANSITION_TIME);
			// set the indicator to true
            isSetTransitionTime = true;          
        }

        void LightStateActionImpl::SetLightType(std::shared_ptr<ILightTypeWriter> lightType)
        {
            _lightType = lightType;
        }

        void LightStateActionImpl::SetLightState(std::shared_ptr<ILightStateWriter> lightState)
        {
            _lightState = lightState;
        }

        std::shared_ptr<void> LightStateActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(LightStateActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ILightStateAction).name())
                return std::dynamic_pointer_cast<ILightStateAction>(shared_from_this());
            else if (classifier == typeid(ILightStateActionWriter).name())
                return std::dynamic_pointer_cast<ILightStateActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> LightStateActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t LightStateActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int LightStateActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double LightStateActionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__TRANSITION_TIME)
                {
                    return GetTransitionTime();
                }
                throw KeyNotSupportedException();

        }

        uint16_t LightStateActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool LightStateActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime LightStateActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> LightStateActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string LightStateActionImpl::GetModelType() const
        {
            return "LightStateAction";
        }

        void LightStateActionImpl::WriteParameterToTransitionTime(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TRANSITION_TIME, parameterName, nullTextMarker /*no textmarker*/);
            _transitionTime = {};
        }

        std::string LightStateActionImpl::GetParameterFromTransitionTime() const
        {
            auto transitionTime = OSC_CONSTANTS::ATTRIBUTE__TRANSITION_TIME;
            return GetParameterNameFromAttribute(transitionTime);
        }

        bool LightStateActionImpl::IsTransitionTimeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TRANSITION_TIME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<ILightTypeWriter> LightStateActionImpl::GetWriterLightType() const
        {
            return std::dynamic_pointer_cast<ILightTypeWriter>(_lightType);
        }
        std::shared_ptr<ILightStateWriter> LightStateActionImpl::GetWriterLightState() const
        {
            return std::dynamic_pointer_cast<ILightStateWriter>(_lightState);
        }

        LightStateActionImpl::LightStateActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TRANSITION_TIME, SimpleType::DOUBLE);
        }

        void LightStateActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRANSITION_TIME)
            {
                // Simple type
                _transitionTime = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType LightStateActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LightStateActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kLightType =  GetWriterLightType();
                if (kLightType)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLightType));
                }
                const auto kLightState =  GetWriterLightState();
                if (kLightState)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLightState));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LightStateActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<LightStateActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_transitionTime = GetTransitionTime();
            // clone indicators
            	clonedObject->isSetTransitionTime = isSetTransitionTime;
            // clone children
            const auto kLightType =  GetWriterLightType();
            if (kLightType)
            {
                auto clonedChild = std::dynamic_pointer_cast<LightTypeImpl>(kLightType)->Clone();
                auto clonedChildILightType = std::dynamic_pointer_cast<ILightType>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLightType(std::dynamic_pointer_cast<ILightTypeWriter>(clonedChildILightType));
            }
            const auto kLightState =  GetWriterLightState();
            if (kLightState)
            {
                auto clonedChild = std::dynamic_pointer_cast<LightStateImpl>(kLightState)->Clone();
                auto clonedChildILightState = std::dynamic_pointer_cast<ILightState>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLightState(std::dynamic_pointer_cast<ILightStateWriter>(clonedChildILightState));
            }
            return clonedObject;
        }

        std::string LightStateActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LightStateActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LIGHT_TYPE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLightType());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LIGHT_STATE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLightState());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LightStateActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LightStateActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LightStateActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void LightStateActionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRANSITION_TIME)
            {
                // Simple type
                _transitionTime = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void LightStateActionImpl::ResetTransitionTime()
	   {
	   		isSetTransitionTime = false; 
			_transitionTime = {0};
			
	   }
       bool LightStateActionImpl::IsSetTransitionTime() const
	   {
			return isSetTransitionTime;
	   }

        IOpenScenarioFlexElement* LightTypeImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IVehicleLight> LightTypeImpl::GetVehicleLight() const
        {
        	  return _vehicleLight;
        }
        std::shared_ptr<IUserDefinedLight> LightTypeImpl::GetUserDefinedLight() const
        {
        	  return _userDefinedLight;
        }


        void LightTypeImpl::SetVehicleLight(std::shared_ptr<IVehicleLightWriter> vehicleLight)
        {
            _vehicleLight = vehicleLight;
            _userDefinedLight = {};
        }

        void LightTypeImpl::SetUserDefinedLight(std::shared_ptr<IUserDefinedLightWriter> userDefinedLight)
        {
            _userDefinedLight = userDefinedLight;
            _vehicleLight = {};
        }

        std::shared_ptr<void> LightTypeImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(LightTypeImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ILightType).name())
                return std::dynamic_pointer_cast<ILightType>(shared_from_this());
            else if (classifier == typeid(ILightTypeWriter).name())
                return std::dynamic_pointer_cast<ILightTypeWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> LightTypeImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t LightTypeImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int LightTypeImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double LightTypeImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t LightTypeImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool LightTypeImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime LightTypeImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> LightTypeImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string LightTypeImpl::GetModelType() const
        {
            return "LightType";
        }

            // children
        std::shared_ptr<IVehicleLightWriter> LightTypeImpl::GetWriterVehicleLight() const
        {
            return std::dynamic_pointer_cast<IVehicleLightWriter>(_vehicleLight);
        }
        std::shared_ptr<IUserDefinedLightWriter> LightTypeImpl::GetWriterUserDefinedLight() const
        {
            return std::dynamic_pointer_cast<IUserDefinedLightWriter>(_userDefinedLight);
        }

        LightTypeImpl::LightTypeImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void LightTypeImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType LightTypeImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LightTypeImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kVehicleLight =  GetWriterVehicleLight();
                if (kVehicleLight)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kVehicleLight));
                }
                const auto kUserDefinedLight =  GetWriterUserDefinedLight();
                if (kUserDefinedLight)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kUserDefinedLight));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LightTypeImpl::Clone()
        {
            auto clonedObject = std::make_shared<LightTypeImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kVehicleLight =  GetWriterVehicleLight();
            if (kVehicleLight)
            {
                auto clonedChild = std::dynamic_pointer_cast<VehicleLightImpl>(kVehicleLight)->Clone();
                auto clonedChildIVehicleLight = std::dynamic_pointer_cast<IVehicleLight>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetVehicleLight(std::dynamic_pointer_cast<IVehicleLightWriter>(clonedChildIVehicleLight));
            }
            const auto kUserDefinedLight =  GetWriterUserDefinedLight();
            if (kUserDefinedLight)
            {
                auto clonedChild = std::dynamic_pointer_cast<UserDefinedLightImpl>(kUserDefinedLight)->Clone();
                auto clonedChildIUserDefinedLight = std::dynamic_pointer_cast<IUserDefinedLight>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetUserDefinedLight(std::dynamic_pointer_cast<IUserDefinedLightWriter>(clonedChildIUserDefinedLight));
            }
            return clonedObject;
        }

        std::string LightTypeImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LightTypeImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__VEHICLE_LIGHT)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetVehicleLight());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__USER_DEFINED_LIGHT)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetUserDefinedLight());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LightTypeImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LightTypeImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LightTypeImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* LongitudinalActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<ISpeedAction> LongitudinalActionImpl::GetSpeedAction() const
        {
        	  return _speedAction;
        }
        std::shared_ptr<ILongitudinalDistanceAction> LongitudinalActionImpl::GetLongitudinalDistanceAction() const
        {
        	  return _longitudinalDistanceAction;
        }
        std::shared_ptr<ISpeedProfileAction> LongitudinalActionImpl::GetSpeedProfileAction() const
        {
        	  return _speedProfileAction;
        }


        void LongitudinalActionImpl::SetSpeedAction(std::shared_ptr<ISpeedActionWriter> speedAction)
        {
            _speedAction = speedAction;
            _longitudinalDistanceAction = {};
            _speedProfileAction = {};
			// set the indicator to true
            isSetSpeedAction = true;          
        }

        void LongitudinalActionImpl::SetLongitudinalDistanceAction(std::shared_ptr<ILongitudinalDistanceActionWriter> longitudinalDistanceAction)
        {
            _longitudinalDistanceAction = longitudinalDistanceAction;
            _speedAction = {};
            _speedProfileAction = {};
			// set the indicator to true
            isSetLongitudinalDistanceAction = true;          
        }

        void LongitudinalActionImpl::SetSpeedProfileAction(std::shared_ptr<ISpeedProfileActionWriter> speedProfileAction)
        {
            _speedProfileAction = speedProfileAction;
            _speedAction = {};
            _longitudinalDistanceAction = {};
			// set the indicator to true
            isSetSpeedProfileAction = true;          
        }

        std::shared_ptr<void> LongitudinalActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(LongitudinalActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ILongitudinalAction).name())
                return std::dynamic_pointer_cast<ILongitudinalAction>(shared_from_this());
            else if (classifier == typeid(ILongitudinalActionWriter).name())
                return std::dynamic_pointer_cast<ILongitudinalActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> LongitudinalActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t LongitudinalActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int LongitudinalActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double LongitudinalActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t LongitudinalActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool LongitudinalActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime LongitudinalActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> LongitudinalActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string LongitudinalActionImpl::GetModelType() const
        {
            return "LongitudinalAction";
        }

            // children
        std::shared_ptr<ISpeedActionWriter> LongitudinalActionImpl::GetWriterSpeedAction() const
        {
            return std::dynamic_pointer_cast<ISpeedActionWriter>(_speedAction);
        }
        std::shared_ptr<ILongitudinalDistanceActionWriter> LongitudinalActionImpl::GetWriterLongitudinalDistanceAction() const
        {
            return std::dynamic_pointer_cast<ILongitudinalDistanceActionWriter>(_longitudinalDistanceAction);
        }
        std::shared_ptr<ISpeedProfileActionWriter> LongitudinalActionImpl::GetWriterSpeedProfileAction() const
        {
            return std::dynamic_pointer_cast<ISpeedProfileActionWriter>(_speedProfileAction);
        }

        LongitudinalActionImpl::LongitudinalActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void LongitudinalActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType LongitudinalActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LongitudinalActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kSpeedAction =  GetWriterSpeedAction();
                if (kSpeedAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSpeedAction));
                }
                const auto kLongitudinalDistanceAction =  GetWriterLongitudinalDistanceAction();
                if (kLongitudinalDistanceAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLongitudinalDistanceAction));
                }
                const auto kSpeedProfileAction =  GetWriterSpeedProfileAction();
                if (kSpeedProfileAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSpeedProfileAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LongitudinalActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<LongitudinalActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kSpeedAction =  GetWriterSpeedAction();
            if (kSpeedAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<SpeedActionImpl>(kSpeedAction)->Clone();
                auto clonedChildISpeedAction = std::dynamic_pointer_cast<ISpeedAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSpeedAction(std::dynamic_pointer_cast<ISpeedActionWriter>(clonedChildISpeedAction));
            }
            const auto kLongitudinalDistanceAction =  GetWriterLongitudinalDistanceAction();
            if (kLongitudinalDistanceAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<LongitudinalDistanceActionImpl>(kLongitudinalDistanceAction)->Clone();
                auto clonedChildILongitudinalDistanceAction = std::dynamic_pointer_cast<ILongitudinalDistanceAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLongitudinalDistanceAction(std::dynamic_pointer_cast<ILongitudinalDistanceActionWriter>(clonedChildILongitudinalDistanceAction));
            }
            const auto kSpeedProfileAction =  GetWriterSpeedProfileAction();
            if (kSpeedProfileAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<SpeedProfileActionImpl>(kSpeedProfileAction)->Clone();
                auto clonedChildISpeedProfileAction = std::dynamic_pointer_cast<ISpeedProfileAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSpeedProfileAction(std::dynamic_pointer_cast<ISpeedProfileActionWriter>(clonedChildISpeedProfileAction));
            }
            return clonedObject;
        }

        std::string LongitudinalActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LongitudinalActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SPEED_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSpeedAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LONGITUDINAL_DISTANCE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLongitudinalDistanceAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SPEED_PROFILE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSpeedProfileAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LongitudinalActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LongitudinalActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LongitudinalActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void LongitudinalActionImpl::ResetSpeedAction()
	   {
	   		isSetSpeedAction = false; 
			_speedAction = {};
			
	   }
       bool LongitudinalActionImpl::IsSetSpeedAction() const
	   {
			return isSetSpeedAction;
	   }
       void LongitudinalActionImpl::ResetLongitudinalDistanceAction()
	   {
	   		isSetLongitudinalDistanceAction = false; 
			_longitudinalDistanceAction = {};
			
	   }
       bool LongitudinalActionImpl::IsSetLongitudinalDistanceAction() const
	   {
			return isSetLongitudinalDistanceAction;
	   }
       void LongitudinalActionImpl::ResetSpeedProfileAction()
	   {
	   		isSetSpeedProfileAction = false; 
			_speedProfileAction = {};
			
	   }
       bool LongitudinalActionImpl::IsSetSpeedProfileAction() const
	   {
			return isSetSpeedProfileAction;
	   }

        IOpenScenarioFlexElement* LongitudinalDistanceActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool LongitudinalDistanceActionImpl::GetContinuous() const
        {
        	  return _continuous;
        }
        CoordinateSystem LongitudinalDistanceActionImpl::GetCoordinateSystem() const
        {
        	  return _coordinateSystem;
        }
        LongitudinalDisplacement LongitudinalDistanceActionImpl::GetDisplacement() const
        {
        	  return _displacement;
        }
        double LongitudinalDistanceActionImpl::GetDistance() const
        {
        	  return _distance;
        }
        std::shared_ptr<INamedReference<IEntity>> LongitudinalDistanceActionImpl::GetEntityRef() const
        {
        	 return _entityRef;
        }
        bool LongitudinalDistanceActionImpl::GetFreespace() const
        {
        	  return _freespace;
        }
        double LongitudinalDistanceActionImpl::GetTimeGap() const
        {
        	  return _timeGap;
        }
        std::shared_ptr<IDynamicConstraints> LongitudinalDistanceActionImpl::GetDynamicConstraints() const
        {
        	  return _dynamicConstraints;
        }


        void LongitudinalDistanceActionImpl::SetContinuous(const bool continuous)
        {
            _continuous = continuous;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS);
        }

        void LongitudinalDistanceActionImpl::SetCoordinateSystem(const CoordinateSystem coordinateSystem)
        {
            _coordinateSystem = coordinateSystem;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM);
			// set the indicator to true
            isSetCoordinateSystem = true;          
        }

        void LongitudinalDistanceActionImpl::SetDisplacement(const LongitudinalDisplacement displacement)
        {
            _displacement = displacement;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DISPLACEMENT);
			// set the indicator to true
            isSetDisplacement = true;          
        }

        void LongitudinalDistanceActionImpl::SetDistance(const double distance)
        {
            _distance = distance;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DISTANCE);
			// set the indicator to true
            isSetDistance = true;          
        }

        void LongitudinalDistanceActionImpl::SetEntityRef(std::shared_ptr<INamedReference<IEntity>> entityRef)
        {
            _entityRef = entityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
        }

        void LongitudinalDistanceActionImpl::SetFreespace(const bool freespace)
        {
            _freespace = freespace;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FREESPACE);
        }

        void LongitudinalDistanceActionImpl::SetTimeGap(const double timeGap)
        {
            _timeGap = timeGap;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TIME_GAP);
			// set the indicator to true
            isSetTimeGap = true;          
        }

        void LongitudinalDistanceActionImpl::SetDynamicConstraints(std::shared_ptr<IDynamicConstraintsWriter> dynamicConstraints)
        {
            _dynamicConstraints = dynamicConstraints;
			// set the indicator to true
            isSetDynamicConstraints = true;          
        }

        std::shared_ptr<void> LongitudinalDistanceActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(LongitudinalDistanceActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ILongitudinalDistanceAction).name())
                return std::dynamic_pointer_cast<ILongitudinalDistanceAction>(shared_from_this());
            else if (classifier == typeid(ILongitudinalDistanceActionWriter).name())
                return std::dynamic_pointer_cast<ILongitudinalDistanceActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> LongitudinalDistanceActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t LongitudinalDistanceActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int LongitudinalDistanceActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double LongitudinalDistanceActionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__DISTANCE)
                {
                    return GetDistance();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__TIME_GAP)
                {
                    return GetTimeGap();
                }
                throw KeyNotSupportedException();

        }

        uint16_t LongitudinalDistanceActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool LongitudinalDistanceActionImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS)
                {
                    return GetContinuous();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
                {
                    return GetFreespace();
                }
                throw KeyNotSupportedException();

        }

        DateTime LongitudinalDistanceActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> LongitudinalDistanceActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string LongitudinalDistanceActionImpl::GetModelType() const
        {
            return "LongitudinalDistanceAction";
        }

        void LongitudinalDistanceActionImpl::WriteParameterToContinuous(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS, parameterName, nullTextMarker /*no textmarker*/);
            _continuous = {};
        }

        void LongitudinalDistanceActionImpl::WriteParameterToCoordinateSystem(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM, parameterName, nullTextMarker /*no textmarker*/);
            _coordinateSystem = {};
        }

        void LongitudinalDistanceActionImpl::WriteParameterToDisplacement(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DISPLACEMENT, parameterName, nullTextMarker /*no textmarker*/);
            _displacement = {};
        }

        void LongitudinalDistanceActionImpl::WriteParameterToDistance(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DISTANCE, parameterName, nullTextMarker /*no textmarker*/);
            _distance = {};
        }

        void LongitudinalDistanceActionImpl::WriteParameterToEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _entityRef = {};
        }

        void LongitudinalDistanceActionImpl::WriteParameterToFreespace(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FREESPACE, parameterName, nullTextMarker /*no textmarker*/);
            _freespace = {};
        }

        void LongitudinalDistanceActionImpl::WriteParameterToTimeGap(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TIME_GAP, parameterName, nullTextMarker /*no textmarker*/);
            _timeGap = {};
        }

        std::string LongitudinalDistanceActionImpl::GetParameterFromContinuous() const
        {
            auto continuous = OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS;
            return GetParameterNameFromAttribute(continuous);
        }

        std::string LongitudinalDistanceActionImpl::GetParameterFromCoordinateSystem() const
        {
            auto coordinateSystem = OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM;
            return GetParameterNameFromAttribute(coordinateSystem);
        }

        std::string LongitudinalDistanceActionImpl::GetParameterFromDisplacement() const
        {
            auto displacement = OSC_CONSTANTS::ATTRIBUTE__DISPLACEMENT;
            return GetParameterNameFromAttribute(displacement);
        }

        std::string LongitudinalDistanceActionImpl::GetParameterFromDistance() const
        {
            auto distance = OSC_CONSTANTS::ATTRIBUTE__DISTANCE;
            return GetParameterNameFromAttribute(distance);
        }

        std::string LongitudinalDistanceActionImpl::GetParameterFromEntityRef() const
        {
            auto entityRef = OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF;
            return GetParameterNameFromAttribute(entityRef);
        }

        std::string LongitudinalDistanceActionImpl::GetParameterFromFreespace() const
        {
            auto freespace = OSC_CONSTANTS::ATTRIBUTE__FREESPACE;
            return GetParameterNameFromAttribute(freespace);
        }

        std::string LongitudinalDistanceActionImpl::GetParameterFromTimeGap() const
        {
            auto timeGap = OSC_CONSTANTS::ATTRIBUTE__TIME_GAP;
            return GetParameterNameFromAttribute(timeGap);
        }

        bool LongitudinalDistanceActionImpl::IsContinuousParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LongitudinalDistanceActionImpl::IsCoordinateSystemParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LongitudinalDistanceActionImpl::IsDisplacementParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DISPLACEMENT);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LongitudinalDistanceActionImpl::IsDistanceParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DISTANCE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LongitudinalDistanceActionImpl::IsEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LongitudinalDistanceActionImpl::IsFreespaceParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__FREESPACE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool LongitudinalDistanceActionImpl::IsTimeGapParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TIME_GAP);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IDynamicConstraintsWriter> LongitudinalDistanceActionImpl::GetWriterDynamicConstraints() const
        {
            return std::dynamic_pointer_cast<IDynamicConstraintsWriter>(_dynamicConstraints);
        }

        LongitudinalDistanceActionImpl::LongitudinalDistanceActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DISPLACEMENT, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DISTANCE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FREESPACE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TIME_GAP, SimpleType::DOUBLE);
        }

        void LongitudinalDistanceActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS)
            {
                // Simple type
                _continuous = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM)
            {
                // Enumeration Type
                const auto kResult = CoordinateSystem::GetFromLiteral(parameterLiteralValue);
                if (kResult != CoordinateSystem::UNKNOWN)
                {
                    _coordinateSystem = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DISPLACEMENT)
            {
                // Enumeration Type
                const auto kResult = LongitudinalDisplacement::GetFromLiteral(parameterLiteralValue);
                if (kResult != LongitudinalDisplacement::UNKNOWN)
                {
                    _displacement = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DISTANCE)
            {
                // Simple type
                _distance = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
            {
                // Simple type
                _freespace = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TIME_GAP)
            {
                // Simple type
                _timeGap = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType LongitudinalDistanceActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LongitudinalDistanceActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDynamicConstraints =  GetWriterDynamicConstraints();
                if (kDynamicConstraints)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDynamicConstraints));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LongitudinalDistanceActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<LongitudinalDistanceActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_continuous = GetContinuous();
            // Enumeration Type
            const auto kCoordinateSystem = GetCoordinateSystem();
            if ( kCoordinateSystem.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_coordinateSystem = CoordinateSystem::GetFromLiteral(kCoordinateSystem.GetLiteral());
            }
            // Enumeration Type
            const auto kDisplacement = GetDisplacement();
            if ( kDisplacement.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_displacement = LongitudinalDisplacement::GetFromLiteral(kDisplacement.GetLiteral());
            }
            // Simple type
            clonedObject->_distance = GetDistance();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Simple type
            clonedObject->_freespace = GetFreespace();
            // Simple type
            clonedObject->_timeGap = GetTimeGap();
            // clone indicators
            	clonedObject->isSetCoordinateSystem = isSetCoordinateSystem;
            	clonedObject->isSetDisplacement = isSetDisplacement;
            	clonedObject->isSetDistance = isSetDistance;
            	clonedObject->isSetTimeGap = isSetTimeGap;
            // clone children
            const auto kDynamicConstraints =  GetWriterDynamicConstraints();
            if (kDynamicConstraints)
            {
                auto clonedChild = std::dynamic_pointer_cast<DynamicConstraintsImpl>(kDynamicConstraints)->Clone();
                auto clonedChildIDynamicConstraints = std::dynamic_pointer_cast<IDynamicConstraints>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDynamicConstraints(std::dynamic_pointer_cast<IDynamicConstraintsWriter>(clonedChildIDynamicConstraints));
            }
            return clonedObject;
        }

        std::string LongitudinalDistanceActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LongitudinalDistanceActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DYNAMIC_CONSTRAINTS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDynamicConstraints());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LongitudinalDistanceActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LongitudinalDistanceActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string LongitudinalDistanceActionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM)
            {
                auto coordinateSystem = GetCoordinateSystem();
                return coordinateSystem.GetLiteral() != "UNKNOWN" ? coordinateSystem.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__DISPLACEMENT)
            {
                auto displacement = GetDisplacement();
                return displacement.GetLiteral() != "UNKNOWN" ? displacement.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void LongitudinalDistanceActionImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS)
            {
                // Simple type
                _continuous = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
            {
                // Simple type
                _freespace = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void LongitudinalDistanceActionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DISTANCE)
            {
                // Simple type
                _distance = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TIME_GAP)
            {
                // Simple type
                _timeGap = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void LongitudinalDistanceActionImpl::ResetCoordinateSystem()
	   {
	   		isSetCoordinateSystem = false; 
			_coordinateSystem = {CoordinateSystem::CoordinateSystemEnum::ENTITY};
			
	   }
       bool LongitudinalDistanceActionImpl::IsSetCoordinateSystem() const
	   {
			return isSetCoordinateSystem;
	   }
       void LongitudinalDistanceActionImpl::ResetDisplacement()
	   {
	   		isSetDisplacement = false; 
			_displacement = {LongitudinalDisplacement::LongitudinalDisplacementEnum::TRAILING_REFERENCED_ENTITY};
			
	   }
       bool LongitudinalDistanceActionImpl::IsSetDisplacement() const
	   {
			return isSetDisplacement;
	   }
       void LongitudinalDistanceActionImpl::ResetDistance()
	   {
	   		isSetDistance = false; 
			_distance = {};
			
	   }
       bool LongitudinalDistanceActionImpl::IsSetDistance() const
	   {
			return isSetDistance;
	   }
       void LongitudinalDistanceActionImpl::ResetTimeGap()
	   {
	   		isSetTimeGap = false; 
			_timeGap = {};
			
	   }
       bool LongitudinalDistanceActionImpl::IsSetTimeGap() const
	   {
			return isSetTimeGap;
	   }
       void LongitudinalDistanceActionImpl::ResetDynamicConstraints()
	   {
	   		isSetDynamicConstraints = false; 
			_dynamicConstraints = {};
			
	   }
       bool LongitudinalDistanceActionImpl::IsSetDynamicConstraints() const
	   {
			return isSetDynamicConstraints;
	   }

        IOpenScenarioFlexElement* ManeuverImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string ManeuverImpl::GetName() const
        {
        	  return _name;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> ManeuverImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IParameterDeclarationWriter>> ManeuverImpl::GetWriterParameterDeclarations() const
        {
            return _parameterDeclarations;
        }

        int ManeuverImpl::GetParameterDeclarationsSize() const
        {
            return static_cast<int>(_parameterDeclarations.size());
        }

        std::shared_ptr<IParameterDeclaration> ManeuverImpl::GetParameterDeclarationsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _parameterDeclarations.size() > index)
            {
                return _parameterDeclarations[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<IEvent>> ManeuverImpl::GetEvents() const
        {
            std::vector<std::shared_ptr<IEvent>> temp;
            for(auto&& elm: _events)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IEventWriter>> ManeuverImpl::GetWriterEvents() const
        {
            return _events;
        }

        int ManeuverImpl::GetEventsSize() const
        {
            return static_cast<int>(_events.size());
        }

        std::shared_ptr<IEvent> ManeuverImpl::GetEventsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _events.size() > index)
            {
                return _events[index];
            }
            return nullptr;
        }


        void ManeuverImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void ManeuverImpl::SetParameterDeclarations(std::vector<std::shared_ptr<IParameterDeclarationWriter>>& parameterDeclarations)
        {
            _parameterDeclarations = parameterDeclarations;
			// set the indicator to true
            isSetParameterDeclarations = true;          
        }

        void ManeuverImpl::SetEvents(std::vector<std::shared_ptr<IEventWriter>>& events)
        {
            _events = events;
        }

        std::shared_ptr<void> ManeuverImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ManeuverImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IManeuver).name())
                return std::dynamic_pointer_cast<IManeuver>(shared_from_this());
            else if (classifier == typeid(IManeuverWriter).name())
                return std::dynamic_pointer_cast<IManeuverWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ManeuverImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ManeuverImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ManeuverImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ManeuverImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ManeuverImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ManeuverImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ManeuverImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ManeuverImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ManeuverImpl::GetModelType() const
        {
            return "Maneuver";
        }

        void ManeuverImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        std::string ManeuverImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        bool ManeuverImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        ManeuverImpl::ManeuverImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        void ManeuverImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ManeuverImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool ManeuverImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> ManeuverImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ManeuverImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto events =  GetWriterEvents();
                if (!events.empty())
                {
                    for(auto&& item : events)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ManeuverImpl::Clone()
        {
            auto clonedObject = std::make_shared<ManeuverImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone indicators
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kEvents =  GetWriterEvents();
            if (!kEvents.empty())
            {
                std::vector<std::shared_ptr<IEventWriter>> clonedList;
                for(auto&& kItem : kEvents)
                {
                    auto clonedChild = std::dynamic_pointer_cast<EventImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IEventWriter>(clonedChild));
                }
                clonedObject->SetEvents(clonedList);
            }
            return clonedObject;
        }

        std::string ManeuverImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ManeuverImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ManeuverImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__EVENT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetEvents())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ManeuverImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ManeuverImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ManeuverImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void ManeuverImpl::ResetParameterDeclarations()
	   {
	   		isSetParameterDeclarations = false; 
			_parameterDeclarations = {};
			
	   }
       bool ManeuverImpl::IsSetParameterDeclarations() const
	   {
			return isSetParameterDeclarations;
	   }

        IOpenScenarioFlexElement* ManeuverCatalogLocationImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IDirectory> ManeuverCatalogLocationImpl::GetDirectory() const
        {
        	  return _directory;
        }


        void ManeuverCatalogLocationImpl::SetDirectory(std::shared_ptr<IDirectoryWriter> directory)
        {
            _directory = directory;
        }

        std::shared_ptr<void> ManeuverCatalogLocationImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ManeuverCatalogLocationImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IManeuverCatalogLocation).name())
                return std::dynamic_pointer_cast<IManeuverCatalogLocation>(shared_from_this());
            else if (classifier == typeid(IManeuverCatalogLocationWriter).name())
                return std::dynamic_pointer_cast<IManeuverCatalogLocationWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ManeuverCatalogLocationImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ManeuverCatalogLocationImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ManeuverCatalogLocationImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ManeuverCatalogLocationImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ManeuverCatalogLocationImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ManeuverCatalogLocationImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ManeuverCatalogLocationImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ManeuverCatalogLocationImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ManeuverCatalogLocationImpl::GetModelType() const
        {
            return "ManeuverCatalogLocation";
        }

            // children
        std::shared_ptr<IDirectoryWriter> ManeuverCatalogLocationImpl::GetWriterDirectory() const
        {
            return std::dynamic_pointer_cast<IDirectoryWriter>(_directory);
        }

        ManeuverCatalogLocationImpl::ManeuverCatalogLocationImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ManeuverCatalogLocationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ManeuverCatalogLocationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ManeuverCatalogLocationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDirectory =  GetWriterDirectory();
                if (kDirectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDirectory));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ManeuverCatalogLocationImpl::Clone()
        {
            auto clonedObject = std::make_shared<ManeuverCatalogLocationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kDirectory =  GetWriterDirectory();
            if (kDirectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<DirectoryImpl>(kDirectory)->Clone();
                auto clonedChildIDirectory = std::dynamic_pointer_cast<IDirectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDirectory(std::dynamic_pointer_cast<IDirectoryWriter>(clonedChildIDirectory));
            }
            return clonedObject;
        }

        std::string ManeuverCatalogLocationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ManeuverCatalogLocationImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIRECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDirectory());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ManeuverCatalogLocationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ManeuverCatalogLocationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ManeuverCatalogLocationImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ManeuverGroupImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        uint32_t ManeuverGroupImpl::GetMaximumExecutionCount() const
        {
        	  return _maximumExecutionCount;
        }
        std::string ManeuverGroupImpl::GetName() const
        {
        	  return _name;
        }
        std::shared_ptr<IActors> ManeuverGroupImpl::GetActors() const
        {
        	  return _actors;
        }
        std::vector<std::shared_ptr<ICatalogReference>> ManeuverGroupImpl::GetCatalogReferences() const
        {
            std::vector<std::shared_ptr<ICatalogReference>> temp;
            for(auto&& elm: _catalogReferences)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<ICatalogReferenceWriter>> ManeuverGroupImpl::GetWriterCatalogReferences() const
        {
            return _catalogReferences;
        }

        int ManeuverGroupImpl::GetCatalogReferencesSize() const
        {
            return static_cast<int>(_catalogReferences.size());
        }

        std::shared_ptr<ICatalogReference> ManeuverGroupImpl::GetCatalogReferencesAtIndex(unsigned int index) const
        {
            if (index >= 0 && _catalogReferences.size() > index)
            {
                return _catalogReferences[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<IManeuver>> ManeuverGroupImpl::GetManeuvers() const
        {
            std::vector<std::shared_ptr<IManeuver>> temp;
            for(auto&& elm: _maneuvers)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IManeuverWriter>> ManeuverGroupImpl::GetWriterManeuvers() const
        {
            return _maneuvers;
        }

        int ManeuverGroupImpl::GetManeuversSize() const
        {
            return static_cast<int>(_maneuvers.size());
        }

        std::shared_ptr<IManeuver> ManeuverGroupImpl::GetManeuversAtIndex(unsigned int index) const
        {
            if (index >= 0 && _maneuvers.size() > index)
            {
                return _maneuvers[index];
            }
            return nullptr;
        }


        void ManeuverGroupImpl::SetMaximumExecutionCount(const uint32_t maximumExecutionCount)
        {
            _maximumExecutionCount = maximumExecutionCount;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT);
        }

        void ManeuverGroupImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void ManeuverGroupImpl::SetActors(std::shared_ptr<IActorsWriter> actors)
        {
            _actors = actors;
        }

        void ManeuverGroupImpl::SetCatalogReferences(std::vector<std::shared_ptr<ICatalogReferenceWriter>>& catalogReferences)
        {
            _catalogReferences = catalogReferences;
			// set the indicator to true
            isSetCatalogReferences = true;          
        }

        void ManeuverGroupImpl::SetManeuvers(std::vector<std::shared_ptr<IManeuverWriter>>& maneuvers)
        {
            _maneuvers = maneuvers;
			// set the indicator to true
            isSetManeuvers = true;          
        }

        std::shared_ptr<void> ManeuverGroupImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ManeuverGroupImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IManeuverGroup).name())
                return std::dynamic_pointer_cast<IManeuverGroup>(shared_from_this());
            else if (classifier == typeid(IManeuverGroupWriter).name())
                return std::dynamic_pointer_cast<IManeuverGroupWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ManeuverGroupImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ManeuverGroupImpl::GetUnsignedIntProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT)
                {
                    return GetMaximumExecutionCount();
                }
                throw KeyNotSupportedException();

        }

        int ManeuverGroupImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ManeuverGroupImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ManeuverGroupImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ManeuverGroupImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ManeuverGroupImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ManeuverGroupImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ManeuverGroupImpl::GetModelType() const
        {
            return "ManeuverGroup";
        }

        void ManeuverGroupImpl::WriteParameterToMaximumExecutionCount(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT, parameterName, nullTextMarker /*no textmarker*/);
            _maximumExecutionCount = {};
        }

        void ManeuverGroupImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        std::string ManeuverGroupImpl::GetParameterFromMaximumExecutionCount() const
        {
            auto maximumExecutionCount = OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT;
            return GetParameterNameFromAttribute(maximumExecutionCount);
        }

        std::string ManeuverGroupImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        bool ManeuverGroupImpl::IsMaximumExecutionCountParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ManeuverGroupImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IActorsWriter> ManeuverGroupImpl::GetWriterActors() const
        {
            return std::dynamic_pointer_cast<IActorsWriter>(_actors);
        }

        ManeuverGroupImpl::ManeuverGroupImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT, SimpleType::UNSIGNED_INT);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        void ManeuverGroupImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT)
            {
                // Simple type
                _maximumExecutionCount = ParserHelper::ParseUnsignedInt(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ManeuverGroupImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ManeuverGroupImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kActors =  GetWriterActors();
                if (kActors)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kActors));
                }
                auto catalogReferences =  GetWriterCatalogReferences();
                if (!catalogReferences.empty())
                {
                    for(auto&& item : catalogReferences)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto maneuvers =  GetWriterManeuvers();
                if (!maneuvers.empty())
                {
                    for(auto&& item : maneuvers)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ManeuverGroupImpl::Clone()
        {
            auto clonedObject = std::make_shared<ManeuverGroupImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_maximumExecutionCount = GetMaximumExecutionCount();
            // Simple type
            clonedObject->_name = GetName();
            // clone indicators
            // clone children
            const auto kActors =  GetWriterActors();
            if (kActors)
            {
                auto clonedChild = std::dynamic_pointer_cast<ActorsImpl>(kActors)->Clone();
                auto clonedChildIActors = std::dynamic_pointer_cast<IActors>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetActors(std::dynamic_pointer_cast<IActorsWriter>(clonedChildIActors));
            }
            const auto kCatalogReferences =  GetWriterCatalogReferences();
            if (!kCatalogReferences.empty())
            {
                std::vector<std::shared_ptr<ICatalogReferenceWriter>> clonedList;
                for(auto&& kItem : kCatalogReferences)
                {
                    auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChild));
                }
                clonedObject->SetCatalogReferences(clonedList);
            }
            const auto kManeuvers =  GetWriterManeuvers();
            if (!kManeuvers.empty())
            {
                std::vector<std::shared_ptr<IManeuverWriter>> clonedList;
                for(auto&& kItem : kManeuvers)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ManeuverImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IManeuverWriter>(clonedChild));
                }
                clonedObject->SetManeuvers(clonedList);
            }
            return clonedObject;
        }

        std::string ManeuverGroupImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ManeuverGroupImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ACTORS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetActors());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ManeuverGroupImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetCatalogReferences())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__MANEUVER)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetManeuvers())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ManeuverGroupImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ManeuverGroupImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ManeuverGroupImpl::ResolveUnsignedIntExpression(std::string& attributeKey, unsigned int& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT)
            {
                // Simple type
                _maximumExecutionCount = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void ManeuverGroupImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void ManeuverGroupImpl::ResetCatalogReferences()
	   {
	   		isSetCatalogReferences = false; 
			_catalogReferences = {};
			
	   }
       bool ManeuverGroupImpl::IsSetCatalogReferences() const
	   {
			return isSetCatalogReferences;
	   }
       void ManeuverGroupImpl::ResetManeuvers()
	   {
	   		isSetManeuvers = false; 
			_maneuvers = {};
			
	   }
       bool ManeuverGroupImpl::IsSetManeuvers() const
	   {
			return isSetManeuvers;
	   }

        IOpenScenarioFlexElement* ManualGearImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        int ManualGearImpl::GetNumber() const
        {
        	  return _number;
        }


        void ManualGearImpl::SetNumber(const int number)
        {
            _number = number;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NUMBER);
        }

        std::shared_ptr<void> ManualGearImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ManualGearImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IManualGear).name())
                return std::dynamic_pointer_cast<IManualGear>(shared_from_this());
            else if (classifier == typeid(IManualGearWriter).name())
                return std::dynamic_pointer_cast<IManualGearWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ManualGearImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ManualGearImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ManualGearImpl::GetIntProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__NUMBER)
                {
                    return GetNumber();
                }
                throw KeyNotSupportedException();

        }

        double ManualGearImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ManualGearImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ManualGearImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ManualGearImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ManualGearImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ManualGearImpl::GetModelType() const
        {
            return "ManualGear";
        }

        void ManualGearImpl::WriteParameterToNumber(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NUMBER, parameterName, nullTextMarker /*no textmarker*/);
            _number = {};
        }

        std::string ManualGearImpl::GetParameterFromNumber() const
        {
            auto number = OSC_CONSTANTS::ATTRIBUTE__NUMBER;
            return GetParameterNameFromAttribute(number);
        }

        bool ManualGearImpl::IsNumberParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NUMBER);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        ManualGearImpl::ManualGearImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NUMBER, SimpleType::INT);
        }

        void ManualGearImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NUMBER)
            {
                // Simple type
                _number = ParserHelper::ParseInt(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ManualGearImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ManualGearImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ManualGearImpl::Clone()
        {
            auto clonedObject = std::make_shared<ManualGearImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_number = GetNumber();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string ManualGearImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ManualGearImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ManualGearImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ManualGearImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ManualGearImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ManualGearImpl::ResolveIntExpression(std::string& attributeKey, int& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NUMBER)
            {
                // Simple type
                _number = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* MiscObjectImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double MiscObjectImpl::GetMass() const
        {
        	  return _mass;
        }
        MiscObjectCategory MiscObjectImpl::GetMiscObjectCategory() const
        {
        	  return _miscObjectCategory;
        }
        std::string MiscObjectImpl::GetModel3d() const
        {
        	  return _model3d;
        }
        std::string MiscObjectImpl::GetName() const
        {
        	  return _name;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> MiscObjectImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IParameterDeclarationWriter>> MiscObjectImpl::GetWriterParameterDeclarations() const
        {
            return _parameterDeclarations;
        }

        int MiscObjectImpl::GetParameterDeclarationsSize() const
        {
            return static_cast<int>(_parameterDeclarations.size());
        }

        std::shared_ptr<IParameterDeclaration> MiscObjectImpl::GetParameterDeclarationsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _parameterDeclarations.size() > index)
            {
                return _parameterDeclarations[index];
            }
            return nullptr;
        }
        std::shared_ptr<IBoundingBox> MiscObjectImpl::GetBoundingBox() const
        {
        	  return _boundingBox;
        }
        std::shared_ptr<IProperties> MiscObjectImpl::GetProperties() const
        {
        	  return _properties;
        }


        void MiscObjectImpl::SetMass(const double mass)
        {
            _mass = mass;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MASS);
        }

        void MiscObjectImpl::SetMiscObjectCategory(const MiscObjectCategory miscObjectCategory)
        {
            _miscObjectCategory = miscObjectCategory;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MISC_OBJECT_CATEGORY);
        }

        void MiscObjectImpl::SetModel3d(const std::string model3d)
        {
            _model3d = model3d;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MODEL3D);
			// set the indicator to true
            isSetModel3d = true;          
        }

        void MiscObjectImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void MiscObjectImpl::SetParameterDeclarations(std::vector<std::shared_ptr<IParameterDeclarationWriter>>& parameterDeclarations)
        {
            _parameterDeclarations = parameterDeclarations;
			// set the indicator to true
            isSetParameterDeclarations = true;          
        }

        void MiscObjectImpl::SetBoundingBox(std::shared_ptr<IBoundingBoxWriter> boundingBox)
        {
            _boundingBox = boundingBox;
        }

        void MiscObjectImpl::SetProperties(std::shared_ptr<IPropertiesWriter> properties)
        {
            _properties = properties;
        }

        std::shared_ptr<void> MiscObjectImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(MiscObjectImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IMiscObject).name())
                return std::dynamic_pointer_cast<IMiscObject>(shared_from_this());
            else if (classifier == typeid(IMiscObjectWriter).name())
                return std::dynamic_pointer_cast<IMiscObjectWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> MiscObjectImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t MiscObjectImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int MiscObjectImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double MiscObjectImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__MASS)
                {
                    return GetMass();
                }
                throw KeyNotSupportedException();

        }

        uint16_t MiscObjectImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool MiscObjectImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime MiscObjectImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> MiscObjectImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string MiscObjectImpl::GetModelType() const
        {
            return "MiscObject";
        }

        void MiscObjectImpl::WriteParameterToMass(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MASS, parameterName, nullTextMarker /*no textmarker*/);
            _mass = {};
        }

        void MiscObjectImpl::WriteParameterToMiscObjectCategory(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MISC_OBJECT_CATEGORY, parameterName, nullTextMarker /*no textmarker*/);
            _miscObjectCategory = {};
        }

        void MiscObjectImpl::WriteParameterToModel3d(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MODEL3D, parameterName, nullTextMarker /*no textmarker*/);
            _model3d = {};
        }

        void MiscObjectImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        std::string MiscObjectImpl::GetParameterFromMass() const
        {
            auto mass = OSC_CONSTANTS::ATTRIBUTE__MASS;
            return GetParameterNameFromAttribute(mass);
        }

        std::string MiscObjectImpl::GetParameterFromMiscObjectCategory() const
        {
            auto miscObjectCategory = OSC_CONSTANTS::ATTRIBUTE__MISC_OBJECT_CATEGORY;
            return GetParameterNameFromAttribute(miscObjectCategory);
        }

        std::string MiscObjectImpl::GetParameterFromModel3d() const
        {
            auto model3d = OSC_CONSTANTS::ATTRIBUTE__MODEL3D;
            return GetParameterNameFromAttribute(model3d);
        }

        std::string MiscObjectImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        bool MiscObjectImpl::IsMassParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MASS);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool MiscObjectImpl::IsMiscObjectCategoryParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MISC_OBJECT_CATEGORY);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool MiscObjectImpl::IsModel3dParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MODEL3D);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool MiscObjectImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IBoundingBoxWriter> MiscObjectImpl::GetWriterBoundingBox() const
        {
            return std::dynamic_pointer_cast<IBoundingBoxWriter>(_boundingBox);
        }
        std::shared_ptr<IPropertiesWriter> MiscObjectImpl::GetWriterProperties() const
        {
            return std::dynamic_pointer_cast<IPropertiesWriter>(_properties);
        }

        MiscObjectImpl::MiscObjectImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MASS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MISC_OBJECT_CATEGORY, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MODEL3D, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        void MiscObjectImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MASS)
            {
                // Simple type
                _mass = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MISC_OBJECT_CATEGORY)
            {
                // Enumeration Type
                const auto kResult = MiscObjectCategory::GetFromLiteral(parameterLiteralValue);
                if (kResult != MiscObjectCategory::UNKNOWN)
                {
                    _miscObjectCategory = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MODEL3D)
            {
                // Simple type
                _model3d = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType MiscObjectImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool MiscObjectImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> MiscObjectImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> MiscObjectImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kBoundingBox =  GetWriterBoundingBox();
                if (kBoundingBox)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kBoundingBox));
                }
                const auto kProperties =  GetWriterProperties();
                if (kProperties)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kProperties));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> MiscObjectImpl::Clone()
        {
            auto clonedObject = std::make_shared<MiscObjectImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_mass = GetMass();
            // Enumeration Type
            const auto kMiscObjectCategory = GetMiscObjectCategory();
            if ( kMiscObjectCategory.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_miscObjectCategory = MiscObjectCategory::GetFromLiteral(kMiscObjectCategory.GetLiteral());
            }
            // Simple type
            clonedObject->_model3d = GetModel3d();
            // Simple type
            clonedObject->_name = GetName();
            // clone indicators
            	clonedObject->isSetModel3d = isSetModel3d;
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kBoundingBox =  GetWriterBoundingBox();
            if (kBoundingBox)
            {
                auto clonedChild = std::dynamic_pointer_cast<BoundingBoxImpl>(kBoundingBox)->Clone();
                auto clonedChildIBoundingBox = std::dynamic_pointer_cast<IBoundingBox>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetBoundingBox(std::dynamic_pointer_cast<IBoundingBoxWriter>(clonedChildIBoundingBox));
            }
            const auto kProperties =  GetWriterProperties();
            if (kProperties)
            {
                auto clonedChild = std::dynamic_pointer_cast<PropertiesImpl>(kProperties)->Clone();
                auto clonedChildIProperties = std::dynamic_pointer_cast<IProperties>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetProperties(std::dynamic_pointer_cast<IPropertiesWriter>(clonedChildIProperties));
            }
            return clonedObject;
        }

        std::string MiscObjectImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__MODEL3D)
            {
                return GetModel3d();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> MiscObjectImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BOUNDING_BOX)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetBoundingBox());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PROPERTIES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetProperties());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> MiscObjectImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> MiscObjectImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string MiscObjectImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__MISC_OBJECT_CATEGORY)
            {
                auto miscObjectCategory = GetMiscObjectCategory();
                return miscObjectCategory.GetLiteral() != "UNKNOWN" ? miscObjectCategory.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void MiscObjectImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MODEL3D)
            {
                // Simple type
                _model3d = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void MiscObjectImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MASS)
            {
                // Simple type
                _mass = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void MiscObjectImpl::ResetModel3d()
	   {
	   		isSetModel3d = false; 
			_model3d = {};
			
	   }
       bool MiscObjectImpl::IsSetModel3d() const
	   {
			return isSetModel3d;
	   }
       void MiscObjectImpl::ResetParameterDeclarations()
	   {
	   		isSetParameterDeclarations = false; 
			_parameterDeclarations = {};
			
	   }
       bool MiscObjectImpl::IsSetParameterDeclarations() const
	   {
			return isSetParameterDeclarations;
	   }

        IOpenScenarioFlexElement* MiscObjectCatalogLocationImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IDirectory> MiscObjectCatalogLocationImpl::GetDirectory() const
        {
        	  return _directory;
        }


        void MiscObjectCatalogLocationImpl::SetDirectory(std::shared_ptr<IDirectoryWriter> directory)
        {
            _directory = directory;
        }

        std::shared_ptr<void> MiscObjectCatalogLocationImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(MiscObjectCatalogLocationImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IMiscObjectCatalogLocation).name())
                return std::dynamic_pointer_cast<IMiscObjectCatalogLocation>(shared_from_this());
            else if (classifier == typeid(IMiscObjectCatalogLocationWriter).name())
                return std::dynamic_pointer_cast<IMiscObjectCatalogLocationWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> MiscObjectCatalogLocationImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t MiscObjectCatalogLocationImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int MiscObjectCatalogLocationImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double MiscObjectCatalogLocationImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t MiscObjectCatalogLocationImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool MiscObjectCatalogLocationImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime MiscObjectCatalogLocationImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> MiscObjectCatalogLocationImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string MiscObjectCatalogLocationImpl::GetModelType() const
        {
            return "MiscObjectCatalogLocation";
        }

            // children
        std::shared_ptr<IDirectoryWriter> MiscObjectCatalogLocationImpl::GetWriterDirectory() const
        {
            return std::dynamic_pointer_cast<IDirectoryWriter>(_directory);
        }

        MiscObjectCatalogLocationImpl::MiscObjectCatalogLocationImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void MiscObjectCatalogLocationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType MiscObjectCatalogLocationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> MiscObjectCatalogLocationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDirectory =  GetWriterDirectory();
                if (kDirectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDirectory));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> MiscObjectCatalogLocationImpl::Clone()
        {
            auto clonedObject = std::make_shared<MiscObjectCatalogLocationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kDirectory =  GetWriterDirectory();
            if (kDirectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<DirectoryImpl>(kDirectory)->Clone();
                auto clonedChildIDirectory = std::dynamic_pointer_cast<IDirectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDirectory(std::dynamic_pointer_cast<IDirectoryWriter>(clonedChildIDirectory));
            }
            return clonedObject;
        }

        std::string MiscObjectCatalogLocationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> MiscObjectCatalogLocationImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIRECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDirectory());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> MiscObjectCatalogLocationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> MiscObjectCatalogLocationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string MiscObjectCatalogLocationImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ModifyRuleImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IParameterAddValueRule> ModifyRuleImpl::GetAddValue() const
        {
        	  return _addValue;
        }
        std::shared_ptr<IParameterMultiplyByValueRule> ModifyRuleImpl::GetMultiplyByValue() const
        {
        	  return _multiplyByValue;
        }


        void ModifyRuleImpl::SetAddValue(std::shared_ptr<IParameterAddValueRuleWriter> addValue)
        {
            _addValue = addValue;
            _multiplyByValue = {};
			// set the indicator to true
            isSetAddValue = true;          
        }

        void ModifyRuleImpl::SetMultiplyByValue(std::shared_ptr<IParameterMultiplyByValueRuleWriter> multiplyByValue)
        {
            _multiplyByValue = multiplyByValue;
            _addValue = {};
			// set the indicator to true
            isSetMultiplyByValue = true;          
        }

        std::shared_ptr<void> ModifyRuleImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ModifyRuleImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IModifyRule).name())
                return std::dynamic_pointer_cast<IModifyRule>(shared_from_this());
            else if (classifier == typeid(IModifyRuleWriter).name())
                return std::dynamic_pointer_cast<IModifyRuleWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ModifyRuleImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ModifyRuleImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ModifyRuleImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ModifyRuleImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ModifyRuleImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ModifyRuleImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ModifyRuleImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ModifyRuleImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ModifyRuleImpl::GetModelType() const
        {
            return "ModifyRule";
        }

            // children
        std::shared_ptr<IParameterAddValueRuleWriter> ModifyRuleImpl::GetWriterAddValue() const
        {
            return std::dynamic_pointer_cast<IParameterAddValueRuleWriter>(_addValue);
        }
        std::shared_ptr<IParameterMultiplyByValueRuleWriter> ModifyRuleImpl::GetWriterMultiplyByValue() const
        {
            return std::dynamic_pointer_cast<IParameterMultiplyByValueRuleWriter>(_multiplyByValue);
        }

        ModifyRuleImpl::ModifyRuleImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ModifyRuleImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ModifyRuleImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ModifyRuleImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kAddValue =  GetWriterAddValue();
                if (kAddValue)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAddValue));
                }
                const auto kMultiplyByValue =  GetWriterMultiplyByValue();
                if (kMultiplyByValue)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kMultiplyByValue));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ModifyRuleImpl::Clone()
        {
            auto clonedObject = std::make_shared<ModifyRuleImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kAddValue =  GetWriterAddValue();
            if (kAddValue)
            {
                auto clonedChild = std::dynamic_pointer_cast<ParameterAddValueRuleImpl>(kAddValue)->Clone();
                auto clonedChildIParameterAddValueRule = std::dynamic_pointer_cast<IParameterAddValueRule>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAddValue(std::dynamic_pointer_cast<IParameterAddValueRuleWriter>(clonedChildIParameterAddValueRule));
            }
            const auto kMultiplyByValue =  GetWriterMultiplyByValue();
            if (kMultiplyByValue)
            {
                auto clonedChild = std::dynamic_pointer_cast<ParameterMultiplyByValueRuleImpl>(kMultiplyByValue)->Clone();
                auto clonedChildIParameterMultiplyByValueRule = std::dynamic_pointer_cast<IParameterMultiplyByValueRule>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetMultiplyByValue(std::dynamic_pointer_cast<IParameterMultiplyByValueRuleWriter>(clonedChildIParameterMultiplyByValueRule));
            }
            return clonedObject;
        }

        std::string ModifyRuleImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ModifyRuleImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ADD_VALUE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAddValue());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__MULTIPLY_BY_VALUE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetMultiplyByValue());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ModifyRuleImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ModifyRuleImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ModifyRuleImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void ModifyRuleImpl::ResetAddValue()
	   {
	   		isSetAddValue = false; 
			_addValue = {};
			
	   }
       bool ModifyRuleImpl::IsSetAddValue() const
	   {
			return isSetAddValue;
	   }
       void ModifyRuleImpl::ResetMultiplyByValue()
	   {
	   		isSetMultiplyByValue = false; 
			_multiplyByValue = {};
			
	   }
       bool ModifyRuleImpl::IsSetMultiplyByValue() const
	   {
			return isSetMultiplyByValue;
	   }

        IOpenScenarioFlexElement* NoneImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }


        std::shared_ptr<void> NoneImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(NoneImpl).name())
                return shared_from_this();
            else if (classifier == typeid(INone).name())
                return std::dynamic_pointer_cast<INone>(shared_from_this());
            else if (classifier == typeid(INoneWriter).name())
                return std::dynamic_pointer_cast<INoneWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> NoneImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t NoneImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int NoneImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double NoneImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t NoneImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool NoneImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime NoneImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> NoneImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string NoneImpl::GetModelType() const
        {
            return "None";
        }

            // children

        NoneImpl::NoneImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void NoneImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType NoneImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> NoneImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> NoneImpl::Clone()
        {
            auto clonedObject = std::make_shared<NoneImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string NoneImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> NoneImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> NoneImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> NoneImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string NoneImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* NormalDistributionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double NormalDistributionImpl::GetExpectedValue() const
        {
        	  return _expectedValue;
        }
        double NormalDistributionImpl::GetVariance() const
        {
        	  return _variance;
        }
        std::shared_ptr<IRange> NormalDistributionImpl::GetRange() const
        {
        	  return _range;
        }


        void NormalDistributionImpl::SetExpectedValue(const double expectedValue)
        {
            _expectedValue = expectedValue;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__EXPECTED_VALUE);
        }

        void NormalDistributionImpl::SetVariance(const double variance)
        {
            _variance = variance;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VARIANCE);
        }

        void NormalDistributionImpl::SetRange(std::shared_ptr<IRangeWriter> range)
        {
            _range = range;
			// set the indicator to true
            isSetRange = true;          
        }

        std::shared_ptr<void> NormalDistributionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(NormalDistributionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(INormalDistribution).name())
                return std::dynamic_pointer_cast<INormalDistribution>(shared_from_this());
            else if (classifier == typeid(INormalDistributionWriter).name())
                return std::dynamic_pointer_cast<INormalDistributionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> NormalDistributionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t NormalDistributionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int NormalDistributionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double NormalDistributionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__EXPECTED_VALUE)
                {
                    return GetExpectedValue();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__VARIANCE)
                {
                    return GetVariance();
                }
                throw KeyNotSupportedException();

        }

        uint16_t NormalDistributionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool NormalDistributionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime NormalDistributionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> NormalDistributionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string NormalDistributionImpl::GetModelType() const
        {
            return "NormalDistribution";
        }

        void NormalDistributionImpl::WriteParameterToExpectedValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__EXPECTED_VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _expectedValue = {};
        }

        void NormalDistributionImpl::WriteParameterToVariance(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VARIANCE, parameterName, nullTextMarker /*no textmarker*/);
            _variance = {};
        }

        std::string NormalDistributionImpl::GetParameterFromExpectedValue() const
        {
            auto expectedValue = OSC_CONSTANTS::ATTRIBUTE__EXPECTED_VALUE;
            return GetParameterNameFromAttribute(expectedValue);
        }

        std::string NormalDistributionImpl::GetParameterFromVariance() const
        {
            auto variance = OSC_CONSTANTS::ATTRIBUTE__VARIANCE;
            return GetParameterNameFromAttribute(variance);
        }

        bool NormalDistributionImpl::IsExpectedValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__EXPECTED_VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool NormalDistributionImpl::IsVarianceParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VARIANCE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IRangeWriter> NormalDistributionImpl::GetWriterRange() const
        {
            return std::dynamic_pointer_cast<IRangeWriter>(_range);
        }

        NormalDistributionImpl::NormalDistributionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__EXPECTED_VALUE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VARIANCE, SimpleType::DOUBLE);
        }

        void NormalDistributionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__EXPECTED_VALUE)
            {
                // Simple type
                _expectedValue = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VARIANCE)
            {
                // Simple type
                _variance = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType NormalDistributionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> NormalDistributionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRange =  GetWriterRange();
                if (kRange)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRange));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> NormalDistributionImpl::Clone()
        {
            auto clonedObject = std::make_shared<NormalDistributionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_expectedValue = GetExpectedValue();
            // Simple type
            clonedObject->_variance = GetVariance();
            // clone indicators
            // clone children
            const auto kRange =  GetWriterRange();
            if (kRange)
            {
                auto clonedChild = std::dynamic_pointer_cast<RangeImpl>(kRange)->Clone();
                auto clonedChildIRange = std::dynamic_pointer_cast<IRange>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRange(std::dynamic_pointer_cast<IRangeWriter>(clonedChildIRange));
            }
            return clonedObject;
        }

        std::string NormalDistributionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> NormalDistributionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RANGE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRange());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> NormalDistributionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> NormalDistributionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string NormalDistributionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void NormalDistributionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__EXPECTED_VALUE)
            {
                // Simple type
                _expectedValue = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VARIANCE)
            {
                // Simple type
                _variance = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void NormalDistributionImpl::ResetRange()
	   {
	   		isSetRange = false; 
			_range = {};
			
	   }
       bool NormalDistributionImpl::IsSetRange() const
	   {
			return isSetRange;
	   }

        IOpenScenarioFlexElement* NurbsImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        uint32_t NurbsImpl::GetOrder() const
        {
        	  return _order;
        }
        std::vector<std::shared_ptr<IControlPoint>> NurbsImpl::GetControlPoints() const
        {
            std::vector<std::shared_ptr<IControlPoint>> temp;
            for(auto&& elm: _controlPoints)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IControlPointWriter>> NurbsImpl::GetWriterControlPoints() const
        {
            return _controlPoints;
        }

        int NurbsImpl::GetControlPointsSize() const
        {
            return static_cast<int>(_controlPoints.size());
        }

        std::shared_ptr<IControlPoint> NurbsImpl::GetControlPointsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _controlPoints.size() > index)
            {
                return _controlPoints[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<IKnot>> NurbsImpl::GetKnots() const
        {
            std::vector<std::shared_ptr<IKnot>> temp;
            for(auto&& elm: _knots)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IKnotWriter>> NurbsImpl::GetWriterKnots() const
        {
            return _knots;
        }

        int NurbsImpl::GetKnotsSize() const
        {
            return static_cast<int>(_knots.size());
        }

        std::shared_ptr<IKnot> NurbsImpl::GetKnotsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _knots.size() > index)
            {
                return _knots[index];
            }
            return nullptr;
        }


        void NurbsImpl::SetOrder(const uint32_t order)
        {
            _order = order;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ORDER);
        }

        void NurbsImpl::SetControlPoints(std::vector<std::shared_ptr<IControlPointWriter>>& controlPoints)
        {
            _controlPoints = controlPoints;
        }

        void NurbsImpl::SetKnots(std::vector<std::shared_ptr<IKnotWriter>>& knots)
        {
            _knots = knots;
        }

        std::shared_ptr<void> NurbsImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(NurbsImpl).name())
                return shared_from_this();
            else if (classifier == typeid(INurbs).name())
                return std::dynamic_pointer_cast<INurbs>(shared_from_this());
            else if (classifier == typeid(INurbsWriter).name())
                return std::dynamic_pointer_cast<INurbsWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> NurbsImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t NurbsImpl::GetUnsignedIntProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__ORDER)
                {
                    return GetOrder();
                }
                throw KeyNotSupportedException();

        }

        int NurbsImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double NurbsImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t NurbsImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool NurbsImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime NurbsImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> NurbsImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string NurbsImpl::GetModelType() const
        {
            return "Nurbs";
        }

        void NurbsImpl::WriteParameterToOrder(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ORDER, parameterName, nullTextMarker /*no textmarker*/);
            _order = {};
        }

        std::string NurbsImpl::GetParameterFromOrder() const
        {
            auto order = OSC_CONSTANTS::ATTRIBUTE__ORDER;
            return GetParameterNameFromAttribute(order);
        }

        bool NurbsImpl::IsOrderParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ORDER);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        NurbsImpl::NurbsImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ORDER, SimpleType::UNSIGNED_INT);
        }

        void NurbsImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ORDER)
            {
                // Simple type
                _order = ParserHelper::ParseUnsignedInt(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType NurbsImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> NurbsImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto controlPoints =  GetWriterControlPoints();
                if (!controlPoints.empty())
                {
                    for(auto&& item : controlPoints)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto knots =  GetWriterKnots();
                if (!knots.empty())
                {
                    for(auto&& item : knots)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> NurbsImpl::Clone()
        {
            auto clonedObject = std::make_shared<NurbsImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_order = GetOrder();
            // clone indicators
            // clone children
            const auto kControlPoints =  GetWriterControlPoints();
            if (!kControlPoints.empty())
            {
                std::vector<std::shared_ptr<IControlPointWriter>> clonedList;
                for(auto&& kItem : kControlPoints)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ControlPointImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IControlPointWriter>(clonedChild));
                }
                clonedObject->SetControlPoints(clonedList);
            }
            const auto kKnots =  GetWriterKnots();
            if (!kKnots.empty())
            {
                std::vector<std::shared_ptr<IKnotWriter>> clonedList;
                for(auto&& kItem : kKnots)
                {
                    auto clonedChild = std::dynamic_pointer_cast<KnotImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IKnotWriter>(clonedChild));
                }
                clonedObject->SetKnots(clonedList);
            }
            return clonedObject;
        }

        std::string NurbsImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> NurbsImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> NurbsImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__CONTROL_POINT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetControlPoints())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__KNOT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetKnots())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> NurbsImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string NurbsImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void NurbsImpl::ResolveUnsignedIntExpression(std::string& attributeKey, unsigned int& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ORDER)
            {
                // Simple type
                _order = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* ObjectControllerImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<ICatalogReference> ObjectControllerImpl::GetCatalogReference() const
        {
        	  return _catalogReference;
        }
        std::shared_ptr<IController> ObjectControllerImpl::GetController() const
        {
        	  return _controller;
        }


        void ObjectControllerImpl::SetCatalogReference(std::shared_ptr<ICatalogReferenceWriter> catalogReference)
        {
            _catalogReference = catalogReference;
            _controller = {};
			// set the indicator to true
            isSetCatalogReference = true;          
        }

        void ObjectControllerImpl::SetController(std::shared_ptr<IControllerWriter> controller)
        {
            _controller = controller;
            _catalogReference = {};
			// set the indicator to true
            isSetController = true;          
        }

        std::shared_ptr<void> ObjectControllerImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ObjectControllerImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IObjectController).name())
                return std::dynamic_pointer_cast<IObjectController>(shared_from_this());
            else if (classifier == typeid(IObjectControllerWriter).name())
                return std::dynamic_pointer_cast<IObjectControllerWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ObjectControllerImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ObjectControllerImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ObjectControllerImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ObjectControllerImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ObjectControllerImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ObjectControllerImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ObjectControllerImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ObjectControllerImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ObjectControllerImpl::GetModelType() const
        {
            return "ObjectController";
        }

            // children
        std::shared_ptr<ICatalogReferenceWriter> ObjectControllerImpl::GetWriterCatalogReference() const
        {
            return std::dynamic_pointer_cast<ICatalogReferenceWriter>(_catalogReference);
        }
        std::shared_ptr<IControllerWriter> ObjectControllerImpl::GetWriterController() const
        {
            return std::dynamic_pointer_cast<IControllerWriter>(_controller);
        }

        ObjectControllerImpl::ObjectControllerImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ObjectControllerImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ObjectControllerImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ObjectControllerImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kCatalogReference =  GetWriterCatalogReference();
                if (kCatalogReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogReference));
                }
                const auto kController =  GetWriterController();
                if (kController)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kController));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ObjectControllerImpl::Clone()
        {
            auto clonedObject = std::make_shared<ObjectControllerImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kCatalogReference =  GetWriterCatalogReference();
            if (kCatalogReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kCatalogReference)->Clone();
                auto clonedChildICatalogReference = std::dynamic_pointer_cast<ICatalogReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogReference(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChildICatalogReference));
            }
            const auto kController =  GetWriterController();
            if (kController)
            {
                auto clonedChild = std::dynamic_pointer_cast<ControllerImpl>(kController)->Clone();
                auto clonedChildIController = std::dynamic_pointer_cast<IController>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetController(std::dynamic_pointer_cast<IControllerWriter>(clonedChildIController));
            }
            return clonedObject;
        }

        std::string ObjectControllerImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ObjectControllerImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogReference());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CONTROLLER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetController());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ObjectControllerImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ObjectControllerImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ObjectControllerImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void ObjectControllerImpl::ResetCatalogReference()
	   {
	   		isSetCatalogReference = false; 
			_catalogReference = {};
			
	   }
       bool ObjectControllerImpl::IsSetCatalogReference() const
	   {
			return isSetCatalogReference;
	   }
       void ObjectControllerImpl::ResetController()
	   {
	   		isSetController = false; 
			_controller = {};
			
	   }
       bool ObjectControllerImpl::IsSetController() const
	   {
			return isSetController;
	   }

        IOpenScenarioFlexElement* OffroadConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double OffroadConditionImpl::GetDuration() const
        {
        	  return _duration;
        }


        void OffroadConditionImpl::SetDuration(const double duration)
        {
            _duration = duration;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DURATION);
        }

        std::shared_ptr<void> OffroadConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(OffroadConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IOffroadCondition).name())
                return std::dynamic_pointer_cast<IOffroadCondition>(shared_from_this());
            else if (classifier == typeid(IOffroadConditionWriter).name())
                return std::dynamic_pointer_cast<IOffroadConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> OffroadConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t OffroadConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int OffroadConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double OffroadConditionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__DURATION)
                {
                    return GetDuration();
                }
                throw KeyNotSupportedException();

        }

        uint16_t OffroadConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool OffroadConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime OffroadConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> OffroadConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string OffroadConditionImpl::GetModelType() const
        {
            return "OffroadCondition";
        }

        void OffroadConditionImpl::WriteParameterToDuration(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DURATION, parameterName, nullTextMarker /*no textmarker*/);
            _duration = {};
        }

        std::string OffroadConditionImpl::GetParameterFromDuration() const
        {
            auto duration = OSC_CONSTANTS::ATTRIBUTE__DURATION;
            return GetParameterNameFromAttribute(duration);
        }

        bool OffroadConditionImpl::IsDurationParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DURATION);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        OffroadConditionImpl::OffroadConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DURATION, SimpleType::DOUBLE);
        }

        void OffroadConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DURATION)
            {
                // Simple type
                _duration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType OffroadConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OffroadConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OffroadConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<OffroadConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_duration = GetDuration();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string OffroadConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OffroadConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OffroadConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OffroadConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OffroadConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void OffroadConditionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DURATION)
            {
                // Simple type
                _duration = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* OpenScenarioImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IFileHeader> OpenScenarioImpl::GetFileHeader() const
        {
        	  return _fileHeader;
        }
        std::shared_ptr<IOpenScenarioCategory> OpenScenarioImpl::GetOpenScenarioCategory() const
        {
        	  return _openScenarioCategory;
        }


        void OpenScenarioImpl::SetFileHeader(std::shared_ptr<IFileHeaderWriter> fileHeader)
        {
            _fileHeader = fileHeader;
        }

        void OpenScenarioImpl::SetOpenScenarioCategory(std::shared_ptr<IOpenScenarioCategoryWriter> openScenarioCategory)
        {
            _openScenarioCategory = openScenarioCategory;
        }

        std::shared_ptr<void> OpenScenarioImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(OpenScenarioImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IOpenScenario).name())
                return std::dynamic_pointer_cast<IOpenScenario>(shared_from_this());
            else if (classifier == typeid(IOpenScenarioWriter).name())
                return std::dynamic_pointer_cast<IOpenScenarioWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> OpenScenarioImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t OpenScenarioImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int OpenScenarioImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double OpenScenarioImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t OpenScenarioImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool OpenScenarioImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime OpenScenarioImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> OpenScenarioImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string OpenScenarioImpl::GetModelType() const
        {
            return "OpenScenario";
        }

            // children
        std::shared_ptr<IFileHeaderWriter> OpenScenarioImpl::GetWriterFileHeader() const
        {
            return std::dynamic_pointer_cast<IFileHeaderWriter>(_fileHeader);
        }
        std::shared_ptr<IOpenScenarioCategoryWriter> OpenScenarioImpl::GetWriterOpenScenarioCategory() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioCategoryWriter>(_openScenarioCategory);
        }

        OpenScenarioImpl::OpenScenarioImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void OpenScenarioImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType OpenScenarioImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OpenScenarioImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kFileHeader =  GetWriterFileHeader();
                if (kFileHeader)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kFileHeader));
                }
                const auto kOpenScenarioCategory =  GetWriterOpenScenarioCategory();
                if (kOpenScenarioCategory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOpenScenarioCategory));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OpenScenarioImpl::Clone()
        {
            auto clonedObject = std::make_shared<OpenScenarioImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kFileHeader =  GetWriterFileHeader();
            if (kFileHeader)
            {
                auto clonedChild = std::dynamic_pointer_cast<FileHeaderImpl>(kFileHeader)->Clone();
                auto clonedChildIFileHeader = std::dynamic_pointer_cast<IFileHeader>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetFileHeader(std::dynamic_pointer_cast<IFileHeaderWriter>(clonedChildIFileHeader));
            }
            const auto kOpenScenarioCategory =  GetWriterOpenScenarioCategory();
            if (kOpenScenarioCategory)
            {
                auto clonedChild = std::dynamic_pointer_cast<OpenScenarioCategoryImpl>(kOpenScenarioCategory)->Clone();
                auto clonedChildIOpenScenarioCategory = std::dynamic_pointer_cast<IOpenScenarioCategory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOpenScenarioCategory(std::dynamic_pointer_cast<IOpenScenarioCategoryWriter>(clonedChildIOpenScenarioCategory));
            }
            return clonedObject;
        }

        std::string OpenScenarioImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OpenScenarioImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__FILE_HEADER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetFileHeader());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__OPEN_SCENARIO_CATEGORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOpenScenarioCategory());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OpenScenarioImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OpenScenarioImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OpenScenarioImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* OpenScenarioCategoryImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IScenarioDefinition> OpenScenarioCategoryImpl::GetScenarioDefinition() const
        {
        	  return _scenarioDefinition;
        }
        std::shared_ptr<ICatalogDefinition> OpenScenarioCategoryImpl::GetCatalogDefinition() const
        {
        	  return _catalogDefinition;
        }
        std::shared_ptr<IParameterValueDistributionDefinition> OpenScenarioCategoryImpl::GetParameterValueDistributionDefinition() const
        {
        	  return _parameterValueDistributionDefinition;
        }


        void OpenScenarioCategoryImpl::SetScenarioDefinition(std::shared_ptr<IScenarioDefinitionWriter> scenarioDefinition)
        {
            _scenarioDefinition = scenarioDefinition;
            _catalogDefinition = {};
            _parameterValueDistributionDefinition = {};
        }

        void OpenScenarioCategoryImpl::SetCatalogDefinition(std::shared_ptr<ICatalogDefinitionWriter> catalogDefinition)
        {
            _catalogDefinition = catalogDefinition;
            _scenarioDefinition = {};
            _parameterValueDistributionDefinition = {};
        }

        void OpenScenarioCategoryImpl::SetParameterValueDistributionDefinition(std::shared_ptr<IParameterValueDistributionDefinitionWriter> parameterValueDistributionDefinition)
        {
            _parameterValueDistributionDefinition = parameterValueDistributionDefinition;
            _scenarioDefinition = {};
            _catalogDefinition = {};
        }

        std::shared_ptr<void> OpenScenarioCategoryImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(OpenScenarioCategoryImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IOpenScenarioCategory).name())
                return std::dynamic_pointer_cast<IOpenScenarioCategory>(shared_from_this());
            else if (classifier == typeid(IOpenScenarioCategoryWriter).name())
                return std::dynamic_pointer_cast<IOpenScenarioCategoryWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> OpenScenarioCategoryImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t OpenScenarioCategoryImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int OpenScenarioCategoryImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double OpenScenarioCategoryImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t OpenScenarioCategoryImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool OpenScenarioCategoryImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime OpenScenarioCategoryImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> OpenScenarioCategoryImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string OpenScenarioCategoryImpl::GetModelType() const
        {
            return "OpenScenarioCategory";
        }

            // children
        std::shared_ptr<IScenarioDefinitionWriter> OpenScenarioCategoryImpl::GetWriterScenarioDefinition() const
        {
            return std::dynamic_pointer_cast<IScenarioDefinitionWriter>(_scenarioDefinition);
        }
        std::shared_ptr<ICatalogDefinitionWriter> OpenScenarioCategoryImpl::GetWriterCatalogDefinition() const
        {
            return std::dynamic_pointer_cast<ICatalogDefinitionWriter>(_catalogDefinition);
        }
        std::shared_ptr<IParameterValueDistributionDefinitionWriter> OpenScenarioCategoryImpl::GetWriterParameterValueDistributionDefinition() const
        {
            return std::dynamic_pointer_cast<IParameterValueDistributionDefinitionWriter>(_parameterValueDistributionDefinition);
        }

        OpenScenarioCategoryImpl::OpenScenarioCategoryImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void OpenScenarioCategoryImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType OpenScenarioCategoryImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OpenScenarioCategoryImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kScenarioDefinition =  GetWriterScenarioDefinition();
                if (kScenarioDefinition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kScenarioDefinition));
                }
                const auto kCatalogDefinition =  GetWriterCatalogDefinition();
                if (kCatalogDefinition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogDefinition));
                }
                const auto kParameterValueDistributionDefinition =  GetWriterParameterValueDistributionDefinition();
                if (kParameterValueDistributionDefinition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kParameterValueDistributionDefinition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OpenScenarioCategoryImpl::Clone()
        {
            auto clonedObject = std::make_shared<OpenScenarioCategoryImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kScenarioDefinition =  GetWriterScenarioDefinition();
            if (kScenarioDefinition)
            {
                auto clonedChild = std::dynamic_pointer_cast<ScenarioDefinitionImpl>(kScenarioDefinition)->Clone();
                auto clonedChildIScenarioDefinition = std::dynamic_pointer_cast<IScenarioDefinition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetScenarioDefinition(std::dynamic_pointer_cast<IScenarioDefinitionWriter>(clonedChildIScenarioDefinition));
            }
            const auto kCatalogDefinition =  GetWriterCatalogDefinition();
            if (kCatalogDefinition)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogDefinitionImpl>(kCatalogDefinition)->Clone();
                auto clonedChildICatalogDefinition = std::dynamic_pointer_cast<ICatalogDefinition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogDefinition(std::dynamic_pointer_cast<ICatalogDefinitionWriter>(clonedChildICatalogDefinition));
            }
            const auto kParameterValueDistributionDefinition =  GetWriterParameterValueDistributionDefinition();
            if (kParameterValueDistributionDefinition)
            {
                auto clonedChild = std::dynamic_pointer_cast<ParameterValueDistributionDefinitionImpl>(kParameterValueDistributionDefinition)->Clone();
                auto clonedChildIParameterValueDistributionDefinition = std::dynamic_pointer_cast<IParameterValueDistributionDefinition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetParameterValueDistributionDefinition(std::dynamic_pointer_cast<IParameterValueDistributionDefinitionWriter>(clonedChildIParameterValueDistributionDefinition));
            }
            return clonedObject;
        }

        std::string OpenScenarioCategoryImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OpenScenarioCategoryImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SCENARIO_DEFINITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetScenarioDefinition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_DEFINITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogDefinition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_VALUE_DISTRIBUTION_DEFINITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParameterValueDistributionDefinition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OpenScenarioCategoryImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OpenScenarioCategoryImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OpenScenarioCategoryImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* OrientationImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double OrientationImpl::GetH() const
        {
        	  return _h;
        }
        double OrientationImpl::GetP() const
        {
        	  return _p;
        }
        double OrientationImpl::GetR() const
        {
        	  return _r;
        }
        ReferenceContext OrientationImpl::GetType() const
        {
        	  return _type;
        }


        void OrientationImpl::SetH(const double h)
        {
            _h = h;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__H);
			// set the indicator to true
            isSetH = true;          
        }

        void OrientationImpl::SetP(const double p)
        {
            _p = p;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__P);
			// set the indicator to true
            isSetP = true;          
        }

        void OrientationImpl::SetR(const double r)
        {
            _r = r;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__R);
			// set the indicator to true
            isSetR = true;          
        }

        void OrientationImpl::SetType(const ReferenceContext type)
        {
            _type = type;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TYPE);
			// set the indicator to true
            isSetType = true;          
        }

        std::shared_ptr<void> OrientationImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(OrientationImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IOrientation).name())
                return std::dynamic_pointer_cast<IOrientation>(shared_from_this());
            else if (classifier == typeid(IOrientationWriter).name())
                return std::dynamic_pointer_cast<IOrientationWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> OrientationImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t OrientationImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int OrientationImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double OrientationImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__H)
                {
                    return GetH();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__P)
                {
                    return GetP();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__R)
                {
                    return GetR();
                }
                throw KeyNotSupportedException();

        }

        uint16_t OrientationImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool OrientationImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime OrientationImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> OrientationImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string OrientationImpl::GetModelType() const
        {
            return "Orientation";
        }

        void OrientationImpl::WriteParameterToH(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__H, parameterName, nullTextMarker /*no textmarker*/);
            _h = {};
        }

        void OrientationImpl::WriteParameterToP(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__P, parameterName, nullTextMarker /*no textmarker*/);
            _p = {};
        }

        void OrientationImpl::WriteParameterToR(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__R, parameterName, nullTextMarker /*no textmarker*/);
            _r = {};
        }

        void OrientationImpl::WriteParameterToType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _type = {};
        }

        std::string OrientationImpl::GetParameterFromH() const
        {
            auto h = OSC_CONSTANTS::ATTRIBUTE__H;
            return GetParameterNameFromAttribute(h);
        }

        std::string OrientationImpl::GetParameterFromP() const
        {
            auto p = OSC_CONSTANTS::ATTRIBUTE__P;
            return GetParameterNameFromAttribute(p);
        }

        std::string OrientationImpl::GetParameterFromR() const
        {
            auto r = OSC_CONSTANTS::ATTRIBUTE__R;
            return GetParameterNameFromAttribute(r);
        }

        std::string OrientationImpl::GetParameterFromType() const
        {
            auto type = OSC_CONSTANTS::ATTRIBUTE__TYPE;
            return GetParameterNameFromAttribute(type);
        }

        bool OrientationImpl::IsHParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__H);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool OrientationImpl::IsPParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__P);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool OrientationImpl::IsRParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__R);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool OrientationImpl::IsTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        OrientationImpl::OrientationImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__H, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__P, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__R, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TYPE, SimpleType::ENUM_TYPE);
        }

        void OrientationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__H)
            {
                // Simple type
                _h = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__P)
            {
                // Simple type
                _p = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__R)
            {
                // Simple type
                _r = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TYPE)
            {
                // Enumeration Type
                const auto kResult = ReferenceContext::GetFromLiteral(parameterLiteralValue);
                if (kResult != ReferenceContext::UNKNOWN)
                {
                    _type = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType OrientationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OrientationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OrientationImpl::Clone()
        {
            auto clonedObject = std::make_shared<OrientationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_h = GetH();
            // Simple type
            clonedObject->_p = GetP();
            // Simple type
            clonedObject->_r = GetR();
            // Enumeration Type
            const auto kType = GetType();
            if ( kType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_type = ReferenceContext::GetFromLiteral(kType.GetLiteral());
            }
            // clone indicators
            	clonedObject->isSetH = isSetH;
            	clonedObject->isSetP = isSetP;
            	clonedObject->isSetR = isSetR;
            	clonedObject->isSetType = isSetType;
            // clone children
            return clonedObject;
        }

        std::string OrientationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OrientationImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OrientationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OrientationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OrientationImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__TYPE)
            {
                auto type = GetType();
                return type.GetLiteral() != "UNKNOWN" ? type.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void OrientationImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__H)
            {
                // Simple type
                _h = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__P)
            {
                // Simple type
                _p = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__R)
            {
                // Simple type
                _r = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void OrientationImpl::ResetH()
	   {
	   		isSetH = false; 
			_h = {0};
			
	   }
       bool OrientationImpl::IsSetH() const
	   {
			return isSetH;
	   }
       void OrientationImpl::ResetP()
	   {
	   		isSetP = false; 
			_p = {0};
			
	   }
       bool OrientationImpl::IsSetP() const
	   {
			return isSetP;
	   }
       void OrientationImpl::ResetR()
	   {
	   		isSetR = false; 
			_r = {0};
			
	   }
       bool OrientationImpl::IsSetR() const
	   {
			return isSetR;
	   }
       void OrientationImpl::ResetType()
	   {
	   		isSetType = false; 
			_type = {ReferenceContext::ReferenceContextEnum::ABSOLUTE};
			
	   }
       bool OrientationImpl::IsSetType() const
	   {
			return isSetType;
	   }

        IOpenScenarioFlexElement* OverrideBrakeActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool OverrideBrakeActionImpl::GetActive() const
        {
        	  return _active;
        }
        double OverrideBrakeActionImpl::GetValue() const
        {
        	  return _value;
        }
        std::shared_ptr<IBrakeInput> OverrideBrakeActionImpl::GetBrakeInput() const
        {
        	  return _brakeInput;
        }


        void OverrideBrakeActionImpl::SetActive(const bool active)
        {
            _active = active;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVE);
        }

        void OverrideBrakeActionImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
			// set the indicator to true
            isSetValue = true;          
        }

        void OverrideBrakeActionImpl::SetBrakeInput(std::shared_ptr<IBrakeInputWriter> brakeInput)
        {
            _brakeInput = brakeInput;
			// set the indicator to true
            isSetBrakeInput = true;          
        }

        std::shared_ptr<void> OverrideBrakeActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(OverrideBrakeActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IOverrideBrakeAction).name())
                return std::dynamic_pointer_cast<IOverrideBrakeAction>(shared_from_this());
            else if (classifier == typeid(IOverrideBrakeActionWriter).name())
                return std::dynamic_pointer_cast<IOverrideBrakeActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> OverrideBrakeActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t OverrideBrakeActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int OverrideBrakeActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double OverrideBrakeActionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t OverrideBrakeActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool OverrideBrakeActionImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
                {
                    return GetActive();
                }
                throw KeyNotSupportedException();

        }

        DateTime OverrideBrakeActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> OverrideBrakeActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string OverrideBrakeActionImpl::GetModelType() const
        {
            return "OverrideBrakeAction";
        }

        void OverrideBrakeActionImpl::WriteParameterToActive(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVE, parameterName, nullTextMarker /*no textmarker*/);
            _active = {};
        }

        void OverrideBrakeActionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string OverrideBrakeActionImpl::GetParameterFromActive() const
        {
            auto active = OSC_CONSTANTS::ATTRIBUTE__ACTIVE;
            return GetParameterNameFromAttribute(active);
        }

        std::string OverrideBrakeActionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool OverrideBrakeActionImpl::IsActiveParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ACTIVE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool OverrideBrakeActionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IBrakeInputWriter> OverrideBrakeActionImpl::GetWriterBrakeInput() const
        {
            return std::dynamic_pointer_cast<IBrakeInputWriter>(_brakeInput);
        }

        OverrideBrakeActionImpl::OverrideBrakeActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ACTIVE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void OverrideBrakeActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
            {
                // Simple type
                _active = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType OverrideBrakeActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OverrideBrakeActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kBrakeInput =  GetWriterBrakeInput();
                if (kBrakeInput)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kBrakeInput));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OverrideBrakeActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<OverrideBrakeActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_active = GetActive();
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            	clonedObject->isSetValue = isSetValue;
            // clone children
            const auto kBrakeInput =  GetWriterBrakeInput();
            if (kBrakeInput)
            {
                auto clonedChild = std::dynamic_pointer_cast<BrakeInputImpl>(kBrakeInput)->Clone();
                auto clonedChildIBrakeInput = std::dynamic_pointer_cast<IBrakeInput>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetBrakeInput(std::dynamic_pointer_cast<IBrakeInputWriter>(clonedChildIBrakeInput));
            }
            return clonedObject;
        }

        std::string OverrideBrakeActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideBrakeActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BRAKE_INPUT)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetBrakeInput());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OverrideBrakeActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideBrakeActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OverrideBrakeActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void OverrideBrakeActionImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
            {
                // Simple type
                _active = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void OverrideBrakeActionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void OverrideBrakeActionImpl::ResetValue()
	   {
	   		isSetValue = false; 
			_value = {};
			
	   }
       bool OverrideBrakeActionImpl::IsSetValue() const
	   {
			return isSetValue;
	   }
       void OverrideBrakeActionImpl::ResetBrakeInput()
	   {
	   		isSetBrakeInput = false; 
			_brakeInput = {};
			
	   }
       bool OverrideBrakeActionImpl::IsSetBrakeInput() const
	   {
			return isSetBrakeInput;
	   }

        IOpenScenarioFlexElement* OverrideClutchActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool OverrideClutchActionImpl::GetActive() const
        {
        	  return _active;
        }
        double OverrideClutchActionImpl::GetMaxRate() const
        {
        	  return _maxRate;
        }
        double OverrideClutchActionImpl::GetValue() const
        {
        	  return _value;
        }


        void OverrideClutchActionImpl::SetActive(const bool active)
        {
            _active = active;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVE);
        }

        void OverrideClutchActionImpl::SetMaxRate(const double maxRate)
        {
            _maxRate = maxRate;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_RATE);
			// set the indicator to true
            isSetMaxRate = true;          
        }

        void OverrideClutchActionImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> OverrideClutchActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(OverrideClutchActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IOverrideClutchAction).name())
                return std::dynamic_pointer_cast<IOverrideClutchAction>(shared_from_this());
            else if (classifier == typeid(IOverrideClutchActionWriter).name())
                return std::dynamic_pointer_cast<IOverrideClutchActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> OverrideClutchActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t OverrideClutchActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int OverrideClutchActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double OverrideClutchActionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAX_RATE)
                {
                    return GetMaxRate();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t OverrideClutchActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool OverrideClutchActionImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
                {
                    return GetActive();
                }
                throw KeyNotSupportedException();

        }

        DateTime OverrideClutchActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> OverrideClutchActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string OverrideClutchActionImpl::GetModelType() const
        {
            return "OverrideClutchAction";
        }

        void OverrideClutchActionImpl::WriteParameterToActive(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVE, parameterName, nullTextMarker /*no textmarker*/);
            _active = {};
        }

        void OverrideClutchActionImpl::WriteParameterToMaxRate(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_RATE, parameterName, nullTextMarker /*no textmarker*/);
            _maxRate = {};
        }

        void OverrideClutchActionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string OverrideClutchActionImpl::GetParameterFromActive() const
        {
            auto active = OSC_CONSTANTS::ATTRIBUTE__ACTIVE;
            return GetParameterNameFromAttribute(active);
        }

        std::string OverrideClutchActionImpl::GetParameterFromMaxRate() const
        {
            auto maxRate = OSC_CONSTANTS::ATTRIBUTE__MAX_RATE;
            return GetParameterNameFromAttribute(maxRate);
        }

        std::string OverrideClutchActionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool OverrideClutchActionImpl::IsActiveParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ACTIVE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool OverrideClutchActionImpl::IsMaxRateParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAX_RATE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool OverrideClutchActionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        OverrideClutchActionImpl::OverrideClutchActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ACTIVE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_RATE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void OverrideClutchActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
            {
                // Simple type
                _active = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_RATE)
            {
                // Simple type
                _maxRate = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType OverrideClutchActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OverrideClutchActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OverrideClutchActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<OverrideClutchActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_active = GetActive();
            // Simple type
            clonedObject->_maxRate = GetMaxRate();
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            	clonedObject->isSetMaxRate = isSetMaxRate;
            // clone children
            return clonedObject;
        }

        std::string OverrideClutchActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideClutchActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OverrideClutchActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideClutchActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OverrideClutchActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void OverrideClutchActionImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
            {
                // Simple type
                _active = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void OverrideClutchActionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_RATE)
            {
                // Simple type
                _maxRate = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void OverrideClutchActionImpl::ResetMaxRate()
	   {
	   		isSetMaxRate = false; 
			_maxRate = {};
			
	   }
       bool OverrideClutchActionImpl::IsSetMaxRate() const
	   {
			return isSetMaxRate;
	   }

        IOpenScenarioFlexElement* OverrideControllerValueActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IOverrideThrottleAction> OverrideControllerValueActionImpl::GetThrottle() const
        {
        	  return _throttle;
        }
        std::shared_ptr<IOverrideBrakeAction> OverrideControllerValueActionImpl::GetBrake() const
        {
        	  return _brake;
        }
        std::shared_ptr<IOverrideClutchAction> OverrideControllerValueActionImpl::GetClutch() const
        {
        	  return _clutch;
        }
        std::shared_ptr<IOverrideParkingBrakeAction> OverrideControllerValueActionImpl::GetParkingBrake() const
        {
        	  return _parkingBrake;
        }
        std::shared_ptr<IOverrideSteeringWheelAction> OverrideControllerValueActionImpl::GetSteeringWheel() const
        {
        	  return _steeringWheel;
        }
        std::shared_ptr<IOverrideGearAction> OverrideControllerValueActionImpl::GetGear() const
        {
        	  return _gear;
        }


        void OverrideControllerValueActionImpl::SetThrottle(std::shared_ptr<IOverrideThrottleActionWriter> throttle)
        {
            _throttle = throttle;
			// set the indicator to true
            isSetThrottle = true;          
        }

        void OverrideControllerValueActionImpl::SetBrake(std::shared_ptr<IOverrideBrakeActionWriter> brake)
        {
            _brake = brake;
			// set the indicator to true
            isSetBrake = true;          
        }

        void OverrideControllerValueActionImpl::SetClutch(std::shared_ptr<IOverrideClutchActionWriter> clutch)
        {
            _clutch = clutch;
			// set the indicator to true
            isSetClutch = true;          
        }

        void OverrideControllerValueActionImpl::SetParkingBrake(std::shared_ptr<IOverrideParkingBrakeActionWriter> parkingBrake)
        {
            _parkingBrake = parkingBrake;
			// set the indicator to true
            isSetParkingBrake = true;          
        }

        void OverrideControllerValueActionImpl::SetSteeringWheel(std::shared_ptr<IOverrideSteeringWheelActionWriter> steeringWheel)
        {
            _steeringWheel = steeringWheel;
			// set the indicator to true
            isSetSteeringWheel = true;          
        }

        void OverrideControllerValueActionImpl::SetGear(std::shared_ptr<IOverrideGearActionWriter> gear)
        {
            _gear = gear;
			// set the indicator to true
            isSetGear = true;          
        }

        std::shared_ptr<void> OverrideControllerValueActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(OverrideControllerValueActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IOverrideControllerValueAction).name())
                return std::dynamic_pointer_cast<IOverrideControllerValueAction>(shared_from_this());
            else if (classifier == typeid(IOverrideControllerValueActionWriter).name())
                return std::dynamic_pointer_cast<IOverrideControllerValueActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> OverrideControllerValueActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t OverrideControllerValueActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int OverrideControllerValueActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double OverrideControllerValueActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t OverrideControllerValueActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool OverrideControllerValueActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime OverrideControllerValueActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> OverrideControllerValueActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string OverrideControllerValueActionImpl::GetModelType() const
        {
            return "OverrideControllerValueAction";
        }

            // children
        std::shared_ptr<IOverrideThrottleActionWriter> OverrideControllerValueActionImpl::GetWriterThrottle() const
        {
            return std::dynamic_pointer_cast<IOverrideThrottleActionWriter>(_throttle);
        }
        std::shared_ptr<IOverrideBrakeActionWriter> OverrideControllerValueActionImpl::GetWriterBrake() const
        {
            return std::dynamic_pointer_cast<IOverrideBrakeActionWriter>(_brake);
        }
        std::shared_ptr<IOverrideClutchActionWriter> OverrideControllerValueActionImpl::GetWriterClutch() const
        {
            return std::dynamic_pointer_cast<IOverrideClutchActionWriter>(_clutch);
        }
        std::shared_ptr<IOverrideParkingBrakeActionWriter> OverrideControllerValueActionImpl::GetWriterParkingBrake() const
        {
            return std::dynamic_pointer_cast<IOverrideParkingBrakeActionWriter>(_parkingBrake);
        }
        std::shared_ptr<IOverrideSteeringWheelActionWriter> OverrideControllerValueActionImpl::GetWriterSteeringWheel() const
        {
            return std::dynamic_pointer_cast<IOverrideSteeringWheelActionWriter>(_steeringWheel);
        }
        std::shared_ptr<IOverrideGearActionWriter> OverrideControllerValueActionImpl::GetWriterGear() const
        {
            return std::dynamic_pointer_cast<IOverrideGearActionWriter>(_gear);
        }

        OverrideControllerValueActionImpl::OverrideControllerValueActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void OverrideControllerValueActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType OverrideControllerValueActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OverrideControllerValueActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kThrottle =  GetWriterThrottle();
                if (kThrottle)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kThrottle));
                }
                const auto kBrake =  GetWriterBrake();
                if (kBrake)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kBrake));
                }
                const auto kClutch =  GetWriterClutch();
                if (kClutch)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kClutch));
                }
                const auto kParkingBrake =  GetWriterParkingBrake();
                if (kParkingBrake)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kParkingBrake));
                }
                const auto kSteeringWheel =  GetWriterSteeringWheel();
                if (kSteeringWheel)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSteeringWheel));
                }
                const auto kGear =  GetWriterGear();
                if (kGear)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kGear));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OverrideControllerValueActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<OverrideControllerValueActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kThrottle =  GetWriterThrottle();
            if (kThrottle)
            {
                auto clonedChild = std::dynamic_pointer_cast<OverrideThrottleActionImpl>(kThrottle)->Clone();
                auto clonedChildIOverrideThrottleAction = std::dynamic_pointer_cast<IOverrideThrottleAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetThrottle(std::dynamic_pointer_cast<IOverrideThrottleActionWriter>(clonedChildIOverrideThrottleAction));
            }
            const auto kBrake =  GetWriterBrake();
            if (kBrake)
            {
                auto clonedChild = std::dynamic_pointer_cast<OverrideBrakeActionImpl>(kBrake)->Clone();
                auto clonedChildIOverrideBrakeAction = std::dynamic_pointer_cast<IOverrideBrakeAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetBrake(std::dynamic_pointer_cast<IOverrideBrakeActionWriter>(clonedChildIOverrideBrakeAction));
            }
            const auto kClutch =  GetWriterClutch();
            if (kClutch)
            {
                auto clonedChild = std::dynamic_pointer_cast<OverrideClutchActionImpl>(kClutch)->Clone();
                auto clonedChildIOverrideClutchAction = std::dynamic_pointer_cast<IOverrideClutchAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetClutch(std::dynamic_pointer_cast<IOverrideClutchActionWriter>(clonedChildIOverrideClutchAction));
            }
            const auto kParkingBrake =  GetWriterParkingBrake();
            if (kParkingBrake)
            {
                auto clonedChild = std::dynamic_pointer_cast<OverrideParkingBrakeActionImpl>(kParkingBrake)->Clone();
                auto clonedChildIOverrideParkingBrakeAction = std::dynamic_pointer_cast<IOverrideParkingBrakeAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetParkingBrake(std::dynamic_pointer_cast<IOverrideParkingBrakeActionWriter>(clonedChildIOverrideParkingBrakeAction));
            }
            const auto kSteeringWheel =  GetWriterSteeringWheel();
            if (kSteeringWheel)
            {
                auto clonedChild = std::dynamic_pointer_cast<OverrideSteeringWheelActionImpl>(kSteeringWheel)->Clone();
                auto clonedChildIOverrideSteeringWheelAction = std::dynamic_pointer_cast<IOverrideSteeringWheelAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSteeringWheel(std::dynamic_pointer_cast<IOverrideSteeringWheelActionWriter>(clonedChildIOverrideSteeringWheelAction));
            }
            const auto kGear =  GetWriterGear();
            if (kGear)
            {
                auto clonedChild = std::dynamic_pointer_cast<OverrideGearActionImpl>(kGear)->Clone();
                auto clonedChildIOverrideGearAction = std::dynamic_pointer_cast<IOverrideGearAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetGear(std::dynamic_pointer_cast<IOverrideGearActionWriter>(clonedChildIOverrideGearAction));
            }
            return clonedObject;
        }

        std::string OverrideControllerValueActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideControllerValueActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__THROTTLE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetThrottle());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BRAKE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetBrake());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CLUTCH)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetClutch());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PARKING_BRAKE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParkingBrake());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__STEERING_WHEEL)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSteeringWheel());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__GEAR)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetGear());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OverrideControllerValueActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideControllerValueActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OverrideControllerValueActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void OverrideControllerValueActionImpl::ResetThrottle()
	   {
	   		isSetThrottle = false; 
			_throttle = {};
			
	   }
       bool OverrideControllerValueActionImpl::IsSetThrottle() const
	   {
			return isSetThrottle;
	   }
       void OverrideControllerValueActionImpl::ResetBrake()
	   {
	   		isSetBrake = false; 
			_brake = {};
			
	   }
       bool OverrideControllerValueActionImpl::IsSetBrake() const
	   {
			return isSetBrake;
	   }
       void OverrideControllerValueActionImpl::ResetClutch()
	   {
	   		isSetClutch = false; 
			_clutch = {};
			
	   }
       bool OverrideControllerValueActionImpl::IsSetClutch() const
	   {
			return isSetClutch;
	   }
       void OverrideControllerValueActionImpl::ResetParkingBrake()
	   {
	   		isSetParkingBrake = false; 
			_parkingBrake = {};
			
	   }
       bool OverrideControllerValueActionImpl::IsSetParkingBrake() const
	   {
			return isSetParkingBrake;
	   }
       void OverrideControllerValueActionImpl::ResetSteeringWheel()
	   {
	   		isSetSteeringWheel = false; 
			_steeringWheel = {};
			
	   }
       bool OverrideControllerValueActionImpl::IsSetSteeringWheel() const
	   {
			return isSetSteeringWheel;
	   }
       void OverrideControllerValueActionImpl::ResetGear()
	   {
	   		isSetGear = false; 
			_gear = {};
			
	   }
       bool OverrideControllerValueActionImpl::IsSetGear() const
	   {
			return isSetGear;
	   }

        IOpenScenarioFlexElement* OverrideGearActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool OverrideGearActionImpl::GetActive() const
        {
        	  return _active;
        }
        double OverrideGearActionImpl::GetNumber() const
        {
        	  return _number;
        }
        std::shared_ptr<IGear> OverrideGearActionImpl::GetGear() const
        {
        	  return _gear;
        }


        void OverrideGearActionImpl::SetActive(const bool active)
        {
            _active = active;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVE);
        }

        void OverrideGearActionImpl::SetNumber(const double number)
        {
            _number = number;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NUMBER);
			// set the indicator to true
            isSetNumber = true;          
        }

        void OverrideGearActionImpl::SetGear(std::shared_ptr<IGearWriter> gear)
        {
            _gear = gear;
			// set the indicator to true
            isSetGear = true;          
        }

        std::shared_ptr<void> OverrideGearActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(OverrideGearActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IOverrideGearAction).name())
                return std::dynamic_pointer_cast<IOverrideGearAction>(shared_from_this());
            else if (classifier == typeid(IOverrideGearActionWriter).name())
                return std::dynamic_pointer_cast<IOverrideGearActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> OverrideGearActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t OverrideGearActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int OverrideGearActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double OverrideGearActionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__NUMBER)
                {
                    return GetNumber();
                }
                throw KeyNotSupportedException();

        }

        uint16_t OverrideGearActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool OverrideGearActionImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
                {
                    return GetActive();
                }
                throw KeyNotSupportedException();

        }

        DateTime OverrideGearActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> OverrideGearActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string OverrideGearActionImpl::GetModelType() const
        {
            return "OverrideGearAction";
        }

        void OverrideGearActionImpl::WriteParameterToActive(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVE, parameterName, nullTextMarker /*no textmarker*/);
            _active = {};
        }

        void OverrideGearActionImpl::WriteParameterToNumber(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NUMBER, parameterName, nullTextMarker /*no textmarker*/);
            _number = {};
        }

        std::string OverrideGearActionImpl::GetParameterFromActive() const
        {
            auto active = OSC_CONSTANTS::ATTRIBUTE__ACTIVE;
            return GetParameterNameFromAttribute(active);
        }

        std::string OverrideGearActionImpl::GetParameterFromNumber() const
        {
            auto number = OSC_CONSTANTS::ATTRIBUTE__NUMBER;
            return GetParameterNameFromAttribute(number);
        }

        bool OverrideGearActionImpl::IsActiveParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ACTIVE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool OverrideGearActionImpl::IsNumberParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NUMBER);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IGearWriter> OverrideGearActionImpl::GetWriterGear() const
        {
            return std::dynamic_pointer_cast<IGearWriter>(_gear);
        }

        OverrideGearActionImpl::OverrideGearActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ACTIVE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NUMBER, SimpleType::DOUBLE);
        }

        void OverrideGearActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
            {
                // Simple type
                _active = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NUMBER)
            {
                // Simple type
                _number = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType OverrideGearActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OverrideGearActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kGear =  GetWriterGear();
                if (kGear)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kGear));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OverrideGearActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<OverrideGearActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_active = GetActive();
            // Simple type
            clonedObject->_number = GetNumber();
            // clone indicators
            	clonedObject->isSetNumber = isSetNumber;
            // clone children
            const auto kGear =  GetWriterGear();
            if (kGear)
            {
                auto clonedChild = std::dynamic_pointer_cast<GearImpl>(kGear)->Clone();
                auto clonedChildIGear = std::dynamic_pointer_cast<IGear>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetGear(std::dynamic_pointer_cast<IGearWriter>(clonedChildIGear));
            }
            return clonedObject;
        }

        std::string OverrideGearActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideGearActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__GEAR)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetGear());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OverrideGearActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideGearActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OverrideGearActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void OverrideGearActionImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
            {
                // Simple type
                _active = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void OverrideGearActionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NUMBER)
            {
                // Simple type
                _number = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void OverrideGearActionImpl::ResetNumber()
	   {
	   		isSetNumber = false; 
			_number = {};
			
	   }
       bool OverrideGearActionImpl::IsSetNumber() const
	   {
			return isSetNumber;
	   }
       void OverrideGearActionImpl::ResetGear()
	   {
	   		isSetGear = false; 
			_gear = {};
			
	   }
       bool OverrideGearActionImpl::IsSetGear() const
	   {
			return isSetGear;
	   }

        IOpenScenarioFlexElement* OverrideParkingBrakeActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool OverrideParkingBrakeActionImpl::GetActive() const
        {
        	  return _active;
        }
        double OverrideParkingBrakeActionImpl::GetValue() const
        {
        	  return _value;
        }
        std::shared_ptr<IBrakeInput> OverrideParkingBrakeActionImpl::GetBrakeInput() const
        {
        	  return _brakeInput;
        }


        void OverrideParkingBrakeActionImpl::SetActive(const bool active)
        {
            _active = active;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVE);
        }

        void OverrideParkingBrakeActionImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
			// set the indicator to true
            isSetValue = true;          
        }

        void OverrideParkingBrakeActionImpl::SetBrakeInput(std::shared_ptr<IBrakeInputWriter> brakeInput)
        {
            _brakeInput = brakeInput;
			// set the indicator to true
            isSetBrakeInput = true;          
        }

        std::shared_ptr<void> OverrideParkingBrakeActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(OverrideParkingBrakeActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IOverrideParkingBrakeAction).name())
                return std::dynamic_pointer_cast<IOverrideParkingBrakeAction>(shared_from_this());
            else if (classifier == typeid(IOverrideParkingBrakeActionWriter).name())
                return std::dynamic_pointer_cast<IOverrideParkingBrakeActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> OverrideParkingBrakeActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t OverrideParkingBrakeActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int OverrideParkingBrakeActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double OverrideParkingBrakeActionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t OverrideParkingBrakeActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool OverrideParkingBrakeActionImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
                {
                    return GetActive();
                }
                throw KeyNotSupportedException();

        }

        DateTime OverrideParkingBrakeActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> OverrideParkingBrakeActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string OverrideParkingBrakeActionImpl::GetModelType() const
        {
            return "OverrideParkingBrakeAction";
        }

        void OverrideParkingBrakeActionImpl::WriteParameterToActive(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVE, parameterName, nullTextMarker /*no textmarker*/);
            _active = {};
        }

        void OverrideParkingBrakeActionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string OverrideParkingBrakeActionImpl::GetParameterFromActive() const
        {
            auto active = OSC_CONSTANTS::ATTRIBUTE__ACTIVE;
            return GetParameterNameFromAttribute(active);
        }

        std::string OverrideParkingBrakeActionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool OverrideParkingBrakeActionImpl::IsActiveParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ACTIVE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool OverrideParkingBrakeActionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IBrakeInputWriter> OverrideParkingBrakeActionImpl::GetWriterBrakeInput() const
        {
            return std::dynamic_pointer_cast<IBrakeInputWriter>(_brakeInput);
        }

        OverrideParkingBrakeActionImpl::OverrideParkingBrakeActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ACTIVE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void OverrideParkingBrakeActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
            {
                // Simple type
                _active = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType OverrideParkingBrakeActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OverrideParkingBrakeActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kBrakeInput =  GetWriterBrakeInput();
                if (kBrakeInput)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kBrakeInput));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OverrideParkingBrakeActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<OverrideParkingBrakeActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_active = GetActive();
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            	clonedObject->isSetValue = isSetValue;
            // clone children
            const auto kBrakeInput =  GetWriterBrakeInput();
            if (kBrakeInput)
            {
                auto clonedChild = std::dynamic_pointer_cast<BrakeInputImpl>(kBrakeInput)->Clone();
                auto clonedChildIBrakeInput = std::dynamic_pointer_cast<IBrakeInput>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetBrakeInput(std::dynamic_pointer_cast<IBrakeInputWriter>(clonedChildIBrakeInput));
            }
            return clonedObject;
        }

        std::string OverrideParkingBrakeActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideParkingBrakeActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BRAKE_INPUT)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetBrakeInput());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OverrideParkingBrakeActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideParkingBrakeActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OverrideParkingBrakeActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void OverrideParkingBrakeActionImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
            {
                // Simple type
                _active = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void OverrideParkingBrakeActionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void OverrideParkingBrakeActionImpl::ResetValue()
	   {
	   		isSetValue = false; 
			_value = {};
			
	   }
       bool OverrideParkingBrakeActionImpl::IsSetValue() const
	   {
			return isSetValue;
	   }
       void OverrideParkingBrakeActionImpl::ResetBrakeInput()
	   {
	   		isSetBrakeInput = false; 
			_brakeInput = {};
			
	   }
       bool OverrideParkingBrakeActionImpl::IsSetBrakeInput() const
	   {
			return isSetBrakeInput;
	   }

        IOpenScenarioFlexElement* OverrideSteeringWheelActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool OverrideSteeringWheelActionImpl::GetActive() const
        {
        	  return _active;
        }
        double OverrideSteeringWheelActionImpl::GetMaxRate() const
        {
        	  return _maxRate;
        }
        double OverrideSteeringWheelActionImpl::GetMaxTorque() const
        {
        	  return _maxTorque;
        }
        double OverrideSteeringWheelActionImpl::GetValue() const
        {
        	  return _value;
        }


        void OverrideSteeringWheelActionImpl::SetActive(const bool active)
        {
            _active = active;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVE);
        }

        void OverrideSteeringWheelActionImpl::SetMaxRate(const double maxRate)
        {
            _maxRate = maxRate;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_RATE);
			// set the indicator to true
            isSetMaxRate = true;          
        }

        void OverrideSteeringWheelActionImpl::SetMaxTorque(const double maxTorque)
        {
            _maxTorque = maxTorque;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_TORQUE);
			// set the indicator to true
            isSetMaxTorque = true;          
        }

        void OverrideSteeringWheelActionImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> OverrideSteeringWheelActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(OverrideSteeringWheelActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IOverrideSteeringWheelAction).name())
                return std::dynamic_pointer_cast<IOverrideSteeringWheelAction>(shared_from_this());
            else if (classifier == typeid(IOverrideSteeringWheelActionWriter).name())
                return std::dynamic_pointer_cast<IOverrideSteeringWheelActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> OverrideSteeringWheelActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t OverrideSteeringWheelActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int OverrideSteeringWheelActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double OverrideSteeringWheelActionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAX_RATE)
                {
                    return GetMaxRate();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAX_TORQUE)
                {
                    return GetMaxTorque();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t OverrideSteeringWheelActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool OverrideSteeringWheelActionImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
                {
                    return GetActive();
                }
                throw KeyNotSupportedException();

        }

        DateTime OverrideSteeringWheelActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> OverrideSteeringWheelActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string OverrideSteeringWheelActionImpl::GetModelType() const
        {
            return "OverrideSteeringWheelAction";
        }

        void OverrideSteeringWheelActionImpl::WriteParameterToActive(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVE, parameterName, nullTextMarker /*no textmarker*/);
            _active = {};
        }

        void OverrideSteeringWheelActionImpl::WriteParameterToMaxRate(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_RATE, parameterName, nullTextMarker /*no textmarker*/);
            _maxRate = {};
        }

        void OverrideSteeringWheelActionImpl::WriteParameterToMaxTorque(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_TORQUE, parameterName, nullTextMarker /*no textmarker*/);
            _maxTorque = {};
        }

        void OverrideSteeringWheelActionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string OverrideSteeringWheelActionImpl::GetParameterFromActive() const
        {
            auto active = OSC_CONSTANTS::ATTRIBUTE__ACTIVE;
            return GetParameterNameFromAttribute(active);
        }

        std::string OverrideSteeringWheelActionImpl::GetParameterFromMaxRate() const
        {
            auto maxRate = OSC_CONSTANTS::ATTRIBUTE__MAX_RATE;
            return GetParameterNameFromAttribute(maxRate);
        }

        std::string OverrideSteeringWheelActionImpl::GetParameterFromMaxTorque() const
        {
            auto maxTorque = OSC_CONSTANTS::ATTRIBUTE__MAX_TORQUE;
            return GetParameterNameFromAttribute(maxTorque);
        }

        std::string OverrideSteeringWheelActionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool OverrideSteeringWheelActionImpl::IsActiveParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ACTIVE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool OverrideSteeringWheelActionImpl::IsMaxRateParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAX_RATE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool OverrideSteeringWheelActionImpl::IsMaxTorqueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAX_TORQUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool OverrideSteeringWheelActionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        OverrideSteeringWheelActionImpl::OverrideSteeringWheelActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ACTIVE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_RATE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_TORQUE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void OverrideSteeringWheelActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
            {
                // Simple type
                _active = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_RATE)
            {
                // Simple type
                _maxRate = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_TORQUE)
            {
                // Simple type
                _maxTorque = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType OverrideSteeringWheelActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OverrideSteeringWheelActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OverrideSteeringWheelActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<OverrideSteeringWheelActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_active = GetActive();
            // Simple type
            clonedObject->_maxRate = GetMaxRate();
            // Simple type
            clonedObject->_maxTorque = GetMaxTorque();
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            	clonedObject->isSetMaxRate = isSetMaxRate;
            	clonedObject->isSetMaxTorque = isSetMaxTorque;
            // clone children
            return clonedObject;
        }

        std::string OverrideSteeringWheelActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideSteeringWheelActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OverrideSteeringWheelActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideSteeringWheelActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OverrideSteeringWheelActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void OverrideSteeringWheelActionImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
            {
                // Simple type
                _active = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void OverrideSteeringWheelActionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_RATE)
            {
                // Simple type
                _maxRate = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_TORQUE)
            {
                // Simple type
                _maxTorque = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void OverrideSteeringWheelActionImpl::ResetMaxRate()
	   {
	   		isSetMaxRate = false; 
			_maxRate = {};
			
	   }
       bool OverrideSteeringWheelActionImpl::IsSetMaxRate() const
	   {
			return isSetMaxRate;
	   }
       void OverrideSteeringWheelActionImpl::ResetMaxTorque()
	   {
	   		isSetMaxTorque = false; 
			_maxTorque = {};
			
	   }
       bool OverrideSteeringWheelActionImpl::IsSetMaxTorque() const
	   {
			return isSetMaxTorque;
	   }

        IOpenScenarioFlexElement* OverrideThrottleActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool OverrideThrottleActionImpl::GetActive() const
        {
        	  return _active;
        }
        double OverrideThrottleActionImpl::GetMaxRate() const
        {
        	  return _maxRate;
        }
        double OverrideThrottleActionImpl::GetValue() const
        {
        	  return _value;
        }


        void OverrideThrottleActionImpl::SetActive(const bool active)
        {
            _active = active;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVE);
        }

        void OverrideThrottleActionImpl::SetMaxRate(const double maxRate)
        {
            _maxRate = maxRate;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_RATE);
			// set the indicator to true
            isSetMaxRate = true;          
        }

        void OverrideThrottleActionImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> OverrideThrottleActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(OverrideThrottleActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IOverrideThrottleAction).name())
                return std::dynamic_pointer_cast<IOverrideThrottleAction>(shared_from_this());
            else if (classifier == typeid(IOverrideThrottleActionWriter).name())
                return std::dynamic_pointer_cast<IOverrideThrottleActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> OverrideThrottleActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t OverrideThrottleActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int OverrideThrottleActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double OverrideThrottleActionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAX_RATE)
                {
                    return GetMaxRate();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t OverrideThrottleActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool OverrideThrottleActionImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
                {
                    return GetActive();
                }
                throw KeyNotSupportedException();

        }

        DateTime OverrideThrottleActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> OverrideThrottleActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string OverrideThrottleActionImpl::GetModelType() const
        {
            return "OverrideThrottleAction";
        }

        void OverrideThrottleActionImpl::WriteParameterToActive(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ACTIVE, parameterName, nullTextMarker /*no textmarker*/);
            _active = {};
        }

        void OverrideThrottleActionImpl::WriteParameterToMaxRate(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_RATE, parameterName, nullTextMarker /*no textmarker*/);
            _maxRate = {};
        }

        void OverrideThrottleActionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string OverrideThrottleActionImpl::GetParameterFromActive() const
        {
            auto active = OSC_CONSTANTS::ATTRIBUTE__ACTIVE;
            return GetParameterNameFromAttribute(active);
        }

        std::string OverrideThrottleActionImpl::GetParameterFromMaxRate() const
        {
            auto maxRate = OSC_CONSTANTS::ATTRIBUTE__MAX_RATE;
            return GetParameterNameFromAttribute(maxRate);
        }

        std::string OverrideThrottleActionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool OverrideThrottleActionImpl::IsActiveParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ACTIVE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool OverrideThrottleActionImpl::IsMaxRateParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAX_RATE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool OverrideThrottleActionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        OverrideThrottleActionImpl::OverrideThrottleActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ACTIVE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_RATE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void OverrideThrottleActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
            {
                // Simple type
                _active = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_RATE)
            {
                // Simple type
                _maxRate = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType OverrideThrottleActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OverrideThrottleActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OverrideThrottleActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<OverrideThrottleActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_active = GetActive();
            // Simple type
            clonedObject->_maxRate = GetMaxRate();
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            	clonedObject->isSetMaxRate = isSetMaxRate;
            // clone children
            return clonedObject;
        }

        std::string OverrideThrottleActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideThrottleActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OverrideThrottleActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideThrottleActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OverrideThrottleActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void OverrideThrottleActionImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
            {
                // Simple type
                _active = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void OverrideThrottleActionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_RATE)
            {
                // Simple type
                _maxRate = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void OverrideThrottleActionImpl::ResetMaxRate()
	   {
	   		isSetMaxRate = false; 
			_maxRate = {};
			
	   }
       bool OverrideThrottleActionImpl::IsSetMaxRate() const
	   {
			return isSetMaxRate;
	   }

        IOpenScenarioFlexElement* ParameterActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<INamedReference<IParameterDeclaration>> ParameterActionImpl::GetParameterRef() const
        {
        	 return _parameterRef;
        }
        std::shared_ptr<IParameterSetAction> ParameterActionImpl::GetSetAction() const
        {
        	  return _setAction;
        }
        std::shared_ptr<IParameterModifyAction> ParameterActionImpl::GetModifyAction() const
        {
        	  return _modifyAction;
        }


        void ParameterActionImpl::SetParameterRef(std::shared_ptr<INamedReference<IParameterDeclaration>> parameterRef)
        {
            _parameterRef = parameterRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF);
        }

        void ParameterActionImpl::SetSetAction(std::shared_ptr<IParameterSetActionWriter> setAction)
        {
            _setAction = setAction;
            _modifyAction = {};
			// set the indicator to true
            isSetSetAction = true;          
        }

        void ParameterActionImpl::SetModifyAction(std::shared_ptr<IParameterModifyActionWriter> modifyAction)
        {
            _modifyAction = modifyAction;
            _setAction = {};
			// set the indicator to true
            isSetModifyAction = true;          
        }

        std::shared_ptr<void> ParameterActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ParameterActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IParameterAction).name())
                return std::dynamic_pointer_cast<IParameterAction>(shared_from_this());
            else if (classifier == typeid(IParameterActionWriter).name())
                return std::dynamic_pointer_cast<IParameterActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ParameterActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ParameterActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ParameterActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ParameterActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ParameterActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ParameterActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ParameterActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ParameterActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ParameterActionImpl::GetModelType() const
        {
            return "ParameterAction";
        }

        void ParameterActionImpl::WriteParameterToParameterRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF, parameterName, nullTextMarker /*no textmarker*/);
            _parameterRef = {};
        }

        std::string ParameterActionImpl::GetParameterFromParameterRef() const
        {
            auto parameterRef = OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF;
            return GetParameterNameFromAttribute(parameterRef);
        }

        bool ParameterActionImpl::IsParameterRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IParameterSetActionWriter> ParameterActionImpl::GetWriterSetAction() const
        {
            return std::dynamic_pointer_cast<IParameterSetActionWriter>(_setAction);
        }
        std::shared_ptr<IParameterModifyActionWriter> ParameterActionImpl::GetWriterModifyAction() const
        {
            return std::dynamic_pointer_cast<IParameterModifyActionWriter>(_modifyAction);
        }

        ParameterActionImpl::ParameterActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF, SimpleType::STRING);
        }

        void ParameterActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IParameterDeclaration>>(parameterLiteralValue);
                _parameterRef = std::dynamic_pointer_cast<INamedReference<IParameterDeclaration>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ParameterActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kSetAction =  GetWriterSetAction();
                if (kSetAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSetAction));
                }
                const auto kModifyAction =  GetWriterModifyAction();
                if (kModifyAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kModifyAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IParameterDeclaration>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IParameterDeclaration>>(GetParameterRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_parameterRef = proxy;
            
            // clone indicators
            // clone children
            const auto kSetAction =  GetWriterSetAction();
            if (kSetAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<ParameterSetActionImpl>(kSetAction)->Clone();
                auto clonedChildIParameterSetAction = std::dynamic_pointer_cast<IParameterSetAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSetAction(std::dynamic_pointer_cast<IParameterSetActionWriter>(clonedChildIParameterSetAction));
            }
            const auto kModifyAction =  GetWriterModifyAction();
            if (kModifyAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<ParameterModifyActionImpl>(kModifyAction)->Clone();
                auto clonedChildIParameterModifyAction = std::dynamic_pointer_cast<IParameterModifyAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetModifyAction(std::dynamic_pointer_cast<IParameterModifyActionWriter>(clonedChildIParameterModifyAction));
            }
            return clonedObject;
        }

        std::string ParameterActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF)
            {
                // Get the Proxy
                auto parameterRef = GetParameterRef();
                return parameterRef!= nullptr ? parameterRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SET_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSetAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__MODIFY_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetModifyAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF)
            {
                // Get the Proxy
                auto parameterRef = GetParameterRef();
                return parameterRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(parameterRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string ParameterActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void ParameterActionImpl::ResetSetAction()
	   {
	   		isSetSetAction = false; 
			_setAction = {};
			
	   }
       bool ParameterActionImpl::IsSetSetAction() const
	   {
			return isSetSetAction;
	   }
       void ParameterActionImpl::ResetModifyAction()
	   {
	   		isSetModifyAction = false; 
			_modifyAction = {};
			
	   }
       bool ParameterActionImpl::IsSetModifyAction() const
	   {
			return isSetModifyAction;
	   }

        IOpenScenarioFlexElement* ParameterAddValueRuleImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double ParameterAddValueRuleImpl::GetValue() const
        {
        	  return _value;
        }


        void ParameterAddValueRuleImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> ParameterAddValueRuleImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ParameterAddValueRuleImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IParameterAddValueRule).name())
                return std::dynamic_pointer_cast<IParameterAddValueRule>(shared_from_this());
            else if (classifier == typeid(IParameterAddValueRuleWriter).name())
                return std::dynamic_pointer_cast<IParameterAddValueRuleWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ParameterAddValueRuleImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ParameterAddValueRuleImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ParameterAddValueRuleImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ParameterAddValueRuleImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t ParameterAddValueRuleImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ParameterAddValueRuleImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ParameterAddValueRuleImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ParameterAddValueRuleImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ParameterAddValueRuleImpl::GetModelType() const
        {
            return "ParameterAddValueRule";
        }

        void ParameterAddValueRuleImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string ParameterAddValueRuleImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool ParameterAddValueRuleImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        ParameterAddValueRuleImpl::ParameterAddValueRuleImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void ParameterAddValueRuleImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ParameterAddValueRuleImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterAddValueRuleImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterAddValueRuleImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterAddValueRuleImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string ParameterAddValueRuleImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterAddValueRuleImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterAddValueRuleImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterAddValueRuleImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ParameterAddValueRuleImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ParameterAddValueRuleImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* ParameterAssignmentImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<INamedReference<IParameterDeclaration>> ParameterAssignmentImpl::GetParameterRef() const
        {
        	 return _parameterRef;
        }
        std::string ParameterAssignmentImpl::GetValue() const
        {
        	  return _value;
        }


        void ParameterAssignmentImpl::SetParameterRef(std::shared_ptr<INamedReference<IParameterDeclaration>> parameterRef)
        {
            _parameterRef = parameterRef;
        }

        void ParameterAssignmentImpl::SetValue(const std::string value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> ParameterAssignmentImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ParameterAssignmentImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IParameterAssignment).name())
                return std::dynamic_pointer_cast<IParameterAssignment>(shared_from_this());
            else if (classifier == typeid(IParameterAssignmentWriter).name())
                return std::dynamic_pointer_cast<IParameterAssignmentWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ParameterAssignmentImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ParameterAssignmentImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ParameterAssignmentImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ParameterAssignmentImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ParameterAssignmentImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ParameterAssignmentImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ParameterAssignmentImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ParameterAssignmentImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ParameterAssignmentImpl::GetModelType() const
        {
            return "ParameterAssignment";
        }

        void ParameterAssignmentImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string ParameterAssignmentImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool ParameterAssignmentImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        ParameterAssignmentImpl::ParameterAssignmentImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
        }

        void ParameterAssignmentImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ParameterAssignmentImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterAssignmentImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterAssignmentImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterAssignmentImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IParameterDeclaration>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IParameterDeclaration>>(GetParameterRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_parameterRef = proxy;
            
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string ParameterAssignmentImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF)
            {
                // Get the Proxy
                auto parameterRef = GetParameterRef();
                return parameterRef!= nullptr ? parameterRef->GetNameRef() : "";
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterAssignmentImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterAssignmentImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterAssignmentImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF)
            {
                // Get the Proxy
                auto parameterRef = GetParameterRef();
                return parameterRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(parameterRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string ParameterAssignmentImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ParameterAssignmentImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}

		bool ParameterAssignmentImpl::IsTypedStringAttribute(std::string& attributeKey)
		{
			return (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE);
		}


        IOpenScenarioFlexElement* ParameterConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<INamedReference<IParameterDeclaration>> ParameterConditionImpl::GetParameterRef() const
        {
        	 return _parameterRef;
        }
        Rule ParameterConditionImpl::GetRule() const
        {
        	  return _rule;
        }
        std::string ParameterConditionImpl::GetValue() const
        {
        	  return _value;
        }


        void ParameterConditionImpl::SetParameterRef(std::shared_ptr<INamedReference<IParameterDeclaration>> parameterRef)
        {
            _parameterRef = parameterRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF);
        }

        void ParameterConditionImpl::SetRule(const Rule rule)
        {
            _rule = rule;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE);
        }

        void ParameterConditionImpl::SetValue(const std::string value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> ParameterConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ParameterConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IParameterCondition).name())
                return std::dynamic_pointer_cast<IParameterCondition>(shared_from_this());
            else if (classifier == typeid(IParameterConditionWriter).name())
                return std::dynamic_pointer_cast<IParameterConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ParameterConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ParameterConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ParameterConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ParameterConditionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ParameterConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ParameterConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ParameterConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ParameterConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ParameterConditionImpl::GetModelType() const
        {
            return "ParameterCondition";
        }

        void ParameterConditionImpl::WriteParameterToParameterRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF, parameterName, nullTextMarker /*no textmarker*/);
            _parameterRef = {};
        }

        void ParameterConditionImpl::WriteParameterToRule(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE, parameterName, nullTextMarker /*no textmarker*/);
            _rule = {};
        }

        void ParameterConditionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string ParameterConditionImpl::GetParameterFromParameterRef() const
        {
            auto parameterRef = OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF;
            return GetParameterNameFromAttribute(parameterRef);
        }

        std::string ParameterConditionImpl::GetParameterFromRule() const
        {
            auto rule = OSC_CONSTANTS::ATTRIBUTE__RULE;
            return GetParameterNameFromAttribute(rule);
        }

        std::string ParameterConditionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool ParameterConditionImpl::IsParameterRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ParameterConditionImpl::IsRuleParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RULE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ParameterConditionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        ParameterConditionImpl::ParameterConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
        }

        void ParameterConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IParameterDeclaration>>(parameterLiteralValue);
                _parameterRef = std::dynamic_pointer_cast<INamedReference<IParameterDeclaration>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ParameterConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IParameterDeclaration>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IParameterDeclaration>>(GetParameterRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_parameterRef = proxy;
            
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string ParameterConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF)
            {
                // Get the Proxy
                auto parameterRef = GetParameterRef();
                return parameterRef!= nullptr ? parameterRef->GetNameRef() : "";
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF)
            {
                // Get the Proxy
                auto parameterRef = GetParameterRef();
                return parameterRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(parameterRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string ParameterConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void ParameterConditionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* ParameterDeclarationImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string ParameterDeclarationImpl::GetName() const
        {
        	  return _name;
        }
        ParameterType ParameterDeclarationImpl::GetParameterType() const
        {
        	  return _parameterType;
        }
        std::string ParameterDeclarationImpl::GetValue() const
        {
        	  return _value;
        }
        std::vector<std::shared_ptr<IValueConstraintGroup>> ParameterDeclarationImpl::GetConstraintGroups() const
        {
            std::vector<std::shared_ptr<IValueConstraintGroup>> temp;
            for(auto&& elm: _constraintGroups)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IValueConstraintGroupWriter>> ParameterDeclarationImpl::GetWriterConstraintGroups() const
        {
            return _constraintGroups;
        }

        int ParameterDeclarationImpl::GetConstraintGroupsSize() const
        {
            return static_cast<int>(_constraintGroups.size());
        }

        std::shared_ptr<IValueConstraintGroup> ParameterDeclarationImpl::GetConstraintGroupsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _constraintGroups.size() > index)
            {
                return _constraintGroups[index];
            }
            return nullptr;
        }


        void ParameterDeclarationImpl::SetName(const std::string name)
        {
            _name = name;
        }

        void ParameterDeclarationImpl::SetParameterType(const ParameterType parameterType)
        {
            _parameterType = parameterType;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_TYPE);
        }

        void ParameterDeclarationImpl::SetValue(const std::string value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        void ParameterDeclarationImpl::SetConstraintGroups(std::vector<std::shared_ptr<IValueConstraintGroupWriter>>& constraintGroups)
        {
            _constraintGroups = constraintGroups;
			// set the indicator to true
            isSetConstraintGroups = true;          
        }

        std::shared_ptr<void> ParameterDeclarationImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ParameterDeclarationImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IParameterDeclaration).name())
                return std::dynamic_pointer_cast<IParameterDeclaration>(shared_from_this());
            else if (classifier == typeid(IParameterDeclarationWriter).name())
                return std::dynamic_pointer_cast<IParameterDeclarationWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ParameterDeclarationImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ParameterDeclarationImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ParameterDeclarationImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ParameterDeclarationImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ParameterDeclarationImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ParameterDeclarationImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ParameterDeclarationImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ParameterDeclarationImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ParameterDeclarationImpl::GetModelType() const
        {
            return "ParameterDeclaration";
        }

        void ParameterDeclarationImpl::WriteParameterToParameterType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _parameterType = {};
        }

        void ParameterDeclarationImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string ParameterDeclarationImpl::GetParameterFromParameterType() const
        {
            auto parameterType = OSC_CONSTANTS::ATTRIBUTE__PARAMETER_TYPE;
            return GetParameterNameFromAttribute(parameterType);
        }

        std::string ParameterDeclarationImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool ParameterDeclarationImpl::IsParameterTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__PARAMETER_TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ParameterDeclarationImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        ParameterDeclarationImpl::ParameterDeclarationImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_TYPE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
        }

        void ParameterDeclarationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_TYPE)
            {
                // Enumeration Type
                const auto kResult = ParameterType::GetFromLiteral(parameterLiteralValue);
                if (kResult != ParameterType::UNKNOWN)
                {
                    _parameterType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ParameterDeclarationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterDeclarationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto constraintGroups =  GetWriterConstraintGroups();
                if (!constraintGroups.empty())
                {
                    for(auto&& item : constraintGroups)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterDeclarationImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterDeclarationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // Enumeration Type
            const auto kParameterType = GetParameterType();
            if ( kParameterType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_parameterType = ParameterType::GetFromLiteral(kParameterType.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            const auto kConstraintGroups =  GetWriterConstraintGroups();
            if (!kConstraintGroups.empty())
            {
                std::vector<std::shared_ptr<IValueConstraintGroupWriter>> clonedList;
                for(auto&& kItem : kConstraintGroups)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ValueConstraintGroupImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IValueConstraintGroupWriter>(clonedChild));
                }
                clonedObject->SetConstraintGroups(clonedList);
            }
            return clonedObject;
        }

        std::string ParameterDeclarationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterDeclarationImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterDeclarationImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__CONSTRAINT_GROUP)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetConstraintGroups())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterDeclarationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ParameterDeclarationImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_TYPE)
            {
                auto parameterType = GetParameterType();
                return parameterType.GetLiteral() != "UNKNOWN" ? parameterType.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void ParameterDeclarationImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}

		bool ParameterDeclarationImpl::IsTypedStringAttribute(std::string& attributeKey)
		{
			return (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE);
		}

       void ParameterDeclarationImpl::ResetConstraintGroups()
	   {
	   		isSetConstraintGroups = false; 
			_constraintGroups = {};
			
	   }
       bool ParameterDeclarationImpl::IsSetConstraintGroups() const
	   {
			return isSetConstraintGroups;
	   }

        IOpenScenarioFlexElement* ParameterModifyActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IModifyRule> ParameterModifyActionImpl::GetRule() const
        {
        	  return _rule;
        }


        void ParameterModifyActionImpl::SetRule(std::shared_ptr<IModifyRuleWriter> rule)
        {
            _rule = rule;
        }

        std::shared_ptr<void> ParameterModifyActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ParameterModifyActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IParameterModifyAction).name())
                return std::dynamic_pointer_cast<IParameterModifyAction>(shared_from_this());
            else if (classifier == typeid(IParameterModifyActionWriter).name())
                return std::dynamic_pointer_cast<IParameterModifyActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ParameterModifyActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ParameterModifyActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ParameterModifyActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ParameterModifyActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ParameterModifyActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ParameterModifyActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ParameterModifyActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ParameterModifyActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ParameterModifyActionImpl::GetModelType() const
        {
            return "ParameterModifyAction";
        }

            // children
        std::shared_ptr<IModifyRuleWriter> ParameterModifyActionImpl::GetWriterRule() const
        {
            return std::dynamic_pointer_cast<IModifyRuleWriter>(_rule);
        }

        ParameterModifyActionImpl::ParameterModifyActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ParameterModifyActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ParameterModifyActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterModifyActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRule =  GetWriterRule();
                if (kRule)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRule));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterModifyActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterModifyActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kRule =  GetWriterRule();
            if (kRule)
            {
                auto clonedChild = std::dynamic_pointer_cast<ModifyRuleImpl>(kRule)->Clone();
                auto clonedChildIModifyRule = std::dynamic_pointer_cast<IModifyRule>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRule(std::dynamic_pointer_cast<IModifyRuleWriter>(clonedChildIModifyRule));
            }
            return clonedObject;
        }

        std::string ParameterModifyActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterModifyActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RULE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRule());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterModifyActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterModifyActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ParameterModifyActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ParameterMultiplyByValueRuleImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double ParameterMultiplyByValueRuleImpl::GetValue() const
        {
        	  return _value;
        }


        void ParameterMultiplyByValueRuleImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> ParameterMultiplyByValueRuleImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ParameterMultiplyByValueRuleImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IParameterMultiplyByValueRule).name())
                return std::dynamic_pointer_cast<IParameterMultiplyByValueRule>(shared_from_this());
            else if (classifier == typeid(IParameterMultiplyByValueRuleWriter).name())
                return std::dynamic_pointer_cast<IParameterMultiplyByValueRuleWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ParameterMultiplyByValueRuleImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ParameterMultiplyByValueRuleImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ParameterMultiplyByValueRuleImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ParameterMultiplyByValueRuleImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t ParameterMultiplyByValueRuleImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ParameterMultiplyByValueRuleImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ParameterMultiplyByValueRuleImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ParameterMultiplyByValueRuleImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ParameterMultiplyByValueRuleImpl::GetModelType() const
        {
            return "ParameterMultiplyByValueRule";
        }

        void ParameterMultiplyByValueRuleImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string ParameterMultiplyByValueRuleImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool ParameterMultiplyByValueRuleImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        ParameterMultiplyByValueRuleImpl::ParameterMultiplyByValueRuleImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void ParameterMultiplyByValueRuleImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ParameterMultiplyByValueRuleImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterMultiplyByValueRuleImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterMultiplyByValueRuleImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterMultiplyByValueRuleImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string ParameterMultiplyByValueRuleImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterMultiplyByValueRuleImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterMultiplyByValueRuleImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterMultiplyByValueRuleImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ParameterMultiplyByValueRuleImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ParameterMultiplyByValueRuleImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* ParameterSetActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string ParameterSetActionImpl::GetValue() const
        {
        	  return _value;
        }


        void ParameterSetActionImpl::SetValue(const std::string value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> ParameterSetActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ParameterSetActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IParameterSetAction).name())
                return std::dynamic_pointer_cast<IParameterSetAction>(shared_from_this());
            else if (classifier == typeid(IParameterSetActionWriter).name())
                return std::dynamic_pointer_cast<IParameterSetActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ParameterSetActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ParameterSetActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ParameterSetActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ParameterSetActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ParameterSetActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ParameterSetActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ParameterSetActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ParameterSetActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ParameterSetActionImpl::GetModelType() const
        {
            return "ParameterSetAction";
        }

        void ParameterSetActionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string ParameterSetActionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool ParameterSetActionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        ParameterSetActionImpl::ParameterSetActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
        }

        void ParameterSetActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ParameterSetActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterSetActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterSetActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterSetActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string ParameterSetActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterSetActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterSetActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterSetActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ParameterSetActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ParameterSetActionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* ParameterValueDistributionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IFile> ParameterValueDistributionImpl::GetScenarioFile() const
        {
        	  return _scenarioFile;
        }
        std::shared_ptr<IDistributionDefinition> ParameterValueDistributionImpl::GetDistributionDefinition() const
        {
        	  return _distributionDefinition;
        }


        void ParameterValueDistributionImpl::SetScenarioFile(std::shared_ptr<IFileWriter> scenarioFile)
        {
            _scenarioFile = scenarioFile;
        }

        void ParameterValueDistributionImpl::SetDistributionDefinition(std::shared_ptr<IDistributionDefinitionWriter> distributionDefinition)
        {
            _distributionDefinition = distributionDefinition;
        }

        std::shared_ptr<void> ParameterValueDistributionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ParameterValueDistributionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IParameterValueDistribution).name())
                return std::dynamic_pointer_cast<IParameterValueDistribution>(shared_from_this());
            else if (classifier == typeid(IParameterValueDistributionWriter).name())
                return std::dynamic_pointer_cast<IParameterValueDistributionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ParameterValueDistributionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ParameterValueDistributionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ParameterValueDistributionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ParameterValueDistributionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ParameterValueDistributionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ParameterValueDistributionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ParameterValueDistributionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ParameterValueDistributionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ParameterValueDistributionImpl::GetModelType() const
        {
            return "ParameterValueDistribution";
        }

            // children
        std::shared_ptr<IFileWriter> ParameterValueDistributionImpl::GetWriterScenarioFile() const
        {
            return std::dynamic_pointer_cast<IFileWriter>(_scenarioFile);
        }
        std::shared_ptr<IDistributionDefinitionWriter> ParameterValueDistributionImpl::GetWriterDistributionDefinition() const
        {
            return std::dynamic_pointer_cast<IDistributionDefinitionWriter>(_distributionDefinition);
        }

        ParameterValueDistributionImpl::ParameterValueDistributionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ParameterValueDistributionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ParameterValueDistributionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterValueDistributionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kScenarioFile =  GetWriterScenarioFile();
                if (kScenarioFile)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kScenarioFile));
                }
                const auto kDistributionDefinition =  GetWriterDistributionDefinition();
                if (kDistributionDefinition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDistributionDefinition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterValueDistributionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterValueDistributionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kScenarioFile =  GetWriterScenarioFile();
            if (kScenarioFile)
            {
                auto clonedChild = std::dynamic_pointer_cast<FileImpl>(kScenarioFile)->Clone();
                auto clonedChildIFile = std::dynamic_pointer_cast<IFile>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetScenarioFile(std::dynamic_pointer_cast<IFileWriter>(clonedChildIFile));
            }
            const auto kDistributionDefinition =  GetWriterDistributionDefinition();
            if (kDistributionDefinition)
            {
                auto clonedChild = std::dynamic_pointer_cast<DistributionDefinitionImpl>(kDistributionDefinition)->Clone();
                auto clonedChildIDistributionDefinition = std::dynamic_pointer_cast<IDistributionDefinition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDistributionDefinition(std::dynamic_pointer_cast<IDistributionDefinitionWriter>(clonedChildIDistributionDefinition));
            }
            return clonedObject;
        }

        std::string ParameterValueDistributionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterValueDistributionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SCENARIO_FILE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetScenarioFile());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DISTRIBUTION_DEFINITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDistributionDefinition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterValueDistributionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterValueDistributionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ParameterValueDistributionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ParameterValueDistributionDefinitionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IParameterValueDistribution> ParameterValueDistributionDefinitionImpl::GetParameterValueDistribution() const
        {
        	  return _parameterValueDistribution;
        }


        void ParameterValueDistributionDefinitionImpl::SetParameterValueDistribution(std::shared_ptr<IParameterValueDistributionWriter> parameterValueDistribution)
        {
            _parameterValueDistribution = parameterValueDistribution;
        }

        std::shared_ptr<void> ParameterValueDistributionDefinitionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ParameterValueDistributionDefinitionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IParameterValueDistributionDefinition).name())
                return std::dynamic_pointer_cast<IParameterValueDistributionDefinition>(shared_from_this());
            else if (classifier == typeid(IParameterValueDistributionDefinitionWriter).name())
                return std::dynamic_pointer_cast<IParameterValueDistributionDefinitionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ParameterValueDistributionDefinitionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ParameterValueDistributionDefinitionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ParameterValueDistributionDefinitionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ParameterValueDistributionDefinitionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ParameterValueDistributionDefinitionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ParameterValueDistributionDefinitionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ParameterValueDistributionDefinitionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ParameterValueDistributionDefinitionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ParameterValueDistributionDefinitionImpl::GetModelType() const
        {
            return "ParameterValueDistributionDefinition";
        }

            // children
        std::shared_ptr<IParameterValueDistributionWriter> ParameterValueDistributionDefinitionImpl::GetWriterParameterValueDistribution() const
        {
            return std::dynamic_pointer_cast<IParameterValueDistributionWriter>(_parameterValueDistribution);
        }

        ParameterValueDistributionDefinitionImpl::ParameterValueDistributionDefinitionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ParameterValueDistributionDefinitionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ParameterValueDistributionDefinitionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterValueDistributionDefinitionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kParameterValueDistribution =  GetWriterParameterValueDistribution();
                if (kParameterValueDistribution)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kParameterValueDistribution));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterValueDistributionDefinitionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterValueDistributionDefinitionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kParameterValueDistribution =  GetWriterParameterValueDistribution();
            if (kParameterValueDistribution)
            {
                auto clonedChild = std::dynamic_pointer_cast<ParameterValueDistributionImpl>(kParameterValueDistribution)->Clone();
                auto clonedChildIParameterValueDistribution = std::dynamic_pointer_cast<IParameterValueDistribution>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetParameterValueDistribution(std::dynamic_pointer_cast<IParameterValueDistributionWriter>(clonedChildIParameterValueDistribution));
            }
            return clonedObject;
        }

        std::string ParameterValueDistributionDefinitionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterValueDistributionDefinitionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_VALUE_DISTRIBUTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParameterValueDistribution());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterValueDistributionDefinitionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterValueDistributionDefinitionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ParameterValueDistributionDefinitionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ParameterValueSetImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<IParameterAssignment>> ParameterValueSetImpl::GetParameterAssignments() const
        {
            std::vector<std::shared_ptr<IParameterAssignment>> temp;
            for(auto&& elm: _parameterAssignments)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IParameterAssignmentWriter>> ParameterValueSetImpl::GetWriterParameterAssignments() const
        {
            return _parameterAssignments;
        }

        int ParameterValueSetImpl::GetParameterAssignmentsSize() const
        {
            return static_cast<int>(_parameterAssignments.size());
        }

        std::shared_ptr<IParameterAssignment> ParameterValueSetImpl::GetParameterAssignmentsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _parameterAssignments.size() > index)
            {
                return _parameterAssignments[index];
            }
            return nullptr;
        }


        void ParameterValueSetImpl::SetParameterAssignments(std::vector<std::shared_ptr<IParameterAssignmentWriter>>& parameterAssignments)
        {
            _parameterAssignments = parameterAssignments;
        }

        std::shared_ptr<void> ParameterValueSetImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ParameterValueSetImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IParameterValueSet).name())
                return std::dynamic_pointer_cast<IParameterValueSet>(shared_from_this());
            else if (classifier == typeid(IParameterValueSetWriter).name())
                return std::dynamic_pointer_cast<IParameterValueSetWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ParameterValueSetImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ParameterValueSetImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ParameterValueSetImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ParameterValueSetImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ParameterValueSetImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ParameterValueSetImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ParameterValueSetImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ParameterValueSetImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ParameterValueSetImpl::GetModelType() const
        {
            return "ParameterValueSet";
        }

            // children

        ParameterValueSetImpl::ParameterValueSetImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ParameterValueSetImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ParameterValueSetImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterValueSetImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterAssignments =  GetWriterParameterAssignments();
                if (!parameterAssignments.empty())
                {
                    for(auto&& item : parameterAssignments)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterValueSetImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterValueSetImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kParameterAssignments =  GetWriterParameterAssignments();
            if (!kParameterAssignments.empty())
            {
                std::vector<std::shared_ptr<IParameterAssignmentWriter>> clonedList;
                for(auto&& kItem : kParameterAssignments)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterAssignmentImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterAssignmentWriter>(clonedChild));
                }
                clonedObject->SetParameterAssignments(clonedList);
            }
            return clonedObject;
        }

        std::string ParameterValueSetImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterValueSetImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterValueSetImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_ASSIGNMENT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterAssignments())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterValueSetImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ParameterValueSetImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* PedestrianImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double PedestrianImpl::GetMass() const
        {
        	  return _mass;
        }
        std::string PedestrianImpl::GetModel() const
        {
        	  return _model;
        }
        std::string PedestrianImpl::GetModel3d() const
        {
        	  return _model3d;
        }
        std::string PedestrianImpl::GetName() const
        {
        	  return _name;
        }
        PedestrianCategory PedestrianImpl::GetPedestrianCategory() const
        {
        	  return _pedestrianCategory;
        }
        Role PedestrianImpl::GetRole() const
        {
        	  return _role;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> PedestrianImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IParameterDeclarationWriter>> PedestrianImpl::GetWriterParameterDeclarations() const
        {
            return _parameterDeclarations;
        }

        int PedestrianImpl::GetParameterDeclarationsSize() const
        {
            return static_cast<int>(_parameterDeclarations.size());
        }

        std::shared_ptr<IParameterDeclaration> PedestrianImpl::GetParameterDeclarationsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _parameterDeclarations.size() > index)
            {
                return _parameterDeclarations[index];
            }
            return nullptr;
        }
        std::shared_ptr<IBoundingBox> PedestrianImpl::GetBoundingBox() const
        {
        	  return _boundingBox;
        }
        std::shared_ptr<IProperties> PedestrianImpl::GetProperties() const
        {
        	  return _properties;
        }


        void PedestrianImpl::SetMass(const double mass)
        {
            _mass = mass;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MASS);
        }

        void PedestrianImpl::SetModel(const std::string model)
        {
            _model = model;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MODEL);
			// set the indicator to true
            isSetModel = true;          
        }

        void PedestrianImpl::SetModel3d(const std::string model3d)
        {
            _model3d = model3d;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MODEL3D);
			// set the indicator to true
            isSetModel3d = true;          
        }

        void PedestrianImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void PedestrianImpl::SetPedestrianCategory(const PedestrianCategory pedestrianCategory)
        {
            _pedestrianCategory = pedestrianCategory;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PEDESTRIAN_CATEGORY);
        }

        void PedestrianImpl::SetRole(const Role role)
        {
            _role = role;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROLE);
			// set the indicator to true
            isSetRole = true;          
        }

        void PedestrianImpl::SetParameterDeclarations(std::vector<std::shared_ptr<IParameterDeclarationWriter>>& parameterDeclarations)
        {
            _parameterDeclarations = parameterDeclarations;
			// set the indicator to true
            isSetParameterDeclarations = true;          
        }

        void PedestrianImpl::SetBoundingBox(std::shared_ptr<IBoundingBoxWriter> boundingBox)
        {
            _boundingBox = boundingBox;
        }

        void PedestrianImpl::SetProperties(std::shared_ptr<IPropertiesWriter> properties)
        {
            _properties = properties;
        }

        std::shared_ptr<void> PedestrianImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(PedestrianImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IPedestrian).name())
                return std::dynamic_pointer_cast<IPedestrian>(shared_from_this());
            else if (classifier == typeid(IPedestrianWriter).name())
                return std::dynamic_pointer_cast<IPedestrianWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> PedestrianImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t PedestrianImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int PedestrianImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double PedestrianImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__MASS)
                {
                    return GetMass();
                }
                throw KeyNotSupportedException();

        }

        uint16_t PedestrianImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool PedestrianImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime PedestrianImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> PedestrianImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string PedestrianImpl::GetModelType() const
        {
            return "Pedestrian";
        }

        void PedestrianImpl::WriteParameterToMass(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MASS, parameterName, nullTextMarker /*no textmarker*/);
            _mass = {};
        }

        void PedestrianImpl::WriteParameterToModel(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MODEL, parameterName, nullTextMarker /*no textmarker*/);
            _model = {};
        }

        void PedestrianImpl::WriteParameterToModel3d(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MODEL3D, parameterName, nullTextMarker /*no textmarker*/);
            _model3d = {};
        }

        void PedestrianImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        void PedestrianImpl::WriteParameterToPedestrianCategory(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PEDESTRIAN_CATEGORY, parameterName, nullTextMarker /*no textmarker*/);
            _pedestrianCategory = {};
        }

        void PedestrianImpl::WriteParameterToRole(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROLE, parameterName, nullTextMarker /*no textmarker*/);
            _role = {};
        }

        std::string PedestrianImpl::GetParameterFromMass() const
        {
            auto mass = OSC_CONSTANTS::ATTRIBUTE__MASS;
            return GetParameterNameFromAttribute(mass);
        }

        std::string PedestrianImpl::GetParameterFromModel() const
        {
            auto model = OSC_CONSTANTS::ATTRIBUTE__MODEL;
            return GetParameterNameFromAttribute(model);
        }

        std::string PedestrianImpl::GetParameterFromModel3d() const
        {
            auto model3d = OSC_CONSTANTS::ATTRIBUTE__MODEL3D;
            return GetParameterNameFromAttribute(model3d);
        }

        std::string PedestrianImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        std::string PedestrianImpl::GetParameterFromPedestrianCategory() const
        {
            auto pedestrianCategory = OSC_CONSTANTS::ATTRIBUTE__PEDESTRIAN_CATEGORY;
            return GetParameterNameFromAttribute(pedestrianCategory);
        }

        std::string PedestrianImpl::GetParameterFromRole() const
        {
            auto role = OSC_CONSTANTS::ATTRIBUTE__ROLE;
            return GetParameterNameFromAttribute(role);
        }

        bool PedestrianImpl::IsMassParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MASS);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool PedestrianImpl::IsModelParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MODEL);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool PedestrianImpl::IsModel3dParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MODEL3D);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool PedestrianImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool PedestrianImpl::IsPedestrianCategoryParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__PEDESTRIAN_CATEGORY);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool PedestrianImpl::IsRoleParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ROLE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IBoundingBoxWriter> PedestrianImpl::GetWriterBoundingBox() const
        {
            return std::dynamic_pointer_cast<IBoundingBoxWriter>(_boundingBox);
        }
        std::shared_ptr<IPropertiesWriter> PedestrianImpl::GetWriterProperties() const
        {
            return std::dynamic_pointer_cast<IPropertiesWriter>(_properties);
        }

        PedestrianImpl::PedestrianImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MASS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MODEL, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MODEL3D, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PEDESTRIAN_CATEGORY, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ROLE, SimpleType::ENUM_TYPE);
        }

        void PedestrianImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MASS)
            {
                // Simple type
                _mass = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MODEL)
            {
                // Simple type
                _model = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MODEL3D)
            {
                // Simple type
                _model3d = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PEDESTRIAN_CATEGORY)
            {
                // Enumeration Type
                const auto kResult = PedestrianCategory::GetFromLiteral(parameterLiteralValue);
                if (kResult != PedestrianCategory::UNKNOWN)
                {
                    _pedestrianCategory = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ROLE)
            {
                // Enumeration Type
                const auto kResult = Role::GetFromLiteral(parameterLiteralValue);
                if (kResult != Role::UNKNOWN)
                {
                    _role = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType PedestrianImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool PedestrianImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> PedestrianImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PedestrianImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kBoundingBox =  GetWriterBoundingBox();
                if (kBoundingBox)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kBoundingBox));
                }
                const auto kProperties =  GetWriterProperties();
                if (kProperties)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kProperties));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PedestrianImpl::Clone()
        {
            auto clonedObject = std::make_shared<PedestrianImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_mass = GetMass();
            // Simple type
            clonedObject->_model = GetModel();
            // Simple type
            clonedObject->_model3d = GetModel3d();
            // Simple type
            clonedObject->_name = GetName();
            // Enumeration Type
            const auto kPedestrianCategory = GetPedestrianCategory();
            if ( kPedestrianCategory.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_pedestrianCategory = PedestrianCategory::GetFromLiteral(kPedestrianCategory.GetLiteral());
            }
            // Enumeration Type
            const auto kRole = GetRole();
            if ( kRole.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_role = Role::GetFromLiteral(kRole.GetLiteral());
            }
            // clone indicators
            	clonedObject->isSetModel = isSetModel;
            	clonedObject->isSetModel3d = isSetModel3d;
            	clonedObject->isSetRole = isSetRole;
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kBoundingBox =  GetWriterBoundingBox();
            if (kBoundingBox)
            {
                auto clonedChild = std::dynamic_pointer_cast<BoundingBoxImpl>(kBoundingBox)->Clone();
                auto clonedChildIBoundingBox = std::dynamic_pointer_cast<IBoundingBox>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetBoundingBox(std::dynamic_pointer_cast<IBoundingBoxWriter>(clonedChildIBoundingBox));
            }
            const auto kProperties =  GetWriterProperties();
            if (kProperties)
            {
                auto clonedChild = std::dynamic_pointer_cast<PropertiesImpl>(kProperties)->Clone();
                auto clonedChildIProperties = std::dynamic_pointer_cast<IProperties>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetProperties(std::dynamic_pointer_cast<IPropertiesWriter>(clonedChildIProperties));
            }
            return clonedObject;
        }

        std::string PedestrianImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__MODEL)
            {
                return GetModel();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__MODEL3D)
            {
                return GetModel3d();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PedestrianImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BOUNDING_BOX)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetBoundingBox());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PROPERTIES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetProperties());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PedestrianImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PedestrianImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PedestrianImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PEDESTRIAN_CATEGORY)
            {
                auto pedestrianCategory = GetPedestrianCategory();
                return pedestrianCategory.GetLiteral() != "UNKNOWN" ? pedestrianCategory.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__ROLE)
            {
                auto role = GetRole();
                return role.GetLiteral() != "UNKNOWN" ? role.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void PedestrianImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MODEL)
            {
                // Simple type
                _model = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MODEL3D)
            {
                // Simple type
                _model3d = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void PedestrianImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MASS)
            {
                // Simple type
                _mass = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void PedestrianImpl::ResetModel()
	   {
	   		isSetModel = false; 
			_model = {};
			
	   }
       bool PedestrianImpl::IsSetModel() const
	   {
			return isSetModel;
	   }
       void PedestrianImpl::ResetModel3d()
	   {
	   		isSetModel3d = false; 
			_model3d = {};
			
	   }
       bool PedestrianImpl::IsSetModel3d() const
	   {
			return isSetModel3d;
	   }
       void PedestrianImpl::ResetRole()
	   {
	   		isSetRole = false; 
			_role = {Role::RoleEnum::NONE};
			
	   }
       bool PedestrianImpl::IsSetRole() const
	   {
			return isSetRole;
	   }
       void PedestrianImpl::ResetParameterDeclarations()
	   {
	   		isSetParameterDeclarations = false; 
			_parameterDeclarations = {};
			
	   }
       bool PedestrianImpl::IsSetParameterDeclarations() const
	   {
			return isSetParameterDeclarations;
	   }

        IOpenScenarioFlexElement* PedestrianAnimationImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        PedestrianMotionType PedestrianAnimationImpl::GetMotion() const
        {
        	  return _motion;
        }
        std::string PedestrianAnimationImpl::GetUserDefinedPedestrianAnimation() const
        {
        	  return _userDefinedPedestrianAnimation;
        }
        std::vector<std::shared_ptr<IPedestrianGesture>> PedestrianAnimationImpl::GetGestures() const
        {
            std::vector<std::shared_ptr<IPedestrianGesture>> temp;
            for(auto&& elm: _gestures)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IPedestrianGestureWriter>> PedestrianAnimationImpl::GetWriterGestures() const
        {
            return _gestures;
        }

        int PedestrianAnimationImpl::GetGesturesSize() const
        {
            return static_cast<int>(_gestures.size());
        }

        std::shared_ptr<IPedestrianGesture> PedestrianAnimationImpl::GetGesturesAtIndex(unsigned int index) const
        {
            if (index >= 0 && _gestures.size() > index)
            {
                return _gestures[index];
            }
            return nullptr;
        }


        void PedestrianAnimationImpl::SetMotion(const PedestrianMotionType motion)
        {
            _motion = motion;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MOTION);
			// set the indicator to true
            isSetMotion = true;          
        }

        void PedestrianAnimationImpl::SetUserDefinedPedestrianAnimation(const std::string userDefinedPedestrianAnimation)
        {
            _userDefinedPedestrianAnimation = userDefinedPedestrianAnimation;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_PEDESTRIAN_ANIMATION);
			// set the indicator to true
            isSetUserDefinedPedestrianAnimation = true;          
        }

        void PedestrianAnimationImpl::SetGestures(std::vector<std::shared_ptr<IPedestrianGestureWriter>>& gestures)
        {
            _gestures = gestures;
			// set the indicator to true
            isSetGestures = true;          
        }

        std::shared_ptr<void> PedestrianAnimationImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(PedestrianAnimationImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IPedestrianAnimation).name())
                return std::dynamic_pointer_cast<IPedestrianAnimation>(shared_from_this());
            else if (classifier == typeid(IPedestrianAnimationWriter).name())
                return std::dynamic_pointer_cast<IPedestrianAnimationWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> PedestrianAnimationImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t PedestrianAnimationImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int PedestrianAnimationImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double PedestrianAnimationImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t PedestrianAnimationImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool PedestrianAnimationImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime PedestrianAnimationImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> PedestrianAnimationImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string PedestrianAnimationImpl::GetModelType() const
        {
            return "PedestrianAnimation";
        }

        void PedestrianAnimationImpl::WriteParameterToMotion(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MOTION, parameterName, nullTextMarker /*no textmarker*/);
            _motion = {};
        }

        void PedestrianAnimationImpl::WriteParameterToUserDefinedPedestrianAnimation(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_PEDESTRIAN_ANIMATION, parameterName, nullTextMarker /*no textmarker*/);
            _userDefinedPedestrianAnimation = {};
        }

        std::string PedestrianAnimationImpl::GetParameterFromMotion() const
        {
            auto motion = OSC_CONSTANTS::ATTRIBUTE__MOTION;
            return GetParameterNameFromAttribute(motion);
        }

        std::string PedestrianAnimationImpl::GetParameterFromUserDefinedPedestrianAnimation() const
        {
            auto userDefinedPedestrianAnimation = OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_PEDESTRIAN_ANIMATION;
            return GetParameterNameFromAttribute(userDefinedPedestrianAnimation);
        }

        bool PedestrianAnimationImpl::IsMotionParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MOTION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool PedestrianAnimationImpl::IsUserDefinedPedestrianAnimationParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_PEDESTRIAN_ANIMATION);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        PedestrianAnimationImpl::PedestrianAnimationImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MOTION, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_PEDESTRIAN_ANIMATION, SimpleType::STRING);
        }

        void PedestrianAnimationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MOTION)
            {
                // Enumeration Type
                const auto kResult = PedestrianMotionType::GetFromLiteral(parameterLiteralValue);
                if (kResult != PedestrianMotionType::UNKNOWN)
                {
                    _motion = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_PEDESTRIAN_ANIMATION)
            {
                // Simple type
                _userDefinedPedestrianAnimation = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType PedestrianAnimationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PedestrianAnimationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto gestures =  GetWriterGestures();
                if (!gestures.empty())
                {
                    for(auto&& item : gestures)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PedestrianAnimationImpl::Clone()
        {
            auto clonedObject = std::make_shared<PedestrianAnimationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kMotion = GetMotion();
            if ( kMotion.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_motion = PedestrianMotionType::GetFromLiteral(kMotion.GetLiteral());
            }
            // Simple type
            clonedObject->_userDefinedPedestrianAnimation = GetUserDefinedPedestrianAnimation();
            // clone indicators
            	clonedObject->isSetMotion = isSetMotion;
            	clonedObject->isSetUserDefinedPedestrianAnimation = isSetUserDefinedPedestrianAnimation;
            // clone children
            const auto kGestures =  GetWriterGestures();
            if (!kGestures.empty())
            {
                std::vector<std::shared_ptr<IPedestrianGestureWriter>> clonedList;
                for(auto&& kItem : kGestures)
                {
                    auto clonedChild = std::dynamic_pointer_cast<PedestrianGestureImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IPedestrianGestureWriter>(clonedChild));
                }
                clonedObject->SetGestures(clonedList);
            }
            return clonedObject;
        }

        std::string PedestrianAnimationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_PEDESTRIAN_ANIMATION)
            {
                return GetUserDefinedPedestrianAnimation();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PedestrianAnimationImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PedestrianAnimationImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__PEDESTRIAN_GESTURE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetGestures())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PedestrianAnimationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PedestrianAnimationImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__MOTION)
            {
                auto motion = GetMotion();
                return motion.GetLiteral() != "UNKNOWN" ? motion.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void PedestrianAnimationImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_PEDESTRIAN_ANIMATION)
            {
                // Simple type
                _userDefinedPedestrianAnimation = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void PedestrianAnimationImpl::ResetMotion()
	   {
	   		isSetMotion = false; 
			_motion = {};
			
	   }
       bool PedestrianAnimationImpl::IsSetMotion() const
	   {
			return isSetMotion;
	   }
       void PedestrianAnimationImpl::ResetUserDefinedPedestrianAnimation()
	   {
	   		isSetUserDefinedPedestrianAnimation = false; 
			_userDefinedPedestrianAnimation = {};
			
	   }
       bool PedestrianAnimationImpl::IsSetUserDefinedPedestrianAnimation() const
	   {
			return isSetUserDefinedPedestrianAnimation;
	   }
       void PedestrianAnimationImpl::ResetGestures()
	   {
	   		isSetGestures = false; 
			_gestures = {};
			
	   }
       bool PedestrianAnimationImpl::IsSetGestures() const
	   {
			return isSetGestures;
	   }

        IOpenScenarioFlexElement* PedestrianCatalogLocationImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IDirectory> PedestrianCatalogLocationImpl::GetDirectory() const
        {
        	  return _directory;
        }


        void PedestrianCatalogLocationImpl::SetDirectory(std::shared_ptr<IDirectoryWriter> directory)
        {
            _directory = directory;
        }

        std::shared_ptr<void> PedestrianCatalogLocationImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(PedestrianCatalogLocationImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IPedestrianCatalogLocation).name())
                return std::dynamic_pointer_cast<IPedestrianCatalogLocation>(shared_from_this());
            else if (classifier == typeid(IPedestrianCatalogLocationWriter).name())
                return std::dynamic_pointer_cast<IPedestrianCatalogLocationWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> PedestrianCatalogLocationImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t PedestrianCatalogLocationImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int PedestrianCatalogLocationImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double PedestrianCatalogLocationImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t PedestrianCatalogLocationImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool PedestrianCatalogLocationImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime PedestrianCatalogLocationImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> PedestrianCatalogLocationImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string PedestrianCatalogLocationImpl::GetModelType() const
        {
            return "PedestrianCatalogLocation";
        }

            // children
        std::shared_ptr<IDirectoryWriter> PedestrianCatalogLocationImpl::GetWriterDirectory() const
        {
            return std::dynamic_pointer_cast<IDirectoryWriter>(_directory);
        }

        PedestrianCatalogLocationImpl::PedestrianCatalogLocationImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void PedestrianCatalogLocationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType PedestrianCatalogLocationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PedestrianCatalogLocationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDirectory =  GetWriterDirectory();
                if (kDirectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDirectory));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PedestrianCatalogLocationImpl::Clone()
        {
            auto clonedObject = std::make_shared<PedestrianCatalogLocationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kDirectory =  GetWriterDirectory();
            if (kDirectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<DirectoryImpl>(kDirectory)->Clone();
                auto clonedChildIDirectory = std::dynamic_pointer_cast<IDirectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDirectory(std::dynamic_pointer_cast<IDirectoryWriter>(clonedChildIDirectory));
            }
            return clonedObject;
        }

        std::string PedestrianCatalogLocationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PedestrianCatalogLocationImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIRECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDirectory());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PedestrianCatalogLocationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PedestrianCatalogLocationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PedestrianCatalogLocationImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* PedestrianGestureImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        PedestrianGestureType PedestrianGestureImpl::GetGesture() const
        {
        	  return _gesture;
        }


        void PedestrianGestureImpl::SetGesture(const PedestrianGestureType gesture)
        {
            _gesture = gesture;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__GESTURE);
        }

        std::shared_ptr<void> PedestrianGestureImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(PedestrianGestureImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IPedestrianGesture).name())
                return std::dynamic_pointer_cast<IPedestrianGesture>(shared_from_this());
            else if (classifier == typeid(IPedestrianGestureWriter).name())
                return std::dynamic_pointer_cast<IPedestrianGestureWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> PedestrianGestureImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t PedestrianGestureImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int PedestrianGestureImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double PedestrianGestureImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t PedestrianGestureImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool PedestrianGestureImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime PedestrianGestureImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> PedestrianGestureImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string PedestrianGestureImpl::GetModelType() const
        {
            return "PedestrianGesture";
        }

        void PedestrianGestureImpl::WriteParameterToGesture(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__GESTURE, parameterName, nullTextMarker /*no textmarker*/);
            _gesture = {};
        }

        std::string PedestrianGestureImpl::GetParameterFromGesture() const
        {
            auto gesture = OSC_CONSTANTS::ATTRIBUTE__GESTURE;
            return GetParameterNameFromAttribute(gesture);
        }

        bool PedestrianGestureImpl::IsGestureParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__GESTURE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        PedestrianGestureImpl::PedestrianGestureImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__GESTURE, SimpleType::ENUM_TYPE);
        }

        void PedestrianGestureImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__GESTURE)
            {
                // Enumeration Type
                const auto kResult = PedestrianGestureType::GetFromLiteral(parameterLiteralValue);
                if (kResult != PedestrianGestureType::UNKNOWN)
                {
                    _gesture = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType PedestrianGestureImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PedestrianGestureImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PedestrianGestureImpl::Clone()
        {
            auto clonedObject = std::make_shared<PedestrianGestureImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kGesture = GetGesture();
            if ( kGesture.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_gesture = PedestrianGestureType::GetFromLiteral(kGesture.GetLiteral());
            }
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string PedestrianGestureImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PedestrianGestureImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PedestrianGestureImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PedestrianGestureImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PedestrianGestureImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__GESTURE)
            {
                auto gesture = GetGesture();
                return gesture.GetLiteral() != "UNKNOWN" ? gesture.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* PerformanceImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double PerformanceImpl::GetMaxAcceleration() const
        {
        	  return _maxAcceleration;
        }
        double PerformanceImpl::GetMaxAccelerationRate() const
        {
        	  return _maxAccelerationRate;
        }
        double PerformanceImpl::GetMaxDeceleration() const
        {
        	  return _maxDeceleration;
        }
        double PerformanceImpl::GetMaxDecelerationRate() const
        {
        	  return _maxDecelerationRate;
        }
        double PerformanceImpl::GetMaxSpeed() const
        {
        	  return _maxSpeed;
        }


        void PerformanceImpl::SetMaxAcceleration(const double maxAcceleration)
        {
            _maxAcceleration = maxAcceleration;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION);
        }

        void PerformanceImpl::SetMaxAccelerationRate(const double maxAccelerationRate)
        {
            _maxAccelerationRate = maxAccelerationRate;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION_RATE);
			// set the indicator to true
            isSetMaxAccelerationRate = true;          
        }

        void PerformanceImpl::SetMaxDeceleration(const double maxDeceleration)
        {
            _maxDeceleration = maxDeceleration;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION);
        }

        void PerformanceImpl::SetMaxDecelerationRate(const double maxDecelerationRate)
        {
            _maxDecelerationRate = maxDecelerationRate;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION_RATE);
			// set the indicator to true
            isSetMaxDecelerationRate = true;          
        }

        void PerformanceImpl::SetMaxSpeed(const double maxSpeed)
        {
            _maxSpeed = maxSpeed;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED);
        }

        std::shared_ptr<void> PerformanceImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(PerformanceImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IPerformance).name())
                return std::dynamic_pointer_cast<IPerformance>(shared_from_this());
            else if (classifier == typeid(IPerformanceWriter).name())
                return std::dynamic_pointer_cast<IPerformanceWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> PerformanceImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t PerformanceImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int PerformanceImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double PerformanceImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION)
                {
                    return GetMaxAcceleration();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION_RATE)
                {
                    return GetMaxAccelerationRate();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION)
                {
                    return GetMaxDeceleration();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION_RATE)
                {
                    return GetMaxDecelerationRate();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED)
                {
                    return GetMaxSpeed();
                }
                throw KeyNotSupportedException();

        }

        uint16_t PerformanceImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool PerformanceImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime PerformanceImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> PerformanceImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string PerformanceImpl::GetModelType() const
        {
            return "Performance";
        }

        void PerformanceImpl::WriteParameterToMaxAcceleration(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION, parameterName, nullTextMarker /*no textmarker*/);
            _maxAcceleration = {};
        }

        void PerformanceImpl::WriteParameterToMaxAccelerationRate(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION_RATE, parameterName, nullTextMarker /*no textmarker*/);
            _maxAccelerationRate = {};
        }

        void PerformanceImpl::WriteParameterToMaxDeceleration(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION, parameterName, nullTextMarker /*no textmarker*/);
            _maxDeceleration = {};
        }

        void PerformanceImpl::WriteParameterToMaxDecelerationRate(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION_RATE, parameterName, nullTextMarker /*no textmarker*/);
            _maxDecelerationRate = {};
        }

        void PerformanceImpl::WriteParameterToMaxSpeed(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED, parameterName, nullTextMarker /*no textmarker*/);
            _maxSpeed = {};
        }

        std::string PerformanceImpl::GetParameterFromMaxAcceleration() const
        {
            auto maxAcceleration = OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION;
            return GetParameterNameFromAttribute(maxAcceleration);
        }

        std::string PerformanceImpl::GetParameterFromMaxAccelerationRate() const
        {
            auto maxAccelerationRate = OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION_RATE;
            return GetParameterNameFromAttribute(maxAccelerationRate);
        }

        std::string PerformanceImpl::GetParameterFromMaxDeceleration() const
        {
            auto maxDeceleration = OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION;
            return GetParameterNameFromAttribute(maxDeceleration);
        }

        std::string PerformanceImpl::GetParameterFromMaxDecelerationRate() const
        {
            auto maxDecelerationRate = OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION_RATE;
            return GetParameterNameFromAttribute(maxDecelerationRate);
        }

        std::string PerformanceImpl::GetParameterFromMaxSpeed() const
        {
            auto maxSpeed = OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED;
            return GetParameterNameFromAttribute(maxSpeed);
        }

        bool PerformanceImpl::IsMaxAccelerationParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool PerformanceImpl::IsMaxAccelerationRateParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION_RATE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool PerformanceImpl::IsMaxDecelerationParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool PerformanceImpl::IsMaxDecelerationRateParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION_RATE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool PerformanceImpl::IsMaxSpeedParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        PerformanceImpl::PerformanceImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION_RATE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION_RATE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED, SimpleType::DOUBLE);
        }

        void PerformanceImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION)
            {
                // Simple type
                _maxAcceleration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION_RATE)
            {
                // Simple type
                _maxAccelerationRate = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION)
            {
                // Simple type
                _maxDeceleration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION_RATE)
            {
                // Simple type
                _maxDecelerationRate = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED)
            {
                // Simple type
                _maxSpeed = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType PerformanceImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PerformanceImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PerformanceImpl::Clone()
        {
            auto clonedObject = std::make_shared<PerformanceImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_maxAcceleration = GetMaxAcceleration();
            // Simple type
            clonedObject->_maxAccelerationRate = GetMaxAccelerationRate();
            // Simple type
            clonedObject->_maxDeceleration = GetMaxDeceleration();
            // Simple type
            clonedObject->_maxDecelerationRate = GetMaxDecelerationRate();
            // Simple type
            clonedObject->_maxSpeed = GetMaxSpeed();
            // clone indicators
            	clonedObject->isSetMaxAccelerationRate = isSetMaxAccelerationRate;
            	clonedObject->isSetMaxDecelerationRate = isSetMaxDecelerationRate;
            // clone children
            return clonedObject;
        }

        std::string PerformanceImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PerformanceImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PerformanceImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PerformanceImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PerformanceImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void PerformanceImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION)
            {
                // Simple type
                _maxAcceleration = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION_RATE)
            {
                // Simple type
                _maxAccelerationRate = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION)
            {
                // Simple type
                _maxDeceleration = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION_RATE)
            {
                // Simple type
                _maxDecelerationRate = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED)
            {
                // Simple type
                _maxSpeed = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void PerformanceImpl::ResetMaxAccelerationRate()
	   {
	   		isSetMaxAccelerationRate = false; 
			_maxAccelerationRate = {};
			
	   }
       bool PerformanceImpl::IsSetMaxAccelerationRate() const
	   {
			return isSetMaxAccelerationRate;
	   }
       void PerformanceImpl::ResetMaxDecelerationRate()
	   {
	   		isSetMaxDecelerationRate = false; 
			_maxDecelerationRate = {};
			
	   }
       bool PerformanceImpl::IsSetMaxDecelerationRate() const
	   {
			return isSetMaxDecelerationRate;
	   }

        IOpenScenarioFlexElement* PhaseImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double PhaseImpl::GetDuration() const
        {
        	  return _duration;
        }
        std::string PhaseImpl::GetName() const
        {
        	  return _name;
        }
        std::vector<std::shared_ptr<ITrafficSignalState>> PhaseImpl::GetTrafficSignalStates() const
        {
            std::vector<std::shared_ptr<ITrafficSignalState>> temp;
            for(auto&& elm: _trafficSignalStates)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<ITrafficSignalStateWriter>> PhaseImpl::GetWriterTrafficSignalStates() const
        {
            return _trafficSignalStates;
        }

        int PhaseImpl::GetTrafficSignalStatesSize() const
        {
            return static_cast<int>(_trafficSignalStates.size());
        }

        std::shared_ptr<ITrafficSignalState> PhaseImpl::GetTrafficSignalStatesAtIndex(unsigned int index) const
        {
            if (index >= 0 && _trafficSignalStates.size() > index)
            {
                return _trafficSignalStates[index];
            }
            return nullptr;
        }
        std::shared_ptr<ITrafficSignalGroupState> PhaseImpl::GetTrafficeSignalGroupState() const
        {
        	  return _trafficeSignalGroupState;
        }


        void PhaseImpl::SetDuration(const double duration)
        {
            _duration = duration;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DURATION);
        }

        void PhaseImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void PhaseImpl::SetTrafficSignalStates(std::vector<std::shared_ptr<ITrafficSignalStateWriter>>& trafficSignalStates)
        {
            _trafficSignalStates = trafficSignalStates;
			// set the indicator to true
            isSetTrafficSignalStates = true;          
        }

        void PhaseImpl::SetTrafficeSignalGroupState(std::shared_ptr<ITrafficSignalGroupStateWriter> trafficeSignalGroupState)
        {
            _trafficeSignalGroupState = trafficeSignalGroupState;
			// set the indicator to true
            isSetTrafficeSignalGroupState = true;          
        }

        std::shared_ptr<void> PhaseImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(PhaseImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IPhase).name())
                return std::dynamic_pointer_cast<IPhase>(shared_from_this());
            else if (classifier == typeid(IPhaseWriter).name())
                return std::dynamic_pointer_cast<IPhaseWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> PhaseImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t PhaseImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int PhaseImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double PhaseImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__DURATION)
                {
                    return GetDuration();
                }
                throw KeyNotSupportedException();

        }

        uint16_t PhaseImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool PhaseImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime PhaseImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> PhaseImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string PhaseImpl::GetModelType() const
        {
            return "Phase";
        }

        void PhaseImpl::WriteParameterToDuration(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DURATION, parameterName, nullTextMarker /*no textmarker*/);
            _duration = {};
        }

        void PhaseImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        std::string PhaseImpl::GetParameterFromDuration() const
        {
            auto duration = OSC_CONSTANTS::ATTRIBUTE__DURATION;
            return GetParameterNameFromAttribute(duration);
        }

        std::string PhaseImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        bool PhaseImpl::IsDurationParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DURATION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool PhaseImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<ITrafficSignalGroupStateWriter> PhaseImpl::GetWriterTrafficeSignalGroupState() const
        {
            return std::dynamic_pointer_cast<ITrafficSignalGroupStateWriter>(_trafficeSignalGroupState);
        }

        PhaseImpl::PhaseImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DURATION, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        void PhaseImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DURATION)
            {
                // Simple type
                _duration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType PhaseImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PhaseImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto trafficSignalStates =  GetWriterTrafficSignalStates();
                if (!trafficSignalStates.empty())
                {
                    for(auto&& item : trafficSignalStates)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kTrafficeSignalGroupState =  GetWriterTrafficeSignalGroupState();
                if (kTrafficeSignalGroupState)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficeSignalGroupState));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PhaseImpl::Clone()
        {
            auto clonedObject = std::make_shared<PhaseImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_duration = GetDuration();
            // Simple type
            clonedObject->_name = GetName();
            // clone indicators
            // clone children
            const auto kTrafficSignalStates =  GetWriterTrafficSignalStates();
            if (!kTrafficSignalStates.empty())
            {
                std::vector<std::shared_ptr<ITrafficSignalStateWriter>> clonedList;
                for(auto&& kItem : kTrafficSignalStates)
                {
                    auto clonedChild = std::dynamic_pointer_cast<TrafficSignalStateImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<ITrafficSignalStateWriter>(clonedChild));
                }
                clonedObject->SetTrafficSignalStates(clonedList);
            }
            const auto kTrafficeSignalGroupState =  GetWriterTrafficeSignalGroupState();
            if (kTrafficeSignalGroupState)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficSignalGroupStateImpl>(kTrafficeSignalGroupState)->Clone();
                auto clonedChildITrafficSignalGroupState = std::dynamic_pointer_cast<ITrafficSignalGroupState>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficeSignalGroupState(std::dynamic_pointer_cast<ITrafficSignalGroupStateWriter>(clonedChildITrafficSignalGroupState));
            }
            return clonedObject;
        }

        std::string PhaseImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PhaseImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFICE_SIGNAL_GROUP_STATE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficeSignalGroupState());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PhaseImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SIGNAL_STATE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetTrafficSignalStates())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PhaseImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PhaseImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void PhaseImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void PhaseImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DURATION)
            {
                // Simple type
                _duration = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void PhaseImpl::ResetTrafficSignalStates()
	   {
	   		isSetTrafficSignalStates = false; 
			_trafficSignalStates = {};
			
	   }
       bool PhaseImpl::IsSetTrafficSignalStates() const
	   {
			return isSetTrafficSignalStates;
	   }
       void PhaseImpl::ResetTrafficeSignalGroupState()
	   {
	   		isSetTrafficeSignalGroupState = false; 
			_trafficeSignalGroupState = {};
			
	   }
       bool PhaseImpl::IsSetTrafficeSignalGroupState() const
	   {
			return isSetTrafficeSignalGroupState;
	   }

        IOpenScenarioFlexElement* PoissonDistributionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double PoissonDistributionImpl::GetExpectedValue() const
        {
        	  return _expectedValue;
        }
        std::shared_ptr<IRange> PoissonDistributionImpl::GetRange() const
        {
        	  return _range;
        }


        void PoissonDistributionImpl::SetExpectedValue(const double expectedValue)
        {
            _expectedValue = expectedValue;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__EXPECTED_VALUE);
        }

        void PoissonDistributionImpl::SetRange(std::shared_ptr<IRangeWriter> range)
        {
            _range = range;
			// set the indicator to true
            isSetRange = true;          
        }

        std::shared_ptr<void> PoissonDistributionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(PoissonDistributionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IPoissonDistribution).name())
                return std::dynamic_pointer_cast<IPoissonDistribution>(shared_from_this());
            else if (classifier == typeid(IPoissonDistributionWriter).name())
                return std::dynamic_pointer_cast<IPoissonDistributionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> PoissonDistributionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t PoissonDistributionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int PoissonDistributionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double PoissonDistributionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__EXPECTED_VALUE)
                {
                    return GetExpectedValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t PoissonDistributionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool PoissonDistributionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime PoissonDistributionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> PoissonDistributionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string PoissonDistributionImpl::GetModelType() const
        {
            return "PoissonDistribution";
        }

        void PoissonDistributionImpl::WriteParameterToExpectedValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__EXPECTED_VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _expectedValue = {};
        }

        std::string PoissonDistributionImpl::GetParameterFromExpectedValue() const
        {
            auto expectedValue = OSC_CONSTANTS::ATTRIBUTE__EXPECTED_VALUE;
            return GetParameterNameFromAttribute(expectedValue);
        }

        bool PoissonDistributionImpl::IsExpectedValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__EXPECTED_VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IRangeWriter> PoissonDistributionImpl::GetWriterRange() const
        {
            return std::dynamic_pointer_cast<IRangeWriter>(_range);
        }

        PoissonDistributionImpl::PoissonDistributionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__EXPECTED_VALUE, SimpleType::DOUBLE);
        }

        void PoissonDistributionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__EXPECTED_VALUE)
            {
                // Simple type
                _expectedValue = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType PoissonDistributionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PoissonDistributionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRange =  GetWriterRange();
                if (kRange)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRange));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PoissonDistributionImpl::Clone()
        {
            auto clonedObject = std::make_shared<PoissonDistributionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_expectedValue = GetExpectedValue();
            // clone indicators
            // clone children
            const auto kRange =  GetWriterRange();
            if (kRange)
            {
                auto clonedChild = std::dynamic_pointer_cast<RangeImpl>(kRange)->Clone();
                auto clonedChildIRange = std::dynamic_pointer_cast<IRange>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRange(std::dynamic_pointer_cast<IRangeWriter>(clonedChildIRange));
            }
            return clonedObject;
        }

        std::string PoissonDistributionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PoissonDistributionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RANGE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRange());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PoissonDistributionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PoissonDistributionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PoissonDistributionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void PoissonDistributionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__EXPECTED_VALUE)
            {
                // Simple type
                _expectedValue = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void PoissonDistributionImpl::ResetRange()
	   {
	   		isSetRange = false; 
			_range = {};
			
	   }
       bool PoissonDistributionImpl::IsSetRange() const
	   {
			return isSetRange;
	   }

        IOpenScenarioFlexElement* PolylineImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<IVertex>> PolylineImpl::GetVertices() const
        {
            std::vector<std::shared_ptr<IVertex>> temp;
            for(auto&& elm: _vertices)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IVertexWriter>> PolylineImpl::GetWriterVertices() const
        {
            return _vertices;
        }

        int PolylineImpl::GetVerticesSize() const
        {
            return static_cast<int>(_vertices.size());
        }

        std::shared_ptr<IVertex> PolylineImpl::GetVerticesAtIndex(unsigned int index) const
        {
            if (index >= 0 && _vertices.size() > index)
            {
                return _vertices[index];
            }
            return nullptr;
        }


        void PolylineImpl::SetVertices(std::vector<std::shared_ptr<IVertexWriter>>& vertices)
        {
            _vertices = vertices;
        }

        std::shared_ptr<void> PolylineImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(PolylineImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IPolyline).name())
                return std::dynamic_pointer_cast<IPolyline>(shared_from_this());
            else if (classifier == typeid(IPolylineWriter).name())
                return std::dynamic_pointer_cast<IPolylineWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> PolylineImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t PolylineImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int PolylineImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double PolylineImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t PolylineImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool PolylineImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime PolylineImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> PolylineImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string PolylineImpl::GetModelType() const
        {
            return "Polyline";
        }

            // children

        PolylineImpl::PolylineImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void PolylineImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType PolylineImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PolylineImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto vertices =  GetWriterVertices();
                if (!vertices.empty())
                {
                    for(auto&& item : vertices)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PolylineImpl::Clone()
        {
            auto clonedObject = std::make_shared<PolylineImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kVertices =  GetWriterVertices();
            if (!kVertices.empty())
            {
                std::vector<std::shared_ptr<IVertexWriter>> clonedList;
                for(auto&& kItem : kVertices)
                {
                    auto clonedChild = std::dynamic_pointer_cast<VertexImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IVertexWriter>(clonedChild));
                }
                clonedObject->SetVertices(clonedList);
            }
            return clonedObject;
        }

        std::string PolylineImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PolylineImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PolylineImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__VERTEX)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetVertices())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PolylineImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PolylineImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* PositionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IWorldPosition> PositionImpl::GetWorldPosition() const
        {
        	  return _worldPosition;
        }
        std::shared_ptr<IRelativeWorldPosition> PositionImpl::GetRelativeWorldPosition() const
        {
        	  return _relativeWorldPosition;
        }
        std::shared_ptr<IRelativeObjectPosition> PositionImpl::GetRelativeObjectPosition() const
        {
        	  return _relativeObjectPosition;
        }
        std::shared_ptr<IRoadPosition> PositionImpl::GetRoadPosition() const
        {
        	  return _roadPosition;
        }
        std::shared_ptr<IRelativeRoadPosition> PositionImpl::GetRelativeRoadPosition() const
        {
        	  return _relativeRoadPosition;
        }
        std::shared_ptr<ILanePosition> PositionImpl::GetLanePosition() const
        {
        	  return _lanePosition;
        }
        std::shared_ptr<IRelativeLanePosition> PositionImpl::GetRelativeLanePosition() const
        {
        	  return _relativeLanePosition;
        }
        std::shared_ptr<IRoutePosition> PositionImpl::GetRoutePosition() const
        {
        	  return _routePosition;
        }
        std::shared_ptr<IGeoPosition> PositionImpl::GetGeoPosition() const
        {
        	  return _geoPosition;
        }
        std::shared_ptr<ITrajectoryPosition> PositionImpl::GetTrajectoryPosition() const
        {
        	  return _trajectoryPosition;
        }


        void PositionImpl::SetWorldPosition(std::shared_ptr<IWorldPositionWriter> worldPosition)
        {
            _worldPosition = worldPosition;
            _relativeWorldPosition = {};
            _relativeObjectPosition = {};
            _roadPosition = {};
            _relativeRoadPosition = {};
            _lanePosition = {};
            _relativeLanePosition = {};
            _routePosition = {};
            _geoPosition = {};
            _trajectoryPosition = {};
			// set the indicator to true
            isSetWorldPosition = true;          
        }

        void PositionImpl::SetRelativeWorldPosition(std::shared_ptr<IRelativeWorldPositionWriter> relativeWorldPosition)
        {
            _relativeWorldPosition = relativeWorldPosition;
            _worldPosition = {};
            _relativeObjectPosition = {};
            _roadPosition = {};
            _relativeRoadPosition = {};
            _lanePosition = {};
            _relativeLanePosition = {};
            _routePosition = {};
            _geoPosition = {};
            _trajectoryPosition = {};
			// set the indicator to true
            isSetRelativeWorldPosition = true;          
        }

        void PositionImpl::SetRelativeObjectPosition(std::shared_ptr<IRelativeObjectPositionWriter> relativeObjectPosition)
        {
            _relativeObjectPosition = relativeObjectPosition;
            _worldPosition = {};
            _relativeWorldPosition = {};
            _roadPosition = {};
            _relativeRoadPosition = {};
            _lanePosition = {};
            _relativeLanePosition = {};
            _routePosition = {};
            _geoPosition = {};
            _trajectoryPosition = {};
			// set the indicator to true
            isSetRelativeObjectPosition = true;          
        }

        void PositionImpl::SetRoadPosition(std::shared_ptr<IRoadPositionWriter> roadPosition)
        {
            _roadPosition = roadPosition;
            _worldPosition = {};
            _relativeWorldPosition = {};
            _relativeObjectPosition = {};
            _relativeRoadPosition = {};
            _lanePosition = {};
            _relativeLanePosition = {};
            _routePosition = {};
            _geoPosition = {};
            _trajectoryPosition = {};
			// set the indicator to true
            isSetRoadPosition = true;          
        }

        void PositionImpl::SetRelativeRoadPosition(std::shared_ptr<IRelativeRoadPositionWriter> relativeRoadPosition)
        {
            _relativeRoadPosition = relativeRoadPosition;
            _worldPosition = {};
            _relativeWorldPosition = {};
            _relativeObjectPosition = {};
            _roadPosition = {};
            _lanePosition = {};
            _relativeLanePosition = {};
            _routePosition = {};
            _geoPosition = {};
            _trajectoryPosition = {};
			// set the indicator to true
            isSetRelativeRoadPosition = true;          
        }

        void PositionImpl::SetLanePosition(std::shared_ptr<ILanePositionWriter> lanePosition)
        {
            _lanePosition = lanePosition;
            _worldPosition = {};
            _relativeWorldPosition = {};
            _relativeObjectPosition = {};
            _roadPosition = {};
            _relativeRoadPosition = {};
            _relativeLanePosition = {};
            _routePosition = {};
            _geoPosition = {};
            _trajectoryPosition = {};
			// set the indicator to true
            isSetLanePosition = true;          
        }

        void PositionImpl::SetRelativeLanePosition(std::shared_ptr<IRelativeLanePositionWriter> relativeLanePosition)
        {
            _relativeLanePosition = relativeLanePosition;
            _worldPosition = {};
            _relativeWorldPosition = {};
            _relativeObjectPosition = {};
            _roadPosition = {};
            _relativeRoadPosition = {};
            _lanePosition = {};
            _routePosition = {};
            _geoPosition = {};
            _trajectoryPosition = {};
			// set the indicator to true
            isSetRelativeLanePosition = true;          
        }

        void PositionImpl::SetRoutePosition(std::shared_ptr<IRoutePositionWriter> routePosition)
        {
            _routePosition = routePosition;
            _worldPosition = {};
            _relativeWorldPosition = {};
            _relativeObjectPosition = {};
            _roadPosition = {};
            _relativeRoadPosition = {};
            _lanePosition = {};
            _relativeLanePosition = {};
            _geoPosition = {};
            _trajectoryPosition = {};
			// set the indicator to true
            isSetRoutePosition = true;          
        }

        void PositionImpl::SetGeoPosition(std::shared_ptr<IGeoPositionWriter> geoPosition)
        {
            _geoPosition = geoPosition;
            _worldPosition = {};
            _relativeWorldPosition = {};
            _relativeObjectPosition = {};
            _roadPosition = {};
            _relativeRoadPosition = {};
            _lanePosition = {};
            _relativeLanePosition = {};
            _routePosition = {};
            _trajectoryPosition = {};
			// set the indicator to true
            isSetGeoPosition = true;          
        }

        void PositionImpl::SetTrajectoryPosition(std::shared_ptr<ITrajectoryPositionWriter> trajectoryPosition)
        {
            _trajectoryPosition = trajectoryPosition;
            _worldPosition = {};
            _relativeWorldPosition = {};
            _relativeObjectPosition = {};
            _roadPosition = {};
            _relativeRoadPosition = {};
            _lanePosition = {};
            _relativeLanePosition = {};
            _routePosition = {};
            _geoPosition = {};
			// set the indicator to true
            isSetTrajectoryPosition = true;          
        }

        std::shared_ptr<void> PositionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(PositionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IPosition).name())
                return std::dynamic_pointer_cast<IPosition>(shared_from_this());
            else if (classifier == typeid(IPositionWriter).name())
                return std::dynamic_pointer_cast<IPositionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> PositionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t PositionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int PositionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double PositionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t PositionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool PositionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime PositionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> PositionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string PositionImpl::GetModelType() const
        {
            return "Position";
        }

            // children
        std::shared_ptr<IWorldPositionWriter> PositionImpl::GetWriterWorldPosition() const
        {
            return std::dynamic_pointer_cast<IWorldPositionWriter>(_worldPosition);
        }
        std::shared_ptr<IRelativeWorldPositionWriter> PositionImpl::GetWriterRelativeWorldPosition() const
        {
            return std::dynamic_pointer_cast<IRelativeWorldPositionWriter>(_relativeWorldPosition);
        }
        std::shared_ptr<IRelativeObjectPositionWriter> PositionImpl::GetWriterRelativeObjectPosition() const
        {
            return std::dynamic_pointer_cast<IRelativeObjectPositionWriter>(_relativeObjectPosition);
        }
        std::shared_ptr<IRoadPositionWriter> PositionImpl::GetWriterRoadPosition() const
        {
            return std::dynamic_pointer_cast<IRoadPositionWriter>(_roadPosition);
        }
        std::shared_ptr<IRelativeRoadPositionWriter> PositionImpl::GetWriterRelativeRoadPosition() const
        {
            return std::dynamic_pointer_cast<IRelativeRoadPositionWriter>(_relativeRoadPosition);
        }
        std::shared_ptr<ILanePositionWriter> PositionImpl::GetWriterLanePosition() const
        {
            return std::dynamic_pointer_cast<ILanePositionWriter>(_lanePosition);
        }
        std::shared_ptr<IRelativeLanePositionWriter> PositionImpl::GetWriterRelativeLanePosition() const
        {
            return std::dynamic_pointer_cast<IRelativeLanePositionWriter>(_relativeLanePosition);
        }
        std::shared_ptr<IRoutePositionWriter> PositionImpl::GetWriterRoutePosition() const
        {
            return std::dynamic_pointer_cast<IRoutePositionWriter>(_routePosition);
        }
        std::shared_ptr<IGeoPositionWriter> PositionImpl::GetWriterGeoPosition() const
        {
            return std::dynamic_pointer_cast<IGeoPositionWriter>(_geoPosition);
        }
        std::shared_ptr<ITrajectoryPositionWriter> PositionImpl::GetWriterTrajectoryPosition() const
        {
            return std::dynamic_pointer_cast<ITrajectoryPositionWriter>(_trajectoryPosition);
        }

        PositionImpl::PositionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void PositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType PositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kWorldPosition =  GetWriterWorldPosition();
                if (kWorldPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kWorldPosition));
                }
                const auto kRelativeWorldPosition =  GetWriterRelativeWorldPosition();
                if (kRelativeWorldPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeWorldPosition));
                }
                const auto kRelativeObjectPosition =  GetWriterRelativeObjectPosition();
                if (kRelativeObjectPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeObjectPosition));
                }
                const auto kRoadPosition =  GetWriterRoadPosition();
                if (kRoadPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRoadPosition));
                }
                const auto kRelativeRoadPosition =  GetWriterRelativeRoadPosition();
                if (kRelativeRoadPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeRoadPosition));
                }
                const auto kLanePosition =  GetWriterLanePosition();
                if (kLanePosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLanePosition));
                }
                const auto kRelativeLanePosition =  GetWriterRelativeLanePosition();
                if (kRelativeLanePosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeLanePosition));
                }
                const auto kRoutePosition =  GetWriterRoutePosition();
                if (kRoutePosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRoutePosition));
                }
                const auto kGeoPosition =  GetWriterGeoPosition();
                if (kGeoPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kGeoPosition));
                }
                const auto kTrajectoryPosition =  GetWriterTrajectoryPosition();
                if (kTrajectoryPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrajectoryPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<PositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kWorldPosition =  GetWriterWorldPosition();
            if (kWorldPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<WorldPositionImpl>(kWorldPosition)->Clone();
                auto clonedChildIWorldPosition = std::dynamic_pointer_cast<IWorldPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetWorldPosition(std::dynamic_pointer_cast<IWorldPositionWriter>(clonedChildIWorldPosition));
            }
            const auto kRelativeWorldPosition =  GetWriterRelativeWorldPosition();
            if (kRelativeWorldPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeWorldPositionImpl>(kRelativeWorldPosition)->Clone();
                auto clonedChildIRelativeWorldPosition = std::dynamic_pointer_cast<IRelativeWorldPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeWorldPosition(std::dynamic_pointer_cast<IRelativeWorldPositionWriter>(clonedChildIRelativeWorldPosition));
            }
            const auto kRelativeObjectPosition =  GetWriterRelativeObjectPosition();
            if (kRelativeObjectPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeObjectPositionImpl>(kRelativeObjectPosition)->Clone();
                auto clonedChildIRelativeObjectPosition = std::dynamic_pointer_cast<IRelativeObjectPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeObjectPosition(std::dynamic_pointer_cast<IRelativeObjectPositionWriter>(clonedChildIRelativeObjectPosition));
            }
            const auto kRoadPosition =  GetWriterRoadPosition();
            if (kRoadPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RoadPositionImpl>(kRoadPosition)->Clone();
                auto clonedChildIRoadPosition = std::dynamic_pointer_cast<IRoadPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRoadPosition(std::dynamic_pointer_cast<IRoadPositionWriter>(clonedChildIRoadPosition));
            }
            const auto kRelativeRoadPosition =  GetWriterRelativeRoadPosition();
            if (kRelativeRoadPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeRoadPositionImpl>(kRelativeRoadPosition)->Clone();
                auto clonedChildIRelativeRoadPosition = std::dynamic_pointer_cast<IRelativeRoadPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeRoadPosition(std::dynamic_pointer_cast<IRelativeRoadPositionWriter>(clonedChildIRelativeRoadPosition));
            }
            const auto kLanePosition =  GetWriterLanePosition();
            if (kLanePosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<LanePositionImpl>(kLanePosition)->Clone();
                auto clonedChildILanePosition = std::dynamic_pointer_cast<ILanePosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLanePosition(std::dynamic_pointer_cast<ILanePositionWriter>(clonedChildILanePosition));
            }
            const auto kRelativeLanePosition =  GetWriterRelativeLanePosition();
            if (kRelativeLanePosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeLanePositionImpl>(kRelativeLanePosition)->Clone();
                auto clonedChildIRelativeLanePosition = std::dynamic_pointer_cast<IRelativeLanePosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeLanePosition(std::dynamic_pointer_cast<IRelativeLanePositionWriter>(clonedChildIRelativeLanePosition));
            }
            const auto kRoutePosition =  GetWriterRoutePosition();
            if (kRoutePosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RoutePositionImpl>(kRoutePosition)->Clone();
                auto clonedChildIRoutePosition = std::dynamic_pointer_cast<IRoutePosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRoutePosition(std::dynamic_pointer_cast<IRoutePositionWriter>(clonedChildIRoutePosition));
            }
            const auto kGeoPosition =  GetWriterGeoPosition();
            if (kGeoPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<GeoPositionImpl>(kGeoPosition)->Clone();
                auto clonedChildIGeoPosition = std::dynamic_pointer_cast<IGeoPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetGeoPosition(std::dynamic_pointer_cast<IGeoPositionWriter>(clonedChildIGeoPosition));
            }
            const auto kTrajectoryPosition =  GetWriterTrajectoryPosition();
            if (kTrajectoryPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrajectoryPositionImpl>(kTrajectoryPosition)->Clone();
                auto clonedChildITrajectoryPosition = std::dynamic_pointer_cast<ITrajectoryPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrajectoryPosition(std::dynamic_pointer_cast<ITrajectoryPositionWriter>(clonedChildITrajectoryPosition));
            }
            return clonedObject;
        }

        std::string PositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__WORLD_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetWorldPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_WORLD_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeWorldPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_OBJECT_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeObjectPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ROAD_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRoadPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_ROAD_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeRoadPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LANE_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLanePosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_LANE_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeLanePosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ROUTE_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRoutePosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__GEO_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetGeoPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAJECTORY_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrajectoryPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void PositionImpl::ResetWorldPosition()
	   {
	   		isSetWorldPosition = false; 
			_worldPosition = {};
			
	   }
       bool PositionImpl::IsSetWorldPosition() const
	   {
			return isSetWorldPosition;
	   }
       void PositionImpl::ResetRelativeWorldPosition()
	   {
	   		isSetRelativeWorldPosition = false; 
			_relativeWorldPosition = {};
			
	   }
       bool PositionImpl::IsSetRelativeWorldPosition() const
	   {
			return isSetRelativeWorldPosition;
	   }
       void PositionImpl::ResetRelativeObjectPosition()
	   {
	   		isSetRelativeObjectPosition = false; 
			_relativeObjectPosition = {};
			
	   }
       bool PositionImpl::IsSetRelativeObjectPosition() const
	   {
			return isSetRelativeObjectPosition;
	   }
       void PositionImpl::ResetRoadPosition()
	   {
	   		isSetRoadPosition = false; 
			_roadPosition = {};
			
	   }
       bool PositionImpl::IsSetRoadPosition() const
	   {
			return isSetRoadPosition;
	   }
       void PositionImpl::ResetRelativeRoadPosition()
	   {
	   		isSetRelativeRoadPosition = false; 
			_relativeRoadPosition = {};
			
	   }
       bool PositionImpl::IsSetRelativeRoadPosition() const
	   {
			return isSetRelativeRoadPosition;
	   }
       void PositionImpl::ResetLanePosition()
	   {
	   		isSetLanePosition = false; 
			_lanePosition = {};
			
	   }
       bool PositionImpl::IsSetLanePosition() const
	   {
			return isSetLanePosition;
	   }
       void PositionImpl::ResetRelativeLanePosition()
	   {
	   		isSetRelativeLanePosition = false; 
			_relativeLanePosition = {};
			
	   }
       bool PositionImpl::IsSetRelativeLanePosition() const
	   {
			return isSetRelativeLanePosition;
	   }
       void PositionImpl::ResetRoutePosition()
	   {
	   		isSetRoutePosition = false; 
			_routePosition = {};
			
	   }
       bool PositionImpl::IsSetRoutePosition() const
	   {
			return isSetRoutePosition;
	   }
       void PositionImpl::ResetGeoPosition()
	   {
	   		isSetGeoPosition = false; 
			_geoPosition = {};
			
	   }
       bool PositionImpl::IsSetGeoPosition() const
	   {
			return isSetGeoPosition;
	   }
       void PositionImpl::ResetTrajectoryPosition()
	   {
	   		isSetTrajectoryPosition = false; 
			_trajectoryPosition = {};
			
	   }
       bool PositionImpl::IsSetTrajectoryPosition() const
	   {
			return isSetTrajectoryPosition;
	   }

        IOpenScenarioFlexElement* PositionInLaneCoordinatesImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string PositionInLaneCoordinatesImpl::GetLaneId() const
        {
        	  return _laneId;
        }
        double PositionInLaneCoordinatesImpl::GetLaneOffset() const
        {
        	  return _laneOffset;
        }
        double PositionInLaneCoordinatesImpl::GetPathS() const
        {
        	  return _pathS;
        }


        void PositionInLaneCoordinatesImpl::SetLaneId(const std::string laneId)
        {
            _laneId = laneId;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LANE_ID);
        }

        void PositionInLaneCoordinatesImpl::SetLaneOffset(const double laneOffset)
        {
            _laneOffset = laneOffset;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LANE_OFFSET);
			// set the indicator to true
            isSetLaneOffset = true;          
        }

        void PositionInLaneCoordinatesImpl::SetPathS(const double pathS)
        {
            _pathS = pathS;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PATH_S);
        }

        std::shared_ptr<void> PositionInLaneCoordinatesImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(PositionInLaneCoordinatesImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IPositionInLaneCoordinates).name())
                return std::dynamic_pointer_cast<IPositionInLaneCoordinates>(shared_from_this());
            else if (classifier == typeid(IPositionInLaneCoordinatesWriter).name())
                return std::dynamic_pointer_cast<IPositionInLaneCoordinatesWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> PositionInLaneCoordinatesImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t PositionInLaneCoordinatesImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int PositionInLaneCoordinatesImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double PositionInLaneCoordinatesImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__LANE_OFFSET)
                {
                    return GetLaneOffset();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__PATH_S)
                {
                    return GetPathS();
                }
                throw KeyNotSupportedException();

        }

        uint16_t PositionInLaneCoordinatesImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool PositionInLaneCoordinatesImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime PositionInLaneCoordinatesImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> PositionInLaneCoordinatesImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string PositionInLaneCoordinatesImpl::GetModelType() const
        {
            return "PositionInLaneCoordinates";
        }

        void PositionInLaneCoordinatesImpl::WriteParameterToLaneId(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LANE_ID, parameterName, nullTextMarker /*no textmarker*/);
            _laneId = {};
        }

        void PositionInLaneCoordinatesImpl::WriteParameterToLaneOffset(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LANE_OFFSET, parameterName, nullTextMarker /*no textmarker*/);
            _laneOffset = {};
        }

        void PositionInLaneCoordinatesImpl::WriteParameterToPathS(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PATH_S, parameterName, nullTextMarker /*no textmarker*/);
            _pathS = {};
        }

        std::string PositionInLaneCoordinatesImpl::GetParameterFromLaneId() const
        {
            auto laneId = OSC_CONSTANTS::ATTRIBUTE__LANE_ID;
            return GetParameterNameFromAttribute(laneId);
        }

        std::string PositionInLaneCoordinatesImpl::GetParameterFromLaneOffset() const
        {
            auto laneOffset = OSC_CONSTANTS::ATTRIBUTE__LANE_OFFSET;
            return GetParameterNameFromAttribute(laneOffset);
        }

        std::string PositionInLaneCoordinatesImpl::GetParameterFromPathS() const
        {
            auto pathS = OSC_CONSTANTS::ATTRIBUTE__PATH_S;
            return GetParameterNameFromAttribute(pathS);
        }

        bool PositionInLaneCoordinatesImpl::IsLaneIdParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__LANE_ID);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool PositionInLaneCoordinatesImpl::IsLaneOffsetParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__LANE_OFFSET);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool PositionInLaneCoordinatesImpl::IsPathSParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__PATH_S);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        PositionInLaneCoordinatesImpl::PositionInLaneCoordinatesImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LANE_ID, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LANE_OFFSET, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PATH_S, SimpleType::DOUBLE);
        }

        void PositionInLaneCoordinatesImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LANE_ID)
            {
                // Simple type
                _laneId = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LANE_OFFSET)
            {
                // Simple type
                _laneOffset = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PATH_S)
            {
                // Simple type
                _pathS = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType PositionInLaneCoordinatesImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PositionInLaneCoordinatesImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PositionInLaneCoordinatesImpl::Clone()
        {
            auto clonedObject = std::make_shared<PositionInLaneCoordinatesImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_laneId = GetLaneId();
            // Simple type
            clonedObject->_laneOffset = GetLaneOffset();
            // Simple type
            clonedObject->_pathS = GetPathS();
            // clone indicators
            	clonedObject->isSetLaneOffset = isSetLaneOffset;
            // clone children
            return clonedObject;
        }

        std::string PositionInLaneCoordinatesImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__LANE_ID)
            {
                return GetLaneId();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PositionInLaneCoordinatesImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PositionInLaneCoordinatesImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PositionInLaneCoordinatesImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PositionInLaneCoordinatesImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void PositionInLaneCoordinatesImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LANE_ID)
            {
                // Simple type
                _laneId = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void PositionInLaneCoordinatesImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LANE_OFFSET)
            {
                // Simple type
                _laneOffset = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PATH_S)
            {
                // Simple type
                _pathS = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void PositionInLaneCoordinatesImpl::ResetLaneOffset()
	   {
	   		isSetLaneOffset = false; 
			_laneOffset = {0};
			
	   }
       bool PositionInLaneCoordinatesImpl::IsSetLaneOffset() const
	   {
			return isSetLaneOffset;
	   }

        IOpenScenarioFlexElement* PositionInRoadCoordinatesImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double PositionInRoadCoordinatesImpl::GetPathS() const
        {
        	  return _pathS;
        }
        double PositionInRoadCoordinatesImpl::GetT() const
        {
        	  return _t;
        }


        void PositionInRoadCoordinatesImpl::SetPathS(const double pathS)
        {
            _pathS = pathS;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PATH_S);
        }

        void PositionInRoadCoordinatesImpl::SetT(const double t)
        {
            _t = t;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__T);
        }

        std::shared_ptr<void> PositionInRoadCoordinatesImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(PositionInRoadCoordinatesImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IPositionInRoadCoordinates).name())
                return std::dynamic_pointer_cast<IPositionInRoadCoordinates>(shared_from_this());
            else if (classifier == typeid(IPositionInRoadCoordinatesWriter).name())
                return std::dynamic_pointer_cast<IPositionInRoadCoordinatesWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> PositionInRoadCoordinatesImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t PositionInRoadCoordinatesImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int PositionInRoadCoordinatesImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double PositionInRoadCoordinatesImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__PATH_S)
                {
                    return GetPathS();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__T)
                {
                    return GetT();
                }
                throw KeyNotSupportedException();

        }

        uint16_t PositionInRoadCoordinatesImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool PositionInRoadCoordinatesImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime PositionInRoadCoordinatesImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> PositionInRoadCoordinatesImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string PositionInRoadCoordinatesImpl::GetModelType() const
        {
            return "PositionInRoadCoordinates";
        }

        void PositionInRoadCoordinatesImpl::WriteParameterToPathS(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PATH_S, parameterName, nullTextMarker /*no textmarker*/);
            _pathS = {};
        }

        void PositionInRoadCoordinatesImpl::WriteParameterToT(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__T, parameterName, nullTextMarker /*no textmarker*/);
            _t = {};
        }

        std::string PositionInRoadCoordinatesImpl::GetParameterFromPathS() const
        {
            auto pathS = OSC_CONSTANTS::ATTRIBUTE__PATH_S;
            return GetParameterNameFromAttribute(pathS);
        }

        std::string PositionInRoadCoordinatesImpl::GetParameterFromT() const
        {
            auto t = OSC_CONSTANTS::ATTRIBUTE__T;
            return GetParameterNameFromAttribute(t);
        }

        bool PositionInRoadCoordinatesImpl::IsPathSParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__PATH_S);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool PositionInRoadCoordinatesImpl::IsTParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__T);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        PositionInRoadCoordinatesImpl::PositionInRoadCoordinatesImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PATH_S, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__T, SimpleType::DOUBLE);
        }

        void PositionInRoadCoordinatesImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PATH_S)
            {
                // Simple type
                _pathS = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__T)
            {
                // Simple type
                _t = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType PositionInRoadCoordinatesImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PositionInRoadCoordinatesImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PositionInRoadCoordinatesImpl::Clone()
        {
            auto clonedObject = std::make_shared<PositionInRoadCoordinatesImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_pathS = GetPathS();
            // Simple type
            clonedObject->_t = GetT();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string PositionInRoadCoordinatesImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PositionInRoadCoordinatesImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PositionInRoadCoordinatesImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PositionInRoadCoordinatesImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PositionInRoadCoordinatesImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void PositionInRoadCoordinatesImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PATH_S)
            {
                // Simple type
                _pathS = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__T)
            {
                // Simple type
                _t = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* PositionOfCurrentEntityImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<INamedReference<IEntity>> PositionOfCurrentEntityImpl::GetEntityRef() const
        {
        	 return _entityRef;
        }


        void PositionOfCurrentEntityImpl::SetEntityRef(std::shared_ptr<INamedReference<IEntity>> entityRef)
        {
            _entityRef = entityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
        }

        std::shared_ptr<void> PositionOfCurrentEntityImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(PositionOfCurrentEntityImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IPositionOfCurrentEntity).name())
                return std::dynamic_pointer_cast<IPositionOfCurrentEntity>(shared_from_this());
            else if (classifier == typeid(IPositionOfCurrentEntityWriter).name())
                return std::dynamic_pointer_cast<IPositionOfCurrentEntityWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> PositionOfCurrentEntityImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t PositionOfCurrentEntityImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int PositionOfCurrentEntityImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double PositionOfCurrentEntityImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t PositionOfCurrentEntityImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool PositionOfCurrentEntityImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime PositionOfCurrentEntityImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> PositionOfCurrentEntityImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string PositionOfCurrentEntityImpl::GetModelType() const
        {
            return "PositionOfCurrentEntity";
        }

        void PositionOfCurrentEntityImpl::WriteParameterToEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _entityRef = {};
        }

        std::string PositionOfCurrentEntityImpl::GetParameterFromEntityRef() const
        {
            auto entityRef = OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF;
            return GetParameterNameFromAttribute(entityRef);
        }

        bool PositionOfCurrentEntityImpl::IsEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        PositionOfCurrentEntityImpl::PositionOfCurrentEntityImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
        }

        void PositionOfCurrentEntityImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType PositionOfCurrentEntityImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PositionOfCurrentEntityImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PositionOfCurrentEntityImpl::Clone()
        {
            auto clonedObject = std::make_shared<PositionOfCurrentEntityImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string PositionOfCurrentEntityImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PositionOfCurrentEntityImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PositionOfCurrentEntityImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PositionOfCurrentEntityImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string PositionOfCurrentEntityImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* PrecipitationImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double PrecipitationImpl::GetIntensity() const
        {
        	  return _intensity;
        }
        double PrecipitationImpl::GetPrecipitationIntensity() const
        {
        	  return _precipitationIntensity;
        }
        PrecipitationType PrecipitationImpl::GetPrecipitationType() const
        {
        	  return _precipitationType;
        }


        void PrecipitationImpl::SetIntensity(const double intensity)
        {
            _intensity = intensity;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__INTENSITY);
			// set the indicator to true
            isSetIntensity = true;          
        }

        void PrecipitationImpl::SetPrecipitationIntensity(const double precipitationIntensity)
        {
            _precipitationIntensity = precipitationIntensity;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PRECIPITATION_INTENSITY);
			// set the indicator to true
            isSetPrecipitationIntensity = true;          
        }

        void PrecipitationImpl::SetPrecipitationType(const PrecipitationType precipitationType)
        {
            _precipitationType = precipitationType;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PRECIPITATION_TYPE);
        }

        std::shared_ptr<void> PrecipitationImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(PrecipitationImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IPrecipitation).name())
                return std::dynamic_pointer_cast<IPrecipitation>(shared_from_this());
            else if (classifier == typeid(IPrecipitationWriter).name())
                return std::dynamic_pointer_cast<IPrecipitationWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> PrecipitationImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t PrecipitationImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int PrecipitationImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double PrecipitationImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__INTENSITY)
                {
                    return GetIntensity();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__PRECIPITATION_INTENSITY)
                {
                    return GetPrecipitationIntensity();
                }
                throw KeyNotSupportedException();

        }

        uint16_t PrecipitationImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool PrecipitationImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime PrecipitationImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> PrecipitationImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string PrecipitationImpl::GetModelType() const
        {
            return "Precipitation";
        }

        void PrecipitationImpl::WriteParameterToIntensity(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__INTENSITY, parameterName, nullTextMarker /*no textmarker*/);
            _intensity = {};
        }

        void PrecipitationImpl::WriteParameterToPrecipitationIntensity(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PRECIPITATION_INTENSITY, parameterName, nullTextMarker /*no textmarker*/);
            _precipitationIntensity = {};
        }

        void PrecipitationImpl::WriteParameterToPrecipitationType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PRECIPITATION_TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _precipitationType = {};
        }

        std::string PrecipitationImpl::GetParameterFromIntensity() const
        {
            auto intensity = OSC_CONSTANTS::ATTRIBUTE__INTENSITY;
            return GetParameterNameFromAttribute(intensity);
        }

        std::string PrecipitationImpl::GetParameterFromPrecipitationIntensity() const
        {
            auto precipitationIntensity = OSC_CONSTANTS::ATTRIBUTE__PRECIPITATION_INTENSITY;
            return GetParameterNameFromAttribute(precipitationIntensity);
        }

        std::string PrecipitationImpl::GetParameterFromPrecipitationType() const
        {
            auto precipitationType = OSC_CONSTANTS::ATTRIBUTE__PRECIPITATION_TYPE;
            return GetParameterNameFromAttribute(precipitationType);
        }

        bool PrecipitationImpl::IsIntensityParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__INTENSITY);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool PrecipitationImpl::IsPrecipitationIntensityParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__PRECIPITATION_INTENSITY);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool PrecipitationImpl::IsPrecipitationTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__PRECIPITATION_TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        PrecipitationImpl::PrecipitationImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__INTENSITY, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PRECIPITATION_INTENSITY, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PRECIPITATION_TYPE, SimpleType::ENUM_TYPE);
        }

        void PrecipitationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__INTENSITY)
            {
                // Simple type
                _intensity = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PRECIPITATION_INTENSITY)
            {
                // Simple type
                _precipitationIntensity = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PRECIPITATION_TYPE)
            {
                // Enumeration Type
                const auto kResult = PrecipitationType::GetFromLiteral(parameterLiteralValue);
                if (kResult != PrecipitationType::UNKNOWN)
                {
                    _precipitationType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType PrecipitationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PrecipitationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PrecipitationImpl::Clone()
        {
            auto clonedObject = std::make_shared<PrecipitationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_intensity = GetIntensity();
            // Simple type
            clonedObject->_precipitationIntensity = GetPrecipitationIntensity();
            // Enumeration Type
            const auto kPrecipitationType = GetPrecipitationType();
            if ( kPrecipitationType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_precipitationType = PrecipitationType::GetFromLiteral(kPrecipitationType.GetLiteral());
            }
            // clone indicators
            	clonedObject->isSetIntensity = isSetIntensity;
            	clonedObject->isSetPrecipitationIntensity = isSetPrecipitationIntensity;
            // clone children
            return clonedObject;
        }

        std::string PrecipitationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PrecipitationImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PrecipitationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PrecipitationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PrecipitationImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PRECIPITATION_TYPE)
            {
                auto precipitationType = GetPrecipitationType();
                return precipitationType.GetLiteral() != "UNKNOWN" ? precipitationType.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void PrecipitationImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__INTENSITY)
            {
                // Simple type
                _intensity = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PRECIPITATION_INTENSITY)
            {
                // Simple type
                _precipitationIntensity = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void PrecipitationImpl::ResetIntensity()
	   {
	   		isSetIntensity = false; 
			_intensity = {};
			
	   }
       bool PrecipitationImpl::IsSetIntensity() const
	   {
			return isSetIntensity;
	   }
       void PrecipitationImpl::ResetPrecipitationIntensity()
	   {
	   		isSetPrecipitationIntensity = false; 
			_precipitationIntensity = {};
			
	   }
       bool PrecipitationImpl::IsSetPrecipitationIntensity() const
	   {
			return isSetPrecipitationIntensity;
	   }

        IOpenScenarioFlexElement* PrivateImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<INamedReference<IEntity>> PrivateImpl::GetEntityRef() const
        {
        	 return _entityRef;
        }
        std::vector<std::shared_ptr<IPrivateAction>> PrivateImpl::GetPrivateActions() const
        {
            std::vector<std::shared_ptr<IPrivateAction>> temp;
            for(auto&& elm: _privateActions)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IPrivateActionWriter>> PrivateImpl::GetWriterPrivateActions() const
        {
            return _privateActions;
        }

        int PrivateImpl::GetPrivateActionsSize() const
        {
            return static_cast<int>(_privateActions.size());
        }

        std::shared_ptr<IPrivateAction> PrivateImpl::GetPrivateActionsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _privateActions.size() > index)
            {
                return _privateActions[index];
            }
            return nullptr;
        }


        void PrivateImpl::SetEntityRef(std::shared_ptr<INamedReference<IEntity>> entityRef)
        {
            _entityRef = entityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
        }

        void PrivateImpl::SetPrivateActions(std::vector<std::shared_ptr<IPrivateActionWriter>>& privateActions)
        {
            _privateActions = privateActions;
        }

        std::shared_ptr<void> PrivateImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(PrivateImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IPrivate).name())
                return std::dynamic_pointer_cast<IPrivate>(shared_from_this());
            else if (classifier == typeid(IPrivateWriter).name())
                return std::dynamic_pointer_cast<IPrivateWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> PrivateImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t PrivateImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int PrivateImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double PrivateImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t PrivateImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool PrivateImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime PrivateImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> PrivateImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string PrivateImpl::GetModelType() const
        {
            return "Private";
        }

        void PrivateImpl::WriteParameterToEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _entityRef = {};
        }

        std::string PrivateImpl::GetParameterFromEntityRef() const
        {
            auto entityRef = OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF;
            return GetParameterNameFromAttribute(entityRef);
        }

        bool PrivateImpl::IsEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        PrivateImpl::PrivateImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
        }

        void PrivateImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType PrivateImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PrivateImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto privateActions =  GetWriterPrivateActions();
                if (!privateActions.empty())
                {
                    for(auto&& item : privateActions)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PrivateImpl::Clone()
        {
            auto clonedObject = std::make_shared<PrivateImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // clone indicators
            // clone children
            const auto kPrivateActions =  GetWriterPrivateActions();
            if (!kPrivateActions.empty())
            {
                std::vector<std::shared_ptr<IPrivateActionWriter>> clonedList;
                for(auto&& kItem : kPrivateActions)
                {
                    auto clonedChild = std::dynamic_pointer_cast<PrivateActionImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IPrivateActionWriter>(clonedChild));
                }
                clonedObject->SetPrivateActions(clonedList);
            }
            return clonedObject;
        }

        std::string PrivateImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PrivateImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PrivateImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__PRIVATE_ACTION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetPrivateActions())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PrivateImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string PrivateImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* PrivateActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<ILongitudinalAction> PrivateActionImpl::GetLongitudinalAction() const
        {
        	  return _longitudinalAction;
        }
        std::shared_ptr<ILateralAction> PrivateActionImpl::GetLateralAction() const
        {
        	  return _lateralAction;
        }
        std::shared_ptr<IVisibilityAction> PrivateActionImpl::GetVisibilityAction() const
        {
        	  return _visibilityAction;
        }
        std::shared_ptr<ISynchronizeAction> PrivateActionImpl::GetSynchronizeAction() const
        {
        	  return _synchronizeAction;
        }
        std::shared_ptr<IActivateControllerAction> PrivateActionImpl::GetActivateControllerAction() const
        {
        	  return _activateControllerAction;
        }
        std::shared_ptr<IControllerAction> PrivateActionImpl::GetControllerAction() const
        {
        	  return _controllerAction;
        }
        std::shared_ptr<ITeleportAction> PrivateActionImpl::GetTeleportAction() const
        {
        	  return _teleportAction;
        }
        std::shared_ptr<IRoutingAction> PrivateActionImpl::GetRoutingAction() const
        {
        	  return _routingAction;
        }
        std::shared_ptr<IAppearanceAction> PrivateActionImpl::GetAppearanceAction() const
        {
        	  return _appearanceAction;
        }


        void PrivateActionImpl::SetLongitudinalAction(std::shared_ptr<ILongitudinalActionWriter> longitudinalAction)
        {
            _longitudinalAction = longitudinalAction;
            _lateralAction = {};
            _visibilityAction = {};
            _synchronizeAction = {};
            _activateControllerAction = {};
            _controllerAction = {};
            _teleportAction = {};
            _routingAction = {};
            _appearanceAction = {};
			// set the indicator to true
            isSetLongitudinalAction = true;          
        }

        void PrivateActionImpl::SetLateralAction(std::shared_ptr<ILateralActionWriter> lateralAction)
        {
            _lateralAction = lateralAction;
            _longitudinalAction = {};
            _visibilityAction = {};
            _synchronizeAction = {};
            _activateControllerAction = {};
            _controllerAction = {};
            _teleportAction = {};
            _routingAction = {};
            _appearanceAction = {};
			// set the indicator to true
            isSetLateralAction = true;          
        }

        void PrivateActionImpl::SetVisibilityAction(std::shared_ptr<IVisibilityActionWriter> visibilityAction)
        {
            _visibilityAction = visibilityAction;
            _longitudinalAction = {};
            _lateralAction = {};
            _synchronizeAction = {};
            _activateControllerAction = {};
            _controllerAction = {};
            _teleportAction = {};
            _routingAction = {};
            _appearanceAction = {};
			// set the indicator to true
            isSetVisibilityAction = true;          
        }

        void PrivateActionImpl::SetSynchronizeAction(std::shared_ptr<ISynchronizeActionWriter> synchronizeAction)
        {
            _synchronizeAction = synchronizeAction;
            _longitudinalAction = {};
            _lateralAction = {};
            _visibilityAction = {};
            _activateControllerAction = {};
            _controllerAction = {};
            _teleportAction = {};
            _routingAction = {};
            _appearanceAction = {};
			// set the indicator to true
            isSetSynchronizeAction = true;          
        }

        void PrivateActionImpl::SetActivateControllerAction(std::shared_ptr<IActivateControllerActionWriter> activateControllerAction)
        {
            _activateControllerAction = activateControllerAction;
            _longitudinalAction = {};
            _lateralAction = {};
            _visibilityAction = {};
            _synchronizeAction = {};
            _controllerAction = {};
            _teleportAction = {};
            _routingAction = {};
            _appearanceAction = {};
			// set the indicator to true
            isSetActivateControllerAction = true;          
        }

        void PrivateActionImpl::SetControllerAction(std::shared_ptr<IControllerActionWriter> controllerAction)
        {
            _controllerAction = controllerAction;
            _longitudinalAction = {};
            _lateralAction = {};
            _visibilityAction = {};
            _synchronizeAction = {};
            _activateControllerAction = {};
            _teleportAction = {};
            _routingAction = {};
            _appearanceAction = {};
			// set the indicator to true
            isSetControllerAction = true;          
        }

        void PrivateActionImpl::SetTeleportAction(std::shared_ptr<ITeleportActionWriter> teleportAction)
        {
            _teleportAction = teleportAction;
            _longitudinalAction = {};
            _lateralAction = {};
            _visibilityAction = {};
            _synchronizeAction = {};
            _activateControllerAction = {};
            _controllerAction = {};
            _routingAction = {};
            _appearanceAction = {};
			// set the indicator to true
            isSetTeleportAction = true;          
        }

        void PrivateActionImpl::SetRoutingAction(std::shared_ptr<IRoutingActionWriter> routingAction)
        {
            _routingAction = routingAction;
            _longitudinalAction = {};
            _lateralAction = {};
            _visibilityAction = {};
            _synchronizeAction = {};
            _activateControllerAction = {};
            _controllerAction = {};
            _teleportAction = {};
            _appearanceAction = {};
			// set the indicator to true
            isSetRoutingAction = true;          
        }

        void PrivateActionImpl::SetAppearanceAction(std::shared_ptr<IAppearanceActionWriter> appearanceAction)
        {
            _appearanceAction = appearanceAction;
            _longitudinalAction = {};
            _lateralAction = {};
            _visibilityAction = {};
            _synchronizeAction = {};
            _activateControllerAction = {};
            _controllerAction = {};
            _teleportAction = {};
            _routingAction = {};
			// set the indicator to true
            isSetAppearanceAction = true;          
        }

        std::shared_ptr<void> PrivateActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(PrivateActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IPrivateAction).name())
                return std::dynamic_pointer_cast<IPrivateAction>(shared_from_this());
            else if (classifier == typeid(IPrivateActionWriter).name())
                return std::dynamic_pointer_cast<IPrivateActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> PrivateActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t PrivateActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int PrivateActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double PrivateActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t PrivateActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool PrivateActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime PrivateActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> PrivateActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string PrivateActionImpl::GetModelType() const
        {
            return "PrivateAction";
        }

            // children
        std::shared_ptr<ILongitudinalActionWriter> PrivateActionImpl::GetWriterLongitudinalAction() const
        {
            return std::dynamic_pointer_cast<ILongitudinalActionWriter>(_longitudinalAction);
        }
        std::shared_ptr<ILateralActionWriter> PrivateActionImpl::GetWriterLateralAction() const
        {
            return std::dynamic_pointer_cast<ILateralActionWriter>(_lateralAction);
        }
        std::shared_ptr<IVisibilityActionWriter> PrivateActionImpl::GetWriterVisibilityAction() const
        {
            return std::dynamic_pointer_cast<IVisibilityActionWriter>(_visibilityAction);
        }
        std::shared_ptr<ISynchronizeActionWriter> PrivateActionImpl::GetWriterSynchronizeAction() const
        {
            return std::dynamic_pointer_cast<ISynchronizeActionWriter>(_synchronizeAction);
        }
        std::shared_ptr<IActivateControllerActionWriter> PrivateActionImpl::GetWriterActivateControllerAction() const
        {
            return std::dynamic_pointer_cast<IActivateControllerActionWriter>(_activateControllerAction);
        }
        std::shared_ptr<IControllerActionWriter> PrivateActionImpl::GetWriterControllerAction() const
        {
            return std::dynamic_pointer_cast<IControllerActionWriter>(_controllerAction);
        }
        std::shared_ptr<ITeleportActionWriter> PrivateActionImpl::GetWriterTeleportAction() const
        {
            return std::dynamic_pointer_cast<ITeleportActionWriter>(_teleportAction);
        }
        std::shared_ptr<IRoutingActionWriter> PrivateActionImpl::GetWriterRoutingAction() const
        {
            return std::dynamic_pointer_cast<IRoutingActionWriter>(_routingAction);
        }
        std::shared_ptr<IAppearanceActionWriter> PrivateActionImpl::GetWriterAppearanceAction() const
        {
            return std::dynamic_pointer_cast<IAppearanceActionWriter>(_appearanceAction);
        }

        PrivateActionImpl::PrivateActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void PrivateActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType PrivateActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PrivateActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kLongitudinalAction =  GetWriterLongitudinalAction();
                if (kLongitudinalAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLongitudinalAction));
                }
                const auto kLateralAction =  GetWriterLateralAction();
                if (kLateralAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLateralAction));
                }
                const auto kVisibilityAction =  GetWriterVisibilityAction();
                if (kVisibilityAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kVisibilityAction));
                }
                const auto kSynchronizeAction =  GetWriterSynchronizeAction();
                if (kSynchronizeAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSynchronizeAction));
                }
                const auto kActivateControllerAction =  GetWriterActivateControllerAction();
                if (kActivateControllerAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kActivateControllerAction));
                }
                const auto kControllerAction =  GetWriterControllerAction();
                if (kControllerAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kControllerAction));
                }
                const auto kTeleportAction =  GetWriterTeleportAction();
                if (kTeleportAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTeleportAction));
                }
                const auto kRoutingAction =  GetWriterRoutingAction();
                if (kRoutingAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRoutingAction));
                }
                const auto kAppearanceAction =  GetWriterAppearanceAction();
                if (kAppearanceAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAppearanceAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PrivateActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<PrivateActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kLongitudinalAction =  GetWriterLongitudinalAction();
            if (kLongitudinalAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<LongitudinalActionImpl>(kLongitudinalAction)->Clone();
                auto clonedChildILongitudinalAction = std::dynamic_pointer_cast<ILongitudinalAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLongitudinalAction(std::dynamic_pointer_cast<ILongitudinalActionWriter>(clonedChildILongitudinalAction));
            }
            const auto kLateralAction =  GetWriterLateralAction();
            if (kLateralAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<LateralActionImpl>(kLateralAction)->Clone();
                auto clonedChildILateralAction = std::dynamic_pointer_cast<ILateralAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLateralAction(std::dynamic_pointer_cast<ILateralActionWriter>(clonedChildILateralAction));
            }
            const auto kVisibilityAction =  GetWriterVisibilityAction();
            if (kVisibilityAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<VisibilityActionImpl>(kVisibilityAction)->Clone();
                auto clonedChildIVisibilityAction = std::dynamic_pointer_cast<IVisibilityAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetVisibilityAction(std::dynamic_pointer_cast<IVisibilityActionWriter>(clonedChildIVisibilityAction));
            }
            const auto kSynchronizeAction =  GetWriterSynchronizeAction();
            if (kSynchronizeAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<SynchronizeActionImpl>(kSynchronizeAction)->Clone();
                auto clonedChildISynchronizeAction = std::dynamic_pointer_cast<ISynchronizeAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSynchronizeAction(std::dynamic_pointer_cast<ISynchronizeActionWriter>(clonedChildISynchronizeAction));
            }
            const auto kActivateControllerAction =  GetWriterActivateControllerAction();
            if (kActivateControllerAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<ActivateControllerActionImpl>(kActivateControllerAction)->Clone();
                auto clonedChildIActivateControllerAction = std::dynamic_pointer_cast<IActivateControllerAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetActivateControllerAction(std::dynamic_pointer_cast<IActivateControllerActionWriter>(clonedChildIActivateControllerAction));
            }
            const auto kControllerAction =  GetWriterControllerAction();
            if (kControllerAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<ControllerActionImpl>(kControllerAction)->Clone();
                auto clonedChildIControllerAction = std::dynamic_pointer_cast<IControllerAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetControllerAction(std::dynamic_pointer_cast<IControllerActionWriter>(clonedChildIControllerAction));
            }
            const auto kTeleportAction =  GetWriterTeleportAction();
            if (kTeleportAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<TeleportActionImpl>(kTeleportAction)->Clone();
                auto clonedChildITeleportAction = std::dynamic_pointer_cast<ITeleportAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTeleportAction(std::dynamic_pointer_cast<ITeleportActionWriter>(clonedChildITeleportAction));
            }
            const auto kRoutingAction =  GetWriterRoutingAction();
            if (kRoutingAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<RoutingActionImpl>(kRoutingAction)->Clone();
                auto clonedChildIRoutingAction = std::dynamic_pointer_cast<IRoutingAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRoutingAction(std::dynamic_pointer_cast<IRoutingActionWriter>(clonedChildIRoutingAction));
            }
            const auto kAppearanceAction =  GetWriterAppearanceAction();
            if (kAppearanceAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<AppearanceActionImpl>(kAppearanceAction)->Clone();
                auto clonedChildIAppearanceAction = std::dynamic_pointer_cast<IAppearanceAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAppearanceAction(std::dynamic_pointer_cast<IAppearanceActionWriter>(clonedChildIAppearanceAction));
            }
            return clonedObject;
        }

        std::string PrivateActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PrivateActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LONGITUDINAL_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLongitudinalAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LATERAL_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLateralAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__VISIBILITY_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetVisibilityAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SYNCHRONIZE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSynchronizeAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ACTIVATE_CONTROLLER_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetActivateControllerAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CONTROLLER_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetControllerAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TELEPORT_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTeleportAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ROUTING_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRoutingAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__APPEARANCE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAppearanceAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PrivateActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PrivateActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PrivateActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void PrivateActionImpl::ResetLongitudinalAction()
	   {
	   		isSetLongitudinalAction = false; 
			_longitudinalAction = {};
			
	   }
       bool PrivateActionImpl::IsSetLongitudinalAction() const
	   {
			return isSetLongitudinalAction;
	   }
       void PrivateActionImpl::ResetLateralAction()
	   {
	   		isSetLateralAction = false; 
			_lateralAction = {};
			
	   }
       bool PrivateActionImpl::IsSetLateralAction() const
	   {
			return isSetLateralAction;
	   }
       void PrivateActionImpl::ResetVisibilityAction()
	   {
	   		isSetVisibilityAction = false; 
			_visibilityAction = {};
			
	   }
       bool PrivateActionImpl::IsSetVisibilityAction() const
	   {
			return isSetVisibilityAction;
	   }
       void PrivateActionImpl::ResetSynchronizeAction()
	   {
	   		isSetSynchronizeAction = false; 
			_synchronizeAction = {};
			
	   }
       bool PrivateActionImpl::IsSetSynchronizeAction() const
	   {
			return isSetSynchronizeAction;
	   }
       void PrivateActionImpl::ResetActivateControllerAction()
	   {
	   		isSetActivateControllerAction = false; 
			_activateControllerAction = {};
			
	   }
       bool PrivateActionImpl::IsSetActivateControllerAction() const
	   {
			return isSetActivateControllerAction;
	   }
       void PrivateActionImpl::ResetControllerAction()
	   {
	   		isSetControllerAction = false; 
			_controllerAction = {};
			
	   }
       bool PrivateActionImpl::IsSetControllerAction() const
	   {
			return isSetControllerAction;
	   }
       void PrivateActionImpl::ResetTeleportAction()
	   {
	   		isSetTeleportAction = false; 
			_teleportAction = {};
			
	   }
       bool PrivateActionImpl::IsSetTeleportAction() const
	   {
			return isSetTeleportAction;
	   }
       void PrivateActionImpl::ResetRoutingAction()
	   {
	   		isSetRoutingAction = false; 
			_routingAction = {};
			
	   }
       bool PrivateActionImpl::IsSetRoutingAction() const
	   {
			return isSetRoutingAction;
	   }
       void PrivateActionImpl::ResetAppearanceAction()
	   {
	   		isSetAppearanceAction = false; 
			_appearanceAction = {};
			
	   }
       bool PrivateActionImpl::IsSetAppearanceAction() const
	   {
			return isSetAppearanceAction;
	   }

        IOpenScenarioFlexElement* ProbabilityDistributionSetImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<IProbabilityDistributionSetElement>> ProbabilityDistributionSetImpl::GetElements() const
        {
            std::vector<std::shared_ptr<IProbabilityDistributionSetElement>> temp;
            for(auto&& elm: _elements)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IProbabilityDistributionSetElementWriter>> ProbabilityDistributionSetImpl::GetWriterElements() const
        {
            return _elements;
        }

        int ProbabilityDistributionSetImpl::GetElementsSize() const
        {
            return static_cast<int>(_elements.size());
        }

        std::shared_ptr<IProbabilityDistributionSetElement> ProbabilityDistributionSetImpl::GetElementsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _elements.size() > index)
            {
                return _elements[index];
            }
            return nullptr;
        }


        void ProbabilityDistributionSetImpl::SetElements(std::vector<std::shared_ptr<IProbabilityDistributionSetElementWriter>>& elements)
        {
            _elements = elements;
        }

        std::shared_ptr<void> ProbabilityDistributionSetImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ProbabilityDistributionSetImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IProbabilityDistributionSet).name())
                return std::dynamic_pointer_cast<IProbabilityDistributionSet>(shared_from_this());
            else if (classifier == typeid(IProbabilityDistributionSetWriter).name())
                return std::dynamic_pointer_cast<IProbabilityDistributionSetWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ProbabilityDistributionSetImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ProbabilityDistributionSetImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ProbabilityDistributionSetImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ProbabilityDistributionSetImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ProbabilityDistributionSetImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ProbabilityDistributionSetImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ProbabilityDistributionSetImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ProbabilityDistributionSetImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ProbabilityDistributionSetImpl::GetModelType() const
        {
            return "ProbabilityDistributionSet";
        }

            // children

        ProbabilityDistributionSetImpl::ProbabilityDistributionSetImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ProbabilityDistributionSetImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ProbabilityDistributionSetImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ProbabilityDistributionSetImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto elements =  GetWriterElements();
                if (!elements.empty())
                {
                    for(auto&& item : elements)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ProbabilityDistributionSetImpl::Clone()
        {
            auto clonedObject = std::make_shared<ProbabilityDistributionSetImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kElements =  GetWriterElements();
            if (!kElements.empty())
            {
                std::vector<std::shared_ptr<IProbabilityDistributionSetElementWriter>> clonedList;
                for(auto&& kItem : kElements)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ProbabilityDistributionSetElementImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IProbabilityDistributionSetElementWriter>(clonedChild));
                }
                clonedObject->SetElements(clonedList);
            }
            return clonedObject;
        }

        std::string ProbabilityDistributionSetImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ProbabilityDistributionSetImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ProbabilityDistributionSetImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__ELEMENT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetElements())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ProbabilityDistributionSetImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ProbabilityDistributionSetImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ProbabilityDistributionSetElementImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string ProbabilityDistributionSetElementImpl::GetValue() const
        {
        	  return _value;
        }
        double ProbabilityDistributionSetElementImpl::GetWeight() const
        {
        	  return _weight;
        }


        void ProbabilityDistributionSetElementImpl::SetValue(const std::string value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        void ProbabilityDistributionSetElementImpl::SetWeight(const double weight)
        {
            _weight = weight;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__WEIGHT);
        }

        std::shared_ptr<void> ProbabilityDistributionSetElementImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ProbabilityDistributionSetElementImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IProbabilityDistributionSetElement).name())
                return std::dynamic_pointer_cast<IProbabilityDistributionSetElement>(shared_from_this());
            else if (classifier == typeid(IProbabilityDistributionSetElementWriter).name())
                return std::dynamic_pointer_cast<IProbabilityDistributionSetElementWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ProbabilityDistributionSetElementImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ProbabilityDistributionSetElementImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ProbabilityDistributionSetElementImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ProbabilityDistributionSetElementImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
                {
                    return GetWeight();
                }
                throw KeyNotSupportedException();

        }

        uint16_t ProbabilityDistributionSetElementImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ProbabilityDistributionSetElementImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ProbabilityDistributionSetElementImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ProbabilityDistributionSetElementImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ProbabilityDistributionSetElementImpl::GetModelType() const
        {
            return "ProbabilityDistributionSetElement";
        }

        void ProbabilityDistributionSetElementImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        void ProbabilityDistributionSetElementImpl::WriteParameterToWeight(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__WEIGHT, parameterName, nullTextMarker /*no textmarker*/);
            _weight = {};
        }

        std::string ProbabilityDistributionSetElementImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        std::string ProbabilityDistributionSetElementImpl::GetParameterFromWeight() const
        {
            auto weight = OSC_CONSTANTS::ATTRIBUTE__WEIGHT;
            return GetParameterNameFromAttribute(weight);
        }

        bool ProbabilityDistributionSetElementImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ProbabilityDistributionSetElementImpl::IsWeightParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__WEIGHT);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        ProbabilityDistributionSetElementImpl::ProbabilityDistributionSetElementImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__WEIGHT, SimpleType::DOUBLE);
        }

        void ProbabilityDistributionSetElementImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
            {
                // Simple type
                _weight = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ProbabilityDistributionSetElementImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ProbabilityDistributionSetElementImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ProbabilityDistributionSetElementImpl::Clone()
        {
            auto clonedObject = std::make_shared<ProbabilityDistributionSetElementImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // Simple type
            clonedObject->_weight = GetWeight();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string ProbabilityDistributionSetElementImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ProbabilityDistributionSetElementImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ProbabilityDistributionSetElementImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ProbabilityDistributionSetElementImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ProbabilityDistributionSetElementImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ProbabilityDistributionSetElementImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void ProbabilityDistributionSetElementImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
            {
                // Simple type
                _weight = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* PropertiesImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<IProperty>> PropertiesImpl::GetProperties() const
        {
            std::vector<std::shared_ptr<IProperty>> temp;
            for(auto&& elm: _properties)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IPropertyWriter>> PropertiesImpl::GetWriterProperties() const
        {
            return _properties;
        }

        int PropertiesImpl::GetPropertiesSize() const
        {
            return static_cast<int>(_properties.size());
        }

        std::shared_ptr<IProperty> PropertiesImpl::GetPropertiesAtIndex(unsigned int index) const
        {
            if (index >= 0 && _properties.size() > index)
            {
                return _properties[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<IFile>> PropertiesImpl::GetFiles() const
        {
            std::vector<std::shared_ptr<IFile>> temp;
            for(auto&& elm: _files)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IFileWriter>> PropertiesImpl::GetWriterFiles() const
        {
            return _files;
        }

        int PropertiesImpl::GetFilesSize() const
        {
            return static_cast<int>(_files.size());
        }

        std::shared_ptr<IFile> PropertiesImpl::GetFilesAtIndex(unsigned int index) const
        {
            if (index >= 0 && _files.size() > index)
            {
                return _files[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<ICustomContent>> PropertiesImpl::GetCustomContent() const
        {
            std::vector<std::shared_ptr<ICustomContent>> temp;
            for(auto&& elm: _customContent)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<ICustomContentWriter>> PropertiesImpl::GetWriterCustomContent() const
        {
            return _customContent;
        }

        int PropertiesImpl::GetCustomContentSize() const
        {
            return static_cast<int>(_customContent.size());
        }

        std::shared_ptr<ICustomContent> PropertiesImpl::GetCustomContentAtIndex(unsigned int index) const
        {
            if (index >= 0 && _customContent.size() > index)
            {
                return _customContent[index];
            }
            return nullptr;
        }


        void PropertiesImpl::SetProperties(std::vector<std::shared_ptr<IPropertyWriter>>& properties)
        {
            _properties = properties;
			// set the indicator to true
            isSetProperties = true;          
        }

        void PropertiesImpl::SetFiles(std::vector<std::shared_ptr<IFileWriter>>& files)
        {
            _files = files;
			// set the indicator to true
            isSetFiles = true;          
        }

        void PropertiesImpl::SetCustomContent(std::vector<std::shared_ptr<ICustomContentWriter>>& customContent)
        {
            _customContent = customContent;
			// set the indicator to true
            isSetCustomContent = true;          
        }

        std::shared_ptr<void> PropertiesImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(PropertiesImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IProperties).name())
                return std::dynamic_pointer_cast<IProperties>(shared_from_this());
            else if (classifier == typeid(IPropertiesWriter).name())
                return std::dynamic_pointer_cast<IPropertiesWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> PropertiesImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t PropertiesImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int PropertiesImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double PropertiesImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t PropertiesImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool PropertiesImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime PropertiesImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> PropertiesImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string PropertiesImpl::GetModelType() const
        {
            return "Properties";
        }

            // children

        PropertiesImpl::PropertiesImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void PropertiesImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType PropertiesImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PropertiesImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto properties =  GetWriterProperties();
                if (!properties.empty())
                {
                    for(auto&& item : properties)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto files =  GetWriterFiles();
                if (!files.empty())
                {
                    for(auto&& item : files)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto customContent =  GetWriterCustomContent();
                if (!customContent.empty())
                {
                    for(auto&& item : customContent)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PropertiesImpl::Clone()
        {
            auto clonedObject = std::make_shared<PropertiesImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kProperties =  GetWriterProperties();
            if (!kProperties.empty())
            {
                std::vector<std::shared_ptr<IPropertyWriter>> clonedList;
                for(auto&& kItem : kProperties)
                {
                    auto clonedChild = std::dynamic_pointer_cast<PropertyImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IPropertyWriter>(clonedChild));
                }
                clonedObject->SetProperties(clonedList);
            }
            const auto kFiles =  GetWriterFiles();
            if (!kFiles.empty())
            {
                std::vector<std::shared_ptr<IFileWriter>> clonedList;
                for(auto&& kItem : kFiles)
                {
                    auto clonedChild = std::dynamic_pointer_cast<FileImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IFileWriter>(clonedChild));
                }
                clonedObject->SetFiles(clonedList);
            }
            const auto kCustomContent =  GetWriterCustomContent();
            if (!kCustomContent.empty())
            {
                std::vector<std::shared_ptr<ICustomContentWriter>> clonedList;
                for(auto&& kItem : kCustomContent)
                {
                    auto clonedChild = std::dynamic_pointer_cast<CustomContentImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<ICustomContentWriter>(clonedChild));
                }
                clonedObject->SetCustomContent(clonedList);
            }
            return clonedObject;
        }

        std::string PropertiesImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PropertiesImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PropertiesImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__PROPERTY)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetProperties())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__FILE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetFiles())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__CUSTOM_CONTENT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetCustomContent())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PropertiesImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PropertiesImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void PropertiesImpl::ResetProperties()
	   {
	   		isSetProperties = false; 
			_properties = {};
			
	   }
       bool PropertiesImpl::IsSetProperties() const
	   {
			return isSetProperties;
	   }
       void PropertiesImpl::ResetFiles()
	   {
	   		isSetFiles = false; 
			_files = {};
			
	   }
       bool PropertiesImpl::IsSetFiles() const
	   {
			return isSetFiles;
	   }
       void PropertiesImpl::ResetCustomContent()
	   {
	   		isSetCustomContent = false; 
			_customContent = {};
			
	   }
       bool PropertiesImpl::IsSetCustomContent() const
	   {
			return isSetCustomContent;
	   }

        IOpenScenarioFlexElement* PropertyImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string PropertyImpl::GetName() const
        {
        	  return _name;
        }
        std::string PropertyImpl::GetValue() const
        {
        	  return _value;
        }


        void PropertyImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void PropertyImpl::SetValue(const std::string value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> PropertyImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(PropertyImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IProperty).name())
                return std::dynamic_pointer_cast<IProperty>(shared_from_this());
            else if (classifier == typeid(IPropertyWriter).name())
                return std::dynamic_pointer_cast<IPropertyWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> PropertyImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t PropertyImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int PropertyImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double PropertyImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t PropertyImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool PropertyImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime PropertyImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> PropertyImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string PropertyImpl::GetModelType() const
        {
            return "Property";
        }

        void PropertyImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        void PropertyImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string PropertyImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        std::string PropertyImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool PropertyImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool PropertyImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        PropertyImpl::PropertyImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
        }

        void PropertyImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType PropertyImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PropertyImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PropertyImpl::Clone()
        {
            auto clonedObject = std::make_shared<PropertyImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string PropertyImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PropertyImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PropertyImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PropertyImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PropertyImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void PropertyImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* RangeImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double RangeImpl::GetLowerLimit() const
        {
        	  return _lowerLimit;
        }
        double RangeImpl::GetUpperLimit() const
        {
        	  return _upperLimit;
        }


        void RangeImpl::SetLowerLimit(const double lowerLimit)
        {
            _lowerLimit = lowerLimit;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LOWER_LIMIT);
        }

        void RangeImpl::SetUpperLimit(const double upperLimit)
        {
            _upperLimit = upperLimit;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__UPPER_LIMIT);
        }

        std::shared_ptr<void> RangeImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RangeImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRange).name())
                return std::dynamic_pointer_cast<IRange>(shared_from_this());
            else if (classifier == typeid(IRangeWriter).name())
                return std::dynamic_pointer_cast<IRangeWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RangeImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RangeImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RangeImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double RangeImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__LOWER_LIMIT)
                {
                    return GetLowerLimit();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__UPPER_LIMIT)
                {
                    return GetUpperLimit();
                }
                throw KeyNotSupportedException();

        }

        uint16_t RangeImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RangeImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime RangeImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RangeImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RangeImpl::GetModelType() const
        {
            return "Range";
        }

        void RangeImpl::WriteParameterToLowerLimit(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__LOWER_LIMIT, parameterName, nullTextMarker /*no textmarker*/);
            _lowerLimit = {};
        }

        void RangeImpl::WriteParameterToUpperLimit(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__UPPER_LIMIT, parameterName, nullTextMarker /*no textmarker*/);
            _upperLimit = {};
        }

        std::string RangeImpl::GetParameterFromLowerLimit() const
        {
            auto lowerLimit = OSC_CONSTANTS::ATTRIBUTE__LOWER_LIMIT;
            return GetParameterNameFromAttribute(lowerLimit);
        }

        std::string RangeImpl::GetParameterFromUpperLimit() const
        {
            auto upperLimit = OSC_CONSTANTS::ATTRIBUTE__UPPER_LIMIT;
            return GetParameterNameFromAttribute(upperLimit);
        }

        bool RangeImpl::IsLowerLimitParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__LOWER_LIMIT);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RangeImpl::IsUpperLimitParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__UPPER_LIMIT);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        RangeImpl::RangeImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LOWER_LIMIT, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__UPPER_LIMIT, SimpleType::DOUBLE);
        }

        void RangeImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LOWER_LIMIT)
            {
                // Simple type
                _lowerLimit = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__UPPER_LIMIT)
            {
                // Simple type
                _upperLimit = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RangeImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RangeImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RangeImpl::Clone()
        {
            auto clonedObject = std::make_shared<RangeImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_lowerLimit = GetLowerLimit();
            // Simple type
            clonedObject->_upperLimit = GetUpperLimit();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string RangeImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RangeImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RangeImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RangeImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RangeImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void RangeImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LOWER_LIMIT)
            {
                // Simple type
                _lowerLimit = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__UPPER_LIMIT)
            {
                // Simple type
                _upperLimit = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* ReachPositionConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double ReachPositionConditionImpl::GetTolerance() const
        {
        	  return _tolerance;
        }
        std::shared_ptr<IPosition> ReachPositionConditionImpl::GetPosition() const
        {
        	  return _position;
        }


        void ReachPositionConditionImpl::SetTolerance(const double tolerance)
        {
            _tolerance = tolerance;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TOLERANCE);
        }

        void ReachPositionConditionImpl::SetPosition(std::shared_ptr<IPositionWriter> position)
        {
            _position = position;
        }

        std::shared_ptr<void> ReachPositionConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ReachPositionConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IReachPositionCondition).name())
                return std::dynamic_pointer_cast<IReachPositionCondition>(shared_from_this());
            else if (classifier == typeid(IReachPositionConditionWriter).name())
                return std::dynamic_pointer_cast<IReachPositionConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ReachPositionConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ReachPositionConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ReachPositionConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ReachPositionConditionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__TOLERANCE)
                {
                    return GetTolerance();
                }
                throw KeyNotSupportedException();

        }

        uint16_t ReachPositionConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ReachPositionConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ReachPositionConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ReachPositionConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ReachPositionConditionImpl::GetModelType() const
        {
            return "ReachPositionCondition";
        }

        void ReachPositionConditionImpl::WriteParameterToTolerance(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TOLERANCE, parameterName, nullTextMarker /*no textmarker*/);
            _tolerance = {};
        }

        std::string ReachPositionConditionImpl::GetParameterFromTolerance() const
        {
            auto tolerance = OSC_CONSTANTS::ATTRIBUTE__TOLERANCE;
            return GetParameterNameFromAttribute(tolerance);
        }

        bool ReachPositionConditionImpl::IsToleranceParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TOLERANCE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IPositionWriter> ReachPositionConditionImpl::GetWriterPosition() const
        {
            return std::dynamic_pointer_cast<IPositionWriter>(_position);
        }

        ReachPositionConditionImpl::ReachPositionConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TOLERANCE, SimpleType::DOUBLE);
        }

        void ReachPositionConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TOLERANCE)
            {
                // Simple type
                _tolerance = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ReachPositionConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ReachPositionConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ReachPositionConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ReachPositionConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_tolerance = GetTolerance();
            // clone indicators
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            return clonedObject;
        }

        std::string ReachPositionConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ReachPositionConditionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ReachPositionConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ReachPositionConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ReachPositionConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ReachPositionConditionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TOLERANCE)
            {
                // Simple type
                _tolerance = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* RelativeClearanceConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double RelativeClearanceConditionImpl::GetDistanceBackward() const
        {
        	  return _distanceBackward;
        }
        double RelativeClearanceConditionImpl::GetDistanceForward() const
        {
        	  return _distanceForward;
        }
        bool RelativeClearanceConditionImpl::GetFreeSpace() const
        {
        	  return _freeSpace;
        }
        bool RelativeClearanceConditionImpl::GetOppositeLanes() const
        {
        	  return _oppositeLanes;
        }
        std::vector<std::shared_ptr<IRelativeLaneRange>> RelativeClearanceConditionImpl::GetRelativeLaneRange() const
        {
            std::vector<std::shared_ptr<IRelativeLaneRange>> temp;
            for(auto&& elm: _relativeLaneRange)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IRelativeLaneRangeWriter>> RelativeClearanceConditionImpl::GetWriterRelativeLaneRange() const
        {
            return _relativeLaneRange;
        }

        int RelativeClearanceConditionImpl::GetRelativeLaneRangeSize() const
        {
            return static_cast<int>(_relativeLaneRange.size());
        }

        std::shared_ptr<IRelativeLaneRange> RelativeClearanceConditionImpl::GetRelativeLaneRangeAtIndex(unsigned int index) const
        {
            if (index >= 0 && _relativeLaneRange.size() > index)
            {
                return _relativeLaneRange[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<IEntityRef>> RelativeClearanceConditionImpl::GetEntityRef() const
        {
            std::vector<std::shared_ptr<IEntityRef>> temp;
            for(auto&& elm: _entityRef)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IEntityRefWriter>> RelativeClearanceConditionImpl::GetWriterEntityRef() const
        {
            return _entityRef;
        }

        int RelativeClearanceConditionImpl::GetEntityRefSize() const
        {
            return static_cast<int>(_entityRef.size());
        }

        std::shared_ptr<IEntityRef> RelativeClearanceConditionImpl::GetEntityRefAtIndex(unsigned int index) const
        {
            if (index >= 0 && _entityRef.size() > index)
            {
                return _entityRef[index];
            }
            return nullptr;
        }


        void RelativeClearanceConditionImpl::SetDistanceBackward(const double distanceBackward)
        {
            _distanceBackward = distanceBackward;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DISTANCE_BACKWARD);
			// set the indicator to true
            isSetDistanceBackward = true;          
        }

        void RelativeClearanceConditionImpl::SetDistanceForward(const double distanceForward)
        {
            _distanceForward = distanceForward;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DISTANCE_FORWARD);
			// set the indicator to true
            isSetDistanceForward = true;          
        }

        void RelativeClearanceConditionImpl::SetFreeSpace(const bool freeSpace)
        {
            _freeSpace = freeSpace;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FREE_SPACE);
        }

        void RelativeClearanceConditionImpl::SetOppositeLanes(const bool oppositeLanes)
        {
            _oppositeLanes = oppositeLanes;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__OPPOSITE_LANES);
        }

        void RelativeClearanceConditionImpl::SetRelativeLaneRange(std::vector<std::shared_ptr<IRelativeLaneRangeWriter>>& relativeLaneRange)
        {
            _relativeLaneRange = relativeLaneRange;
			// set the indicator to true
            isSetRelativeLaneRange = true;          
        }

        void RelativeClearanceConditionImpl::SetEntityRef(std::vector<std::shared_ptr<IEntityRefWriter>>& entityRef)
        {
            _entityRef = entityRef;
			// set the indicator to true
            isSetEntityRef = true;          
        }

        std::shared_ptr<void> RelativeClearanceConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RelativeClearanceConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRelativeClearanceCondition).name())
                return std::dynamic_pointer_cast<IRelativeClearanceCondition>(shared_from_this());
            else if (classifier == typeid(IRelativeClearanceConditionWriter).name())
                return std::dynamic_pointer_cast<IRelativeClearanceConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RelativeClearanceConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RelativeClearanceConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RelativeClearanceConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double RelativeClearanceConditionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__DISTANCE_BACKWARD)
                {
                    return GetDistanceBackward();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__DISTANCE_FORWARD)
                {
                    return GetDistanceForward();
                }
                throw KeyNotSupportedException();

        }

        uint16_t RelativeClearanceConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RelativeClearanceConditionImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__FREE_SPACE)
                {
                    return GetFreeSpace();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__OPPOSITE_LANES)
                {
                    return GetOppositeLanes();
                }
                throw KeyNotSupportedException();

        }

        DateTime RelativeClearanceConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RelativeClearanceConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RelativeClearanceConditionImpl::GetModelType() const
        {
            return "RelativeClearanceCondition";
        }

        void RelativeClearanceConditionImpl::WriteParameterToDistanceBackward(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DISTANCE_BACKWARD, parameterName, nullTextMarker /*no textmarker*/);
            _distanceBackward = {};
        }

        void RelativeClearanceConditionImpl::WriteParameterToDistanceForward(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DISTANCE_FORWARD, parameterName, nullTextMarker /*no textmarker*/);
            _distanceForward = {};
        }

        void RelativeClearanceConditionImpl::WriteParameterToFreeSpace(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FREE_SPACE, parameterName, nullTextMarker /*no textmarker*/);
            _freeSpace = {};
        }

        void RelativeClearanceConditionImpl::WriteParameterToOppositeLanes(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__OPPOSITE_LANES, parameterName, nullTextMarker /*no textmarker*/);
            _oppositeLanes = {};
        }

        std::string RelativeClearanceConditionImpl::GetParameterFromDistanceBackward() const
        {
            auto distanceBackward = OSC_CONSTANTS::ATTRIBUTE__DISTANCE_BACKWARD;
            return GetParameterNameFromAttribute(distanceBackward);
        }

        std::string RelativeClearanceConditionImpl::GetParameterFromDistanceForward() const
        {
            auto distanceForward = OSC_CONSTANTS::ATTRIBUTE__DISTANCE_FORWARD;
            return GetParameterNameFromAttribute(distanceForward);
        }

        std::string RelativeClearanceConditionImpl::GetParameterFromFreeSpace() const
        {
            auto freeSpace = OSC_CONSTANTS::ATTRIBUTE__FREE_SPACE;
            return GetParameterNameFromAttribute(freeSpace);
        }

        std::string RelativeClearanceConditionImpl::GetParameterFromOppositeLanes() const
        {
            auto oppositeLanes = OSC_CONSTANTS::ATTRIBUTE__OPPOSITE_LANES;
            return GetParameterNameFromAttribute(oppositeLanes);
        }

        bool RelativeClearanceConditionImpl::IsDistanceBackwardParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DISTANCE_BACKWARD);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeClearanceConditionImpl::IsDistanceForwardParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DISTANCE_FORWARD);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeClearanceConditionImpl::IsFreeSpaceParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__FREE_SPACE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeClearanceConditionImpl::IsOppositeLanesParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__OPPOSITE_LANES);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        RelativeClearanceConditionImpl::RelativeClearanceConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DISTANCE_BACKWARD, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DISTANCE_FORWARD, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FREE_SPACE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__OPPOSITE_LANES, SimpleType::BOOLEAN);
        }

        void RelativeClearanceConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DISTANCE_BACKWARD)
            {
                // Simple type
                _distanceBackward = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DISTANCE_FORWARD)
            {
                // Simple type
                _distanceForward = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREE_SPACE)
            {
                // Simple type
                _freeSpace = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__OPPOSITE_LANES)
            {
                // Simple type
                _oppositeLanes = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeClearanceConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeClearanceConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto relativeLaneRange =  GetWriterRelativeLaneRange();
                if (!relativeLaneRange.empty())
                {
                    for(auto&& item : relativeLaneRange)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto entityRef =  GetWriterEntityRef();
                if (!entityRef.empty())
                {
                    for(auto&& item : entityRef)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeClearanceConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeClearanceConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_distanceBackward = GetDistanceBackward();
            // Simple type
            clonedObject->_distanceForward = GetDistanceForward();
            // Simple type
            clonedObject->_freeSpace = GetFreeSpace();
            // Simple type
            clonedObject->_oppositeLanes = GetOppositeLanes();
            // clone indicators
            	clonedObject->isSetDistanceBackward = isSetDistanceBackward;
            	clonedObject->isSetDistanceForward = isSetDistanceForward;
            // clone children
            const auto kRelativeLaneRange =  GetWriterRelativeLaneRange();
            if (!kRelativeLaneRange.empty())
            {
                std::vector<std::shared_ptr<IRelativeLaneRangeWriter>> clonedList;
                for(auto&& kItem : kRelativeLaneRange)
                {
                    auto clonedChild = std::dynamic_pointer_cast<RelativeLaneRangeImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IRelativeLaneRangeWriter>(clonedChild));
                }
                clonedObject->SetRelativeLaneRange(clonedList);
            }
            const auto kEntityRef =  GetWriterEntityRef();
            if (!kEntityRef.empty())
            {
                std::vector<std::shared_ptr<IEntityRefWriter>> clonedList;
                for(auto&& kItem : kEntityRef)
                {
                    auto clonedChild = std::dynamic_pointer_cast<EntityRefImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IEntityRefWriter>(clonedChild));
                }
                clonedObject->SetEntityRef(clonedList);
            }
            return clonedObject;
        }

        std::string RelativeClearanceConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeClearanceConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeClearanceConditionImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_LANE_RANGE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetRelativeLaneRange())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_REF)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetEntityRef())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeClearanceConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RelativeClearanceConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void RelativeClearanceConditionImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREE_SPACE)
            {
                // Simple type
                _freeSpace = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__OPPOSITE_LANES)
            {
                // Simple type
                _oppositeLanes = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void RelativeClearanceConditionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DISTANCE_BACKWARD)
            {
                // Simple type
                _distanceBackward = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DISTANCE_FORWARD)
            {
                // Simple type
                _distanceForward = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void RelativeClearanceConditionImpl::ResetDistanceBackward()
	   {
	   		isSetDistanceBackward = false; 
			_distanceBackward = {0};
			
	   }
       bool RelativeClearanceConditionImpl::IsSetDistanceBackward() const
	   {
			return isSetDistanceBackward;
	   }
       void RelativeClearanceConditionImpl::ResetDistanceForward()
	   {
	   		isSetDistanceForward = false; 
			_distanceForward = {0};
			
	   }
       bool RelativeClearanceConditionImpl::IsSetDistanceForward() const
	   {
			return isSetDistanceForward;
	   }
       void RelativeClearanceConditionImpl::ResetRelativeLaneRange()
	   {
	   		isSetRelativeLaneRange = false; 
			_relativeLaneRange = {};
			
	   }
       bool RelativeClearanceConditionImpl::IsSetRelativeLaneRange() const
	   {
			return isSetRelativeLaneRange;
	   }
       void RelativeClearanceConditionImpl::ResetEntityRef()
	   {
	   		isSetEntityRef = false; 
			_entityRef = {};
			
	   }
       bool RelativeClearanceConditionImpl::IsSetEntityRef() const
	   {
			return isSetEntityRef;
	   }

        IOpenScenarioFlexElement* RelativeDistanceConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        CoordinateSystem RelativeDistanceConditionImpl::GetCoordinateSystem() const
        {
        	  return _coordinateSystem;
        }
        std::shared_ptr<INamedReference<IEntity>> RelativeDistanceConditionImpl::GetEntityRef() const
        {
        	 return _entityRef;
        }
        bool RelativeDistanceConditionImpl::GetFreespace() const
        {
        	  return _freespace;
        }
        RelativeDistanceType RelativeDistanceConditionImpl::GetRelativeDistanceType() const
        {
        	  return _relativeDistanceType;
        }
        RoutingAlgorithm RelativeDistanceConditionImpl::GetRoutingAlgorithm() const
        {
        	  return _routingAlgorithm;
        }
        Rule RelativeDistanceConditionImpl::GetRule() const
        {
        	  return _rule;
        }
        double RelativeDistanceConditionImpl::GetValue() const
        {
        	  return _value;
        }


        void RelativeDistanceConditionImpl::SetCoordinateSystem(const CoordinateSystem coordinateSystem)
        {
            _coordinateSystem = coordinateSystem;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM);
			// set the indicator to true
            isSetCoordinateSystem = true;          
        }

        void RelativeDistanceConditionImpl::SetEntityRef(std::shared_ptr<INamedReference<IEntity>> entityRef)
        {
            _entityRef = entityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
        }

        void RelativeDistanceConditionImpl::SetFreespace(const bool freespace)
        {
            _freespace = freespace;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FREESPACE);
        }

        void RelativeDistanceConditionImpl::SetRelativeDistanceType(const RelativeDistanceType relativeDistanceType)
        {
            _relativeDistanceType = relativeDistanceType;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE);
        }

        void RelativeDistanceConditionImpl::SetRoutingAlgorithm(const RoutingAlgorithm routingAlgorithm)
        {
            _routingAlgorithm = routingAlgorithm;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM);
			// set the indicator to true
            isSetRoutingAlgorithm = true;          
        }

        void RelativeDistanceConditionImpl::SetRule(const Rule rule)
        {
            _rule = rule;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE);
        }

        void RelativeDistanceConditionImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> RelativeDistanceConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RelativeDistanceConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRelativeDistanceCondition).name())
                return std::dynamic_pointer_cast<IRelativeDistanceCondition>(shared_from_this());
            else if (classifier == typeid(IRelativeDistanceConditionWriter).name())
                return std::dynamic_pointer_cast<IRelativeDistanceConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RelativeDistanceConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RelativeDistanceConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RelativeDistanceConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double RelativeDistanceConditionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t RelativeDistanceConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RelativeDistanceConditionImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
                {
                    return GetFreespace();
                }
                throw KeyNotSupportedException();

        }

        DateTime RelativeDistanceConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RelativeDistanceConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RelativeDistanceConditionImpl::GetModelType() const
        {
            return "RelativeDistanceCondition";
        }

        void RelativeDistanceConditionImpl::WriteParameterToCoordinateSystem(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM, parameterName, nullTextMarker /*no textmarker*/);
            _coordinateSystem = {};
        }

        void RelativeDistanceConditionImpl::WriteParameterToEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _entityRef = {};
        }

        void RelativeDistanceConditionImpl::WriteParameterToFreespace(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FREESPACE, parameterName, nullTextMarker /*no textmarker*/);
            _freespace = {};
        }

        void RelativeDistanceConditionImpl::WriteParameterToRelativeDistanceType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _relativeDistanceType = {};
        }

        void RelativeDistanceConditionImpl::WriteParameterToRoutingAlgorithm(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM, parameterName, nullTextMarker /*no textmarker*/);
            _routingAlgorithm = {};
        }

        void RelativeDistanceConditionImpl::WriteParameterToRule(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE, parameterName, nullTextMarker /*no textmarker*/);
            _rule = {};
        }

        void RelativeDistanceConditionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string RelativeDistanceConditionImpl::GetParameterFromCoordinateSystem() const
        {
            auto coordinateSystem = OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM;
            return GetParameterNameFromAttribute(coordinateSystem);
        }

        std::string RelativeDistanceConditionImpl::GetParameterFromEntityRef() const
        {
            auto entityRef = OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF;
            return GetParameterNameFromAttribute(entityRef);
        }

        std::string RelativeDistanceConditionImpl::GetParameterFromFreespace() const
        {
            auto freespace = OSC_CONSTANTS::ATTRIBUTE__FREESPACE;
            return GetParameterNameFromAttribute(freespace);
        }

        std::string RelativeDistanceConditionImpl::GetParameterFromRelativeDistanceType() const
        {
            auto relativeDistanceType = OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE;
            return GetParameterNameFromAttribute(relativeDistanceType);
        }

        std::string RelativeDistanceConditionImpl::GetParameterFromRoutingAlgorithm() const
        {
            auto routingAlgorithm = OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM;
            return GetParameterNameFromAttribute(routingAlgorithm);
        }

        std::string RelativeDistanceConditionImpl::GetParameterFromRule() const
        {
            auto rule = OSC_CONSTANTS::ATTRIBUTE__RULE;
            return GetParameterNameFromAttribute(rule);
        }

        std::string RelativeDistanceConditionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool RelativeDistanceConditionImpl::IsCoordinateSystemParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeDistanceConditionImpl::IsEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeDistanceConditionImpl::IsFreespaceParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__FREESPACE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeDistanceConditionImpl::IsRelativeDistanceTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeDistanceConditionImpl::IsRoutingAlgorithmParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeDistanceConditionImpl::IsRuleParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RULE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeDistanceConditionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        RelativeDistanceConditionImpl::RelativeDistanceConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FREESPACE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void RelativeDistanceConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM)
            {
                // Enumeration Type
                const auto kResult = CoordinateSystem::GetFromLiteral(parameterLiteralValue);
                if (kResult != CoordinateSystem::UNKNOWN)
                {
                    _coordinateSystem = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
            {
                // Simple type
                _freespace = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE)
            {
                // Enumeration Type
                const auto kResult = RelativeDistanceType::GetFromLiteral(parameterLiteralValue);
                if (kResult != RelativeDistanceType::UNKNOWN)
                {
                    _relativeDistanceType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM)
            {
                // Enumeration Type
                const auto kResult = RoutingAlgorithm::GetFromLiteral(parameterLiteralValue);
                if (kResult != RoutingAlgorithm::UNKNOWN)
                {
                    _routingAlgorithm = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeDistanceConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeDistanceConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeDistanceConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeDistanceConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kCoordinateSystem = GetCoordinateSystem();
            if ( kCoordinateSystem.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_coordinateSystem = CoordinateSystem::GetFromLiteral(kCoordinateSystem.GetLiteral());
            }
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Simple type
            clonedObject->_freespace = GetFreespace();
            // Enumeration Type
            const auto kRelativeDistanceType = GetRelativeDistanceType();
            if ( kRelativeDistanceType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_relativeDistanceType = RelativeDistanceType::GetFromLiteral(kRelativeDistanceType.GetLiteral());
            }
            // Enumeration Type
            const auto kRoutingAlgorithm = GetRoutingAlgorithm();
            if ( kRoutingAlgorithm.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_routingAlgorithm = RoutingAlgorithm::GetFromLiteral(kRoutingAlgorithm.GetLiteral());
            }
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            	clonedObject->isSetCoordinateSystem = isSetCoordinateSystem;
            	clonedObject->isSetRoutingAlgorithm = isSetRoutingAlgorithm;
            // clone children
            return clonedObject;
        }

        std::string RelativeDistanceConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeDistanceConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeDistanceConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeDistanceConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string RelativeDistanceConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM)
            {
                auto coordinateSystem = GetCoordinateSystem();
                return coordinateSystem.GetLiteral() != "UNKNOWN" ? coordinateSystem.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE)
            {
                auto relativeDistanceType = GetRelativeDistanceType();
                return relativeDistanceType.GetLiteral() != "UNKNOWN" ? relativeDistanceType.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM)
            {
                auto routingAlgorithm = GetRoutingAlgorithm();
                return routingAlgorithm.GetLiteral() != "UNKNOWN" ? routingAlgorithm.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void RelativeDistanceConditionImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
            {
                // Simple type
                _freespace = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void RelativeDistanceConditionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void RelativeDistanceConditionImpl::ResetCoordinateSystem()
	   {
	   		isSetCoordinateSystem = false; 
			_coordinateSystem = {CoordinateSystem::CoordinateSystemEnum::ENTITY};
			
	   }
       bool RelativeDistanceConditionImpl::IsSetCoordinateSystem() const
	   {
			return isSetCoordinateSystem;
	   }
       void RelativeDistanceConditionImpl::ResetRoutingAlgorithm()
	   {
	   		isSetRoutingAlgorithm = false; 
			_routingAlgorithm = {RoutingAlgorithm::RoutingAlgorithmEnum::UNDEFINED};
			
	   }
       bool RelativeDistanceConditionImpl::IsSetRoutingAlgorithm() const
	   {
			return isSetRoutingAlgorithm;
	   }

        IOpenScenarioFlexElement* RelativeLanePositionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        int RelativeLanePositionImpl::GetDLane() const
        {
        	  return _dLane;
        }
        double RelativeLanePositionImpl::GetDs() const
        {
        	  return _ds;
        }
        double RelativeLanePositionImpl::GetDsLane() const
        {
        	  return _dsLane;
        }
        std::shared_ptr<INamedReference<IEntity>> RelativeLanePositionImpl::GetEntityRef() const
        {
        	 return _entityRef;
        }
        double RelativeLanePositionImpl::GetOffset() const
        {
        	  return _offset;
        }
        std::shared_ptr<IOrientation> RelativeLanePositionImpl::GetOrientation() const
        {
        	  return _orientation;
        }


        void RelativeLanePositionImpl::SetDLane(const int dLane)
        {
            _dLane = dLane;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__D_LANE);
        }

        void RelativeLanePositionImpl::SetDs(const double ds)
        {
            _ds = ds;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DS);
			// set the indicator to true
            isSetDs = true;          
        }

        void RelativeLanePositionImpl::SetDsLane(const double dsLane)
        {
            _dsLane = dsLane;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DS_LANE);
			// set the indicator to true
            isSetDsLane = true;          
        }

        void RelativeLanePositionImpl::SetEntityRef(std::shared_ptr<INamedReference<IEntity>> entityRef)
        {
            _entityRef = entityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
        }

        void RelativeLanePositionImpl::SetOffset(const double offset)
        {
            _offset = offset;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__OFFSET);
			// set the indicator to true
            isSetOffset = true;          
        }

        void RelativeLanePositionImpl::SetOrientation(std::shared_ptr<IOrientationWriter> orientation)
        {
            _orientation = orientation;
			// set the indicator to true
            isSetOrientation = true;          
        }

        std::shared_ptr<void> RelativeLanePositionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RelativeLanePositionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRelativeLanePosition).name())
                return std::dynamic_pointer_cast<IRelativeLanePosition>(shared_from_this());
            else if (classifier == typeid(IRelativeLanePositionWriter).name())
                return std::dynamic_pointer_cast<IRelativeLanePositionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RelativeLanePositionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RelativeLanePositionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RelativeLanePositionImpl::GetIntProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__D_LANE)
                {
                    return GetDLane();
                }
                throw KeyNotSupportedException();

        }

        double RelativeLanePositionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__DS)
                {
                    return GetDs();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__DS_LANE)
                {
                    return GetDsLane();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__OFFSET)
                {
                    return GetOffset();
                }
                throw KeyNotSupportedException();

        }

        uint16_t RelativeLanePositionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RelativeLanePositionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime RelativeLanePositionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RelativeLanePositionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RelativeLanePositionImpl::GetModelType() const
        {
            return "RelativeLanePosition";
        }

        void RelativeLanePositionImpl::WriteParameterToDLane(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__D_LANE, parameterName, nullTextMarker /*no textmarker*/);
            _dLane = {};
        }

        void RelativeLanePositionImpl::WriteParameterToDs(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DS, parameterName, nullTextMarker /*no textmarker*/);
            _ds = {};
        }

        void RelativeLanePositionImpl::WriteParameterToDsLane(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DS_LANE, parameterName, nullTextMarker /*no textmarker*/);
            _dsLane = {};
        }

        void RelativeLanePositionImpl::WriteParameterToEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _entityRef = {};
        }

        void RelativeLanePositionImpl::WriteParameterToOffset(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__OFFSET, parameterName, nullTextMarker /*no textmarker*/);
            _offset = {};
        }

        std::string RelativeLanePositionImpl::GetParameterFromDLane() const
        {
            auto dLane = OSC_CONSTANTS::ATTRIBUTE__D_LANE;
            return GetParameterNameFromAttribute(dLane);
        }

        std::string RelativeLanePositionImpl::GetParameterFromDs() const
        {
            auto ds = OSC_CONSTANTS::ATTRIBUTE__DS;
            return GetParameterNameFromAttribute(ds);
        }

        std::string RelativeLanePositionImpl::GetParameterFromDsLane() const
        {
            auto dsLane = OSC_CONSTANTS::ATTRIBUTE__DS_LANE;
            return GetParameterNameFromAttribute(dsLane);
        }

        std::string RelativeLanePositionImpl::GetParameterFromEntityRef() const
        {
            auto entityRef = OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF;
            return GetParameterNameFromAttribute(entityRef);
        }

        std::string RelativeLanePositionImpl::GetParameterFromOffset() const
        {
            auto offset = OSC_CONSTANTS::ATTRIBUTE__OFFSET;
            return GetParameterNameFromAttribute(offset);
        }

        bool RelativeLanePositionImpl::IsDLaneParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__D_LANE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeLanePositionImpl::IsDsParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DS);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeLanePositionImpl::IsDsLaneParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DS_LANE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeLanePositionImpl::IsEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeLanePositionImpl::IsOffsetParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__OFFSET);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IOrientationWriter> RelativeLanePositionImpl::GetWriterOrientation() const
        {
            return std::dynamic_pointer_cast<IOrientationWriter>(_orientation);
        }

        RelativeLanePositionImpl::RelativeLanePositionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__D_LANE, SimpleType::INT);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DS_LANE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__OFFSET, SimpleType::DOUBLE);
        }

        void RelativeLanePositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__D_LANE)
            {
                // Simple type
                _dLane = ParserHelper::ParseInt(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DS)
            {
                // Simple type
                _ds = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DS_LANE)
            {
                // Simple type
                _dsLane = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__OFFSET)
            {
                // Simple type
                _offset = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeLanePositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeLanePositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kOrientation =  GetWriterOrientation();
                if (kOrientation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOrientation));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeLanePositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeLanePositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_dLane = GetDLane();
            // Simple type
            clonedObject->_ds = GetDs();
            // Simple type
            clonedObject->_dsLane = GetDsLane();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Simple type
            clonedObject->_offset = GetOffset();
            // clone indicators
            	clonedObject->isSetDs = isSetDs;
            	clonedObject->isSetDsLane = isSetDsLane;
            	clonedObject->isSetOffset = isSetOffset;
            // clone children
            const auto kOrientation =  GetWriterOrientation();
            if (kOrientation)
            {
                auto clonedChild = std::dynamic_pointer_cast<OrientationImpl>(kOrientation)->Clone();
                auto clonedChildIOrientation = std::dynamic_pointer_cast<IOrientation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOrientation(std::dynamic_pointer_cast<IOrientationWriter>(clonedChildIOrientation));
            }
            return clonedObject;
        }

        std::string RelativeLanePositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeLanePositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ORIENTATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOrientation());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeLanePositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeLanePositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string RelativeLanePositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void RelativeLanePositionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DS)
            {
                // Simple type
                _ds = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DS_LANE)
            {
                // Simple type
                _dsLane = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__OFFSET)
            {
                // Simple type
                _offset = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void RelativeLanePositionImpl::ResolveIntExpression(std::string& attributeKey, int& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__D_LANE)
            {
                // Simple type
                _dLane = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void RelativeLanePositionImpl::ResetDs()
	   {
	   		isSetDs = false; 
			_ds = {};
			
	   }
       bool RelativeLanePositionImpl::IsSetDs() const
	   {
			return isSetDs;
	   }
       void RelativeLanePositionImpl::ResetDsLane()
	   {
	   		isSetDsLane = false; 
			_dsLane = {};
			
	   }
       bool RelativeLanePositionImpl::IsSetDsLane() const
	   {
			return isSetDsLane;
	   }
       void RelativeLanePositionImpl::ResetOffset()
	   {
	   		isSetOffset = false; 
			_offset = {0};
			
	   }
       bool RelativeLanePositionImpl::IsSetOffset() const
	   {
			return isSetOffset;
	   }
       void RelativeLanePositionImpl::ResetOrientation()
	   {
	   		isSetOrientation = false; 
			_orientation = {};
			
	   }
       bool RelativeLanePositionImpl::IsSetOrientation() const
	   {
			return isSetOrientation;
	   }

        IOpenScenarioFlexElement* RelativeLaneRangeImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        int RelativeLaneRangeImpl::GetFrom() const
        {
        	  return _from;
        }
        int RelativeLaneRangeImpl::GetTo() const
        {
        	  return _to;
        }


        void RelativeLaneRangeImpl::SetFrom(const int from)
        {
            _from = from;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FROM);
			// set the indicator to true
            isSetFrom = true;          
        }

        void RelativeLaneRangeImpl::SetTo(const int to)
        {
            _to = to;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TO);
			// set the indicator to true
            isSetTo = true;          
        }

        std::shared_ptr<void> RelativeLaneRangeImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RelativeLaneRangeImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRelativeLaneRange).name())
                return std::dynamic_pointer_cast<IRelativeLaneRange>(shared_from_this());
            else if (classifier == typeid(IRelativeLaneRangeWriter).name())
                return std::dynamic_pointer_cast<IRelativeLaneRangeWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RelativeLaneRangeImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RelativeLaneRangeImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RelativeLaneRangeImpl::GetIntProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__FROM)
                {
                    return GetFrom();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__TO)
                {
                    return GetTo();
                }
                throw KeyNotSupportedException();

        }

        double RelativeLaneRangeImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t RelativeLaneRangeImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RelativeLaneRangeImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime RelativeLaneRangeImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RelativeLaneRangeImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RelativeLaneRangeImpl::GetModelType() const
        {
            return "RelativeLaneRange";
        }

        void RelativeLaneRangeImpl::WriteParameterToFrom(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FROM, parameterName, nullTextMarker /*no textmarker*/);
            _from = {};
        }

        void RelativeLaneRangeImpl::WriteParameterToTo(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TO, parameterName, nullTextMarker /*no textmarker*/);
            _to = {};
        }

        std::string RelativeLaneRangeImpl::GetParameterFromFrom() const
        {
            auto from = OSC_CONSTANTS::ATTRIBUTE__FROM;
            return GetParameterNameFromAttribute(from);
        }

        std::string RelativeLaneRangeImpl::GetParameterFromTo() const
        {
            auto to = OSC_CONSTANTS::ATTRIBUTE__TO;
            return GetParameterNameFromAttribute(to);
        }

        bool RelativeLaneRangeImpl::IsFromParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__FROM);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeLaneRangeImpl::IsToParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TO);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        RelativeLaneRangeImpl::RelativeLaneRangeImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FROM, SimpleType::INT);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TO, SimpleType::INT);
        }

        void RelativeLaneRangeImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FROM)
            {
                // Simple type
                _from = ParserHelper::ParseInt(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TO)
            {
                // Simple type
                _to = ParserHelper::ParseInt(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeLaneRangeImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeLaneRangeImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeLaneRangeImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeLaneRangeImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_from = GetFrom();
            // Simple type
            clonedObject->_to = GetTo();
            // clone indicators
            	clonedObject->isSetFrom = isSetFrom;
            	clonedObject->isSetTo = isSetTo;
            // clone children
            return clonedObject;
        }

        std::string RelativeLaneRangeImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeLaneRangeImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeLaneRangeImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeLaneRangeImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RelativeLaneRangeImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void RelativeLaneRangeImpl::ResolveIntExpression(std::string& attributeKey, int& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FROM)
            {
                // Simple type
                _from = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TO)
            {
                // Simple type
                _to = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void RelativeLaneRangeImpl::ResetFrom()
	   {
	   		isSetFrom = false; 
			_from = {};
			
	   }
       bool RelativeLaneRangeImpl::IsSetFrom() const
	   {
			return isSetFrom;
	   }
       void RelativeLaneRangeImpl::ResetTo()
	   {
	   		isSetTo = false; 
			_to = {};
			
	   }
       bool RelativeLaneRangeImpl::IsSetTo() const
	   {
			return isSetTo;
	   }

        IOpenScenarioFlexElement* RelativeObjectPositionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double RelativeObjectPositionImpl::GetDx() const
        {
        	  return _dx;
        }
        double RelativeObjectPositionImpl::GetDy() const
        {
        	  return _dy;
        }
        double RelativeObjectPositionImpl::GetDz() const
        {
        	  return _dz;
        }
        std::shared_ptr<INamedReference<IEntity>> RelativeObjectPositionImpl::GetEntityRef() const
        {
        	 return _entityRef;
        }
        std::shared_ptr<IOrientation> RelativeObjectPositionImpl::GetOrientation() const
        {
        	  return _orientation;
        }


        void RelativeObjectPositionImpl::SetDx(const double dx)
        {
            _dx = dx;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DX);
        }

        void RelativeObjectPositionImpl::SetDy(const double dy)
        {
            _dy = dy;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DY);
        }

        void RelativeObjectPositionImpl::SetDz(const double dz)
        {
            _dz = dz;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DZ);
			// set the indicator to true
            isSetDz = true;          
        }

        void RelativeObjectPositionImpl::SetEntityRef(std::shared_ptr<INamedReference<IEntity>> entityRef)
        {
            _entityRef = entityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
        }

        void RelativeObjectPositionImpl::SetOrientation(std::shared_ptr<IOrientationWriter> orientation)
        {
            _orientation = orientation;
			// set the indicator to true
            isSetOrientation = true;          
        }

        std::shared_ptr<void> RelativeObjectPositionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RelativeObjectPositionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRelativeObjectPosition).name())
                return std::dynamic_pointer_cast<IRelativeObjectPosition>(shared_from_this());
            else if (classifier == typeid(IRelativeObjectPositionWriter).name())
                return std::dynamic_pointer_cast<IRelativeObjectPositionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RelativeObjectPositionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RelativeObjectPositionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RelativeObjectPositionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double RelativeObjectPositionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__DX)
                {
                    return GetDx();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__DY)
                {
                    return GetDy();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__DZ)
                {
                    return GetDz();
                }
                throw KeyNotSupportedException();

        }

        uint16_t RelativeObjectPositionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RelativeObjectPositionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime RelativeObjectPositionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RelativeObjectPositionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RelativeObjectPositionImpl::GetModelType() const
        {
            return "RelativeObjectPosition";
        }

        void RelativeObjectPositionImpl::WriteParameterToDx(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DX, parameterName, nullTextMarker /*no textmarker*/);
            _dx = {};
        }

        void RelativeObjectPositionImpl::WriteParameterToDy(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DY, parameterName, nullTextMarker /*no textmarker*/);
            _dy = {};
        }

        void RelativeObjectPositionImpl::WriteParameterToDz(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DZ, parameterName, nullTextMarker /*no textmarker*/);
            _dz = {};
        }

        void RelativeObjectPositionImpl::WriteParameterToEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _entityRef = {};
        }

        std::string RelativeObjectPositionImpl::GetParameterFromDx() const
        {
            auto dx = OSC_CONSTANTS::ATTRIBUTE__DX;
            return GetParameterNameFromAttribute(dx);
        }

        std::string RelativeObjectPositionImpl::GetParameterFromDy() const
        {
            auto dy = OSC_CONSTANTS::ATTRIBUTE__DY;
            return GetParameterNameFromAttribute(dy);
        }

        std::string RelativeObjectPositionImpl::GetParameterFromDz() const
        {
            auto dz = OSC_CONSTANTS::ATTRIBUTE__DZ;
            return GetParameterNameFromAttribute(dz);
        }

        std::string RelativeObjectPositionImpl::GetParameterFromEntityRef() const
        {
            auto entityRef = OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF;
            return GetParameterNameFromAttribute(entityRef);
        }

        bool RelativeObjectPositionImpl::IsDxParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DX);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeObjectPositionImpl::IsDyParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DY);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeObjectPositionImpl::IsDzParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DZ);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeObjectPositionImpl::IsEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IOrientationWriter> RelativeObjectPositionImpl::GetWriterOrientation() const
        {
            return std::dynamic_pointer_cast<IOrientationWriter>(_orientation);
        }

        RelativeObjectPositionImpl::RelativeObjectPositionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DX, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DY, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DZ, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
        }

        void RelativeObjectPositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DX)
            {
                // Simple type
                _dx = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DY)
            {
                // Simple type
                _dy = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DZ)
            {
                // Simple type
                _dz = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeObjectPositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeObjectPositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kOrientation =  GetWriterOrientation();
                if (kOrientation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOrientation));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeObjectPositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeObjectPositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_dx = GetDx();
            // Simple type
            clonedObject->_dy = GetDy();
            // Simple type
            clonedObject->_dz = GetDz();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // clone indicators
            	clonedObject->isSetDz = isSetDz;
            // clone children
            const auto kOrientation =  GetWriterOrientation();
            if (kOrientation)
            {
                auto clonedChild = std::dynamic_pointer_cast<OrientationImpl>(kOrientation)->Clone();
                auto clonedChildIOrientation = std::dynamic_pointer_cast<IOrientation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOrientation(std::dynamic_pointer_cast<IOrientationWriter>(clonedChildIOrientation));
            }
            return clonedObject;
        }

        std::string RelativeObjectPositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeObjectPositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ORIENTATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOrientation());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeObjectPositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeObjectPositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string RelativeObjectPositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void RelativeObjectPositionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DX)
            {
                // Simple type
                _dx = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DY)
            {
                // Simple type
                _dy = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DZ)
            {
                // Simple type
                _dz = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void RelativeObjectPositionImpl::ResetDz()
	   {
	   		isSetDz = false; 
			_dz = {0};
			
	   }
       bool RelativeObjectPositionImpl::IsSetDz() const
	   {
			return isSetDz;
	   }
       void RelativeObjectPositionImpl::ResetOrientation()
	   {
	   		isSetOrientation = false; 
			_orientation = {};
			
	   }
       bool RelativeObjectPositionImpl::IsSetOrientation() const
	   {
			return isSetOrientation;
	   }

        IOpenScenarioFlexElement* RelativeRoadPositionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double RelativeRoadPositionImpl::GetDs() const
        {
        	  return _ds;
        }
        double RelativeRoadPositionImpl::GetDt() const
        {
        	  return _dt;
        }
        std::shared_ptr<INamedReference<IEntity>> RelativeRoadPositionImpl::GetEntityRef() const
        {
        	 return _entityRef;
        }
        std::shared_ptr<IOrientation> RelativeRoadPositionImpl::GetOrientation() const
        {
        	  return _orientation;
        }


        void RelativeRoadPositionImpl::SetDs(const double ds)
        {
            _ds = ds;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DS);
        }

        void RelativeRoadPositionImpl::SetDt(const double dt)
        {
            _dt = dt;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DT);
        }

        void RelativeRoadPositionImpl::SetEntityRef(std::shared_ptr<INamedReference<IEntity>> entityRef)
        {
            _entityRef = entityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
        }

        void RelativeRoadPositionImpl::SetOrientation(std::shared_ptr<IOrientationWriter> orientation)
        {
            _orientation = orientation;
			// set the indicator to true
            isSetOrientation = true;          
        }

        std::shared_ptr<void> RelativeRoadPositionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RelativeRoadPositionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRelativeRoadPosition).name())
                return std::dynamic_pointer_cast<IRelativeRoadPosition>(shared_from_this());
            else if (classifier == typeid(IRelativeRoadPositionWriter).name())
                return std::dynamic_pointer_cast<IRelativeRoadPositionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RelativeRoadPositionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RelativeRoadPositionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RelativeRoadPositionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double RelativeRoadPositionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__DS)
                {
                    return GetDs();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__DT)
                {
                    return GetDt();
                }
                throw KeyNotSupportedException();

        }

        uint16_t RelativeRoadPositionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RelativeRoadPositionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime RelativeRoadPositionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RelativeRoadPositionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RelativeRoadPositionImpl::GetModelType() const
        {
            return "RelativeRoadPosition";
        }

        void RelativeRoadPositionImpl::WriteParameterToDs(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DS, parameterName, nullTextMarker /*no textmarker*/);
            _ds = {};
        }

        void RelativeRoadPositionImpl::WriteParameterToDt(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DT, parameterName, nullTextMarker /*no textmarker*/);
            _dt = {};
        }

        void RelativeRoadPositionImpl::WriteParameterToEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _entityRef = {};
        }

        std::string RelativeRoadPositionImpl::GetParameterFromDs() const
        {
            auto ds = OSC_CONSTANTS::ATTRIBUTE__DS;
            return GetParameterNameFromAttribute(ds);
        }

        std::string RelativeRoadPositionImpl::GetParameterFromDt() const
        {
            auto dt = OSC_CONSTANTS::ATTRIBUTE__DT;
            return GetParameterNameFromAttribute(dt);
        }

        std::string RelativeRoadPositionImpl::GetParameterFromEntityRef() const
        {
            auto entityRef = OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF;
            return GetParameterNameFromAttribute(entityRef);
        }

        bool RelativeRoadPositionImpl::IsDsParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DS);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeRoadPositionImpl::IsDtParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DT);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeRoadPositionImpl::IsEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IOrientationWriter> RelativeRoadPositionImpl::GetWriterOrientation() const
        {
            return std::dynamic_pointer_cast<IOrientationWriter>(_orientation);
        }

        RelativeRoadPositionImpl::RelativeRoadPositionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DT, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
        }

        void RelativeRoadPositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DS)
            {
                // Simple type
                _ds = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DT)
            {
                // Simple type
                _dt = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeRoadPositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeRoadPositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kOrientation =  GetWriterOrientation();
                if (kOrientation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOrientation));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeRoadPositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeRoadPositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_ds = GetDs();
            // Simple type
            clonedObject->_dt = GetDt();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // clone indicators
            // clone children
            const auto kOrientation =  GetWriterOrientation();
            if (kOrientation)
            {
                auto clonedChild = std::dynamic_pointer_cast<OrientationImpl>(kOrientation)->Clone();
                auto clonedChildIOrientation = std::dynamic_pointer_cast<IOrientation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOrientation(std::dynamic_pointer_cast<IOrientationWriter>(clonedChildIOrientation));
            }
            return clonedObject;
        }

        std::string RelativeRoadPositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeRoadPositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ORIENTATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOrientation());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeRoadPositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeRoadPositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string RelativeRoadPositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void RelativeRoadPositionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DS)
            {
                // Simple type
                _ds = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DT)
            {
                // Simple type
                _dt = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void RelativeRoadPositionImpl::ResetOrientation()
	   {
	   		isSetOrientation = false; 
			_orientation = {};
			
	   }
       bool RelativeRoadPositionImpl::IsSetOrientation() const
	   {
			return isSetOrientation;
	   }

        IOpenScenarioFlexElement* RelativeSpeedConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        DirectionalDimension RelativeSpeedConditionImpl::GetDirection() const
        {
        	  return _direction;
        }
        std::shared_ptr<INamedReference<IEntity>> RelativeSpeedConditionImpl::GetEntityRef() const
        {
        	 return _entityRef;
        }
        Rule RelativeSpeedConditionImpl::GetRule() const
        {
        	  return _rule;
        }
        double RelativeSpeedConditionImpl::GetValue() const
        {
        	  return _value;
        }


        void RelativeSpeedConditionImpl::SetDirection(const DirectionalDimension direction)
        {
            _direction = direction;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DIRECTION);
			// set the indicator to true
            isSetDirection = true;          
        }

        void RelativeSpeedConditionImpl::SetEntityRef(std::shared_ptr<INamedReference<IEntity>> entityRef)
        {
            _entityRef = entityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
        }

        void RelativeSpeedConditionImpl::SetRule(const Rule rule)
        {
            _rule = rule;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE);
        }

        void RelativeSpeedConditionImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> RelativeSpeedConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RelativeSpeedConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRelativeSpeedCondition).name())
                return std::dynamic_pointer_cast<IRelativeSpeedCondition>(shared_from_this());
            else if (classifier == typeid(IRelativeSpeedConditionWriter).name())
                return std::dynamic_pointer_cast<IRelativeSpeedConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RelativeSpeedConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RelativeSpeedConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RelativeSpeedConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double RelativeSpeedConditionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t RelativeSpeedConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RelativeSpeedConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime RelativeSpeedConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RelativeSpeedConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RelativeSpeedConditionImpl::GetModelType() const
        {
            return "RelativeSpeedCondition";
        }

        void RelativeSpeedConditionImpl::WriteParameterToDirection(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DIRECTION, parameterName, nullTextMarker /*no textmarker*/);
            _direction = {};
        }

        void RelativeSpeedConditionImpl::WriteParameterToEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _entityRef = {};
        }

        void RelativeSpeedConditionImpl::WriteParameterToRule(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE, parameterName, nullTextMarker /*no textmarker*/);
            _rule = {};
        }

        void RelativeSpeedConditionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string RelativeSpeedConditionImpl::GetParameterFromDirection() const
        {
            auto direction = OSC_CONSTANTS::ATTRIBUTE__DIRECTION;
            return GetParameterNameFromAttribute(direction);
        }

        std::string RelativeSpeedConditionImpl::GetParameterFromEntityRef() const
        {
            auto entityRef = OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF;
            return GetParameterNameFromAttribute(entityRef);
        }

        std::string RelativeSpeedConditionImpl::GetParameterFromRule() const
        {
            auto rule = OSC_CONSTANTS::ATTRIBUTE__RULE;
            return GetParameterNameFromAttribute(rule);
        }

        std::string RelativeSpeedConditionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool RelativeSpeedConditionImpl::IsDirectionParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DIRECTION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeSpeedConditionImpl::IsEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeSpeedConditionImpl::IsRuleParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RULE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeSpeedConditionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        RelativeSpeedConditionImpl::RelativeSpeedConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DIRECTION, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void RelativeSpeedConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DIRECTION)
            {
                // Enumeration Type
                const auto kResult = DirectionalDimension::GetFromLiteral(parameterLiteralValue);
                if (kResult != DirectionalDimension::UNKNOWN)
                {
                    _direction = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeSpeedConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeSpeedConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeSpeedConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeSpeedConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kDirection = GetDirection();
            if ( kDirection.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_direction = DirectionalDimension::GetFromLiteral(kDirection.GetLiteral());
            }
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            	clonedObject->isSetDirection = isSetDirection;
            // clone children
            return clonedObject;
        }

        std::string RelativeSpeedConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeSpeedConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeSpeedConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeSpeedConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string RelativeSpeedConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__DIRECTION)
            {
                auto direction = GetDirection();
                return direction.GetLiteral() != "UNKNOWN" ? direction.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void RelativeSpeedConditionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void RelativeSpeedConditionImpl::ResetDirection()
	   {
	   		isSetDirection = false; 
			_direction = {};
			
	   }
       bool RelativeSpeedConditionImpl::IsSetDirection() const
	   {
			return isSetDirection;
	   }

        IOpenScenarioFlexElement* RelativeSpeedToMasterImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        SpeedTargetValueType RelativeSpeedToMasterImpl::GetSpeedTargetValueType() const
        {
        	  return _speedTargetValueType;
        }
        double RelativeSpeedToMasterImpl::GetValue() const
        {
        	  return _value;
        }
        std::shared_ptr<ISteadyState> RelativeSpeedToMasterImpl::GetSteadyState() const
        {
        	  return _steadyState;
        }


        void RelativeSpeedToMasterImpl::SetSpeedTargetValueType(const SpeedTargetValueType speedTargetValueType)
        {
            _speedTargetValueType = speedTargetValueType;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE);
        }

        void RelativeSpeedToMasterImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        void RelativeSpeedToMasterImpl::SetSteadyState(std::shared_ptr<ISteadyStateWriter> steadyState)
        {
            _steadyState = steadyState;
			// set the indicator to true
            isSetSteadyState = true;          
        }

        std::shared_ptr<void> RelativeSpeedToMasterImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RelativeSpeedToMasterImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRelativeSpeedToMaster).name())
                return std::dynamic_pointer_cast<IRelativeSpeedToMaster>(shared_from_this());
            else if (classifier == typeid(IRelativeSpeedToMasterWriter).name())
                return std::dynamic_pointer_cast<IRelativeSpeedToMasterWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RelativeSpeedToMasterImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RelativeSpeedToMasterImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RelativeSpeedToMasterImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double RelativeSpeedToMasterImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t RelativeSpeedToMasterImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RelativeSpeedToMasterImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime RelativeSpeedToMasterImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RelativeSpeedToMasterImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RelativeSpeedToMasterImpl::GetModelType() const
        {
            return "RelativeSpeedToMaster";
        }

        void RelativeSpeedToMasterImpl::WriteParameterToSpeedTargetValueType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _speedTargetValueType = {};
        }

        void RelativeSpeedToMasterImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string RelativeSpeedToMasterImpl::GetParameterFromSpeedTargetValueType() const
        {
            auto speedTargetValueType = OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE;
            return GetParameterNameFromAttribute(speedTargetValueType);
        }

        std::string RelativeSpeedToMasterImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool RelativeSpeedToMasterImpl::IsSpeedTargetValueTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeSpeedToMasterImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<ISteadyStateWriter> RelativeSpeedToMasterImpl::GetWriterSteadyState() const
        {
            return std::dynamic_pointer_cast<ISteadyStateWriter>(_steadyState);
        }

        RelativeSpeedToMasterImpl::RelativeSpeedToMasterImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void RelativeSpeedToMasterImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE)
            {
                // Enumeration Type
                const auto kResult = SpeedTargetValueType::GetFromLiteral(parameterLiteralValue);
                if (kResult != SpeedTargetValueType::UNKNOWN)
                {
                    _speedTargetValueType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeSpeedToMasterImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeSpeedToMasterImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kSteadyState =  GetWriterSteadyState();
                if (kSteadyState)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSteadyState));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeSpeedToMasterImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeSpeedToMasterImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kSpeedTargetValueType = GetSpeedTargetValueType();
            if ( kSpeedTargetValueType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_speedTargetValueType = SpeedTargetValueType::GetFromLiteral(kSpeedTargetValueType.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            const auto kSteadyState =  GetWriterSteadyState();
            if (kSteadyState)
            {
                auto clonedChild = std::dynamic_pointer_cast<SteadyStateImpl>(kSteadyState)->Clone();
                auto clonedChildISteadyState = std::dynamic_pointer_cast<ISteadyState>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSteadyState(std::dynamic_pointer_cast<ISteadyStateWriter>(clonedChildISteadyState));
            }
            return clonedObject;
        }

        std::string RelativeSpeedToMasterImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeSpeedToMasterImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__STEADY_STATE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSteadyState());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeSpeedToMasterImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeSpeedToMasterImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RelativeSpeedToMasterImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE)
            {
                auto speedTargetValueType = GetSpeedTargetValueType();
                return speedTargetValueType.GetLiteral() != "UNKNOWN" ? speedTargetValueType.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void RelativeSpeedToMasterImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void RelativeSpeedToMasterImpl::ResetSteadyState()
	   {
	   		isSetSteadyState = false; 
			_steadyState = {};
			
	   }
       bool RelativeSpeedToMasterImpl::IsSetSteadyState() const
	   {
			return isSetSteadyState;
	   }

        IOpenScenarioFlexElement* RelativeTargetLaneImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<INamedReference<IEntity>> RelativeTargetLaneImpl::GetEntityRef() const
        {
        	 return _entityRef;
        }
        int RelativeTargetLaneImpl::GetValue() const
        {
        	  return _value;
        }


        void RelativeTargetLaneImpl::SetEntityRef(std::shared_ptr<INamedReference<IEntity>> entityRef)
        {
            _entityRef = entityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
        }

        void RelativeTargetLaneImpl::SetValue(const int value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> RelativeTargetLaneImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RelativeTargetLaneImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRelativeTargetLane).name())
                return std::dynamic_pointer_cast<IRelativeTargetLane>(shared_from_this());
            else if (classifier == typeid(IRelativeTargetLaneWriter).name())
                return std::dynamic_pointer_cast<IRelativeTargetLaneWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RelativeTargetLaneImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RelativeTargetLaneImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RelativeTargetLaneImpl::GetIntProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        double RelativeTargetLaneImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t RelativeTargetLaneImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RelativeTargetLaneImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime RelativeTargetLaneImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RelativeTargetLaneImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RelativeTargetLaneImpl::GetModelType() const
        {
            return "RelativeTargetLane";
        }

        void RelativeTargetLaneImpl::WriteParameterToEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _entityRef = {};
        }

        void RelativeTargetLaneImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string RelativeTargetLaneImpl::GetParameterFromEntityRef() const
        {
            auto entityRef = OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF;
            return GetParameterNameFromAttribute(entityRef);
        }

        std::string RelativeTargetLaneImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool RelativeTargetLaneImpl::IsEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeTargetLaneImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        RelativeTargetLaneImpl::RelativeTargetLaneImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::INT);
        }

        void RelativeTargetLaneImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseInt(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeTargetLaneImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeTargetLaneImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeTargetLaneImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeTargetLaneImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string RelativeTargetLaneImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeTargetLaneImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeTargetLaneImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeTargetLaneImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string RelativeTargetLaneImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void RelativeTargetLaneImpl::ResolveIntExpression(std::string& attributeKey, int& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* RelativeTargetLaneOffsetImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<INamedReference<IEntity>> RelativeTargetLaneOffsetImpl::GetEntityRef() const
        {
        	 return _entityRef;
        }
        double RelativeTargetLaneOffsetImpl::GetValue() const
        {
        	  return _value;
        }


        void RelativeTargetLaneOffsetImpl::SetEntityRef(std::shared_ptr<INamedReference<IEntity>> entityRef)
        {
            _entityRef = entityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
        }

        void RelativeTargetLaneOffsetImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> RelativeTargetLaneOffsetImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RelativeTargetLaneOffsetImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRelativeTargetLaneOffset).name())
                return std::dynamic_pointer_cast<IRelativeTargetLaneOffset>(shared_from_this());
            else if (classifier == typeid(IRelativeTargetLaneOffsetWriter).name())
                return std::dynamic_pointer_cast<IRelativeTargetLaneOffsetWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RelativeTargetLaneOffsetImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RelativeTargetLaneOffsetImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RelativeTargetLaneOffsetImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double RelativeTargetLaneOffsetImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t RelativeTargetLaneOffsetImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RelativeTargetLaneOffsetImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime RelativeTargetLaneOffsetImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RelativeTargetLaneOffsetImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RelativeTargetLaneOffsetImpl::GetModelType() const
        {
            return "RelativeTargetLaneOffset";
        }

        void RelativeTargetLaneOffsetImpl::WriteParameterToEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _entityRef = {};
        }

        void RelativeTargetLaneOffsetImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string RelativeTargetLaneOffsetImpl::GetParameterFromEntityRef() const
        {
            auto entityRef = OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF;
            return GetParameterNameFromAttribute(entityRef);
        }

        std::string RelativeTargetLaneOffsetImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool RelativeTargetLaneOffsetImpl::IsEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeTargetLaneOffsetImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        RelativeTargetLaneOffsetImpl::RelativeTargetLaneOffsetImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void RelativeTargetLaneOffsetImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeTargetLaneOffsetImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeTargetLaneOffsetImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeTargetLaneOffsetImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeTargetLaneOffsetImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string RelativeTargetLaneOffsetImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeTargetLaneOffsetImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeTargetLaneOffsetImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeTargetLaneOffsetImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string RelativeTargetLaneOffsetImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void RelativeTargetLaneOffsetImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* RelativeTargetSpeedImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool RelativeTargetSpeedImpl::GetContinuous() const
        {
        	  return _continuous;
        }
        std::shared_ptr<INamedReference<IEntity>> RelativeTargetSpeedImpl::GetEntityRef() const
        {
        	 return _entityRef;
        }
        SpeedTargetValueType RelativeTargetSpeedImpl::GetSpeedTargetValueType() const
        {
        	  return _speedTargetValueType;
        }
        double RelativeTargetSpeedImpl::GetValue() const
        {
        	  return _value;
        }


        void RelativeTargetSpeedImpl::SetContinuous(const bool continuous)
        {
            _continuous = continuous;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS);
        }

        void RelativeTargetSpeedImpl::SetEntityRef(std::shared_ptr<INamedReference<IEntity>> entityRef)
        {
            _entityRef = entityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
        }

        void RelativeTargetSpeedImpl::SetSpeedTargetValueType(const SpeedTargetValueType speedTargetValueType)
        {
            _speedTargetValueType = speedTargetValueType;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE);
        }

        void RelativeTargetSpeedImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> RelativeTargetSpeedImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RelativeTargetSpeedImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRelativeTargetSpeed).name())
                return std::dynamic_pointer_cast<IRelativeTargetSpeed>(shared_from_this());
            else if (classifier == typeid(IRelativeTargetSpeedWriter).name())
                return std::dynamic_pointer_cast<IRelativeTargetSpeedWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RelativeTargetSpeedImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RelativeTargetSpeedImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RelativeTargetSpeedImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double RelativeTargetSpeedImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t RelativeTargetSpeedImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RelativeTargetSpeedImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS)
                {
                    return GetContinuous();
                }
                throw KeyNotSupportedException();

        }

        DateTime RelativeTargetSpeedImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RelativeTargetSpeedImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RelativeTargetSpeedImpl::GetModelType() const
        {
            return "RelativeTargetSpeed";
        }

        void RelativeTargetSpeedImpl::WriteParameterToContinuous(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS, parameterName, nullTextMarker /*no textmarker*/);
            _continuous = {};
        }

        void RelativeTargetSpeedImpl::WriteParameterToEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _entityRef = {};
        }

        void RelativeTargetSpeedImpl::WriteParameterToSpeedTargetValueType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _speedTargetValueType = {};
        }

        void RelativeTargetSpeedImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string RelativeTargetSpeedImpl::GetParameterFromContinuous() const
        {
            auto continuous = OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS;
            return GetParameterNameFromAttribute(continuous);
        }

        std::string RelativeTargetSpeedImpl::GetParameterFromEntityRef() const
        {
            auto entityRef = OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF;
            return GetParameterNameFromAttribute(entityRef);
        }

        std::string RelativeTargetSpeedImpl::GetParameterFromSpeedTargetValueType() const
        {
            auto speedTargetValueType = OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE;
            return GetParameterNameFromAttribute(speedTargetValueType);
        }

        std::string RelativeTargetSpeedImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool RelativeTargetSpeedImpl::IsContinuousParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeTargetSpeedImpl::IsEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeTargetSpeedImpl::IsSpeedTargetValueTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeTargetSpeedImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        RelativeTargetSpeedImpl::RelativeTargetSpeedImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void RelativeTargetSpeedImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS)
            {
                // Simple type
                _continuous = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE)
            {
                // Enumeration Type
                const auto kResult = SpeedTargetValueType::GetFromLiteral(parameterLiteralValue);
                if (kResult != SpeedTargetValueType::UNKNOWN)
                {
                    _speedTargetValueType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeTargetSpeedImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeTargetSpeedImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeTargetSpeedImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeTargetSpeedImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_continuous = GetContinuous();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Enumeration Type
            const auto kSpeedTargetValueType = GetSpeedTargetValueType();
            if ( kSpeedTargetValueType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_speedTargetValueType = SpeedTargetValueType::GetFromLiteral(kSpeedTargetValueType.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string RelativeTargetSpeedImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeTargetSpeedImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeTargetSpeedImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeTargetSpeedImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string RelativeTargetSpeedImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE)
            {
                auto speedTargetValueType = GetSpeedTargetValueType();
                return speedTargetValueType.GetLiteral() != "UNKNOWN" ? speedTargetValueType.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void RelativeTargetSpeedImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS)
            {
                // Simple type
                _continuous = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void RelativeTargetSpeedImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* RelativeWorldPositionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double RelativeWorldPositionImpl::GetDx() const
        {
        	  return _dx;
        }
        double RelativeWorldPositionImpl::GetDy() const
        {
        	  return _dy;
        }
        double RelativeWorldPositionImpl::GetDz() const
        {
        	  return _dz;
        }
        std::shared_ptr<INamedReference<IEntity>> RelativeWorldPositionImpl::GetEntityRef() const
        {
        	 return _entityRef;
        }
        std::shared_ptr<IOrientation> RelativeWorldPositionImpl::GetOrientation() const
        {
        	  return _orientation;
        }


        void RelativeWorldPositionImpl::SetDx(const double dx)
        {
            _dx = dx;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DX);
        }

        void RelativeWorldPositionImpl::SetDy(const double dy)
        {
            _dy = dy;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DY);
        }

        void RelativeWorldPositionImpl::SetDz(const double dz)
        {
            _dz = dz;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DZ);
			// set the indicator to true
            isSetDz = true;          
        }

        void RelativeWorldPositionImpl::SetEntityRef(std::shared_ptr<INamedReference<IEntity>> entityRef)
        {
            _entityRef = entityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
        }

        void RelativeWorldPositionImpl::SetOrientation(std::shared_ptr<IOrientationWriter> orientation)
        {
            _orientation = orientation;
			// set the indicator to true
            isSetOrientation = true;          
        }

        std::shared_ptr<void> RelativeWorldPositionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RelativeWorldPositionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRelativeWorldPosition).name())
                return std::dynamic_pointer_cast<IRelativeWorldPosition>(shared_from_this());
            else if (classifier == typeid(IRelativeWorldPositionWriter).name())
                return std::dynamic_pointer_cast<IRelativeWorldPositionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RelativeWorldPositionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RelativeWorldPositionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RelativeWorldPositionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double RelativeWorldPositionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__DX)
                {
                    return GetDx();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__DY)
                {
                    return GetDy();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__DZ)
                {
                    return GetDz();
                }
                throw KeyNotSupportedException();

        }

        uint16_t RelativeWorldPositionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RelativeWorldPositionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime RelativeWorldPositionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RelativeWorldPositionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RelativeWorldPositionImpl::GetModelType() const
        {
            return "RelativeWorldPosition";
        }

        void RelativeWorldPositionImpl::WriteParameterToDx(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DX, parameterName, nullTextMarker /*no textmarker*/);
            _dx = {};
        }

        void RelativeWorldPositionImpl::WriteParameterToDy(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DY, parameterName, nullTextMarker /*no textmarker*/);
            _dy = {};
        }

        void RelativeWorldPositionImpl::WriteParameterToDz(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DZ, parameterName, nullTextMarker /*no textmarker*/);
            _dz = {};
        }

        void RelativeWorldPositionImpl::WriteParameterToEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _entityRef = {};
        }

        std::string RelativeWorldPositionImpl::GetParameterFromDx() const
        {
            auto dx = OSC_CONSTANTS::ATTRIBUTE__DX;
            return GetParameterNameFromAttribute(dx);
        }

        std::string RelativeWorldPositionImpl::GetParameterFromDy() const
        {
            auto dy = OSC_CONSTANTS::ATTRIBUTE__DY;
            return GetParameterNameFromAttribute(dy);
        }

        std::string RelativeWorldPositionImpl::GetParameterFromDz() const
        {
            auto dz = OSC_CONSTANTS::ATTRIBUTE__DZ;
            return GetParameterNameFromAttribute(dz);
        }

        std::string RelativeWorldPositionImpl::GetParameterFromEntityRef() const
        {
            auto entityRef = OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF;
            return GetParameterNameFromAttribute(entityRef);
        }

        bool RelativeWorldPositionImpl::IsDxParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DX);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeWorldPositionImpl::IsDyParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DY);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeWorldPositionImpl::IsDzParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DZ);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RelativeWorldPositionImpl::IsEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IOrientationWriter> RelativeWorldPositionImpl::GetWriterOrientation() const
        {
            return std::dynamic_pointer_cast<IOrientationWriter>(_orientation);
        }

        RelativeWorldPositionImpl::RelativeWorldPositionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DX, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DY, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DZ, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
        }

        void RelativeWorldPositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DX)
            {
                // Simple type
                _dx = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DY)
            {
                // Simple type
                _dy = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DZ)
            {
                // Simple type
                _dz = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeWorldPositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeWorldPositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kOrientation =  GetWriterOrientation();
                if (kOrientation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOrientation));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeWorldPositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeWorldPositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_dx = GetDx();
            // Simple type
            clonedObject->_dy = GetDy();
            // Simple type
            clonedObject->_dz = GetDz();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // clone indicators
            	clonedObject->isSetDz = isSetDz;
            // clone children
            const auto kOrientation =  GetWriterOrientation();
            if (kOrientation)
            {
                auto clonedChild = std::dynamic_pointer_cast<OrientationImpl>(kOrientation)->Clone();
                auto clonedChildIOrientation = std::dynamic_pointer_cast<IOrientation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOrientation(std::dynamic_pointer_cast<IOrientationWriter>(clonedChildIOrientation));
            }
            return clonedObject;
        }

        std::string RelativeWorldPositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeWorldPositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ORIENTATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOrientation());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeWorldPositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeWorldPositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string RelativeWorldPositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void RelativeWorldPositionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DX)
            {
                // Simple type
                _dx = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DY)
            {
                // Simple type
                _dy = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DZ)
            {
                // Simple type
                _dz = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void RelativeWorldPositionImpl::ResetDz()
	   {
	   		isSetDz = false; 
			_dz = {0};
			
	   }
       bool RelativeWorldPositionImpl::IsSetDz() const
	   {
			return isSetDz;
	   }
       void RelativeWorldPositionImpl::ResetOrientation()
	   {
	   		isSetOrientation = false; 
			_orientation = {};
			
	   }
       bool RelativeWorldPositionImpl::IsSetOrientation() const
	   {
			return isSetOrientation;
	   }

        IOpenScenarioFlexElement* RoadConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double RoadConditionImpl::GetFrictionScaleFactor() const
        {
        	  return _frictionScaleFactor;
        }
        Wetness RoadConditionImpl::GetWetness() const
        {
        	  return _wetness;
        }
        std::shared_ptr<IProperties> RoadConditionImpl::GetProperties() const
        {
        	  return _properties;
        }


        void RoadConditionImpl::SetFrictionScaleFactor(const double frictionScaleFactor)
        {
            _frictionScaleFactor = frictionScaleFactor;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FRICTION_SCALE_FACTOR);
        }

        void RoadConditionImpl::SetWetness(const Wetness wetness)
        {
            _wetness = wetness;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__WETNESS);
			// set the indicator to true
            isSetWetness = true;          
        }

        void RoadConditionImpl::SetProperties(std::shared_ptr<IPropertiesWriter> properties)
        {
            _properties = properties;
			// set the indicator to true
            isSetProperties = true;          
        }

        std::shared_ptr<void> RoadConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RoadConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRoadCondition).name())
                return std::dynamic_pointer_cast<IRoadCondition>(shared_from_this());
            else if (classifier == typeid(IRoadConditionWriter).name())
                return std::dynamic_pointer_cast<IRoadConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RoadConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RoadConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RoadConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double RoadConditionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__FRICTION_SCALE_FACTOR)
                {
                    return GetFrictionScaleFactor();
                }
                throw KeyNotSupportedException();

        }

        uint16_t RoadConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RoadConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime RoadConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RoadConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RoadConditionImpl::GetModelType() const
        {
            return "RoadCondition";
        }

        void RoadConditionImpl::WriteParameterToFrictionScaleFactor(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FRICTION_SCALE_FACTOR, parameterName, nullTextMarker /*no textmarker*/);
            _frictionScaleFactor = {};
        }

        void RoadConditionImpl::WriteParameterToWetness(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__WETNESS, parameterName, nullTextMarker /*no textmarker*/);
            _wetness = {};
        }

        std::string RoadConditionImpl::GetParameterFromFrictionScaleFactor() const
        {
            auto frictionScaleFactor = OSC_CONSTANTS::ATTRIBUTE__FRICTION_SCALE_FACTOR;
            return GetParameterNameFromAttribute(frictionScaleFactor);
        }

        std::string RoadConditionImpl::GetParameterFromWetness() const
        {
            auto wetness = OSC_CONSTANTS::ATTRIBUTE__WETNESS;
            return GetParameterNameFromAttribute(wetness);
        }

        bool RoadConditionImpl::IsFrictionScaleFactorParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__FRICTION_SCALE_FACTOR);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RoadConditionImpl::IsWetnessParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__WETNESS);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IPropertiesWriter> RoadConditionImpl::GetWriterProperties() const
        {
            return std::dynamic_pointer_cast<IPropertiesWriter>(_properties);
        }

        RoadConditionImpl::RoadConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FRICTION_SCALE_FACTOR, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__WETNESS, SimpleType::ENUM_TYPE);
        }

        void RoadConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FRICTION_SCALE_FACTOR)
            {
                // Simple type
                _frictionScaleFactor = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WETNESS)
            {
                // Enumeration Type
                const auto kResult = Wetness::GetFromLiteral(parameterLiteralValue);
                if (kResult != Wetness::UNKNOWN)
                {
                    _wetness = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType RoadConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RoadConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kProperties =  GetWriterProperties();
                if (kProperties)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kProperties));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RoadConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RoadConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_frictionScaleFactor = GetFrictionScaleFactor();
            // Enumeration Type
            const auto kWetness = GetWetness();
            if ( kWetness.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_wetness = Wetness::GetFromLiteral(kWetness.GetLiteral());
            }
            // clone indicators
            	clonedObject->isSetWetness = isSetWetness;
            // clone children
            const auto kProperties =  GetWriterProperties();
            if (kProperties)
            {
                auto clonedChild = std::dynamic_pointer_cast<PropertiesImpl>(kProperties)->Clone();
                auto clonedChildIProperties = std::dynamic_pointer_cast<IProperties>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetProperties(std::dynamic_pointer_cast<IPropertiesWriter>(clonedChildIProperties));
            }
            return clonedObject;
        }

        std::string RoadConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoadConditionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PROPERTIES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetProperties());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RoadConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoadConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RoadConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__WETNESS)
            {
                auto wetness = GetWetness();
                return wetness.GetLiteral() != "UNKNOWN" ? wetness.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void RoadConditionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FRICTION_SCALE_FACTOR)
            {
                // Simple type
                _frictionScaleFactor = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void RoadConditionImpl::ResetWetness()
	   {
	   		isSetWetness = false; 
			_wetness = {};
			
	   }
       bool RoadConditionImpl::IsSetWetness() const
	   {
			return isSetWetness;
	   }
       void RoadConditionImpl::ResetProperties()
	   {
	   		isSetProperties = false; 
			_properties = {};
			
	   }
       bool RoadConditionImpl::IsSetProperties() const
	   {
			return isSetProperties;
	   }

        IOpenScenarioFlexElement* RoadNetworkImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IFile> RoadNetworkImpl::GetLogicFile() const
        {
        	  return _logicFile;
        }
        std::shared_ptr<IFile> RoadNetworkImpl::GetSceneGraphFile() const
        {
        	  return _sceneGraphFile;
        }
        std::vector<std::shared_ptr<ITrafficSignalController>> RoadNetworkImpl::GetTrafficSignals() const
        {
            std::vector<std::shared_ptr<ITrafficSignalController>> temp;
            for(auto&& elm: _trafficSignals)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<ITrafficSignalControllerWriter>> RoadNetworkImpl::GetWriterTrafficSignals() const
        {
            return _trafficSignals;
        }

        int RoadNetworkImpl::GetTrafficSignalsSize() const
        {
            return static_cast<int>(_trafficSignals.size());
        }

        std::shared_ptr<ITrafficSignalController> RoadNetworkImpl::GetTrafficSignalsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _trafficSignals.size() > index)
            {
                return _trafficSignals[index];
            }
            return nullptr;
        }
        std::shared_ptr<IUsedArea> RoadNetworkImpl::GetUsedArea() const
        {
        	  return _usedArea;
        }


        void RoadNetworkImpl::SetLogicFile(std::shared_ptr<IFileWriter> logicFile)
        {
            _logicFile = logicFile;
			// set the indicator to true
            isSetLogicFile = true;          
        }

        void RoadNetworkImpl::SetSceneGraphFile(std::shared_ptr<IFileWriter> sceneGraphFile)
        {
            _sceneGraphFile = sceneGraphFile;
			// set the indicator to true
            isSetSceneGraphFile = true;          
        }

        void RoadNetworkImpl::SetTrafficSignals(std::vector<std::shared_ptr<ITrafficSignalControllerWriter>>& trafficSignals)
        {
            _trafficSignals = trafficSignals;
			// set the indicator to true
            isSetTrafficSignals = true;          
        }

        void RoadNetworkImpl::SetUsedArea(std::shared_ptr<IUsedAreaWriter> usedArea)
        {
            _usedArea = usedArea;
			// set the indicator to true
            isSetUsedArea = true;          
        }

        std::shared_ptr<void> RoadNetworkImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RoadNetworkImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRoadNetwork).name())
                return std::dynamic_pointer_cast<IRoadNetwork>(shared_from_this());
            else if (classifier == typeid(IRoadNetworkWriter).name())
                return std::dynamic_pointer_cast<IRoadNetworkWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RoadNetworkImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RoadNetworkImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RoadNetworkImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double RoadNetworkImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t RoadNetworkImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RoadNetworkImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime RoadNetworkImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RoadNetworkImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RoadNetworkImpl::GetModelType() const
        {
            return "RoadNetwork";
        }

            // children
        std::shared_ptr<IFileWriter> RoadNetworkImpl::GetWriterLogicFile() const
        {
            return std::dynamic_pointer_cast<IFileWriter>(_logicFile);
        }
        std::shared_ptr<IFileWriter> RoadNetworkImpl::GetWriterSceneGraphFile() const
        {
            return std::dynamic_pointer_cast<IFileWriter>(_sceneGraphFile);
        }
        std::shared_ptr<IUsedAreaWriter> RoadNetworkImpl::GetWriterUsedArea() const
        {
            return std::dynamic_pointer_cast<IUsedAreaWriter>(_usedArea);
        }

        RoadNetworkImpl::RoadNetworkImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void RoadNetworkImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType RoadNetworkImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RoadNetworkImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kLogicFile =  GetWriterLogicFile();
                if (kLogicFile)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLogicFile));
                }
                const auto kSceneGraphFile =  GetWriterSceneGraphFile();
                if (kSceneGraphFile)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSceneGraphFile));
                }
                auto trafficSignals =  GetWriterTrafficSignals();
                if (!trafficSignals.empty())
                {
                    for(auto&& item : trafficSignals)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kUsedArea =  GetWriterUsedArea();
                if (kUsedArea)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kUsedArea));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RoadNetworkImpl::Clone()
        {
            auto clonedObject = std::make_shared<RoadNetworkImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kLogicFile =  GetWriterLogicFile();
            if (kLogicFile)
            {
                auto clonedChild = std::dynamic_pointer_cast<FileImpl>(kLogicFile)->Clone();
                auto clonedChildIFile = std::dynamic_pointer_cast<IFile>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLogicFile(std::dynamic_pointer_cast<IFileWriter>(clonedChildIFile));
            }
            const auto kSceneGraphFile =  GetWriterSceneGraphFile();
            if (kSceneGraphFile)
            {
                auto clonedChild = std::dynamic_pointer_cast<FileImpl>(kSceneGraphFile)->Clone();
                auto clonedChildIFile = std::dynamic_pointer_cast<IFile>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSceneGraphFile(std::dynamic_pointer_cast<IFileWriter>(clonedChildIFile));
            }
            const auto kTrafficSignals =  GetWriterTrafficSignals();
            if (!kTrafficSignals.empty())
            {
                std::vector<std::shared_ptr<ITrafficSignalControllerWriter>> clonedList;
                for(auto&& kItem : kTrafficSignals)
                {
                    auto clonedChild = std::dynamic_pointer_cast<TrafficSignalControllerImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<ITrafficSignalControllerWriter>(clonedChild));
                }
                clonedObject->SetTrafficSignals(clonedList);
            }
            const auto kUsedArea =  GetWriterUsedArea();
            if (kUsedArea)
            {
                auto clonedChild = std::dynamic_pointer_cast<UsedAreaImpl>(kUsedArea)->Clone();
                auto clonedChildIUsedArea = std::dynamic_pointer_cast<IUsedArea>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetUsedArea(std::dynamic_pointer_cast<IUsedAreaWriter>(clonedChildIUsedArea));
            }
            return clonedObject;
        }

        std::string RoadNetworkImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoadNetworkImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LOGIC_FILE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLogicFile());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SCENE_GRAPH_FILE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSceneGraphFile());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__USED_AREA)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetUsedArea());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RoadNetworkImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SIGNAL_CONTROLLER)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetTrafficSignals())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoadNetworkImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RoadNetworkImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void RoadNetworkImpl::ResetLogicFile()
	   {
	   		isSetLogicFile = false; 
			_logicFile = {};
			
	   }
       bool RoadNetworkImpl::IsSetLogicFile() const
	   {
			return isSetLogicFile;
	   }
       void RoadNetworkImpl::ResetSceneGraphFile()
	   {
	   		isSetSceneGraphFile = false; 
			_sceneGraphFile = {};
			
	   }
       bool RoadNetworkImpl::IsSetSceneGraphFile() const
	   {
			return isSetSceneGraphFile;
	   }
       void RoadNetworkImpl::ResetTrafficSignals()
	   {
	   		isSetTrafficSignals = false; 
			_trafficSignals = {};
			
	   }
       bool RoadNetworkImpl::IsSetTrafficSignals() const
	   {
			return isSetTrafficSignals;
	   }
       void RoadNetworkImpl::ResetUsedArea()
	   {
	   		isSetUsedArea = false; 
			_usedArea = {};
			
	   }
       bool RoadNetworkImpl::IsSetUsedArea() const
	   {
			return isSetUsedArea;
	   }

        IOpenScenarioFlexElement* RoadPositionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string RoadPositionImpl::GetRoadId() const
        {
        	  return _roadId;
        }
        double RoadPositionImpl::GetS() const
        {
        	  return _s;
        }
        double RoadPositionImpl::GetT() const
        {
        	  return _t;
        }
        std::shared_ptr<IOrientation> RoadPositionImpl::GetOrientation() const
        {
        	  return _orientation;
        }


        void RoadPositionImpl::SetRoadId(const std::string roadId)
        {
            _roadId = roadId;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROAD_ID);
        }

        void RoadPositionImpl::SetS(const double s)
        {
            _s = s;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__S);
        }

        void RoadPositionImpl::SetT(const double t)
        {
            _t = t;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__T);
        }

        void RoadPositionImpl::SetOrientation(std::shared_ptr<IOrientationWriter> orientation)
        {
            _orientation = orientation;
			// set the indicator to true
            isSetOrientation = true;          
        }

        std::shared_ptr<void> RoadPositionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RoadPositionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRoadPosition).name())
                return std::dynamic_pointer_cast<IRoadPosition>(shared_from_this());
            else if (classifier == typeid(IRoadPositionWriter).name())
                return std::dynamic_pointer_cast<IRoadPositionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RoadPositionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RoadPositionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RoadPositionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double RoadPositionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__S)
                {
                    return GetS();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__T)
                {
                    return GetT();
                }
                throw KeyNotSupportedException();

        }

        uint16_t RoadPositionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RoadPositionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime RoadPositionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RoadPositionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RoadPositionImpl::GetModelType() const
        {
            return "RoadPosition";
        }

        void RoadPositionImpl::WriteParameterToRoadId(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROAD_ID, parameterName, nullTextMarker /*no textmarker*/);
            _roadId = {};
        }

        void RoadPositionImpl::WriteParameterToS(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__S, parameterName, nullTextMarker /*no textmarker*/);
            _s = {};
        }

        void RoadPositionImpl::WriteParameterToT(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__T, parameterName, nullTextMarker /*no textmarker*/);
            _t = {};
        }

        std::string RoadPositionImpl::GetParameterFromRoadId() const
        {
            auto roadId = OSC_CONSTANTS::ATTRIBUTE__ROAD_ID;
            return GetParameterNameFromAttribute(roadId);
        }

        std::string RoadPositionImpl::GetParameterFromS() const
        {
            auto s = OSC_CONSTANTS::ATTRIBUTE__S;
            return GetParameterNameFromAttribute(s);
        }

        std::string RoadPositionImpl::GetParameterFromT() const
        {
            auto t = OSC_CONSTANTS::ATTRIBUTE__T;
            return GetParameterNameFromAttribute(t);
        }

        bool RoadPositionImpl::IsRoadIdParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ROAD_ID);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RoadPositionImpl::IsSParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__S);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RoadPositionImpl::IsTParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__T);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IOrientationWriter> RoadPositionImpl::GetWriterOrientation() const
        {
            return std::dynamic_pointer_cast<IOrientationWriter>(_orientation);
        }

        RoadPositionImpl::RoadPositionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ROAD_ID, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__S, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__T, SimpleType::DOUBLE);
        }

        void RoadPositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ROAD_ID)
            {
                // Simple type
                _roadId = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__S)
            {
                // Simple type
                _s = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__T)
            {
                // Simple type
                _t = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RoadPositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RoadPositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kOrientation =  GetWriterOrientation();
                if (kOrientation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOrientation));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RoadPositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RoadPositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_roadId = GetRoadId();
            // Simple type
            clonedObject->_s = GetS();
            // Simple type
            clonedObject->_t = GetT();
            // clone indicators
            // clone children
            const auto kOrientation =  GetWriterOrientation();
            if (kOrientation)
            {
                auto clonedChild = std::dynamic_pointer_cast<OrientationImpl>(kOrientation)->Clone();
                auto clonedChildIOrientation = std::dynamic_pointer_cast<IOrientation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOrientation(std::dynamic_pointer_cast<IOrientationWriter>(clonedChildIOrientation));
            }
            return clonedObject;
        }

        std::string RoadPositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ROAD_ID)
            {
                return GetRoadId();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoadPositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ORIENTATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOrientation());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RoadPositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoadPositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RoadPositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void RoadPositionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ROAD_ID)
            {
                // Simple type
                _roadId = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void RoadPositionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__S)
            {
                // Simple type
                _s = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__T)
            {
                // Simple type
                _t = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void RoadPositionImpl::ResetOrientation()
	   {
	   		isSetOrientation = false; 
			_orientation = {};
			
	   }
       bool RoadPositionImpl::IsSetOrientation() const
	   {
			return isSetOrientation;
	   }

        IOpenScenarioFlexElement* RouteImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool RouteImpl::GetClosed() const
        {
        	  return _closed;
        }
        std::string RouteImpl::GetName() const
        {
        	  return _name;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> RouteImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IParameterDeclarationWriter>> RouteImpl::GetWriterParameterDeclarations() const
        {
            return _parameterDeclarations;
        }

        int RouteImpl::GetParameterDeclarationsSize() const
        {
            return static_cast<int>(_parameterDeclarations.size());
        }

        std::shared_ptr<IParameterDeclaration> RouteImpl::GetParameterDeclarationsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _parameterDeclarations.size() > index)
            {
                return _parameterDeclarations[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<IWaypoint>> RouteImpl::GetWaypoints() const
        {
            std::vector<std::shared_ptr<IWaypoint>> temp;
            for(auto&& elm: _waypoints)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IWaypointWriter>> RouteImpl::GetWriterWaypoints() const
        {
            return _waypoints;
        }

        int RouteImpl::GetWaypointsSize() const
        {
            return static_cast<int>(_waypoints.size());
        }

        std::shared_ptr<IWaypoint> RouteImpl::GetWaypointsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _waypoints.size() > index)
            {
                return _waypoints[index];
            }
            return nullptr;
        }


        void RouteImpl::SetClosed(const bool closed)
        {
            _closed = closed;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CLOSED);
        }

        void RouteImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void RouteImpl::SetParameterDeclarations(std::vector<std::shared_ptr<IParameterDeclarationWriter>>& parameterDeclarations)
        {
            _parameterDeclarations = parameterDeclarations;
			// set the indicator to true
            isSetParameterDeclarations = true;          
        }

        void RouteImpl::SetWaypoints(std::vector<std::shared_ptr<IWaypointWriter>>& waypoints)
        {
            _waypoints = waypoints;
        }

        std::shared_ptr<void> RouteImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RouteImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRoute).name())
                return std::dynamic_pointer_cast<IRoute>(shared_from_this());
            else if (classifier == typeid(IRouteWriter).name())
                return std::dynamic_pointer_cast<IRouteWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RouteImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RouteImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RouteImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double RouteImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t RouteImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RouteImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__CLOSED)
                {
                    return GetClosed();
                }
                throw KeyNotSupportedException();

        }

        DateTime RouteImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RouteImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RouteImpl::GetModelType() const
        {
            return "Route";
        }

        void RouteImpl::WriteParameterToClosed(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CLOSED, parameterName, nullTextMarker /*no textmarker*/);
            _closed = {};
        }

        void RouteImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        std::string RouteImpl::GetParameterFromClosed() const
        {
            auto closed = OSC_CONSTANTS::ATTRIBUTE__CLOSED;
            return GetParameterNameFromAttribute(closed);
        }

        std::string RouteImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        bool RouteImpl::IsClosedParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CLOSED);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool RouteImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        RouteImpl::RouteImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CLOSED, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        void RouteImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CLOSED)
            {
                // Simple type
                _closed = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RouteImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool RouteImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> RouteImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RouteImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto waypoints =  GetWriterWaypoints();
                if (!waypoints.empty())
                {
                    for(auto&& item : waypoints)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RouteImpl::Clone()
        {
            auto clonedObject = std::make_shared<RouteImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_closed = GetClosed();
            // Simple type
            clonedObject->_name = GetName();
            // clone indicators
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kWaypoints =  GetWriterWaypoints();
            if (!kWaypoints.empty())
            {
                std::vector<std::shared_ptr<IWaypointWriter>> clonedList;
                for(auto&& kItem : kWaypoints)
                {
                    auto clonedChild = std::dynamic_pointer_cast<WaypointImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IWaypointWriter>(clonedChild));
                }
                clonedObject->SetWaypoints(clonedList);
            }
            return clonedObject;
        }

        std::string RouteImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RouteImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RouteImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__WAYPOINT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetWaypoints())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RouteImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RouteImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void RouteImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CLOSED)
            {
                // Simple type
                _closed = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void RouteImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void RouteImpl::ResetParameterDeclarations()
	   {
	   		isSetParameterDeclarations = false; 
			_parameterDeclarations = {};
			
	   }
       bool RouteImpl::IsSetParameterDeclarations() const
	   {
			return isSetParameterDeclarations;
	   }

        IOpenScenarioFlexElement* RouteCatalogLocationImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IDirectory> RouteCatalogLocationImpl::GetDirectory() const
        {
        	  return _directory;
        }


        void RouteCatalogLocationImpl::SetDirectory(std::shared_ptr<IDirectoryWriter> directory)
        {
            _directory = directory;
        }

        std::shared_ptr<void> RouteCatalogLocationImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RouteCatalogLocationImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRouteCatalogLocation).name())
                return std::dynamic_pointer_cast<IRouteCatalogLocation>(shared_from_this());
            else if (classifier == typeid(IRouteCatalogLocationWriter).name())
                return std::dynamic_pointer_cast<IRouteCatalogLocationWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RouteCatalogLocationImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RouteCatalogLocationImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RouteCatalogLocationImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double RouteCatalogLocationImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t RouteCatalogLocationImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RouteCatalogLocationImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime RouteCatalogLocationImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RouteCatalogLocationImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RouteCatalogLocationImpl::GetModelType() const
        {
            return "RouteCatalogLocation";
        }

            // children
        std::shared_ptr<IDirectoryWriter> RouteCatalogLocationImpl::GetWriterDirectory() const
        {
            return std::dynamic_pointer_cast<IDirectoryWriter>(_directory);
        }

        RouteCatalogLocationImpl::RouteCatalogLocationImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void RouteCatalogLocationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType RouteCatalogLocationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RouteCatalogLocationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDirectory =  GetWriterDirectory();
                if (kDirectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDirectory));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RouteCatalogLocationImpl::Clone()
        {
            auto clonedObject = std::make_shared<RouteCatalogLocationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kDirectory =  GetWriterDirectory();
            if (kDirectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<DirectoryImpl>(kDirectory)->Clone();
                auto clonedChildIDirectory = std::dynamic_pointer_cast<IDirectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDirectory(std::dynamic_pointer_cast<IDirectoryWriter>(clonedChildIDirectory));
            }
            return clonedObject;
        }

        std::string RouteCatalogLocationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RouteCatalogLocationImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIRECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDirectory());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RouteCatalogLocationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RouteCatalogLocationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RouteCatalogLocationImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* RoutePositionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IRouteRef> RoutePositionImpl::GetRouteRef() const
        {
        	  return _routeRef;
        }
        std::shared_ptr<IOrientation> RoutePositionImpl::GetOrientation() const
        {
        	  return _orientation;
        }
        std::shared_ptr<IInRoutePosition> RoutePositionImpl::GetInRoutePosition() const
        {
        	  return _inRoutePosition;
        }


        void RoutePositionImpl::SetRouteRef(std::shared_ptr<IRouteRefWriter> routeRef)
        {
            _routeRef = routeRef;
        }

        void RoutePositionImpl::SetOrientation(std::shared_ptr<IOrientationWriter> orientation)
        {
            _orientation = orientation;
			// set the indicator to true
            isSetOrientation = true;          
        }

        void RoutePositionImpl::SetInRoutePosition(std::shared_ptr<IInRoutePositionWriter> inRoutePosition)
        {
            _inRoutePosition = inRoutePosition;
        }

        std::shared_ptr<void> RoutePositionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RoutePositionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRoutePosition).name())
                return std::dynamic_pointer_cast<IRoutePosition>(shared_from_this());
            else if (classifier == typeid(IRoutePositionWriter).name())
                return std::dynamic_pointer_cast<IRoutePositionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RoutePositionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RoutePositionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RoutePositionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double RoutePositionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t RoutePositionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RoutePositionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime RoutePositionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RoutePositionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RoutePositionImpl::GetModelType() const
        {
            return "RoutePosition";
        }

            // children
        std::shared_ptr<IRouteRefWriter> RoutePositionImpl::GetWriterRouteRef() const
        {
            return std::dynamic_pointer_cast<IRouteRefWriter>(_routeRef);
        }
        std::shared_ptr<IOrientationWriter> RoutePositionImpl::GetWriterOrientation() const
        {
            return std::dynamic_pointer_cast<IOrientationWriter>(_orientation);
        }
        std::shared_ptr<IInRoutePositionWriter> RoutePositionImpl::GetWriterInRoutePosition() const
        {
            return std::dynamic_pointer_cast<IInRoutePositionWriter>(_inRoutePosition);
        }

        RoutePositionImpl::RoutePositionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void RoutePositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType RoutePositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RoutePositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRouteRef =  GetWriterRouteRef();
                if (kRouteRef)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRouteRef));
                }
                const auto kOrientation =  GetWriterOrientation();
                if (kOrientation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOrientation));
                }
                const auto kInRoutePosition =  GetWriterInRoutePosition();
                if (kInRoutePosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kInRoutePosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RoutePositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RoutePositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kRouteRef =  GetWriterRouteRef();
            if (kRouteRef)
            {
                auto clonedChild = std::dynamic_pointer_cast<RouteRefImpl>(kRouteRef)->Clone();
                auto clonedChildIRouteRef = std::dynamic_pointer_cast<IRouteRef>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRouteRef(std::dynamic_pointer_cast<IRouteRefWriter>(clonedChildIRouteRef));
            }
            const auto kOrientation =  GetWriterOrientation();
            if (kOrientation)
            {
                auto clonedChild = std::dynamic_pointer_cast<OrientationImpl>(kOrientation)->Clone();
                auto clonedChildIOrientation = std::dynamic_pointer_cast<IOrientation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOrientation(std::dynamic_pointer_cast<IOrientationWriter>(clonedChildIOrientation));
            }
            const auto kInRoutePosition =  GetWriterInRoutePosition();
            if (kInRoutePosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<InRoutePositionImpl>(kInRoutePosition)->Clone();
                auto clonedChildIInRoutePosition = std::dynamic_pointer_cast<IInRoutePosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetInRoutePosition(std::dynamic_pointer_cast<IInRoutePositionWriter>(clonedChildIInRoutePosition));
            }
            return clonedObject;
        }

        std::string RoutePositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoutePositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ROUTE_REF)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRouteRef());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ORIENTATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOrientation());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__IN_ROUTE_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetInRoutePosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RoutePositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoutePositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RoutePositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void RoutePositionImpl::ResetOrientation()
	   {
	   		isSetOrientation = false; 
			_orientation = {};
			
	   }
       bool RoutePositionImpl::IsSetOrientation() const
	   {
			return isSetOrientation;
	   }

        IOpenScenarioFlexElement* RouteRefImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IRoute> RouteRefImpl::GetRoute() const
        {
        	  return _route;
        }
        std::shared_ptr<ICatalogReference> RouteRefImpl::GetCatalogReference() const
        {
        	  return _catalogReference;
        }


        void RouteRefImpl::SetRoute(std::shared_ptr<IRouteWriter> route)
        {
            _route = route;
            _catalogReference = {};
			// set the indicator to true
            isSetRoute = true;          
        }

        void RouteRefImpl::SetCatalogReference(std::shared_ptr<ICatalogReferenceWriter> catalogReference)
        {
            _catalogReference = catalogReference;
            _route = {};
			// set the indicator to true
            isSetCatalogReference = true;          
        }

        std::shared_ptr<void> RouteRefImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RouteRefImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRouteRef).name())
                return std::dynamic_pointer_cast<IRouteRef>(shared_from_this());
            else if (classifier == typeid(IRouteRefWriter).name())
                return std::dynamic_pointer_cast<IRouteRefWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RouteRefImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RouteRefImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RouteRefImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double RouteRefImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t RouteRefImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RouteRefImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime RouteRefImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RouteRefImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RouteRefImpl::GetModelType() const
        {
            return "RouteRef";
        }

            // children
        std::shared_ptr<IRouteWriter> RouteRefImpl::GetWriterRoute() const
        {
            return std::dynamic_pointer_cast<IRouteWriter>(_route);
        }
        std::shared_ptr<ICatalogReferenceWriter> RouteRefImpl::GetWriterCatalogReference() const
        {
            return std::dynamic_pointer_cast<ICatalogReferenceWriter>(_catalogReference);
        }

        RouteRefImpl::RouteRefImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void RouteRefImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType RouteRefImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RouteRefImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRoute =  GetWriterRoute();
                if (kRoute)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRoute));
                }
                const auto kCatalogReference =  GetWriterCatalogReference();
                if (kCatalogReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogReference));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RouteRefImpl::Clone()
        {
            auto clonedObject = std::make_shared<RouteRefImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kRoute =  GetWriterRoute();
            if (kRoute)
            {
                auto clonedChild = std::dynamic_pointer_cast<RouteImpl>(kRoute)->Clone();
                auto clonedChildIRoute = std::dynamic_pointer_cast<IRoute>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRoute(std::dynamic_pointer_cast<IRouteWriter>(clonedChildIRoute));
            }
            const auto kCatalogReference =  GetWriterCatalogReference();
            if (kCatalogReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kCatalogReference)->Clone();
                auto clonedChildICatalogReference = std::dynamic_pointer_cast<ICatalogReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogReference(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChildICatalogReference));
            }
            return clonedObject;
        }

        std::string RouteRefImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RouteRefImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ROUTE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRoute());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogReference());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RouteRefImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RouteRefImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RouteRefImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void RouteRefImpl::ResetRoute()
	   {
	   		isSetRoute = false; 
			_route = {};
			
	   }
       bool RouteRefImpl::IsSetRoute() const
	   {
			return isSetRoute;
	   }
       void RouteRefImpl::ResetCatalogReference()
	   {
	   		isSetCatalogReference = false; 
			_catalogReference = {};
			
	   }
       bool RouteRefImpl::IsSetCatalogReference() const
	   {
			return isSetCatalogReference;
	   }

        IOpenScenarioFlexElement* RoutingActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IAssignRouteAction> RoutingActionImpl::GetAssignRouteAction() const
        {
        	  return _assignRouteAction;
        }
        std::shared_ptr<IFollowTrajectoryAction> RoutingActionImpl::GetFollowTrajectoryAction() const
        {
        	  return _followTrajectoryAction;
        }
        std::shared_ptr<IAcquirePositionAction> RoutingActionImpl::GetAcquirePositionAction() const
        {
        	  return _acquirePositionAction;
        }


        void RoutingActionImpl::SetAssignRouteAction(std::shared_ptr<IAssignRouteActionWriter> assignRouteAction)
        {
            _assignRouteAction = assignRouteAction;
            _followTrajectoryAction = {};
            _acquirePositionAction = {};
			// set the indicator to true
            isSetAssignRouteAction = true;          
        }

        void RoutingActionImpl::SetFollowTrajectoryAction(std::shared_ptr<IFollowTrajectoryActionWriter> followTrajectoryAction)
        {
            _followTrajectoryAction = followTrajectoryAction;
            _assignRouteAction = {};
            _acquirePositionAction = {};
			// set the indicator to true
            isSetFollowTrajectoryAction = true;          
        }

        void RoutingActionImpl::SetAcquirePositionAction(std::shared_ptr<IAcquirePositionActionWriter> acquirePositionAction)
        {
            _acquirePositionAction = acquirePositionAction;
            _assignRouteAction = {};
            _followTrajectoryAction = {};
			// set the indicator to true
            isSetAcquirePositionAction = true;          
        }

        std::shared_ptr<void> RoutingActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(RoutingActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IRoutingAction).name())
                return std::dynamic_pointer_cast<IRoutingAction>(shared_from_this());
            else if (classifier == typeid(IRoutingActionWriter).name())
                return std::dynamic_pointer_cast<IRoutingActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> RoutingActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t RoutingActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int RoutingActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double RoutingActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t RoutingActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool RoutingActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime RoutingActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> RoutingActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string RoutingActionImpl::GetModelType() const
        {
            return "RoutingAction";
        }

            // children
        std::shared_ptr<IAssignRouteActionWriter> RoutingActionImpl::GetWriterAssignRouteAction() const
        {
            return std::dynamic_pointer_cast<IAssignRouteActionWriter>(_assignRouteAction);
        }
        std::shared_ptr<IFollowTrajectoryActionWriter> RoutingActionImpl::GetWriterFollowTrajectoryAction() const
        {
            return std::dynamic_pointer_cast<IFollowTrajectoryActionWriter>(_followTrajectoryAction);
        }
        std::shared_ptr<IAcquirePositionActionWriter> RoutingActionImpl::GetWriterAcquirePositionAction() const
        {
            return std::dynamic_pointer_cast<IAcquirePositionActionWriter>(_acquirePositionAction);
        }

        RoutingActionImpl::RoutingActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void RoutingActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType RoutingActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RoutingActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kAssignRouteAction =  GetWriterAssignRouteAction();
                if (kAssignRouteAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAssignRouteAction));
                }
                const auto kFollowTrajectoryAction =  GetWriterFollowTrajectoryAction();
                if (kFollowTrajectoryAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kFollowTrajectoryAction));
                }
                const auto kAcquirePositionAction =  GetWriterAcquirePositionAction();
                if (kAcquirePositionAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAcquirePositionAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RoutingActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RoutingActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kAssignRouteAction =  GetWriterAssignRouteAction();
            if (kAssignRouteAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<AssignRouteActionImpl>(kAssignRouteAction)->Clone();
                auto clonedChildIAssignRouteAction = std::dynamic_pointer_cast<IAssignRouteAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAssignRouteAction(std::dynamic_pointer_cast<IAssignRouteActionWriter>(clonedChildIAssignRouteAction));
            }
            const auto kFollowTrajectoryAction =  GetWriterFollowTrajectoryAction();
            if (kFollowTrajectoryAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<FollowTrajectoryActionImpl>(kFollowTrajectoryAction)->Clone();
                auto clonedChildIFollowTrajectoryAction = std::dynamic_pointer_cast<IFollowTrajectoryAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetFollowTrajectoryAction(std::dynamic_pointer_cast<IFollowTrajectoryActionWriter>(clonedChildIFollowTrajectoryAction));
            }
            const auto kAcquirePositionAction =  GetWriterAcquirePositionAction();
            if (kAcquirePositionAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<AcquirePositionActionImpl>(kAcquirePositionAction)->Clone();
                auto clonedChildIAcquirePositionAction = std::dynamic_pointer_cast<IAcquirePositionAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAcquirePositionAction(std::dynamic_pointer_cast<IAcquirePositionActionWriter>(clonedChildIAcquirePositionAction));
            }
            return clonedObject;
        }

        std::string RoutingActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoutingActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ASSIGN_ROUTE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAssignRouteAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__FOLLOW_TRAJECTORY_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetFollowTrajectoryAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ACQUIRE_POSITION_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAcquirePositionAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RoutingActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoutingActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RoutingActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void RoutingActionImpl::ResetAssignRouteAction()
	   {
	   		isSetAssignRouteAction = false; 
			_assignRouteAction = {};
			
	   }
       bool RoutingActionImpl::IsSetAssignRouteAction() const
	   {
			return isSetAssignRouteAction;
	   }
       void RoutingActionImpl::ResetFollowTrajectoryAction()
	   {
	   		isSetFollowTrajectoryAction = false; 
			_followTrajectoryAction = {};
			
	   }
       bool RoutingActionImpl::IsSetFollowTrajectoryAction() const
	   {
			return isSetFollowTrajectoryAction;
	   }
       void RoutingActionImpl::ResetAcquirePositionAction()
	   {
	   		isSetAcquirePositionAction = false; 
			_acquirePositionAction = {};
			
	   }
       bool RoutingActionImpl::IsSetAcquirePositionAction() const
	   {
			return isSetAcquirePositionAction;
	   }

        IOpenScenarioFlexElement* ScenarioDefinitionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> ScenarioDefinitionImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IParameterDeclarationWriter>> ScenarioDefinitionImpl::GetWriterParameterDeclarations() const
        {
            return _parameterDeclarations;
        }

        int ScenarioDefinitionImpl::GetParameterDeclarationsSize() const
        {
            return static_cast<int>(_parameterDeclarations.size());
        }

        std::shared_ptr<IParameterDeclaration> ScenarioDefinitionImpl::GetParameterDeclarationsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _parameterDeclarations.size() > index)
            {
                return _parameterDeclarations[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<IVariableDeclaration>> ScenarioDefinitionImpl::GetVariableDeclarations() const
        {
            std::vector<std::shared_ptr<IVariableDeclaration>> temp;
            for(auto&& elm: _variableDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IVariableDeclarationWriter>> ScenarioDefinitionImpl::GetWriterVariableDeclarations() const
        {
            return _variableDeclarations;
        }

        int ScenarioDefinitionImpl::GetVariableDeclarationsSize() const
        {
            return static_cast<int>(_variableDeclarations.size());
        }

        std::shared_ptr<IVariableDeclaration> ScenarioDefinitionImpl::GetVariableDeclarationsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _variableDeclarations.size() > index)
            {
                return _variableDeclarations[index];
            }
            return nullptr;
        }
        std::shared_ptr<ICatalogLocations> ScenarioDefinitionImpl::GetCatalogLocations() const
        {
        	  return _catalogLocations;
        }
        std::shared_ptr<IRoadNetwork> ScenarioDefinitionImpl::GetRoadNetwork() const
        {
        	  return _roadNetwork;
        }
        std::shared_ptr<IEntities> ScenarioDefinitionImpl::GetEntities() const
        {
        	  return _entities;
        }
        std::shared_ptr<IStoryboard> ScenarioDefinitionImpl::GetStoryboard() const
        {
        	  return _storyboard;
        }


        void ScenarioDefinitionImpl::SetParameterDeclarations(std::vector<std::shared_ptr<IParameterDeclarationWriter>>& parameterDeclarations)
        {
            _parameterDeclarations = parameterDeclarations;
			// set the indicator to true
            isSetParameterDeclarations = true;          
        }

        void ScenarioDefinitionImpl::SetVariableDeclarations(std::vector<std::shared_ptr<IVariableDeclarationWriter>>& variableDeclarations)
        {
            _variableDeclarations = variableDeclarations;
			// set the indicator to true
            isSetVariableDeclarations = true;          
        }

        void ScenarioDefinitionImpl::SetCatalogLocations(std::shared_ptr<ICatalogLocationsWriter> catalogLocations)
        {
            _catalogLocations = catalogLocations;
        }

        void ScenarioDefinitionImpl::SetRoadNetwork(std::shared_ptr<IRoadNetworkWriter> roadNetwork)
        {
            _roadNetwork = roadNetwork;
        }

        void ScenarioDefinitionImpl::SetEntities(std::shared_ptr<IEntitiesWriter> entities)
        {
            _entities = entities;
        }

        void ScenarioDefinitionImpl::SetStoryboard(std::shared_ptr<IStoryboardWriter> storyboard)
        {
            _storyboard = storyboard;
        }

        std::shared_ptr<void> ScenarioDefinitionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ScenarioDefinitionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IScenarioDefinition).name())
                return std::dynamic_pointer_cast<IScenarioDefinition>(shared_from_this());
            else if (classifier == typeid(IScenarioDefinitionWriter).name())
                return std::dynamic_pointer_cast<IScenarioDefinitionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ScenarioDefinitionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ScenarioDefinitionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ScenarioDefinitionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ScenarioDefinitionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ScenarioDefinitionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ScenarioDefinitionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ScenarioDefinitionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ScenarioDefinitionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ScenarioDefinitionImpl::GetModelType() const
        {
            return "ScenarioDefinition";
        }

            // children
        std::shared_ptr<ICatalogLocationsWriter> ScenarioDefinitionImpl::GetWriterCatalogLocations() const
        {
            return std::dynamic_pointer_cast<ICatalogLocationsWriter>(_catalogLocations);
        }
        std::shared_ptr<IRoadNetworkWriter> ScenarioDefinitionImpl::GetWriterRoadNetwork() const
        {
            return std::dynamic_pointer_cast<IRoadNetworkWriter>(_roadNetwork);
        }
        std::shared_ptr<IEntitiesWriter> ScenarioDefinitionImpl::GetWriterEntities() const
        {
            return std::dynamic_pointer_cast<IEntitiesWriter>(_entities);
        }
        std::shared_ptr<IStoryboardWriter> ScenarioDefinitionImpl::GetWriterStoryboard() const
        {
            return std::dynamic_pointer_cast<IStoryboardWriter>(_storyboard);
        }

        ScenarioDefinitionImpl::ScenarioDefinitionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ScenarioDefinitionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ScenarioDefinitionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool ScenarioDefinitionImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> ScenarioDefinitionImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ScenarioDefinitionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto variableDeclarations =  GetWriterVariableDeclarations();
                if (!variableDeclarations.empty())
                {
                    for(auto&& item : variableDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kCatalogLocations =  GetWriterCatalogLocations();
                if (kCatalogLocations)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogLocations));
                }
                const auto kRoadNetwork =  GetWriterRoadNetwork();
                if (kRoadNetwork)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRoadNetwork));
                }
                const auto kEntities =  GetWriterEntities();
                if (kEntities)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEntities));
                }
                const auto kStoryboard =  GetWriterStoryboard();
                if (kStoryboard)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kStoryboard));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ScenarioDefinitionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ScenarioDefinitionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kVariableDeclarations =  GetWriterVariableDeclarations();
            if (!kVariableDeclarations.empty())
            {
                std::vector<std::shared_ptr<IVariableDeclarationWriter>> clonedList;
                for(auto&& kItem : kVariableDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<VariableDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IVariableDeclarationWriter>(clonedChild));
                }
                clonedObject->SetVariableDeclarations(clonedList);
            }
            const auto kCatalogLocations =  GetWriterCatalogLocations();
            if (kCatalogLocations)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogLocationsImpl>(kCatalogLocations)->Clone();
                auto clonedChildICatalogLocations = std::dynamic_pointer_cast<ICatalogLocations>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogLocations(std::dynamic_pointer_cast<ICatalogLocationsWriter>(clonedChildICatalogLocations));
            }
            const auto kRoadNetwork =  GetWriterRoadNetwork();
            if (kRoadNetwork)
            {
                auto clonedChild = std::dynamic_pointer_cast<RoadNetworkImpl>(kRoadNetwork)->Clone();
                auto clonedChildIRoadNetwork = std::dynamic_pointer_cast<IRoadNetwork>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRoadNetwork(std::dynamic_pointer_cast<IRoadNetworkWriter>(clonedChildIRoadNetwork));
            }
            const auto kEntities =  GetWriterEntities();
            if (kEntities)
            {
                auto clonedChild = std::dynamic_pointer_cast<EntitiesImpl>(kEntities)->Clone();
                auto clonedChildIEntities = std::dynamic_pointer_cast<IEntities>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEntities(std::dynamic_pointer_cast<IEntitiesWriter>(clonedChildIEntities));
            }
            const auto kStoryboard =  GetWriterStoryboard();
            if (kStoryboard)
            {
                auto clonedChild = std::dynamic_pointer_cast<StoryboardImpl>(kStoryboard)->Clone();
                auto clonedChildIStoryboard = std::dynamic_pointer_cast<IStoryboard>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetStoryboard(std::dynamic_pointer_cast<IStoryboardWriter>(clonedChildIStoryboard));
            }
            return clonedObject;
        }

        std::string ScenarioDefinitionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ScenarioDefinitionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_LOCATIONS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogLocations());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ROAD_NETWORK)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRoadNetwork());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ENTITIES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEntities());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__STORYBOARD)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetStoryboard());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ScenarioDefinitionImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }            if (key == OSC_CONSTANTS::ELEMENT__VARIABLE_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetVariableDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ScenarioDefinitionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ScenarioDefinitionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void ScenarioDefinitionImpl::ResetParameterDeclarations()
	   {
	   		isSetParameterDeclarations = false; 
			_parameterDeclarations = {};
			
	   }
       bool ScenarioDefinitionImpl::IsSetParameterDeclarations() const
	   {
			return isSetParameterDeclarations;
	   }
       void ScenarioDefinitionImpl::ResetVariableDeclarations()
	   {
	   		isSetVariableDeclarations = false; 
			_variableDeclarations = {};
			
	   }
       bool ScenarioDefinitionImpl::IsSetVariableDeclarations() const
	   {
			return isSetVariableDeclarations;
	   }

        IOpenScenarioFlexElement* ScenarioObjectImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string ScenarioObjectImpl::GetName() const
        {
        	  return _name;
        }
        std::shared_ptr<IEntityObject> ScenarioObjectImpl::GetEntityObject() const
        {
        	  return _entityObject;
        }
        std::vector<std::shared_ptr<IObjectController>> ScenarioObjectImpl::GetObjectController() const
        {
            std::vector<std::shared_ptr<IObjectController>> temp;
            for(auto&& elm: _objectController)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IObjectControllerWriter>> ScenarioObjectImpl::GetWriterObjectController() const
        {
            return _objectController;
        }

        int ScenarioObjectImpl::GetObjectControllerSize() const
        {
            return static_cast<int>(_objectController.size());
        }

        std::shared_ptr<IObjectController> ScenarioObjectImpl::GetObjectControllerAtIndex(unsigned int index) const
        {
            if (index >= 0 && _objectController.size() > index)
            {
                return _objectController[index];
            }
            return nullptr;
        }


        void ScenarioObjectImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void ScenarioObjectImpl::SetEntityObject(std::shared_ptr<IEntityObjectWriter> entityObject)
        {
            _entityObject = entityObject;
        }

        void ScenarioObjectImpl::SetObjectController(std::vector<std::shared_ptr<IObjectControllerWriter>>& objectController)
        {
            _objectController = objectController;
			// set the indicator to true
            isSetObjectController = true;          
        }

        std::shared_ptr<void> ScenarioObjectImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ScenarioObjectImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IScenarioObject).name())
                return std::dynamic_pointer_cast<IScenarioObject>(shared_from_this());
            else if (classifier == typeid(IScenarioObjectWriter).name())
                return std::dynamic_pointer_cast<IScenarioObjectWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ScenarioObjectImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ScenarioObjectImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ScenarioObjectImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ScenarioObjectImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ScenarioObjectImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ScenarioObjectImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ScenarioObjectImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ScenarioObjectImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ScenarioObjectImpl::GetModelType() const
        {
            return "ScenarioObject";
        }

        void ScenarioObjectImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        std::string ScenarioObjectImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        bool ScenarioObjectImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IEntityObjectWriter> ScenarioObjectImpl::GetWriterEntityObject() const
        {
            return std::dynamic_pointer_cast<IEntityObjectWriter>(_entityObject);
        }

        ScenarioObjectImpl::ScenarioObjectImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        void ScenarioObjectImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ScenarioObjectImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ScenarioObjectImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kEntityObject =  GetWriterEntityObject();
                if (kEntityObject)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEntityObject));
                }
                auto objectController =  GetWriterObjectController();
                if (!objectController.empty())
                {
                    for(auto&& item : objectController)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ScenarioObjectImpl::Clone()
        {
            auto clonedObject = std::make_shared<ScenarioObjectImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone indicators
            // clone children
            const auto kEntityObject =  GetWriterEntityObject();
            if (kEntityObject)
            {
                auto clonedChild = std::dynamic_pointer_cast<EntityObjectImpl>(kEntityObject)->Clone();
                auto clonedChildIEntityObject = std::dynamic_pointer_cast<IEntityObject>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEntityObject(std::dynamic_pointer_cast<IEntityObjectWriter>(clonedChildIEntityObject));
            }
            const auto kObjectController =  GetWriterObjectController();
            if (!kObjectController.empty())
            {
                std::vector<std::shared_ptr<IObjectControllerWriter>> clonedList;
                for(auto&& kItem : kObjectController)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ObjectControllerImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IObjectControllerWriter>(clonedChild));
                }
                clonedObject->SetObjectController(clonedList);
            }
            return clonedObject;
        }

        std::string ScenarioObjectImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ScenarioObjectImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_OBJECT)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEntityObject());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ScenarioObjectImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__OBJECT_CONTROLLER)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetObjectController())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ScenarioObjectImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ScenarioObjectImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void ScenarioObjectImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void ScenarioObjectImpl::ResetObjectController()
	   {
	   		isSetObjectController = false; 
			_objectController = {};
			
	   }
       bool ScenarioObjectImpl::IsSetObjectController() const
	   {
			return isSetObjectController;
	   }

        IOpenScenarioFlexElement* SelectedEntitiesImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<IEntityRef>> SelectedEntitiesImpl::GetEntityRef() const
        {
            std::vector<std::shared_ptr<IEntityRef>> temp;
            for(auto&& elm: _entityRef)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IEntityRefWriter>> SelectedEntitiesImpl::GetWriterEntityRef() const
        {
            return _entityRef;
        }

        int SelectedEntitiesImpl::GetEntityRefSize() const
        {
            return static_cast<int>(_entityRef.size());
        }

        std::shared_ptr<IEntityRef> SelectedEntitiesImpl::GetEntityRefAtIndex(unsigned int index) const
        {
            if (index >= 0 && _entityRef.size() > index)
            {
                return _entityRef[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<IByType>> SelectedEntitiesImpl::GetByType() const
        {
            std::vector<std::shared_ptr<IByType>> temp;
            for(auto&& elm: _byType)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IByTypeWriter>> SelectedEntitiesImpl::GetWriterByType() const
        {
            return _byType;
        }

        int SelectedEntitiesImpl::GetByTypeSize() const
        {
            return static_cast<int>(_byType.size());
        }

        std::shared_ptr<IByType> SelectedEntitiesImpl::GetByTypeAtIndex(unsigned int index) const
        {
            if (index >= 0 && _byType.size() > index)
            {
                return _byType[index];
            }
            return nullptr;
        }


        void SelectedEntitiesImpl::SetEntityRef(std::vector<std::shared_ptr<IEntityRefWriter>>& entityRef)
        {
            _entityRef = entityRef;
            _byType = {};
			// set the indicator to true
            isSetEntityRef = true;          
        }

        void SelectedEntitiesImpl::SetByType(std::vector<std::shared_ptr<IByTypeWriter>>& byType)
        {
            _byType = byType;
            _entityRef = {};
			// set the indicator to true
            isSetByType = true;          
        }

        std::shared_ptr<void> SelectedEntitiesImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(SelectedEntitiesImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ISelectedEntities).name())
                return std::dynamic_pointer_cast<ISelectedEntities>(shared_from_this());
            else if (classifier == typeid(ISelectedEntitiesWriter).name())
                return std::dynamic_pointer_cast<ISelectedEntitiesWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> SelectedEntitiesImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t SelectedEntitiesImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int SelectedEntitiesImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double SelectedEntitiesImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t SelectedEntitiesImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool SelectedEntitiesImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime SelectedEntitiesImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> SelectedEntitiesImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string SelectedEntitiesImpl::GetModelType() const
        {
            return "SelectedEntities";
        }

            // children

        SelectedEntitiesImpl::SelectedEntitiesImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void SelectedEntitiesImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType SelectedEntitiesImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SelectedEntitiesImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto entityRef =  GetWriterEntityRef();
                if (!entityRef.empty())
                {
                    for(auto&& item : entityRef)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto byType =  GetWriterByType();
                if (!byType.empty())
                {
                    for(auto&& item : byType)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SelectedEntitiesImpl::Clone()
        {
            auto clonedObject = std::make_shared<SelectedEntitiesImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kEntityRef =  GetWriterEntityRef();
            if (!kEntityRef.empty())
            {
                std::vector<std::shared_ptr<IEntityRefWriter>> clonedList;
                for(auto&& kItem : kEntityRef)
                {
                    auto clonedChild = std::dynamic_pointer_cast<EntityRefImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IEntityRefWriter>(clonedChild));
                }
                clonedObject->SetEntityRef(clonedList);
            }
            const auto kByType =  GetWriterByType();
            if (!kByType.empty())
            {
                std::vector<std::shared_ptr<IByTypeWriter>> clonedList;
                for(auto&& kItem : kByType)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ByTypeImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IByTypeWriter>(clonedChild));
                }
                clonedObject->SetByType(clonedList);
            }
            return clonedObject;
        }

        std::string SelectedEntitiesImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SelectedEntitiesImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SelectedEntitiesImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_REF)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetEntityRef())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__BY_TYPE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetByType())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SelectedEntitiesImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string SelectedEntitiesImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void SelectedEntitiesImpl::ResetEntityRef()
	   {
	   		isSetEntityRef = false; 
			_entityRef = {};
			
	   }
       bool SelectedEntitiesImpl::IsSetEntityRef() const
	   {
			return isSetEntityRef;
	   }
       void SelectedEntitiesImpl::ResetByType()
	   {
	   		isSetByType = false; 
			_byType = {};
			
	   }
       bool SelectedEntitiesImpl::IsSetByType() const
	   {
			return isSetByType;
	   }

        IOpenScenarioFlexElement* SensorReferenceImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string SensorReferenceImpl::GetName() const
        {
        	  return _name;
        }


        void SensorReferenceImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        std::shared_ptr<void> SensorReferenceImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(SensorReferenceImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ISensorReference).name())
                return std::dynamic_pointer_cast<ISensorReference>(shared_from_this());
            else if (classifier == typeid(ISensorReferenceWriter).name())
                return std::dynamic_pointer_cast<ISensorReferenceWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> SensorReferenceImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t SensorReferenceImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int SensorReferenceImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double SensorReferenceImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t SensorReferenceImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool SensorReferenceImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime SensorReferenceImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> SensorReferenceImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string SensorReferenceImpl::GetModelType() const
        {
            return "SensorReference";
        }

        void SensorReferenceImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        std::string SensorReferenceImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        bool SensorReferenceImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        SensorReferenceImpl::SensorReferenceImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        void SensorReferenceImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType SensorReferenceImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SensorReferenceImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SensorReferenceImpl::Clone()
        {
            auto clonedObject = std::make_shared<SensorReferenceImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string SensorReferenceImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SensorReferenceImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SensorReferenceImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SensorReferenceImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string SensorReferenceImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void SensorReferenceImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* SensorReferenceSetImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<ISensorReference>> SensorReferenceSetImpl::GetSensorReferences() const
        {
            std::vector<std::shared_ptr<ISensorReference>> temp;
            for(auto&& elm: _sensorReferences)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<ISensorReferenceWriter>> SensorReferenceSetImpl::GetWriterSensorReferences() const
        {
            return _sensorReferences;
        }

        int SensorReferenceSetImpl::GetSensorReferencesSize() const
        {
            return static_cast<int>(_sensorReferences.size());
        }

        std::shared_ptr<ISensorReference> SensorReferenceSetImpl::GetSensorReferencesAtIndex(unsigned int index) const
        {
            if (index >= 0 && _sensorReferences.size() > index)
            {
                return _sensorReferences[index];
            }
            return nullptr;
        }


        void SensorReferenceSetImpl::SetSensorReferences(std::vector<std::shared_ptr<ISensorReferenceWriter>>& sensorReferences)
        {
            _sensorReferences = sensorReferences;
        }

        std::shared_ptr<void> SensorReferenceSetImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(SensorReferenceSetImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ISensorReferenceSet).name())
                return std::dynamic_pointer_cast<ISensorReferenceSet>(shared_from_this());
            else if (classifier == typeid(ISensorReferenceSetWriter).name())
                return std::dynamic_pointer_cast<ISensorReferenceSetWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> SensorReferenceSetImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t SensorReferenceSetImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int SensorReferenceSetImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double SensorReferenceSetImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t SensorReferenceSetImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool SensorReferenceSetImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime SensorReferenceSetImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> SensorReferenceSetImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string SensorReferenceSetImpl::GetModelType() const
        {
            return "SensorReferenceSet";
        }

            // children

        SensorReferenceSetImpl::SensorReferenceSetImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void SensorReferenceSetImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType SensorReferenceSetImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SensorReferenceSetImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto sensorReferences =  GetWriterSensorReferences();
                if (!sensorReferences.empty())
                {
                    for(auto&& item : sensorReferences)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SensorReferenceSetImpl::Clone()
        {
            auto clonedObject = std::make_shared<SensorReferenceSetImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kSensorReferences =  GetWriterSensorReferences();
            if (!kSensorReferences.empty())
            {
                std::vector<std::shared_ptr<ISensorReferenceWriter>> clonedList;
                for(auto&& kItem : kSensorReferences)
                {
                    auto clonedChild = std::dynamic_pointer_cast<SensorReferenceImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<ISensorReferenceWriter>(clonedChild));
                }
                clonedObject->SetSensorReferences(clonedList);
            }
            return clonedObject;
        }

        std::string SensorReferenceSetImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SensorReferenceSetImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SensorReferenceSetImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__SENSOR_REFERENCE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetSensorReferences())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SensorReferenceSetImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string SensorReferenceSetImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ShapeImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IPolyline> ShapeImpl::GetPolyline() const
        {
        	  return _polyline;
        }
        std::shared_ptr<IClothoid> ShapeImpl::GetClothoid() const
        {
        	  return _clothoid;
        }
        std::shared_ptr<INurbs> ShapeImpl::GetNurbs() const
        {
        	  return _nurbs;
        }


        void ShapeImpl::SetPolyline(std::shared_ptr<IPolylineWriter> polyline)
        {
            _polyline = polyline;
            _clothoid = {};
            _nurbs = {};
			// set the indicator to true
            isSetPolyline = true;          
        }

        void ShapeImpl::SetClothoid(std::shared_ptr<IClothoidWriter> clothoid)
        {
            _clothoid = clothoid;
            _polyline = {};
            _nurbs = {};
			// set the indicator to true
            isSetClothoid = true;          
        }

        void ShapeImpl::SetNurbs(std::shared_ptr<INurbsWriter> nurbs)
        {
            _nurbs = nurbs;
            _polyline = {};
            _clothoid = {};
			// set the indicator to true
            isSetNurbs = true;          
        }

        std::shared_ptr<void> ShapeImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ShapeImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IShape).name())
                return std::dynamic_pointer_cast<IShape>(shared_from_this());
            else if (classifier == typeid(IShapeWriter).name())
                return std::dynamic_pointer_cast<IShapeWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ShapeImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ShapeImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ShapeImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ShapeImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ShapeImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ShapeImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ShapeImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ShapeImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ShapeImpl::GetModelType() const
        {
            return "Shape";
        }

            // children
        std::shared_ptr<IPolylineWriter> ShapeImpl::GetWriterPolyline() const
        {
            return std::dynamic_pointer_cast<IPolylineWriter>(_polyline);
        }
        std::shared_ptr<IClothoidWriter> ShapeImpl::GetWriterClothoid() const
        {
            return std::dynamic_pointer_cast<IClothoidWriter>(_clothoid);
        }
        std::shared_ptr<INurbsWriter> ShapeImpl::GetWriterNurbs() const
        {
            return std::dynamic_pointer_cast<INurbsWriter>(_nurbs);
        }

        ShapeImpl::ShapeImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ShapeImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ShapeImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ShapeImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPolyline =  GetWriterPolyline();
                if (kPolyline)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPolyline));
                }
                const auto kClothoid =  GetWriterClothoid();
                if (kClothoid)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kClothoid));
                }
                const auto kNurbs =  GetWriterNurbs();
                if (kNurbs)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kNurbs));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ShapeImpl::Clone()
        {
            auto clonedObject = std::make_shared<ShapeImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kPolyline =  GetWriterPolyline();
            if (kPolyline)
            {
                auto clonedChild = std::dynamic_pointer_cast<PolylineImpl>(kPolyline)->Clone();
                auto clonedChildIPolyline = std::dynamic_pointer_cast<IPolyline>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPolyline(std::dynamic_pointer_cast<IPolylineWriter>(clonedChildIPolyline));
            }
            const auto kClothoid =  GetWriterClothoid();
            if (kClothoid)
            {
                auto clonedChild = std::dynamic_pointer_cast<ClothoidImpl>(kClothoid)->Clone();
                auto clonedChildIClothoid = std::dynamic_pointer_cast<IClothoid>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetClothoid(std::dynamic_pointer_cast<IClothoidWriter>(clonedChildIClothoid));
            }
            const auto kNurbs =  GetWriterNurbs();
            if (kNurbs)
            {
                auto clonedChild = std::dynamic_pointer_cast<NurbsImpl>(kNurbs)->Clone();
                auto clonedChildINurbs = std::dynamic_pointer_cast<INurbs>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetNurbs(std::dynamic_pointer_cast<INurbsWriter>(clonedChildINurbs));
            }
            return clonedObject;
        }

        std::string ShapeImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ShapeImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POLYLINE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPolyline());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CLOTHOID)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetClothoid());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__NURBS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetNurbs());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ShapeImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ShapeImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ShapeImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void ShapeImpl::ResetPolyline()
	   {
	   		isSetPolyline = false; 
			_polyline = {};
			
	   }
       bool ShapeImpl::IsSetPolyline() const
	   {
			return isSetPolyline;
	   }
       void ShapeImpl::ResetClothoid()
	   {
	   		isSetClothoid = false; 
			_clothoid = {};
			
	   }
       bool ShapeImpl::IsSetClothoid() const
	   {
			return isSetClothoid;
	   }
       void ShapeImpl::ResetNurbs()
	   {
	   		isSetNurbs = false; 
			_nurbs = {};
			
	   }
       bool ShapeImpl::IsSetNurbs() const
	   {
			return isSetNurbs;
	   }

        IOpenScenarioFlexElement* SimulationTimeConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        Rule SimulationTimeConditionImpl::GetRule() const
        {
        	  return _rule;
        }
        double SimulationTimeConditionImpl::GetValue() const
        {
        	  return _value;
        }


        void SimulationTimeConditionImpl::SetRule(const Rule rule)
        {
            _rule = rule;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE);
        }

        void SimulationTimeConditionImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> SimulationTimeConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(SimulationTimeConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ISimulationTimeCondition).name())
                return std::dynamic_pointer_cast<ISimulationTimeCondition>(shared_from_this());
            else if (classifier == typeid(ISimulationTimeConditionWriter).name())
                return std::dynamic_pointer_cast<ISimulationTimeConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> SimulationTimeConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t SimulationTimeConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int SimulationTimeConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double SimulationTimeConditionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t SimulationTimeConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool SimulationTimeConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime SimulationTimeConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> SimulationTimeConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string SimulationTimeConditionImpl::GetModelType() const
        {
            return "SimulationTimeCondition";
        }

        void SimulationTimeConditionImpl::WriteParameterToRule(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE, parameterName, nullTextMarker /*no textmarker*/);
            _rule = {};
        }

        void SimulationTimeConditionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string SimulationTimeConditionImpl::GetParameterFromRule() const
        {
            auto rule = OSC_CONSTANTS::ATTRIBUTE__RULE;
            return GetParameterNameFromAttribute(rule);
        }

        std::string SimulationTimeConditionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool SimulationTimeConditionImpl::IsRuleParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RULE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool SimulationTimeConditionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        SimulationTimeConditionImpl::SimulationTimeConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void SimulationTimeConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType SimulationTimeConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SimulationTimeConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SimulationTimeConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<SimulationTimeConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string SimulationTimeConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SimulationTimeConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SimulationTimeConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SimulationTimeConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string SimulationTimeConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void SimulationTimeConditionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* SpeedActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<ITransitionDynamics> SpeedActionImpl::GetSpeedActionDynamics() const
        {
        	  return _speedActionDynamics;
        }
        std::shared_ptr<ISpeedActionTarget> SpeedActionImpl::GetSpeedActionTarget() const
        {
        	  return _speedActionTarget;
        }


        void SpeedActionImpl::SetSpeedActionDynamics(std::shared_ptr<ITransitionDynamicsWriter> speedActionDynamics)
        {
            _speedActionDynamics = speedActionDynamics;
        }

        void SpeedActionImpl::SetSpeedActionTarget(std::shared_ptr<ISpeedActionTargetWriter> speedActionTarget)
        {
            _speedActionTarget = speedActionTarget;
        }

        std::shared_ptr<void> SpeedActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(SpeedActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ISpeedAction).name())
                return std::dynamic_pointer_cast<ISpeedAction>(shared_from_this());
            else if (classifier == typeid(ISpeedActionWriter).name())
                return std::dynamic_pointer_cast<ISpeedActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> SpeedActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t SpeedActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int SpeedActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double SpeedActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t SpeedActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool SpeedActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime SpeedActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> SpeedActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string SpeedActionImpl::GetModelType() const
        {
            return "SpeedAction";
        }

            // children
        std::shared_ptr<ITransitionDynamicsWriter> SpeedActionImpl::GetWriterSpeedActionDynamics() const
        {
            return std::dynamic_pointer_cast<ITransitionDynamicsWriter>(_speedActionDynamics);
        }
        std::shared_ptr<ISpeedActionTargetWriter> SpeedActionImpl::GetWriterSpeedActionTarget() const
        {
            return std::dynamic_pointer_cast<ISpeedActionTargetWriter>(_speedActionTarget);
        }

        SpeedActionImpl::SpeedActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void SpeedActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType SpeedActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SpeedActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kSpeedActionDynamics =  GetWriterSpeedActionDynamics();
                if (kSpeedActionDynamics)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSpeedActionDynamics));
                }
                const auto kSpeedActionTarget =  GetWriterSpeedActionTarget();
                if (kSpeedActionTarget)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSpeedActionTarget));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SpeedActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<SpeedActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kSpeedActionDynamics =  GetWriterSpeedActionDynamics();
            if (kSpeedActionDynamics)
            {
                auto clonedChild = std::dynamic_pointer_cast<TransitionDynamicsImpl>(kSpeedActionDynamics)->Clone();
                auto clonedChildITransitionDynamics = std::dynamic_pointer_cast<ITransitionDynamics>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSpeedActionDynamics(std::dynamic_pointer_cast<ITransitionDynamicsWriter>(clonedChildITransitionDynamics));
            }
            const auto kSpeedActionTarget =  GetWriterSpeedActionTarget();
            if (kSpeedActionTarget)
            {
                auto clonedChild = std::dynamic_pointer_cast<SpeedActionTargetImpl>(kSpeedActionTarget)->Clone();
                auto clonedChildISpeedActionTarget = std::dynamic_pointer_cast<ISpeedActionTarget>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSpeedActionTarget(std::dynamic_pointer_cast<ISpeedActionTargetWriter>(clonedChildISpeedActionTarget));
            }
            return clonedObject;
        }

        std::string SpeedActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SpeedActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SPEED_ACTION_DYNAMICS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSpeedActionDynamics());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SPEED_ACTION_TARGET)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSpeedActionTarget());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SpeedActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SpeedActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string SpeedActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* SpeedActionTargetImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IRelativeTargetSpeed> SpeedActionTargetImpl::GetRelativeTargetSpeed() const
        {
        	  return _relativeTargetSpeed;
        }
        std::shared_ptr<IAbsoluteTargetSpeed> SpeedActionTargetImpl::GetAbsoluteTargetSpeed() const
        {
        	  return _absoluteTargetSpeed;
        }


        void SpeedActionTargetImpl::SetRelativeTargetSpeed(std::shared_ptr<IRelativeTargetSpeedWriter> relativeTargetSpeed)
        {
            _relativeTargetSpeed = relativeTargetSpeed;
            _absoluteTargetSpeed = {};
			// set the indicator to true
            isSetRelativeTargetSpeed = true;          
        }

        void SpeedActionTargetImpl::SetAbsoluteTargetSpeed(std::shared_ptr<IAbsoluteTargetSpeedWriter> absoluteTargetSpeed)
        {
            _absoluteTargetSpeed = absoluteTargetSpeed;
            _relativeTargetSpeed = {};
			// set the indicator to true
            isSetAbsoluteTargetSpeed = true;          
        }

        std::shared_ptr<void> SpeedActionTargetImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(SpeedActionTargetImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ISpeedActionTarget).name())
                return std::dynamic_pointer_cast<ISpeedActionTarget>(shared_from_this());
            else if (classifier == typeid(ISpeedActionTargetWriter).name())
                return std::dynamic_pointer_cast<ISpeedActionTargetWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> SpeedActionTargetImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t SpeedActionTargetImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int SpeedActionTargetImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double SpeedActionTargetImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t SpeedActionTargetImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool SpeedActionTargetImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime SpeedActionTargetImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> SpeedActionTargetImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string SpeedActionTargetImpl::GetModelType() const
        {
            return "SpeedActionTarget";
        }

            // children
        std::shared_ptr<IRelativeTargetSpeedWriter> SpeedActionTargetImpl::GetWriterRelativeTargetSpeed() const
        {
            return std::dynamic_pointer_cast<IRelativeTargetSpeedWriter>(_relativeTargetSpeed);
        }
        std::shared_ptr<IAbsoluteTargetSpeedWriter> SpeedActionTargetImpl::GetWriterAbsoluteTargetSpeed() const
        {
            return std::dynamic_pointer_cast<IAbsoluteTargetSpeedWriter>(_absoluteTargetSpeed);
        }

        SpeedActionTargetImpl::SpeedActionTargetImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void SpeedActionTargetImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType SpeedActionTargetImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SpeedActionTargetImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRelativeTargetSpeed =  GetWriterRelativeTargetSpeed();
                if (kRelativeTargetSpeed)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeTargetSpeed));
                }
                const auto kAbsoluteTargetSpeed =  GetWriterAbsoluteTargetSpeed();
                if (kAbsoluteTargetSpeed)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAbsoluteTargetSpeed));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SpeedActionTargetImpl::Clone()
        {
            auto clonedObject = std::make_shared<SpeedActionTargetImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kRelativeTargetSpeed =  GetWriterRelativeTargetSpeed();
            if (kRelativeTargetSpeed)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeTargetSpeedImpl>(kRelativeTargetSpeed)->Clone();
                auto clonedChildIRelativeTargetSpeed = std::dynamic_pointer_cast<IRelativeTargetSpeed>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeTargetSpeed(std::dynamic_pointer_cast<IRelativeTargetSpeedWriter>(clonedChildIRelativeTargetSpeed));
            }
            const auto kAbsoluteTargetSpeed =  GetWriterAbsoluteTargetSpeed();
            if (kAbsoluteTargetSpeed)
            {
                auto clonedChild = std::dynamic_pointer_cast<AbsoluteTargetSpeedImpl>(kAbsoluteTargetSpeed)->Clone();
                auto clonedChildIAbsoluteTargetSpeed = std::dynamic_pointer_cast<IAbsoluteTargetSpeed>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAbsoluteTargetSpeed(std::dynamic_pointer_cast<IAbsoluteTargetSpeedWriter>(clonedChildIAbsoluteTargetSpeed));
            }
            return clonedObject;
        }

        std::string SpeedActionTargetImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SpeedActionTargetImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_TARGET_SPEED)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeTargetSpeed());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ABSOLUTE_TARGET_SPEED)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAbsoluteTargetSpeed());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SpeedActionTargetImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SpeedActionTargetImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string SpeedActionTargetImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void SpeedActionTargetImpl::ResetRelativeTargetSpeed()
	   {
	   		isSetRelativeTargetSpeed = false; 
			_relativeTargetSpeed = {};
			
	   }
       bool SpeedActionTargetImpl::IsSetRelativeTargetSpeed() const
	   {
			return isSetRelativeTargetSpeed;
	   }
       void SpeedActionTargetImpl::ResetAbsoluteTargetSpeed()
	   {
	   		isSetAbsoluteTargetSpeed = false; 
			_absoluteTargetSpeed = {};
			
	   }
       bool SpeedActionTargetImpl::IsSetAbsoluteTargetSpeed() const
	   {
			return isSetAbsoluteTargetSpeed;
	   }

        IOpenScenarioFlexElement* SpeedConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        DirectionalDimension SpeedConditionImpl::GetDirection() const
        {
        	  return _direction;
        }
        Rule SpeedConditionImpl::GetRule() const
        {
        	  return _rule;
        }
        double SpeedConditionImpl::GetValue() const
        {
        	  return _value;
        }


        void SpeedConditionImpl::SetDirection(const DirectionalDimension direction)
        {
            _direction = direction;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DIRECTION);
			// set the indicator to true
            isSetDirection = true;          
        }

        void SpeedConditionImpl::SetRule(const Rule rule)
        {
            _rule = rule;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE);
        }

        void SpeedConditionImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> SpeedConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(SpeedConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ISpeedCondition).name())
                return std::dynamic_pointer_cast<ISpeedCondition>(shared_from_this());
            else if (classifier == typeid(ISpeedConditionWriter).name())
                return std::dynamic_pointer_cast<ISpeedConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> SpeedConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t SpeedConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int SpeedConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double SpeedConditionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t SpeedConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool SpeedConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime SpeedConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> SpeedConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string SpeedConditionImpl::GetModelType() const
        {
            return "SpeedCondition";
        }

        void SpeedConditionImpl::WriteParameterToDirection(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DIRECTION, parameterName, nullTextMarker /*no textmarker*/);
            _direction = {};
        }

        void SpeedConditionImpl::WriteParameterToRule(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE, parameterName, nullTextMarker /*no textmarker*/);
            _rule = {};
        }

        void SpeedConditionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string SpeedConditionImpl::GetParameterFromDirection() const
        {
            auto direction = OSC_CONSTANTS::ATTRIBUTE__DIRECTION;
            return GetParameterNameFromAttribute(direction);
        }

        std::string SpeedConditionImpl::GetParameterFromRule() const
        {
            auto rule = OSC_CONSTANTS::ATTRIBUTE__RULE;
            return GetParameterNameFromAttribute(rule);
        }

        std::string SpeedConditionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool SpeedConditionImpl::IsDirectionParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DIRECTION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool SpeedConditionImpl::IsRuleParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RULE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool SpeedConditionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        SpeedConditionImpl::SpeedConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DIRECTION, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void SpeedConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DIRECTION)
            {
                // Enumeration Type
                const auto kResult = DirectionalDimension::GetFromLiteral(parameterLiteralValue);
                if (kResult != DirectionalDimension::UNKNOWN)
                {
                    _direction = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType SpeedConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SpeedConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SpeedConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<SpeedConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kDirection = GetDirection();
            if ( kDirection.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_direction = DirectionalDimension::GetFromLiteral(kDirection.GetLiteral());
            }
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            	clonedObject->isSetDirection = isSetDirection;
            // clone children
            return clonedObject;
        }

        std::string SpeedConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SpeedConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SpeedConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SpeedConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string SpeedConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__DIRECTION)
            {
                auto direction = GetDirection();
                return direction.GetLiteral() != "UNKNOWN" ? direction.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void SpeedConditionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void SpeedConditionImpl::ResetDirection()
	   {
	   		isSetDirection = false; 
			_direction = {};
			
	   }
       bool SpeedConditionImpl::IsSetDirection() const
	   {
			return isSetDirection;
	   }

        IOpenScenarioFlexElement* SpeedProfileActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<INamedReference<IEntity>> SpeedProfileActionImpl::GetEntityRef() const
        {
        	 return _entityRef;
        }
        FollowingMode SpeedProfileActionImpl::GetFollowingMode() const
        {
        	  return _followingMode;
        }
        std::shared_ptr<IDynamicConstraints> SpeedProfileActionImpl::GetDynamicConstraints() const
        {
        	  return _dynamicConstraints;
        }
        std::vector<std::shared_ptr<ISpeedProfileEntry>> SpeedProfileActionImpl::GetSpeedProfileEntry() const
        {
            std::vector<std::shared_ptr<ISpeedProfileEntry>> temp;
            for(auto&& elm: _speedProfileEntry)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<ISpeedProfileEntryWriter>> SpeedProfileActionImpl::GetWriterSpeedProfileEntry() const
        {
            return _speedProfileEntry;
        }

        int SpeedProfileActionImpl::GetSpeedProfileEntrySize() const
        {
            return static_cast<int>(_speedProfileEntry.size());
        }

        std::shared_ptr<ISpeedProfileEntry> SpeedProfileActionImpl::GetSpeedProfileEntryAtIndex(unsigned int index) const
        {
            if (index >= 0 && _speedProfileEntry.size() > index)
            {
                return _speedProfileEntry[index];
            }
            return nullptr;
        }


        void SpeedProfileActionImpl::SetEntityRef(std::shared_ptr<INamedReference<IEntity>> entityRef)
        {
            _entityRef = entityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
			// set the indicator to true
            isSetEntityRef = true;          
        }

        void SpeedProfileActionImpl::SetFollowingMode(const FollowingMode followingMode)
        {
            _followingMode = followingMode;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE);
        }

        void SpeedProfileActionImpl::SetDynamicConstraints(std::shared_ptr<IDynamicConstraintsWriter> dynamicConstraints)
        {
            _dynamicConstraints = dynamicConstraints;
			// set the indicator to true
            isSetDynamicConstraints = true;          
        }

        void SpeedProfileActionImpl::SetSpeedProfileEntry(std::vector<std::shared_ptr<ISpeedProfileEntryWriter>>& speedProfileEntry)
        {
            _speedProfileEntry = speedProfileEntry;
        }

        std::shared_ptr<void> SpeedProfileActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(SpeedProfileActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ISpeedProfileAction).name())
                return std::dynamic_pointer_cast<ISpeedProfileAction>(shared_from_this());
            else if (classifier == typeid(ISpeedProfileActionWriter).name())
                return std::dynamic_pointer_cast<ISpeedProfileActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> SpeedProfileActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t SpeedProfileActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int SpeedProfileActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double SpeedProfileActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t SpeedProfileActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool SpeedProfileActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime SpeedProfileActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> SpeedProfileActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string SpeedProfileActionImpl::GetModelType() const
        {
            return "SpeedProfileAction";
        }

        void SpeedProfileActionImpl::WriteParameterToEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _entityRef = {};
        }

        void SpeedProfileActionImpl::WriteParameterToFollowingMode(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE, parameterName, nullTextMarker /*no textmarker*/);
            _followingMode = {};
        }

        std::string SpeedProfileActionImpl::GetParameterFromEntityRef() const
        {
            auto entityRef = OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF;
            return GetParameterNameFromAttribute(entityRef);
        }

        std::string SpeedProfileActionImpl::GetParameterFromFollowingMode() const
        {
            auto followingMode = OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE;
            return GetParameterNameFromAttribute(followingMode);
        }

        bool SpeedProfileActionImpl::IsEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool SpeedProfileActionImpl::IsFollowingModeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IDynamicConstraintsWriter> SpeedProfileActionImpl::GetWriterDynamicConstraints() const
        {
            return std::dynamic_pointer_cast<IDynamicConstraintsWriter>(_dynamicConstraints);
        }

        SpeedProfileActionImpl::SpeedProfileActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE, SimpleType::ENUM_TYPE);
        }

        void SpeedProfileActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE)
            {
                // Enumeration Type
                const auto kResult = FollowingMode::GetFromLiteral(parameterLiteralValue);
                if (kResult != FollowingMode::UNKNOWN)
                {
                    _followingMode = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType SpeedProfileActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SpeedProfileActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDynamicConstraints =  GetWriterDynamicConstraints();
                if (kDynamicConstraints)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDynamicConstraints));
                }
                auto speedProfileEntry =  GetWriterSpeedProfileEntry();
                if (!speedProfileEntry.empty())
                {
                    for(auto&& item : speedProfileEntry)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SpeedProfileActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<SpeedProfileActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Enumeration Type
            const auto kFollowingMode = GetFollowingMode();
            if ( kFollowingMode.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_followingMode = FollowingMode::GetFromLiteral(kFollowingMode.GetLiteral());
            }
            // clone indicators
            	clonedObject->isSetEntityRef = isSetEntityRef;
            // clone children
            const auto kDynamicConstraints =  GetWriterDynamicConstraints();
            if (kDynamicConstraints)
            {
                auto clonedChild = std::dynamic_pointer_cast<DynamicConstraintsImpl>(kDynamicConstraints)->Clone();
                auto clonedChildIDynamicConstraints = std::dynamic_pointer_cast<IDynamicConstraints>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDynamicConstraints(std::dynamic_pointer_cast<IDynamicConstraintsWriter>(clonedChildIDynamicConstraints));
            }
            const auto kSpeedProfileEntry =  GetWriterSpeedProfileEntry();
            if (!kSpeedProfileEntry.empty())
            {
                std::vector<std::shared_ptr<ISpeedProfileEntryWriter>> clonedList;
                for(auto&& kItem : kSpeedProfileEntry)
                {
                    auto clonedChild = std::dynamic_pointer_cast<SpeedProfileEntryImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<ISpeedProfileEntryWriter>(clonedChild));
                }
                clonedObject->SetSpeedProfileEntry(clonedList);
            }
            return clonedObject;
        }

        std::string SpeedProfileActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SpeedProfileActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DYNAMIC_CONSTRAINTS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDynamicConstraints());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SpeedProfileActionImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__SPEED_PROFILE_ENTRY)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetSpeedProfileEntry())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SpeedProfileActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string SpeedProfileActionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE)
            {
                auto followingMode = GetFollowingMode();
                return followingMode.GetLiteral() != "UNKNOWN" ? followingMode.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


       void SpeedProfileActionImpl::ResetEntityRef()
	   {
	   		isSetEntityRef = false; 
        	_entityRef = nullptr;
			
	   }
       bool SpeedProfileActionImpl::IsSetEntityRef() const
	   {
			return isSetEntityRef;
	   }
       void SpeedProfileActionImpl::ResetDynamicConstraints()
	   {
	   		isSetDynamicConstraints = false; 
			_dynamicConstraints = {};
			
	   }
       bool SpeedProfileActionImpl::IsSetDynamicConstraints() const
	   {
			return isSetDynamicConstraints;
	   }

        IOpenScenarioFlexElement* SpeedProfileEntryImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double SpeedProfileEntryImpl::GetSpeed() const
        {
        	  return _speed;
        }
        double SpeedProfileEntryImpl::GetTime() const
        {
        	  return _time;
        }


        void SpeedProfileEntryImpl::SetSpeed(const double speed)
        {
            _speed = speed;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SPEED);
        }

        void SpeedProfileEntryImpl::SetTime(const double time)
        {
            _time = time;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TIME);
			// set the indicator to true
            isSetTime = true;          
        }

        std::shared_ptr<void> SpeedProfileEntryImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(SpeedProfileEntryImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ISpeedProfileEntry).name())
                return std::dynamic_pointer_cast<ISpeedProfileEntry>(shared_from_this());
            else if (classifier == typeid(ISpeedProfileEntryWriter).name())
                return std::dynamic_pointer_cast<ISpeedProfileEntryWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> SpeedProfileEntryImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t SpeedProfileEntryImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int SpeedProfileEntryImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double SpeedProfileEntryImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__SPEED)
                {
                    return GetSpeed();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__TIME)
                {
                    return GetTime();
                }
                throw KeyNotSupportedException();

        }

        uint16_t SpeedProfileEntryImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool SpeedProfileEntryImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime SpeedProfileEntryImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> SpeedProfileEntryImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string SpeedProfileEntryImpl::GetModelType() const
        {
            return "SpeedProfileEntry";
        }

        void SpeedProfileEntryImpl::WriteParameterToSpeed(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SPEED, parameterName, nullTextMarker /*no textmarker*/);
            _speed = {};
        }

        void SpeedProfileEntryImpl::WriteParameterToTime(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TIME, parameterName, nullTextMarker /*no textmarker*/);
            _time = {};
        }

        std::string SpeedProfileEntryImpl::GetParameterFromSpeed() const
        {
            auto speed = OSC_CONSTANTS::ATTRIBUTE__SPEED;
            return GetParameterNameFromAttribute(speed);
        }

        std::string SpeedProfileEntryImpl::GetParameterFromTime() const
        {
            auto time = OSC_CONSTANTS::ATTRIBUTE__TIME;
            return GetParameterNameFromAttribute(time);
        }

        bool SpeedProfileEntryImpl::IsSpeedParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__SPEED);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool SpeedProfileEntryImpl::IsTimeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TIME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        SpeedProfileEntryImpl::SpeedProfileEntryImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SPEED, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TIME, SimpleType::DOUBLE);
        }

        void SpeedProfileEntryImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SPEED)
            {
                // Simple type
                _speed = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TIME)
            {
                // Simple type
                _time = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType SpeedProfileEntryImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SpeedProfileEntryImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SpeedProfileEntryImpl::Clone()
        {
            auto clonedObject = std::make_shared<SpeedProfileEntryImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_speed = GetSpeed();
            // Simple type
            clonedObject->_time = GetTime();
            // clone indicators
            	clonedObject->isSetTime = isSetTime;
            // clone children
            return clonedObject;
        }

        std::string SpeedProfileEntryImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SpeedProfileEntryImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SpeedProfileEntryImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SpeedProfileEntryImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string SpeedProfileEntryImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void SpeedProfileEntryImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SPEED)
            {
                // Simple type
                _speed = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TIME)
            {
                // Simple type
                _time = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void SpeedProfileEntryImpl::ResetTime()
	   {
	   		isSetTime = false; 
			_time = {};
			
	   }
       bool SpeedProfileEntryImpl::IsSetTime() const
	   {
			return isSetTime;
	   }

        IOpenScenarioFlexElement* StandStillConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double StandStillConditionImpl::GetDuration() const
        {
        	  return _duration;
        }


        void StandStillConditionImpl::SetDuration(const double duration)
        {
            _duration = duration;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DURATION);
        }

        std::shared_ptr<void> StandStillConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(StandStillConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IStandStillCondition).name())
                return std::dynamic_pointer_cast<IStandStillCondition>(shared_from_this());
            else if (classifier == typeid(IStandStillConditionWriter).name())
                return std::dynamic_pointer_cast<IStandStillConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> StandStillConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t StandStillConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int StandStillConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double StandStillConditionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__DURATION)
                {
                    return GetDuration();
                }
                throw KeyNotSupportedException();

        }

        uint16_t StandStillConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool StandStillConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime StandStillConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> StandStillConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string StandStillConditionImpl::GetModelType() const
        {
            return "StandStillCondition";
        }

        void StandStillConditionImpl::WriteParameterToDuration(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DURATION, parameterName, nullTextMarker /*no textmarker*/);
            _duration = {};
        }

        std::string StandStillConditionImpl::GetParameterFromDuration() const
        {
            auto duration = OSC_CONSTANTS::ATTRIBUTE__DURATION;
            return GetParameterNameFromAttribute(duration);
        }

        bool StandStillConditionImpl::IsDurationParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DURATION);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        StandStillConditionImpl::StandStillConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DURATION, SimpleType::DOUBLE);
        }

        void StandStillConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DURATION)
            {
                // Simple type
                _duration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType StandStillConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> StandStillConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> StandStillConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<StandStillConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_duration = GetDuration();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string StandStillConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StandStillConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> StandStillConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StandStillConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string StandStillConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void StandStillConditionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DURATION)
            {
                // Simple type
                _duration = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* SteadyStateImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<ITargetDistanceSteadyState> SteadyStateImpl::GetTargetDistanceSteadyState() const
        {
        	  return _targetDistanceSteadyState;
        }
        std::shared_ptr<ITargetTimeSteadyState> SteadyStateImpl::GetTargetTimeSteadyState() const
        {
        	  return _targetTimeSteadyState;
        }


        void SteadyStateImpl::SetTargetDistanceSteadyState(std::shared_ptr<ITargetDistanceSteadyStateWriter> targetDistanceSteadyState)
        {
            _targetDistanceSteadyState = targetDistanceSteadyState;
            _targetTimeSteadyState = {};
        }

        void SteadyStateImpl::SetTargetTimeSteadyState(std::shared_ptr<ITargetTimeSteadyStateWriter> targetTimeSteadyState)
        {
            _targetTimeSteadyState = targetTimeSteadyState;
            _targetDistanceSteadyState = {};
        }

        std::shared_ptr<void> SteadyStateImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(SteadyStateImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ISteadyState).name())
                return std::dynamic_pointer_cast<ISteadyState>(shared_from_this());
            else if (classifier == typeid(ISteadyStateWriter).name())
                return std::dynamic_pointer_cast<ISteadyStateWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> SteadyStateImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t SteadyStateImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int SteadyStateImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double SteadyStateImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t SteadyStateImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool SteadyStateImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime SteadyStateImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> SteadyStateImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string SteadyStateImpl::GetModelType() const
        {
            return "SteadyState";
        }

            // children
        std::shared_ptr<ITargetDistanceSteadyStateWriter> SteadyStateImpl::GetWriterTargetDistanceSteadyState() const
        {
            return std::dynamic_pointer_cast<ITargetDistanceSteadyStateWriter>(_targetDistanceSteadyState);
        }
        std::shared_ptr<ITargetTimeSteadyStateWriter> SteadyStateImpl::GetWriterTargetTimeSteadyState() const
        {
            return std::dynamic_pointer_cast<ITargetTimeSteadyStateWriter>(_targetTimeSteadyState);
        }

        SteadyStateImpl::SteadyStateImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void SteadyStateImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType SteadyStateImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SteadyStateImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kTargetDistanceSteadyState =  GetWriterTargetDistanceSteadyState();
                if (kTargetDistanceSteadyState)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTargetDistanceSteadyState));
                }
                const auto kTargetTimeSteadyState =  GetWriterTargetTimeSteadyState();
                if (kTargetTimeSteadyState)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTargetTimeSteadyState));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SteadyStateImpl::Clone()
        {
            auto clonedObject = std::make_shared<SteadyStateImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kTargetDistanceSteadyState =  GetWriterTargetDistanceSteadyState();
            if (kTargetDistanceSteadyState)
            {
                auto clonedChild = std::dynamic_pointer_cast<TargetDistanceSteadyStateImpl>(kTargetDistanceSteadyState)->Clone();
                auto clonedChildITargetDistanceSteadyState = std::dynamic_pointer_cast<ITargetDistanceSteadyState>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTargetDistanceSteadyState(std::dynamic_pointer_cast<ITargetDistanceSteadyStateWriter>(clonedChildITargetDistanceSteadyState));
            }
            const auto kTargetTimeSteadyState =  GetWriterTargetTimeSteadyState();
            if (kTargetTimeSteadyState)
            {
                auto clonedChild = std::dynamic_pointer_cast<TargetTimeSteadyStateImpl>(kTargetTimeSteadyState)->Clone();
                auto clonedChildITargetTimeSteadyState = std::dynamic_pointer_cast<ITargetTimeSteadyState>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTargetTimeSteadyState(std::dynamic_pointer_cast<ITargetTimeSteadyStateWriter>(clonedChildITargetTimeSteadyState));
            }
            return clonedObject;
        }

        std::string SteadyStateImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SteadyStateImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TARGET_DISTANCE_STEADY_STATE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTargetDistanceSteadyState());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TARGET_TIME_STEADY_STATE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTargetTimeSteadyState());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SteadyStateImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SteadyStateImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string SteadyStateImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* StochasticImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        uint32_t StochasticImpl::GetNumberOfTestRuns() const
        {
        	  return _numberOfTestRuns;
        }
        double StochasticImpl::GetRandomSeed() const
        {
        	  return _randomSeed;
        }
        std::vector<std::shared_ptr<IStochasticDistribution>> StochasticImpl::GetStochasticDistributions() const
        {
            std::vector<std::shared_ptr<IStochasticDistribution>> temp;
            for(auto&& elm: _stochasticDistributions)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IStochasticDistributionWriter>> StochasticImpl::GetWriterStochasticDistributions() const
        {
            return _stochasticDistributions;
        }

        int StochasticImpl::GetStochasticDistributionsSize() const
        {
            return static_cast<int>(_stochasticDistributions.size());
        }

        std::shared_ptr<IStochasticDistribution> StochasticImpl::GetStochasticDistributionsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _stochasticDistributions.size() > index)
            {
                return _stochasticDistributions[index];
            }
            return nullptr;
        }


        void StochasticImpl::SetNumberOfTestRuns(const uint32_t numberOfTestRuns)
        {
            _numberOfTestRuns = numberOfTestRuns;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NUMBER_OF_TEST_RUNS);
        }

        void StochasticImpl::SetRandomSeed(const double randomSeed)
        {
            _randomSeed = randomSeed;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RANDOM_SEED);
			// set the indicator to true
            isSetRandomSeed = true;          
        }

        void StochasticImpl::SetStochasticDistributions(std::vector<std::shared_ptr<IStochasticDistributionWriter>>& stochasticDistributions)
        {
            _stochasticDistributions = stochasticDistributions;
        }

        std::shared_ptr<void> StochasticImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(StochasticImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IStochastic).name())
                return std::dynamic_pointer_cast<IStochastic>(shared_from_this());
            else if (classifier == typeid(IStochasticWriter).name())
                return std::dynamic_pointer_cast<IStochasticWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> StochasticImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t StochasticImpl::GetUnsignedIntProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__NUMBER_OF_TEST_RUNS)
                {
                    return GetNumberOfTestRuns();
                }
                throw KeyNotSupportedException();

        }

        int StochasticImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double StochasticImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__RANDOM_SEED)
                {
                    return GetRandomSeed();
                }
                throw KeyNotSupportedException();

        }

        uint16_t StochasticImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool StochasticImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime StochasticImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> StochasticImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string StochasticImpl::GetModelType() const
        {
            return "Stochastic";
        }

        void StochasticImpl::WriteParameterToNumberOfTestRuns(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NUMBER_OF_TEST_RUNS, parameterName, nullTextMarker /*no textmarker*/);
            _numberOfTestRuns = {};
        }

        void StochasticImpl::WriteParameterToRandomSeed(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RANDOM_SEED, parameterName, nullTextMarker /*no textmarker*/);
            _randomSeed = {};
        }

        std::string StochasticImpl::GetParameterFromNumberOfTestRuns() const
        {
            auto numberOfTestRuns = OSC_CONSTANTS::ATTRIBUTE__NUMBER_OF_TEST_RUNS;
            return GetParameterNameFromAttribute(numberOfTestRuns);
        }

        std::string StochasticImpl::GetParameterFromRandomSeed() const
        {
            auto randomSeed = OSC_CONSTANTS::ATTRIBUTE__RANDOM_SEED;
            return GetParameterNameFromAttribute(randomSeed);
        }

        bool StochasticImpl::IsNumberOfTestRunsParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NUMBER_OF_TEST_RUNS);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool StochasticImpl::IsRandomSeedParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RANDOM_SEED);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        StochasticImpl::StochasticImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NUMBER_OF_TEST_RUNS, SimpleType::UNSIGNED_INT);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RANDOM_SEED, SimpleType::DOUBLE);
        }

        void StochasticImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NUMBER_OF_TEST_RUNS)
            {
                // Simple type
                _numberOfTestRuns = ParserHelper::ParseUnsignedInt(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RANDOM_SEED)
            {
                // Simple type
                _randomSeed = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType StochasticImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> StochasticImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto stochasticDistributions =  GetWriterStochasticDistributions();
                if (!stochasticDistributions.empty())
                {
                    for(auto&& item : stochasticDistributions)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> StochasticImpl::Clone()
        {
            auto clonedObject = std::make_shared<StochasticImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_numberOfTestRuns = GetNumberOfTestRuns();
            // Simple type
            clonedObject->_randomSeed = GetRandomSeed();
            // clone indicators
            	clonedObject->isSetRandomSeed = isSetRandomSeed;
            // clone children
            const auto kStochasticDistributions =  GetWriterStochasticDistributions();
            if (!kStochasticDistributions.empty())
            {
                std::vector<std::shared_ptr<IStochasticDistributionWriter>> clonedList;
                for(auto&& kItem : kStochasticDistributions)
                {
                    auto clonedChild = std::dynamic_pointer_cast<StochasticDistributionImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IStochasticDistributionWriter>(clonedChild));
                }
                clonedObject->SetStochasticDistributions(clonedList);
            }
            return clonedObject;
        }

        std::string StochasticImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StochasticImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> StochasticImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__STOCHASTIC_DISTRIBUTION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetStochasticDistributions())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StochasticImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string StochasticImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void StochasticImpl::ResolveUnsignedIntExpression(std::string& attributeKey, unsigned int& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NUMBER_OF_TEST_RUNS)
            {
                // Simple type
                _numberOfTestRuns = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void StochasticImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RANDOM_SEED)
            {
                // Simple type
                _randomSeed = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void StochasticImpl::ResetRandomSeed()
	   {
	   		isSetRandomSeed = false; 
			_randomSeed = {};
			
	   }
       bool StochasticImpl::IsSetRandomSeed() const
	   {
			return isSetRandomSeed;
	   }

        IOpenScenarioFlexElement* StochasticDistributionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string StochasticDistributionImpl::GetParameterName() const
        {
        	  return _parameterName;
        }
        std::shared_ptr<IStochasticDistributionType> StochasticDistributionImpl::GetStochasticDistributionType() const
        {
        	  return _stochasticDistributionType;
        }


        void StochasticDistributionImpl::SetParameterName(const std::string parameterName)
        {
            _parameterName = parameterName;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_NAME);
        }

        void StochasticDistributionImpl::SetStochasticDistributionType(std::shared_ptr<IStochasticDistributionTypeWriter> stochasticDistributionType)
        {
            _stochasticDistributionType = stochasticDistributionType;
        }

        std::shared_ptr<void> StochasticDistributionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(StochasticDistributionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IStochasticDistribution).name())
                return std::dynamic_pointer_cast<IStochasticDistribution>(shared_from_this());
            else if (classifier == typeid(IStochasticDistributionWriter).name())
                return std::dynamic_pointer_cast<IStochasticDistributionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> StochasticDistributionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t StochasticDistributionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int StochasticDistributionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double StochasticDistributionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t StochasticDistributionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool StochasticDistributionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime StochasticDistributionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> StochasticDistributionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string StochasticDistributionImpl::GetModelType() const
        {
            return "StochasticDistribution";
        }

        void StochasticDistributionImpl::WriteParameterToParameterName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_NAME, parameterName, nullTextMarker /*no textmarker*/);
            _parameterName = {};
        }

        std::string StochasticDistributionImpl::GetParameterFromParameterName() const
        {
            auto parameterName = OSC_CONSTANTS::ATTRIBUTE__PARAMETER_NAME;
            return GetParameterNameFromAttribute(parameterName);
        }

        bool StochasticDistributionImpl::IsParameterNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__PARAMETER_NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IStochasticDistributionTypeWriter> StochasticDistributionImpl::GetWriterStochasticDistributionType() const
        {
            return std::dynamic_pointer_cast<IStochasticDistributionTypeWriter>(_stochasticDistributionType);
        }

        StochasticDistributionImpl::StochasticDistributionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_NAME, SimpleType::STRING);
        }

        void StochasticDistributionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_NAME)
            {
                // Simple type
                _parameterName = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType StochasticDistributionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> StochasticDistributionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kStochasticDistributionType =  GetWriterStochasticDistributionType();
                if (kStochasticDistributionType)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kStochasticDistributionType));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> StochasticDistributionImpl::Clone()
        {
            auto clonedObject = std::make_shared<StochasticDistributionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_parameterName = GetParameterName();
            // clone indicators
            // clone children
            const auto kStochasticDistributionType =  GetWriterStochasticDistributionType();
            if (kStochasticDistributionType)
            {
                auto clonedChild = std::dynamic_pointer_cast<StochasticDistributionTypeImpl>(kStochasticDistributionType)->Clone();
                auto clonedChildIStochasticDistributionType = std::dynamic_pointer_cast<IStochasticDistributionType>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetStochasticDistributionType(std::dynamic_pointer_cast<IStochasticDistributionTypeWriter>(clonedChildIStochasticDistributionType));
            }
            return clonedObject;
        }

        std::string StochasticDistributionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_NAME)
            {
                return GetParameterName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StochasticDistributionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__STOCHASTIC_DISTRIBUTION_TYPE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetStochasticDistributionType());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> StochasticDistributionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StochasticDistributionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string StochasticDistributionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void StochasticDistributionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_NAME)
            {
                // Simple type
                _parameterName = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* StochasticDistributionTypeImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IProbabilityDistributionSet> StochasticDistributionTypeImpl::GetProbabilityDistributionSet() const
        {
        	  return _probabilityDistributionSet;
        }
        std::shared_ptr<INormalDistribution> StochasticDistributionTypeImpl::GetNormalDistribution() const
        {
        	  return _normalDistribution;
        }
        std::shared_ptr<IUniformDistribution> StochasticDistributionTypeImpl::GetUniformDistribution() const
        {
        	  return _uniformDistribution;
        }
        std::shared_ptr<IPoissonDistribution> StochasticDistributionTypeImpl::GetPoissonDistribution() const
        {
        	  return _poissonDistribution;
        }
        std::shared_ptr<IHistogram> StochasticDistributionTypeImpl::GetHistogram() const
        {
        	  return _histogram;
        }
        std::shared_ptr<IUserDefinedDistribution> StochasticDistributionTypeImpl::GetUserDefinedDistribution() const
        {
        	  return _userDefinedDistribution;
        }


        void StochasticDistributionTypeImpl::SetProbabilityDistributionSet(std::shared_ptr<IProbabilityDistributionSetWriter> probabilityDistributionSet)
        {
            _probabilityDistributionSet = probabilityDistributionSet;
            _normalDistribution = {};
            _uniformDistribution = {};
            _poissonDistribution = {};
            _histogram = {};
            _userDefinedDistribution = {};
        }

        void StochasticDistributionTypeImpl::SetNormalDistribution(std::shared_ptr<INormalDistributionWriter> normalDistribution)
        {
            _normalDistribution = normalDistribution;
            _probabilityDistributionSet = {};
            _uniformDistribution = {};
            _poissonDistribution = {};
            _histogram = {};
            _userDefinedDistribution = {};
        }

        void StochasticDistributionTypeImpl::SetUniformDistribution(std::shared_ptr<IUniformDistributionWriter> uniformDistribution)
        {
            _uniformDistribution = uniformDistribution;
            _probabilityDistributionSet = {};
            _normalDistribution = {};
            _poissonDistribution = {};
            _histogram = {};
            _userDefinedDistribution = {};
        }

        void StochasticDistributionTypeImpl::SetPoissonDistribution(std::shared_ptr<IPoissonDistributionWriter> poissonDistribution)
        {
            _poissonDistribution = poissonDistribution;
            _probabilityDistributionSet = {};
            _normalDistribution = {};
            _uniformDistribution = {};
            _histogram = {};
            _userDefinedDistribution = {};
        }

        void StochasticDistributionTypeImpl::SetHistogram(std::shared_ptr<IHistogramWriter> histogram)
        {
            _histogram = histogram;
            _probabilityDistributionSet = {};
            _normalDistribution = {};
            _uniformDistribution = {};
            _poissonDistribution = {};
            _userDefinedDistribution = {};
        }

        void StochasticDistributionTypeImpl::SetUserDefinedDistribution(std::shared_ptr<IUserDefinedDistributionWriter> userDefinedDistribution)
        {
            _userDefinedDistribution = userDefinedDistribution;
            _probabilityDistributionSet = {};
            _normalDistribution = {};
            _uniformDistribution = {};
            _poissonDistribution = {};
            _histogram = {};
        }

        std::shared_ptr<void> StochasticDistributionTypeImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(StochasticDistributionTypeImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IStochasticDistributionType).name())
                return std::dynamic_pointer_cast<IStochasticDistributionType>(shared_from_this());
            else if (classifier == typeid(IStochasticDistributionTypeWriter).name())
                return std::dynamic_pointer_cast<IStochasticDistributionTypeWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> StochasticDistributionTypeImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t StochasticDistributionTypeImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int StochasticDistributionTypeImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double StochasticDistributionTypeImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t StochasticDistributionTypeImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool StochasticDistributionTypeImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime StochasticDistributionTypeImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> StochasticDistributionTypeImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string StochasticDistributionTypeImpl::GetModelType() const
        {
            return "StochasticDistributionType";
        }

            // children
        std::shared_ptr<IProbabilityDistributionSetWriter> StochasticDistributionTypeImpl::GetWriterProbabilityDistributionSet() const
        {
            return std::dynamic_pointer_cast<IProbabilityDistributionSetWriter>(_probabilityDistributionSet);
        }
        std::shared_ptr<INormalDistributionWriter> StochasticDistributionTypeImpl::GetWriterNormalDistribution() const
        {
            return std::dynamic_pointer_cast<INormalDistributionWriter>(_normalDistribution);
        }
        std::shared_ptr<IUniformDistributionWriter> StochasticDistributionTypeImpl::GetWriterUniformDistribution() const
        {
            return std::dynamic_pointer_cast<IUniformDistributionWriter>(_uniformDistribution);
        }
        std::shared_ptr<IPoissonDistributionWriter> StochasticDistributionTypeImpl::GetWriterPoissonDistribution() const
        {
            return std::dynamic_pointer_cast<IPoissonDistributionWriter>(_poissonDistribution);
        }
        std::shared_ptr<IHistogramWriter> StochasticDistributionTypeImpl::GetWriterHistogram() const
        {
            return std::dynamic_pointer_cast<IHistogramWriter>(_histogram);
        }
        std::shared_ptr<IUserDefinedDistributionWriter> StochasticDistributionTypeImpl::GetWriterUserDefinedDistribution() const
        {
            return std::dynamic_pointer_cast<IUserDefinedDistributionWriter>(_userDefinedDistribution);
        }

        StochasticDistributionTypeImpl::StochasticDistributionTypeImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void StochasticDistributionTypeImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType StochasticDistributionTypeImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> StochasticDistributionTypeImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kProbabilityDistributionSet =  GetWriterProbabilityDistributionSet();
                if (kProbabilityDistributionSet)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kProbabilityDistributionSet));
                }
                const auto kNormalDistribution =  GetWriterNormalDistribution();
                if (kNormalDistribution)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kNormalDistribution));
                }
                const auto kUniformDistribution =  GetWriterUniformDistribution();
                if (kUniformDistribution)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kUniformDistribution));
                }
                const auto kPoissonDistribution =  GetWriterPoissonDistribution();
                if (kPoissonDistribution)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPoissonDistribution));
                }
                const auto kHistogram =  GetWriterHistogram();
                if (kHistogram)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kHistogram));
                }
                const auto kUserDefinedDistribution =  GetWriterUserDefinedDistribution();
                if (kUserDefinedDistribution)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kUserDefinedDistribution));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> StochasticDistributionTypeImpl::Clone()
        {
            auto clonedObject = std::make_shared<StochasticDistributionTypeImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kProbabilityDistributionSet =  GetWriterProbabilityDistributionSet();
            if (kProbabilityDistributionSet)
            {
                auto clonedChild = std::dynamic_pointer_cast<ProbabilityDistributionSetImpl>(kProbabilityDistributionSet)->Clone();
                auto clonedChildIProbabilityDistributionSet = std::dynamic_pointer_cast<IProbabilityDistributionSet>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetProbabilityDistributionSet(std::dynamic_pointer_cast<IProbabilityDistributionSetWriter>(clonedChildIProbabilityDistributionSet));
            }
            const auto kNormalDistribution =  GetWriterNormalDistribution();
            if (kNormalDistribution)
            {
                auto clonedChild = std::dynamic_pointer_cast<NormalDistributionImpl>(kNormalDistribution)->Clone();
                auto clonedChildINormalDistribution = std::dynamic_pointer_cast<INormalDistribution>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetNormalDistribution(std::dynamic_pointer_cast<INormalDistributionWriter>(clonedChildINormalDistribution));
            }
            const auto kUniformDistribution =  GetWriterUniformDistribution();
            if (kUniformDistribution)
            {
                auto clonedChild = std::dynamic_pointer_cast<UniformDistributionImpl>(kUniformDistribution)->Clone();
                auto clonedChildIUniformDistribution = std::dynamic_pointer_cast<IUniformDistribution>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetUniformDistribution(std::dynamic_pointer_cast<IUniformDistributionWriter>(clonedChildIUniformDistribution));
            }
            const auto kPoissonDistribution =  GetWriterPoissonDistribution();
            if (kPoissonDistribution)
            {
                auto clonedChild = std::dynamic_pointer_cast<PoissonDistributionImpl>(kPoissonDistribution)->Clone();
                auto clonedChildIPoissonDistribution = std::dynamic_pointer_cast<IPoissonDistribution>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPoissonDistribution(std::dynamic_pointer_cast<IPoissonDistributionWriter>(clonedChildIPoissonDistribution));
            }
            const auto kHistogram =  GetWriterHistogram();
            if (kHistogram)
            {
                auto clonedChild = std::dynamic_pointer_cast<HistogramImpl>(kHistogram)->Clone();
                auto clonedChildIHistogram = std::dynamic_pointer_cast<IHistogram>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetHistogram(std::dynamic_pointer_cast<IHistogramWriter>(clonedChildIHistogram));
            }
            const auto kUserDefinedDistribution =  GetWriterUserDefinedDistribution();
            if (kUserDefinedDistribution)
            {
                auto clonedChild = std::dynamic_pointer_cast<UserDefinedDistributionImpl>(kUserDefinedDistribution)->Clone();
                auto clonedChildIUserDefinedDistribution = std::dynamic_pointer_cast<IUserDefinedDistribution>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetUserDefinedDistribution(std::dynamic_pointer_cast<IUserDefinedDistributionWriter>(clonedChildIUserDefinedDistribution));
            }
            return clonedObject;
        }

        std::string StochasticDistributionTypeImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StochasticDistributionTypeImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PROBABILITY_DISTRIBUTION_SET)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetProbabilityDistributionSet());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__NORMAL_DISTRIBUTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetNormalDistribution());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__UNIFORM_DISTRIBUTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetUniformDistribution());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POISSON_DISTRIBUTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPoissonDistribution());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__HISTOGRAM)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetHistogram());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__USER_DEFINED_DISTRIBUTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetUserDefinedDistribution());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> StochasticDistributionTypeImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StochasticDistributionTypeImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string StochasticDistributionTypeImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* StoryImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string StoryImpl::GetName() const
        {
        	  return _name;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> StoryImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IParameterDeclarationWriter>> StoryImpl::GetWriterParameterDeclarations() const
        {
            return _parameterDeclarations;
        }

        int StoryImpl::GetParameterDeclarationsSize() const
        {
            return static_cast<int>(_parameterDeclarations.size());
        }

        std::shared_ptr<IParameterDeclaration> StoryImpl::GetParameterDeclarationsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _parameterDeclarations.size() > index)
            {
                return _parameterDeclarations[index];
            }
            return nullptr;
        }
        std::vector<std::shared_ptr<IAct>> StoryImpl::GetActs() const
        {
            std::vector<std::shared_ptr<IAct>> temp;
            for(auto&& elm: _acts)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IActWriter>> StoryImpl::GetWriterActs() const
        {
            return _acts;
        }

        int StoryImpl::GetActsSize() const
        {
            return static_cast<int>(_acts.size());
        }

        std::shared_ptr<IAct> StoryImpl::GetActsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _acts.size() > index)
            {
                return _acts[index];
            }
            return nullptr;
        }


        void StoryImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void StoryImpl::SetParameterDeclarations(std::vector<std::shared_ptr<IParameterDeclarationWriter>>& parameterDeclarations)
        {
            _parameterDeclarations = parameterDeclarations;
			// set the indicator to true
            isSetParameterDeclarations = true;          
        }

        void StoryImpl::SetActs(std::vector<std::shared_ptr<IActWriter>>& acts)
        {
            _acts = acts;
        }

        std::shared_ptr<void> StoryImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(StoryImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IStory).name())
                return std::dynamic_pointer_cast<IStory>(shared_from_this());
            else if (classifier == typeid(IStoryWriter).name())
                return std::dynamic_pointer_cast<IStoryWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> StoryImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t StoryImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int StoryImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double StoryImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t StoryImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool StoryImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime StoryImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> StoryImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string StoryImpl::GetModelType() const
        {
            return "Story";
        }

        void StoryImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        std::string StoryImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        bool StoryImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        StoryImpl::StoryImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        void StoryImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType StoryImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool StoryImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> StoryImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> StoryImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto acts =  GetWriterActs();
                if (!acts.empty())
                {
                    for(auto&& item : acts)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> StoryImpl::Clone()
        {
            auto clonedObject = std::make_shared<StoryImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone indicators
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kActs =  GetWriterActs();
            if (!kActs.empty())
            {
                std::vector<std::shared_ptr<IActWriter>> clonedList;
                for(auto&& kItem : kActs)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ActImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IActWriter>(clonedChild));
                }
                clonedObject->SetActs(clonedList);
            }
            return clonedObject;
        }

        std::string StoryImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StoryImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> StoryImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__ACT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetActs())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StoryImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string StoryImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void StoryImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void StoryImpl::ResetParameterDeclarations()
	   {
	   		isSetParameterDeclarations = false; 
			_parameterDeclarations = {};
			
	   }
       bool StoryImpl::IsSetParameterDeclarations() const
	   {
			return isSetParameterDeclarations;
	   }

        IOpenScenarioFlexElement* StoryboardImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IInit> StoryboardImpl::GetInit() const
        {
        	  return _init;
        }
        std::vector<std::shared_ptr<IStory>> StoryboardImpl::GetStories() const
        {
            std::vector<std::shared_ptr<IStory>> temp;
            for(auto&& elm: _stories)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IStoryWriter>> StoryboardImpl::GetWriterStories() const
        {
            return _stories;
        }

        int StoryboardImpl::GetStoriesSize() const
        {
            return static_cast<int>(_stories.size());
        }

        std::shared_ptr<IStory> StoryboardImpl::GetStoriesAtIndex(unsigned int index) const
        {
            if (index >= 0 && _stories.size() > index)
            {
                return _stories[index];
            }
            return nullptr;
        }
        std::shared_ptr<ITrigger> StoryboardImpl::GetStopTrigger() const
        {
        	  return _stopTrigger;
        }


        void StoryboardImpl::SetInit(std::shared_ptr<IInitWriter> init)
        {
            _init = init;
        }

        void StoryboardImpl::SetStories(std::vector<std::shared_ptr<IStoryWriter>>& stories)
        {
            _stories = stories;
			// set the indicator to true
            isSetStories = true;          
        }

        void StoryboardImpl::SetStopTrigger(std::shared_ptr<ITriggerWriter> stopTrigger)
        {
            _stopTrigger = stopTrigger;
        }

        std::shared_ptr<void> StoryboardImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(StoryboardImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IStoryboard).name())
                return std::dynamic_pointer_cast<IStoryboard>(shared_from_this());
            else if (classifier == typeid(IStoryboardWriter).name())
                return std::dynamic_pointer_cast<IStoryboardWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> StoryboardImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t StoryboardImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int StoryboardImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double StoryboardImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t StoryboardImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool StoryboardImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime StoryboardImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> StoryboardImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string StoryboardImpl::GetModelType() const
        {
            return "Storyboard";
        }

            // children
        std::shared_ptr<IInitWriter> StoryboardImpl::GetWriterInit() const
        {
            return std::dynamic_pointer_cast<IInitWriter>(_init);
        }
        std::shared_ptr<ITriggerWriter> StoryboardImpl::GetWriterStopTrigger() const
        {
            return std::dynamic_pointer_cast<ITriggerWriter>(_stopTrigger);
        }

        StoryboardImpl::StoryboardImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void StoryboardImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType StoryboardImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> StoryboardImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kInit =  GetWriterInit();
                if (kInit)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kInit));
                }
                auto stories =  GetWriterStories();
                if (!stories.empty())
                {
                    for(auto&& item : stories)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kStopTrigger =  GetWriterStopTrigger();
                if (kStopTrigger)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kStopTrigger));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> StoryboardImpl::Clone()
        {
            auto clonedObject = std::make_shared<StoryboardImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kInit =  GetWriterInit();
            if (kInit)
            {
                auto clonedChild = std::dynamic_pointer_cast<InitImpl>(kInit)->Clone();
                auto clonedChildIInit = std::dynamic_pointer_cast<IInit>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetInit(std::dynamic_pointer_cast<IInitWriter>(clonedChildIInit));
            }
            const auto kStories =  GetWriterStories();
            if (!kStories.empty())
            {
                std::vector<std::shared_ptr<IStoryWriter>> clonedList;
                for(auto&& kItem : kStories)
                {
                    auto clonedChild = std::dynamic_pointer_cast<StoryImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IStoryWriter>(clonedChild));
                }
                clonedObject->SetStories(clonedList);
            }
            const auto kStopTrigger =  GetWriterStopTrigger();
            if (kStopTrigger)
            {
                auto clonedChild = std::dynamic_pointer_cast<TriggerImpl>(kStopTrigger)->Clone();
                auto clonedChildITrigger = std::dynamic_pointer_cast<ITrigger>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetStopTrigger(std::dynamic_pointer_cast<ITriggerWriter>(clonedChildITrigger));
            }
            return clonedObject;
        }

        std::string StoryboardImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StoryboardImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__INIT)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetInit());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__STOP_TRIGGER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetStopTrigger());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> StoryboardImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__STORY)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetStories())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StoryboardImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string StoryboardImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void StoryboardImpl::ResetStories()
	   {
	   		isSetStories = false; 
			_stories = {};
			
	   }
       bool StoryboardImpl::IsSetStories() const
	   {
			return isSetStories;
	   }

        IOpenScenarioFlexElement* StoryboardElementStateConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        StoryboardElementState StoryboardElementStateConditionImpl::GetState() const
        {
        	  return _state;
        }
        std::shared_ptr<INamedReference<IStoryboardElement>> StoryboardElementStateConditionImpl::GetStoryboardElementRef() const
        {
        	 return _storyboardElementRef;
        }
        StoryboardElementType StoryboardElementStateConditionImpl::GetStoryboardElementType() const
        {
        	  return _storyboardElementType;
        }


        void StoryboardElementStateConditionImpl::SetState(const StoryboardElementState state)
        {
            _state = state;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STATE);
        }

        void StoryboardElementStateConditionImpl::SetStoryboardElementRef(std::shared_ptr<INamedReference<IStoryboardElement>> storyboardElementRef)
        {
            _storyboardElementRef = storyboardElementRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_REF);
        }

        void StoryboardElementStateConditionImpl::SetStoryboardElementType(const StoryboardElementType storyboardElementType)
        {
            _storyboardElementType = storyboardElementType;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_TYPE);
        }

        std::shared_ptr<void> StoryboardElementStateConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(StoryboardElementStateConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IStoryboardElementStateCondition).name())
                return std::dynamic_pointer_cast<IStoryboardElementStateCondition>(shared_from_this());
            else if (classifier == typeid(IStoryboardElementStateConditionWriter).name())
                return std::dynamic_pointer_cast<IStoryboardElementStateConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> StoryboardElementStateConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t StoryboardElementStateConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int StoryboardElementStateConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double StoryboardElementStateConditionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t StoryboardElementStateConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool StoryboardElementStateConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime StoryboardElementStateConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> StoryboardElementStateConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string StoryboardElementStateConditionImpl::GetModelType() const
        {
            return "StoryboardElementStateCondition";
        }

        void StoryboardElementStateConditionImpl::WriteParameterToState(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STATE, parameterName, nullTextMarker /*no textmarker*/);
            _state = {};
        }

        void StoryboardElementStateConditionImpl::WriteParameterToStoryboardElementRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_REF, parameterName, nullTextMarker /*no textmarker*/);
            _storyboardElementRef = {};
        }

        void StoryboardElementStateConditionImpl::WriteParameterToStoryboardElementType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _storyboardElementType = {};
        }

        std::string StoryboardElementStateConditionImpl::GetParameterFromState() const
        {
            auto state = OSC_CONSTANTS::ATTRIBUTE__STATE;
            return GetParameterNameFromAttribute(state);
        }

        std::string StoryboardElementStateConditionImpl::GetParameterFromStoryboardElementRef() const
        {
            auto storyboardElementRef = OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_REF;
            return GetParameterNameFromAttribute(storyboardElementRef);
        }

        std::string StoryboardElementStateConditionImpl::GetParameterFromStoryboardElementType() const
        {
            auto storyboardElementType = OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_TYPE;
            return GetParameterNameFromAttribute(storyboardElementType);
        }

        bool StoryboardElementStateConditionImpl::IsStateParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__STATE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool StoryboardElementStateConditionImpl::IsStoryboardElementRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool StoryboardElementStateConditionImpl::IsStoryboardElementTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        StoryboardElementStateConditionImpl::StoryboardElementStateConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__STATE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_TYPE, SimpleType::ENUM_TYPE);
        }

        void StoryboardElementStateConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                // Enumeration Type
                const auto kResult = StoryboardElementState::GetFromLiteral(parameterLiteralValue);
                if (kResult != StoryboardElementState::UNKNOWN)
                {
                    _state = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IStoryboardElement>>(parameterLiteralValue);
                _storyboardElementRef = std::dynamic_pointer_cast<INamedReference<IStoryboardElement>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_TYPE)
            {
                // Enumeration Type
                const auto kResult = StoryboardElementType::GetFromLiteral(parameterLiteralValue);
                if (kResult != StoryboardElementType::UNKNOWN)
                {
                    _storyboardElementType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType StoryboardElementStateConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> StoryboardElementStateConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> StoryboardElementStateConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<StoryboardElementStateConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kState = GetState();
            if ( kState.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_state = StoryboardElementState::GetFromLiteral(kState.GetLiteral());
            }
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IStoryboardElement>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IStoryboardElement>>(GetStoryboardElementRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_storyboardElementRef = proxy;
            
            // Enumeration Type
            const auto kStoryboardElementType = GetStoryboardElementType();
            if ( kStoryboardElementType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_storyboardElementType = StoryboardElementType::GetFromLiteral(kStoryboardElementType.GetLiteral());
            }
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string StoryboardElementStateConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_REF)
            {
                // Get the Proxy
                auto storyboardElementRef = GetStoryboardElementRef();
                return storyboardElementRef!= nullptr ? storyboardElementRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StoryboardElementStateConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> StoryboardElementStateConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StoryboardElementStateConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_REF)
            {
                // Get the Proxy
                auto storyboardElementRef = GetStoryboardElementRef();
                return storyboardElementRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(storyboardElementRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string StoryboardElementStateConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                auto state = GetState();
                return state.GetLiteral() != "UNKNOWN" ? state.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_TYPE)
            {
                auto storyboardElementType = GetStoryboardElementType();
                return storyboardElementType.GetLiteral() != "UNKNOWN" ? storyboardElementType.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* SunImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double SunImpl::GetAzimuth() const
        {
        	  return _azimuth;
        }
        double SunImpl::GetElevation() const
        {
        	  return _elevation;
        }
        double SunImpl::GetIlluminance() const
        {
        	  return _illuminance;
        }
        double SunImpl::GetIntensity() const
        {
        	  return _intensity;
        }


        void SunImpl::SetAzimuth(const double azimuth)
        {
            _azimuth = azimuth;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__AZIMUTH);
        }

        void SunImpl::SetElevation(const double elevation)
        {
            _elevation = elevation;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ELEVATION);
        }

        void SunImpl::SetIlluminance(const double illuminance)
        {
            _illuminance = illuminance;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ILLUMINANCE);
			// set the indicator to true
            isSetIlluminance = true;          
        }

        void SunImpl::SetIntensity(const double intensity)
        {
            _intensity = intensity;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__INTENSITY);
			// set the indicator to true
            isSetIntensity = true;          
        }

        std::shared_ptr<void> SunImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(SunImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ISun).name())
                return std::dynamic_pointer_cast<ISun>(shared_from_this());
            else if (classifier == typeid(ISunWriter).name())
                return std::dynamic_pointer_cast<ISunWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> SunImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t SunImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int SunImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double SunImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__AZIMUTH)
                {
                    return GetAzimuth();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__ELEVATION)
                {
                    return GetElevation();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__ILLUMINANCE)
                {
                    return GetIlluminance();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__INTENSITY)
                {
                    return GetIntensity();
                }
                throw KeyNotSupportedException();

        }

        uint16_t SunImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool SunImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime SunImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> SunImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string SunImpl::GetModelType() const
        {
            return "Sun";
        }

        void SunImpl::WriteParameterToAzimuth(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__AZIMUTH, parameterName, nullTextMarker /*no textmarker*/);
            _azimuth = {};
        }

        void SunImpl::WriteParameterToElevation(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ELEVATION, parameterName, nullTextMarker /*no textmarker*/);
            _elevation = {};
        }

        void SunImpl::WriteParameterToIlluminance(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ILLUMINANCE, parameterName, nullTextMarker /*no textmarker*/);
            _illuminance = {};
        }

        void SunImpl::WriteParameterToIntensity(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__INTENSITY, parameterName, nullTextMarker /*no textmarker*/);
            _intensity = {};
        }

        std::string SunImpl::GetParameterFromAzimuth() const
        {
            auto azimuth = OSC_CONSTANTS::ATTRIBUTE__AZIMUTH;
            return GetParameterNameFromAttribute(azimuth);
        }

        std::string SunImpl::GetParameterFromElevation() const
        {
            auto elevation = OSC_CONSTANTS::ATTRIBUTE__ELEVATION;
            return GetParameterNameFromAttribute(elevation);
        }

        std::string SunImpl::GetParameterFromIlluminance() const
        {
            auto illuminance = OSC_CONSTANTS::ATTRIBUTE__ILLUMINANCE;
            return GetParameterNameFromAttribute(illuminance);
        }

        std::string SunImpl::GetParameterFromIntensity() const
        {
            auto intensity = OSC_CONSTANTS::ATTRIBUTE__INTENSITY;
            return GetParameterNameFromAttribute(intensity);
        }

        bool SunImpl::IsAzimuthParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__AZIMUTH);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool SunImpl::IsElevationParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ELEVATION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool SunImpl::IsIlluminanceParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ILLUMINANCE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool SunImpl::IsIntensityParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__INTENSITY);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        SunImpl::SunImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__AZIMUTH, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ELEVATION, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ILLUMINANCE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__INTENSITY, SimpleType::DOUBLE);
        }

        void SunImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__AZIMUTH)
            {
                // Simple type
                _azimuth = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ELEVATION)
            {
                // Simple type
                _elevation = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ILLUMINANCE)
            {
                // Simple type
                _illuminance = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__INTENSITY)
            {
                // Simple type
                _intensity = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType SunImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SunImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SunImpl::Clone()
        {
            auto clonedObject = std::make_shared<SunImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_azimuth = GetAzimuth();
            // Simple type
            clonedObject->_elevation = GetElevation();
            // Simple type
            clonedObject->_illuminance = GetIlluminance();
            // Simple type
            clonedObject->_intensity = GetIntensity();
            // clone indicators
            	clonedObject->isSetIlluminance = isSetIlluminance;
            	clonedObject->isSetIntensity = isSetIntensity;
            // clone children
            return clonedObject;
        }

        std::string SunImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SunImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SunImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SunImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string SunImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void SunImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__AZIMUTH)
            {
                // Simple type
                _azimuth = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ELEVATION)
            {
                // Simple type
                _elevation = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ILLUMINANCE)
            {
                // Simple type
                _illuminance = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__INTENSITY)
            {
                // Simple type
                _intensity = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void SunImpl::ResetIlluminance()
	   {
	   		isSetIlluminance = false; 
			_illuminance = {0};
			
	   }
       bool SunImpl::IsSetIlluminance() const
	   {
			return isSetIlluminance;
	   }
       void SunImpl::ResetIntensity()
	   {
	   		isSetIntensity = false; 
			_intensity = {};
			
	   }
       bool SunImpl::IsSetIntensity() const
	   {
			return isSetIntensity;
	   }

        IOpenScenarioFlexElement* SynchronizeActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<INamedReference<IEntity>> SynchronizeActionImpl::GetMasterEntityRef() const
        {
        	 return _masterEntityRef;
        }
        double SynchronizeActionImpl::GetTargetTolerance() const
        {
        	  return _targetTolerance;
        }
        double SynchronizeActionImpl::GetTargetToleranceMaster() const
        {
        	  return _targetToleranceMaster;
        }
        std::shared_ptr<IPosition> SynchronizeActionImpl::GetTargetPositionMaster() const
        {
        	  return _targetPositionMaster;
        }
        std::shared_ptr<IPosition> SynchronizeActionImpl::GetTargetPosition() const
        {
        	  return _targetPosition;
        }
        std::shared_ptr<IFinalSpeed> SynchronizeActionImpl::GetFinalSpeed() const
        {
        	  return _finalSpeed;
        }


        void SynchronizeActionImpl::SetMasterEntityRef(std::shared_ptr<INamedReference<IEntity>> masterEntityRef)
        {
            _masterEntityRef = masterEntityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MASTER_ENTITY_REF);
        }

        void SynchronizeActionImpl::SetTargetTolerance(const double targetTolerance)
        {
            _targetTolerance = targetTolerance;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TARGET_TOLERANCE);
			// set the indicator to true
            isSetTargetTolerance = true;          
        }

        void SynchronizeActionImpl::SetTargetToleranceMaster(const double targetToleranceMaster)
        {
            _targetToleranceMaster = targetToleranceMaster;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TARGET_TOLERANCE_MASTER);
			// set the indicator to true
            isSetTargetToleranceMaster = true;          
        }

        void SynchronizeActionImpl::SetTargetPositionMaster(std::shared_ptr<IPositionWriter> targetPositionMaster)
        {
            _targetPositionMaster = targetPositionMaster;
        }

        void SynchronizeActionImpl::SetTargetPosition(std::shared_ptr<IPositionWriter> targetPosition)
        {
            _targetPosition = targetPosition;
        }

        void SynchronizeActionImpl::SetFinalSpeed(std::shared_ptr<IFinalSpeedWriter> finalSpeed)
        {
            _finalSpeed = finalSpeed;
			// set the indicator to true
            isSetFinalSpeed = true;          
        }

        std::shared_ptr<void> SynchronizeActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(SynchronizeActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ISynchronizeAction).name())
                return std::dynamic_pointer_cast<ISynchronizeAction>(shared_from_this());
            else if (classifier == typeid(ISynchronizeActionWriter).name())
                return std::dynamic_pointer_cast<ISynchronizeActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> SynchronizeActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t SynchronizeActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int SynchronizeActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double SynchronizeActionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__TARGET_TOLERANCE)
                {
                    return GetTargetTolerance();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__TARGET_TOLERANCE_MASTER)
                {
                    return GetTargetToleranceMaster();
                }
                throw KeyNotSupportedException();

        }

        uint16_t SynchronizeActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool SynchronizeActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime SynchronizeActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> SynchronizeActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string SynchronizeActionImpl::GetModelType() const
        {
            return "SynchronizeAction";
        }

        void SynchronizeActionImpl::WriteParameterToMasterEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MASTER_ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _masterEntityRef = {};
        }

        void SynchronizeActionImpl::WriteParameterToTargetTolerance(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TARGET_TOLERANCE, parameterName, nullTextMarker /*no textmarker*/);
            _targetTolerance = {};
        }

        void SynchronizeActionImpl::WriteParameterToTargetToleranceMaster(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TARGET_TOLERANCE_MASTER, parameterName, nullTextMarker /*no textmarker*/);
            _targetToleranceMaster = {};
        }

        std::string SynchronizeActionImpl::GetParameterFromMasterEntityRef() const
        {
            auto masterEntityRef = OSC_CONSTANTS::ATTRIBUTE__MASTER_ENTITY_REF;
            return GetParameterNameFromAttribute(masterEntityRef);
        }

        std::string SynchronizeActionImpl::GetParameterFromTargetTolerance() const
        {
            auto targetTolerance = OSC_CONSTANTS::ATTRIBUTE__TARGET_TOLERANCE;
            return GetParameterNameFromAttribute(targetTolerance);
        }

        std::string SynchronizeActionImpl::GetParameterFromTargetToleranceMaster() const
        {
            auto targetToleranceMaster = OSC_CONSTANTS::ATTRIBUTE__TARGET_TOLERANCE_MASTER;
            return GetParameterNameFromAttribute(targetToleranceMaster);
        }

        bool SynchronizeActionImpl::IsMasterEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MASTER_ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool SynchronizeActionImpl::IsTargetToleranceParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TARGET_TOLERANCE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool SynchronizeActionImpl::IsTargetToleranceMasterParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TARGET_TOLERANCE_MASTER);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IPositionWriter> SynchronizeActionImpl::GetWriterTargetPositionMaster() const
        {
            return std::dynamic_pointer_cast<IPositionWriter>(_targetPositionMaster);
        }
        std::shared_ptr<IPositionWriter> SynchronizeActionImpl::GetWriterTargetPosition() const
        {
            return std::dynamic_pointer_cast<IPositionWriter>(_targetPosition);
        }
        std::shared_ptr<IFinalSpeedWriter> SynchronizeActionImpl::GetWriterFinalSpeed() const
        {
            return std::dynamic_pointer_cast<IFinalSpeedWriter>(_finalSpeed);
        }

        SynchronizeActionImpl::SynchronizeActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MASTER_ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TARGET_TOLERANCE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TARGET_TOLERANCE_MASTER, SimpleType::DOUBLE);
        }

        void SynchronizeActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MASTER_ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _masterEntityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TARGET_TOLERANCE)
            {
                // Simple type
                _targetTolerance = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TARGET_TOLERANCE_MASTER)
            {
                // Simple type
                _targetToleranceMaster = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType SynchronizeActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SynchronizeActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kTargetPositionMaster =  GetWriterTargetPositionMaster();
                if (kTargetPositionMaster)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTargetPositionMaster));
                }
                const auto kTargetPosition =  GetWriterTargetPosition();
                if (kTargetPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTargetPosition));
                }
                const auto kFinalSpeed =  GetWriterFinalSpeed();
                if (kFinalSpeed)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kFinalSpeed));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SynchronizeActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<SynchronizeActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetMasterEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_masterEntityRef = proxy;
            
            // Simple type
            clonedObject->_targetTolerance = GetTargetTolerance();
            // Simple type
            clonedObject->_targetToleranceMaster = GetTargetToleranceMaster();
            // clone indicators
            	clonedObject->isSetTargetTolerance = isSetTargetTolerance;
            	clonedObject->isSetTargetToleranceMaster = isSetTargetToleranceMaster;
            // clone children
            const auto kTargetPositionMaster =  GetWriterTargetPositionMaster();
            if (kTargetPositionMaster)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kTargetPositionMaster)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTargetPositionMaster(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            const auto kTargetPosition =  GetWriterTargetPosition();
            if (kTargetPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kTargetPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTargetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            const auto kFinalSpeed =  GetWriterFinalSpeed();
            if (kFinalSpeed)
            {
                auto clonedChild = std::dynamic_pointer_cast<FinalSpeedImpl>(kFinalSpeed)->Clone();
                auto clonedChildIFinalSpeed = std::dynamic_pointer_cast<IFinalSpeed>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetFinalSpeed(std::dynamic_pointer_cast<IFinalSpeedWriter>(clonedChildIFinalSpeed));
            }
            return clonedObject;
        }

        std::string SynchronizeActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__MASTER_ENTITY_REF)
            {
                // Get the Proxy
                auto masterEntityRef = GetMasterEntityRef();
                return masterEntityRef!= nullptr ? masterEntityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SynchronizeActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TARGET_POSITION_MASTER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTargetPositionMaster());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TARGET_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTargetPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__FINAL_SPEED)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetFinalSpeed());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SynchronizeActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SynchronizeActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__MASTER_ENTITY_REF)
            {
                // Get the Proxy
                auto masterEntityRef = GetMasterEntityRef();
                return masterEntityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(masterEntityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string SynchronizeActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void SynchronizeActionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TARGET_TOLERANCE)
            {
                // Simple type
                _targetTolerance = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TARGET_TOLERANCE_MASTER)
            {
                // Simple type
                _targetToleranceMaster = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void SynchronizeActionImpl::ResetTargetTolerance()
	   {
	   		isSetTargetTolerance = false; 
			_targetTolerance = {};
			
	   }
       bool SynchronizeActionImpl::IsSetTargetTolerance() const
	   {
			return isSetTargetTolerance;
	   }
       void SynchronizeActionImpl::ResetTargetToleranceMaster()
	   {
	   		isSetTargetToleranceMaster = false; 
			_targetToleranceMaster = {};
			
	   }
       bool SynchronizeActionImpl::IsSetTargetToleranceMaster() const
	   {
			return isSetTargetToleranceMaster;
	   }
       void SynchronizeActionImpl::ResetFinalSpeed()
	   {
	   		isSetFinalSpeed = false; 
			_finalSpeed = {};
			
	   }
       bool SynchronizeActionImpl::IsSetFinalSpeed() const
	   {
			return isSetFinalSpeed;
	   }

        IOpenScenarioFlexElement* TargetDistanceSteadyStateImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double TargetDistanceSteadyStateImpl::GetDistance() const
        {
        	  return _distance;
        }


        void TargetDistanceSteadyStateImpl::SetDistance(const double distance)
        {
            _distance = distance;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DISTANCE);
        }

        std::shared_ptr<void> TargetDistanceSteadyStateImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TargetDistanceSteadyStateImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITargetDistanceSteadyState).name())
                return std::dynamic_pointer_cast<ITargetDistanceSteadyState>(shared_from_this());
            else if (classifier == typeid(ITargetDistanceSteadyStateWriter).name())
                return std::dynamic_pointer_cast<ITargetDistanceSteadyStateWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TargetDistanceSteadyStateImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TargetDistanceSteadyStateImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TargetDistanceSteadyStateImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TargetDistanceSteadyStateImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__DISTANCE)
                {
                    return GetDistance();
                }
                throw KeyNotSupportedException();

        }

        uint16_t TargetDistanceSteadyStateImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TargetDistanceSteadyStateImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TargetDistanceSteadyStateImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TargetDistanceSteadyStateImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TargetDistanceSteadyStateImpl::GetModelType() const
        {
            return "TargetDistanceSteadyState";
        }

        void TargetDistanceSteadyStateImpl::WriteParameterToDistance(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DISTANCE, parameterName, nullTextMarker /*no textmarker*/);
            _distance = {};
        }

        std::string TargetDistanceSteadyStateImpl::GetParameterFromDistance() const
        {
            auto distance = OSC_CONSTANTS::ATTRIBUTE__DISTANCE;
            return GetParameterNameFromAttribute(distance);
        }

        bool TargetDistanceSteadyStateImpl::IsDistanceParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DISTANCE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        TargetDistanceSteadyStateImpl::TargetDistanceSteadyStateImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DISTANCE, SimpleType::DOUBLE);
        }

        void TargetDistanceSteadyStateImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DISTANCE)
            {
                // Simple type
                _distance = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TargetDistanceSteadyStateImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TargetDistanceSteadyStateImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TargetDistanceSteadyStateImpl::Clone()
        {
            auto clonedObject = std::make_shared<TargetDistanceSteadyStateImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_distance = GetDistance();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string TargetDistanceSteadyStateImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TargetDistanceSteadyStateImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TargetDistanceSteadyStateImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TargetDistanceSteadyStateImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TargetDistanceSteadyStateImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void TargetDistanceSteadyStateImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DISTANCE)
            {
                // Simple type
                _distance = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* TargetTimeSteadyStateImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double TargetTimeSteadyStateImpl::GetTime() const
        {
        	  return _time;
        }


        void TargetTimeSteadyStateImpl::SetTime(const double time)
        {
            _time = time;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TIME);
        }

        std::shared_ptr<void> TargetTimeSteadyStateImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TargetTimeSteadyStateImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITargetTimeSteadyState).name())
                return std::dynamic_pointer_cast<ITargetTimeSteadyState>(shared_from_this());
            else if (classifier == typeid(ITargetTimeSteadyStateWriter).name())
                return std::dynamic_pointer_cast<ITargetTimeSteadyStateWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TargetTimeSteadyStateImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TargetTimeSteadyStateImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TargetTimeSteadyStateImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TargetTimeSteadyStateImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__TIME)
                {
                    return GetTime();
                }
                throw KeyNotSupportedException();

        }

        uint16_t TargetTimeSteadyStateImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TargetTimeSteadyStateImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TargetTimeSteadyStateImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TargetTimeSteadyStateImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TargetTimeSteadyStateImpl::GetModelType() const
        {
            return "TargetTimeSteadyState";
        }

        void TargetTimeSteadyStateImpl::WriteParameterToTime(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TIME, parameterName, nullTextMarker /*no textmarker*/);
            _time = {};
        }

        std::string TargetTimeSteadyStateImpl::GetParameterFromTime() const
        {
            auto time = OSC_CONSTANTS::ATTRIBUTE__TIME;
            return GetParameterNameFromAttribute(time);
        }

        bool TargetTimeSteadyStateImpl::IsTimeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TIME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        TargetTimeSteadyStateImpl::TargetTimeSteadyStateImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TIME, SimpleType::DOUBLE);
        }

        void TargetTimeSteadyStateImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TIME)
            {
                // Simple type
                _time = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TargetTimeSteadyStateImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TargetTimeSteadyStateImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TargetTimeSteadyStateImpl::Clone()
        {
            auto clonedObject = std::make_shared<TargetTimeSteadyStateImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_time = GetTime();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string TargetTimeSteadyStateImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TargetTimeSteadyStateImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TargetTimeSteadyStateImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TargetTimeSteadyStateImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TargetTimeSteadyStateImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void TargetTimeSteadyStateImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TIME)
            {
                // Simple type
                _time = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* TeleportActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IPosition> TeleportActionImpl::GetPosition() const
        {
        	  return _position;
        }


        void TeleportActionImpl::SetPosition(std::shared_ptr<IPositionWriter> position)
        {
            _position = position;
        }

        std::shared_ptr<void> TeleportActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TeleportActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITeleportAction).name())
                return std::dynamic_pointer_cast<ITeleportAction>(shared_from_this());
            else if (classifier == typeid(ITeleportActionWriter).name())
                return std::dynamic_pointer_cast<ITeleportActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TeleportActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TeleportActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TeleportActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TeleportActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TeleportActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TeleportActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TeleportActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TeleportActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TeleportActionImpl::GetModelType() const
        {
            return "TeleportAction";
        }

            // children
        std::shared_ptr<IPositionWriter> TeleportActionImpl::GetWriterPosition() const
        {
            return std::dynamic_pointer_cast<IPositionWriter>(_position);
        }

        TeleportActionImpl::TeleportActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void TeleportActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType TeleportActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TeleportActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TeleportActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TeleportActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            return clonedObject;
        }

        std::string TeleportActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TeleportActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TeleportActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TeleportActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TeleportActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* TimeHeadwayConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool TimeHeadwayConditionImpl::GetAlongRoute() const
        {
        	  return _alongRoute;
        }
        CoordinateSystem TimeHeadwayConditionImpl::GetCoordinateSystem() const
        {
        	  return _coordinateSystem;
        }
        std::shared_ptr<INamedReference<IEntity>> TimeHeadwayConditionImpl::GetEntityRef() const
        {
        	 return _entityRef;
        }
        bool TimeHeadwayConditionImpl::GetFreespace() const
        {
        	  return _freespace;
        }
        RelativeDistanceType TimeHeadwayConditionImpl::GetRelativeDistanceType() const
        {
        	  return _relativeDistanceType;
        }
        RoutingAlgorithm TimeHeadwayConditionImpl::GetRoutingAlgorithm() const
        {
        	  return _routingAlgorithm;
        }
        Rule TimeHeadwayConditionImpl::GetRule() const
        {
        	  return _rule;
        }
        double TimeHeadwayConditionImpl::GetValue() const
        {
        	  return _value;
        }


        void TimeHeadwayConditionImpl::SetAlongRoute(const bool alongRoute)
        {
            _alongRoute = alongRoute;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE);
			// set the indicator to true
            isSetAlongRoute = true;          
        }

        void TimeHeadwayConditionImpl::SetCoordinateSystem(const CoordinateSystem coordinateSystem)
        {
            _coordinateSystem = coordinateSystem;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM);
			// set the indicator to true
            isSetCoordinateSystem = true;          
        }

        void TimeHeadwayConditionImpl::SetEntityRef(std::shared_ptr<INamedReference<IEntity>> entityRef)
        {
            _entityRef = entityRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
        }

        void TimeHeadwayConditionImpl::SetFreespace(const bool freespace)
        {
            _freespace = freespace;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FREESPACE);
        }

        void TimeHeadwayConditionImpl::SetRelativeDistanceType(const RelativeDistanceType relativeDistanceType)
        {
            _relativeDistanceType = relativeDistanceType;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE);
			// set the indicator to true
            isSetRelativeDistanceType = true;          
        }

        void TimeHeadwayConditionImpl::SetRoutingAlgorithm(const RoutingAlgorithm routingAlgorithm)
        {
            _routingAlgorithm = routingAlgorithm;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM);
			// set the indicator to true
            isSetRoutingAlgorithm = true;          
        }

        void TimeHeadwayConditionImpl::SetRule(const Rule rule)
        {
            _rule = rule;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE);
        }

        void TimeHeadwayConditionImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> TimeHeadwayConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TimeHeadwayConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITimeHeadwayCondition).name())
                return std::dynamic_pointer_cast<ITimeHeadwayCondition>(shared_from_this());
            else if (classifier == typeid(ITimeHeadwayConditionWriter).name())
                return std::dynamic_pointer_cast<ITimeHeadwayConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TimeHeadwayConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TimeHeadwayConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TimeHeadwayConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TimeHeadwayConditionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t TimeHeadwayConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TimeHeadwayConditionImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE)
                {
                    return GetAlongRoute();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
                {
                    return GetFreespace();
                }
                throw KeyNotSupportedException();

        }

        DateTime TimeHeadwayConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TimeHeadwayConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TimeHeadwayConditionImpl::GetModelType() const
        {
            return "TimeHeadwayCondition";
        }

        void TimeHeadwayConditionImpl::WriteParameterToAlongRoute(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE, parameterName, nullTextMarker /*no textmarker*/);
            _alongRoute = {};
        }

        void TimeHeadwayConditionImpl::WriteParameterToCoordinateSystem(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM, parameterName, nullTextMarker /*no textmarker*/);
            _coordinateSystem = {};
        }

        void TimeHeadwayConditionImpl::WriteParameterToEntityRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, parameterName, nullTextMarker /*no textmarker*/);
            _entityRef = {};
        }

        void TimeHeadwayConditionImpl::WriteParameterToFreespace(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FREESPACE, parameterName, nullTextMarker /*no textmarker*/);
            _freespace = {};
        }

        void TimeHeadwayConditionImpl::WriteParameterToRelativeDistanceType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _relativeDistanceType = {};
        }

        void TimeHeadwayConditionImpl::WriteParameterToRoutingAlgorithm(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM, parameterName, nullTextMarker /*no textmarker*/);
            _routingAlgorithm = {};
        }

        void TimeHeadwayConditionImpl::WriteParameterToRule(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE, parameterName, nullTextMarker /*no textmarker*/);
            _rule = {};
        }

        void TimeHeadwayConditionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string TimeHeadwayConditionImpl::GetParameterFromAlongRoute() const
        {
            auto alongRoute = OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE;
            return GetParameterNameFromAttribute(alongRoute);
        }

        std::string TimeHeadwayConditionImpl::GetParameterFromCoordinateSystem() const
        {
            auto coordinateSystem = OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM;
            return GetParameterNameFromAttribute(coordinateSystem);
        }

        std::string TimeHeadwayConditionImpl::GetParameterFromEntityRef() const
        {
            auto entityRef = OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF;
            return GetParameterNameFromAttribute(entityRef);
        }

        std::string TimeHeadwayConditionImpl::GetParameterFromFreespace() const
        {
            auto freespace = OSC_CONSTANTS::ATTRIBUTE__FREESPACE;
            return GetParameterNameFromAttribute(freespace);
        }

        std::string TimeHeadwayConditionImpl::GetParameterFromRelativeDistanceType() const
        {
            auto relativeDistanceType = OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE;
            return GetParameterNameFromAttribute(relativeDistanceType);
        }

        std::string TimeHeadwayConditionImpl::GetParameterFromRoutingAlgorithm() const
        {
            auto routingAlgorithm = OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM;
            return GetParameterNameFromAttribute(routingAlgorithm);
        }

        std::string TimeHeadwayConditionImpl::GetParameterFromRule() const
        {
            auto rule = OSC_CONSTANTS::ATTRIBUTE__RULE;
            return GetParameterNameFromAttribute(rule);
        }

        std::string TimeHeadwayConditionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool TimeHeadwayConditionImpl::IsAlongRouteParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TimeHeadwayConditionImpl::IsCoordinateSystemParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TimeHeadwayConditionImpl::IsEntityRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TimeHeadwayConditionImpl::IsFreespaceParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__FREESPACE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TimeHeadwayConditionImpl::IsRelativeDistanceTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TimeHeadwayConditionImpl::IsRoutingAlgorithmParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TimeHeadwayConditionImpl::IsRuleParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RULE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TimeHeadwayConditionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        TimeHeadwayConditionImpl::TimeHeadwayConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FREESPACE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void TimeHeadwayConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE)
            {
                // Simple type
                _alongRoute = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM)
            {
                // Enumeration Type
                const auto kResult = CoordinateSystem::GetFromLiteral(parameterLiteralValue);
                if (kResult != CoordinateSystem::UNKNOWN)
                {
                    _coordinateSystem = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
            {
                // Simple type
                _freespace = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE)
            {
                // Enumeration Type
                const auto kResult = RelativeDistanceType::GetFromLiteral(parameterLiteralValue);
                if (kResult != RelativeDistanceType::UNKNOWN)
                {
                    _relativeDistanceType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM)
            {
                // Enumeration Type
                const auto kResult = RoutingAlgorithm::GetFromLiteral(parameterLiteralValue);
                if (kResult != RoutingAlgorithm::UNKNOWN)
                {
                    _routingAlgorithm = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TimeHeadwayConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TimeHeadwayConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TimeHeadwayConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TimeHeadwayConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_alongRoute = GetAlongRoute();
            // Enumeration Type
            const auto kCoordinateSystem = GetCoordinateSystem();
            if ( kCoordinateSystem.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_coordinateSystem = CoordinateSystem::GetFromLiteral(kCoordinateSystem.GetLiteral());
            }
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Simple type
            clonedObject->_freespace = GetFreespace();
            // Enumeration Type
            const auto kRelativeDistanceType = GetRelativeDistanceType();
            if ( kRelativeDistanceType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_relativeDistanceType = RelativeDistanceType::GetFromLiteral(kRelativeDistanceType.GetLiteral());
            }
            // Enumeration Type
            const auto kRoutingAlgorithm = GetRoutingAlgorithm();
            if ( kRoutingAlgorithm.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_routingAlgorithm = RoutingAlgorithm::GetFromLiteral(kRoutingAlgorithm.GetLiteral());
            }
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            	clonedObject->isSetAlongRoute = isSetAlongRoute;
            	clonedObject->isSetCoordinateSystem = isSetCoordinateSystem;
            	clonedObject->isSetRelativeDistanceType = isSetRelativeDistanceType;
            	clonedObject->isSetRoutingAlgorithm = isSetRoutingAlgorithm;
            // clone children
            return clonedObject;
        }

        std::string TimeHeadwayConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeHeadwayConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TimeHeadwayConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeHeadwayConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string TimeHeadwayConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM)
            {
                auto coordinateSystem = GetCoordinateSystem();
                return coordinateSystem.GetLiteral() != "UNKNOWN" ? coordinateSystem.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE)
            {
                auto relativeDistanceType = GetRelativeDistanceType();
                return relativeDistanceType.GetLiteral() != "UNKNOWN" ? relativeDistanceType.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM)
            {
                auto routingAlgorithm = GetRoutingAlgorithm();
                return routingAlgorithm.GetLiteral() != "UNKNOWN" ? routingAlgorithm.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void TimeHeadwayConditionImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE)
            {
                // Simple type
                _alongRoute = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
            {
                // Simple type
                _freespace = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void TimeHeadwayConditionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void TimeHeadwayConditionImpl::ResetAlongRoute()
	   {
	   		isSetAlongRoute = false; 
			_alongRoute = {};
			
	   }
       bool TimeHeadwayConditionImpl::IsSetAlongRoute() const
	   {
			return isSetAlongRoute;
	   }
       void TimeHeadwayConditionImpl::ResetCoordinateSystem()
	   {
	   		isSetCoordinateSystem = false; 
			_coordinateSystem = {CoordinateSystem::CoordinateSystemEnum::ENTITY};
			
	   }
       bool TimeHeadwayConditionImpl::IsSetCoordinateSystem() const
	   {
			return isSetCoordinateSystem;
	   }
       void TimeHeadwayConditionImpl::ResetRelativeDistanceType()
	   {
	   		isSetRelativeDistanceType = false; 
			_relativeDistanceType = {RelativeDistanceType::RelativeDistanceTypeEnum::EUCLIDIAN_DISTANCE};
			
	   }
       bool TimeHeadwayConditionImpl::IsSetRelativeDistanceType() const
	   {
			return isSetRelativeDistanceType;
	   }
       void TimeHeadwayConditionImpl::ResetRoutingAlgorithm()
	   {
	   		isSetRoutingAlgorithm = false; 
			_routingAlgorithm = {};
			
	   }
       bool TimeHeadwayConditionImpl::IsSetRoutingAlgorithm() const
	   {
			return isSetRoutingAlgorithm;
	   }

        IOpenScenarioFlexElement* TimeOfDayImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool TimeOfDayImpl::GetAnimation() const
        {
        	  return _animation;
        }
        DateTime TimeOfDayImpl::GetDateTime() const
        {
        	  return _dateTime;
        }


        void TimeOfDayImpl::SetAnimation(const bool animation)
        {
            _animation = animation;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ANIMATION);
        }

        void TimeOfDayImpl::SetDateTime(const DateTime dateTime)
        {
            _dateTime = dateTime;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DATE_TIME);
        }

        std::shared_ptr<void> TimeOfDayImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TimeOfDayImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITimeOfDay).name())
                return std::dynamic_pointer_cast<ITimeOfDay>(shared_from_this());
            else if (classifier == typeid(ITimeOfDayWriter).name())
                return std::dynamic_pointer_cast<ITimeOfDayWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TimeOfDayImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TimeOfDayImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TimeOfDayImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TimeOfDayImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TimeOfDayImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TimeOfDayImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__ANIMATION)
                {
                    return GetAnimation();
                }
                throw KeyNotSupportedException();

        }

        DateTime TimeOfDayImpl::GetDateTimeProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__DATE_TIME)
                {
                    return GetDateTime();
                }
                throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TimeOfDayImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TimeOfDayImpl::GetModelType() const
        {
            return "TimeOfDay";
        }

        void TimeOfDayImpl::WriteParameterToAnimation(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ANIMATION, parameterName, nullTextMarker /*no textmarker*/);
            _animation = {};
        }

        void TimeOfDayImpl::WriteParameterToDateTime(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DATE_TIME, parameterName, nullTextMarker /*no textmarker*/);
            _dateTime = {};
        }

        std::string TimeOfDayImpl::GetParameterFromAnimation() const
        {
            auto animation = OSC_CONSTANTS::ATTRIBUTE__ANIMATION;
            return GetParameterNameFromAttribute(animation);
        }

        std::string TimeOfDayImpl::GetParameterFromDateTime() const
        {
            auto dateTime = OSC_CONSTANTS::ATTRIBUTE__DATE_TIME;
            return GetParameterNameFromAttribute(dateTime);
        }

        bool TimeOfDayImpl::IsAnimationParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ANIMATION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TimeOfDayImpl::IsDateTimeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DATE_TIME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        TimeOfDayImpl::TimeOfDayImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ANIMATION, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DATE_TIME, SimpleType::DATE_TIME);
        }

        void TimeOfDayImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ANIMATION)
            {
                // Simple type
                _animation = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DATE_TIME)
            {
                // Simple type
                _dateTime = ParserHelper::ParseDateTime(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TimeOfDayImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TimeOfDayImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TimeOfDayImpl::Clone()
        {
            auto clonedObject = std::make_shared<TimeOfDayImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_animation = GetAnimation();
            // Simple type
            clonedObject->_dateTime = GetDateTime();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string TimeOfDayImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeOfDayImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TimeOfDayImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeOfDayImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TimeOfDayImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void TimeOfDayImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ANIMATION)
            {
                // Simple type
                _animation = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void TimeOfDayImpl::ResolveDateTimeExpression(std::string& attributeKey, DateTime& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DATE_TIME)
            {
                // Simple type
                _dateTime = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* TimeOfDayConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        DateTime TimeOfDayConditionImpl::GetDateTime() const
        {
        	  return _dateTime;
        }
        Rule TimeOfDayConditionImpl::GetRule() const
        {
        	  return _rule;
        }


        void TimeOfDayConditionImpl::SetDateTime(const DateTime dateTime)
        {
            _dateTime = dateTime;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DATE_TIME);
        }

        void TimeOfDayConditionImpl::SetRule(const Rule rule)
        {
            _rule = rule;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE);
        }

        std::shared_ptr<void> TimeOfDayConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TimeOfDayConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITimeOfDayCondition).name())
                return std::dynamic_pointer_cast<ITimeOfDayCondition>(shared_from_this());
            else if (classifier == typeid(ITimeOfDayConditionWriter).name())
                return std::dynamic_pointer_cast<ITimeOfDayConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TimeOfDayConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TimeOfDayConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TimeOfDayConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TimeOfDayConditionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TimeOfDayConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TimeOfDayConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TimeOfDayConditionImpl::GetDateTimeProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__DATE_TIME)
                {
                    return GetDateTime();
                }
                throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TimeOfDayConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TimeOfDayConditionImpl::GetModelType() const
        {
            return "TimeOfDayCondition";
        }

        void TimeOfDayConditionImpl::WriteParameterToDateTime(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DATE_TIME, parameterName, nullTextMarker /*no textmarker*/);
            _dateTime = {};
        }

        void TimeOfDayConditionImpl::WriteParameterToRule(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE, parameterName, nullTextMarker /*no textmarker*/);
            _rule = {};
        }

        std::string TimeOfDayConditionImpl::GetParameterFromDateTime() const
        {
            auto dateTime = OSC_CONSTANTS::ATTRIBUTE__DATE_TIME;
            return GetParameterNameFromAttribute(dateTime);
        }

        std::string TimeOfDayConditionImpl::GetParameterFromRule() const
        {
            auto rule = OSC_CONSTANTS::ATTRIBUTE__RULE;
            return GetParameterNameFromAttribute(rule);
        }

        bool TimeOfDayConditionImpl::IsDateTimeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DATE_TIME);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TimeOfDayConditionImpl::IsRuleParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RULE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        TimeOfDayConditionImpl::TimeOfDayConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DATE_TIME, SimpleType::DATE_TIME);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
        }

        void TimeOfDayConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DATE_TIME)
            {
                // Simple type
                _dateTime = ParserHelper::ParseDateTime(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType TimeOfDayConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TimeOfDayConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TimeOfDayConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TimeOfDayConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_dateTime = GetDateTime();
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string TimeOfDayConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeOfDayConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TimeOfDayConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeOfDayConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TimeOfDayConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void TimeOfDayConditionImpl::ResolveDateTimeExpression(std::string& attributeKey, DateTime& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DATE_TIME)
            {
                // Simple type
                _dateTime = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* TimeReferenceImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<INone> TimeReferenceImpl::GetNone() const
        {
        	  return _none;
        }
        std::shared_ptr<ITiming> TimeReferenceImpl::GetTiming() const
        {
        	  return _timing;
        }


        void TimeReferenceImpl::SetNone(std::shared_ptr<INoneWriter> none)
        {
            _none = none;
            _timing = {};
			// set the indicator to true
            isSetNone = true;          
        }

        void TimeReferenceImpl::SetTiming(std::shared_ptr<ITimingWriter> timing)
        {
            _timing = timing;
            _none = {};
			// set the indicator to true
            isSetTiming = true;          
        }

        std::shared_ptr<void> TimeReferenceImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TimeReferenceImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITimeReference).name())
                return std::dynamic_pointer_cast<ITimeReference>(shared_from_this());
            else if (classifier == typeid(ITimeReferenceWriter).name())
                return std::dynamic_pointer_cast<ITimeReferenceWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TimeReferenceImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TimeReferenceImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TimeReferenceImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TimeReferenceImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TimeReferenceImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TimeReferenceImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TimeReferenceImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TimeReferenceImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TimeReferenceImpl::GetModelType() const
        {
            return "TimeReference";
        }

            // children
        std::shared_ptr<INoneWriter> TimeReferenceImpl::GetWriterNone() const
        {
            return std::dynamic_pointer_cast<INoneWriter>(_none);
        }
        std::shared_ptr<ITimingWriter> TimeReferenceImpl::GetWriterTiming() const
        {
            return std::dynamic_pointer_cast<ITimingWriter>(_timing);
        }

        TimeReferenceImpl::TimeReferenceImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void TimeReferenceImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType TimeReferenceImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TimeReferenceImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kNone =  GetWriterNone();
                if (kNone)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kNone));
                }
                const auto kTiming =  GetWriterTiming();
                if (kTiming)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTiming));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TimeReferenceImpl::Clone()
        {
            auto clonedObject = std::make_shared<TimeReferenceImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kNone =  GetWriterNone();
            if (kNone)
            {
                auto clonedChild = std::dynamic_pointer_cast<NoneImpl>(kNone)->Clone();
                auto clonedChildINone = std::dynamic_pointer_cast<INone>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetNone(std::dynamic_pointer_cast<INoneWriter>(clonedChildINone));
            }
            const auto kTiming =  GetWriterTiming();
            if (kTiming)
            {
                auto clonedChild = std::dynamic_pointer_cast<TimingImpl>(kTiming)->Clone();
                auto clonedChildITiming = std::dynamic_pointer_cast<ITiming>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTiming(std::dynamic_pointer_cast<ITimingWriter>(clonedChildITiming));
            }
            return clonedObject;
        }

        std::string TimeReferenceImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeReferenceImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__NONE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetNone());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TIMING)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTiming());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TimeReferenceImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeReferenceImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TimeReferenceImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void TimeReferenceImpl::ResetNone()
	   {
	   		isSetNone = false; 
			_none = {};
			
	   }
       bool TimeReferenceImpl::IsSetNone() const
	   {
			return isSetNone;
	   }
       void TimeReferenceImpl::ResetTiming()
	   {
	   		isSetTiming = false; 
			_timing = {};
			
	   }
       bool TimeReferenceImpl::IsSetTiming() const
	   {
			return isSetTiming;
	   }

        IOpenScenarioFlexElement* TimeToCollisionConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool TimeToCollisionConditionImpl::GetAlongRoute() const
        {
        	  return _alongRoute;
        }
        CoordinateSystem TimeToCollisionConditionImpl::GetCoordinateSystem() const
        {
        	  return _coordinateSystem;
        }
        bool TimeToCollisionConditionImpl::GetFreespace() const
        {
        	  return _freespace;
        }
        RelativeDistanceType TimeToCollisionConditionImpl::GetRelativeDistanceType() const
        {
        	  return _relativeDistanceType;
        }
        RoutingAlgorithm TimeToCollisionConditionImpl::GetRoutingAlgorithm() const
        {
        	  return _routingAlgorithm;
        }
        Rule TimeToCollisionConditionImpl::GetRule() const
        {
        	  return _rule;
        }
        double TimeToCollisionConditionImpl::GetValue() const
        {
        	  return _value;
        }
        std::shared_ptr<ITimeToCollisionConditionTarget> TimeToCollisionConditionImpl::GetTimeToCollisionConditionTarget() const
        {
        	  return _timeToCollisionConditionTarget;
        }


        void TimeToCollisionConditionImpl::SetAlongRoute(const bool alongRoute)
        {
            _alongRoute = alongRoute;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE);
			// set the indicator to true
            isSetAlongRoute = true;          
        }

        void TimeToCollisionConditionImpl::SetCoordinateSystem(const CoordinateSystem coordinateSystem)
        {
            _coordinateSystem = coordinateSystem;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM);
			// set the indicator to true
            isSetCoordinateSystem = true;          
        }

        void TimeToCollisionConditionImpl::SetFreespace(const bool freespace)
        {
            _freespace = freespace;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FREESPACE);
        }

        void TimeToCollisionConditionImpl::SetRelativeDistanceType(const RelativeDistanceType relativeDistanceType)
        {
            _relativeDistanceType = relativeDistanceType;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE);
			// set the indicator to true
            isSetRelativeDistanceType = true;          
        }

        void TimeToCollisionConditionImpl::SetRoutingAlgorithm(const RoutingAlgorithm routingAlgorithm)
        {
            _routingAlgorithm = routingAlgorithm;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM);
			// set the indicator to true
            isSetRoutingAlgorithm = true;          
        }

        void TimeToCollisionConditionImpl::SetRule(const Rule rule)
        {
            _rule = rule;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE);
        }

        void TimeToCollisionConditionImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        void TimeToCollisionConditionImpl::SetTimeToCollisionConditionTarget(std::shared_ptr<ITimeToCollisionConditionTargetWriter> timeToCollisionConditionTarget)
        {
            _timeToCollisionConditionTarget = timeToCollisionConditionTarget;
        }

        std::shared_ptr<void> TimeToCollisionConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TimeToCollisionConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITimeToCollisionCondition).name())
                return std::dynamic_pointer_cast<ITimeToCollisionCondition>(shared_from_this());
            else if (classifier == typeid(ITimeToCollisionConditionWriter).name())
                return std::dynamic_pointer_cast<ITimeToCollisionConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TimeToCollisionConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TimeToCollisionConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TimeToCollisionConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TimeToCollisionConditionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t TimeToCollisionConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TimeToCollisionConditionImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE)
                {
                    return GetAlongRoute();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
                {
                    return GetFreespace();
                }
                throw KeyNotSupportedException();

        }

        DateTime TimeToCollisionConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TimeToCollisionConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TimeToCollisionConditionImpl::GetModelType() const
        {
            return "TimeToCollisionCondition";
        }

        void TimeToCollisionConditionImpl::WriteParameterToAlongRoute(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE, parameterName, nullTextMarker /*no textmarker*/);
            _alongRoute = {};
        }

        void TimeToCollisionConditionImpl::WriteParameterToCoordinateSystem(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM, parameterName, nullTextMarker /*no textmarker*/);
            _coordinateSystem = {};
        }

        void TimeToCollisionConditionImpl::WriteParameterToFreespace(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FREESPACE, parameterName, nullTextMarker /*no textmarker*/);
            _freespace = {};
        }

        void TimeToCollisionConditionImpl::WriteParameterToRelativeDistanceType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _relativeDistanceType = {};
        }

        void TimeToCollisionConditionImpl::WriteParameterToRoutingAlgorithm(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM, parameterName, nullTextMarker /*no textmarker*/);
            _routingAlgorithm = {};
        }

        void TimeToCollisionConditionImpl::WriteParameterToRule(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE, parameterName, nullTextMarker /*no textmarker*/);
            _rule = {};
        }

        void TimeToCollisionConditionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string TimeToCollisionConditionImpl::GetParameterFromAlongRoute() const
        {
            auto alongRoute = OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE;
            return GetParameterNameFromAttribute(alongRoute);
        }

        std::string TimeToCollisionConditionImpl::GetParameterFromCoordinateSystem() const
        {
            auto coordinateSystem = OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM;
            return GetParameterNameFromAttribute(coordinateSystem);
        }

        std::string TimeToCollisionConditionImpl::GetParameterFromFreespace() const
        {
            auto freespace = OSC_CONSTANTS::ATTRIBUTE__FREESPACE;
            return GetParameterNameFromAttribute(freespace);
        }

        std::string TimeToCollisionConditionImpl::GetParameterFromRelativeDistanceType() const
        {
            auto relativeDistanceType = OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE;
            return GetParameterNameFromAttribute(relativeDistanceType);
        }

        std::string TimeToCollisionConditionImpl::GetParameterFromRoutingAlgorithm() const
        {
            auto routingAlgorithm = OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM;
            return GetParameterNameFromAttribute(routingAlgorithm);
        }

        std::string TimeToCollisionConditionImpl::GetParameterFromRule() const
        {
            auto rule = OSC_CONSTANTS::ATTRIBUTE__RULE;
            return GetParameterNameFromAttribute(rule);
        }

        std::string TimeToCollisionConditionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool TimeToCollisionConditionImpl::IsAlongRouteParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TimeToCollisionConditionImpl::IsCoordinateSystemParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TimeToCollisionConditionImpl::IsFreespaceParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__FREESPACE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TimeToCollisionConditionImpl::IsRelativeDistanceTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TimeToCollisionConditionImpl::IsRoutingAlgorithmParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TimeToCollisionConditionImpl::IsRuleParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RULE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TimeToCollisionConditionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<ITimeToCollisionConditionTargetWriter> TimeToCollisionConditionImpl::GetWriterTimeToCollisionConditionTarget() const
        {
            return std::dynamic_pointer_cast<ITimeToCollisionConditionTargetWriter>(_timeToCollisionConditionTarget);
        }

        TimeToCollisionConditionImpl::TimeToCollisionConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FREESPACE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void TimeToCollisionConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE)
            {
                // Simple type
                _alongRoute = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM)
            {
                // Enumeration Type
                const auto kResult = CoordinateSystem::GetFromLiteral(parameterLiteralValue);
                if (kResult != CoordinateSystem::UNKNOWN)
                {
                    _coordinateSystem = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
            {
                // Simple type
                _freespace = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE)
            {
                // Enumeration Type
                const auto kResult = RelativeDistanceType::GetFromLiteral(parameterLiteralValue);
                if (kResult != RelativeDistanceType::UNKNOWN)
                {
                    _relativeDistanceType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM)
            {
                // Enumeration Type
                const auto kResult = RoutingAlgorithm::GetFromLiteral(parameterLiteralValue);
                if (kResult != RoutingAlgorithm::UNKNOWN)
                {
                    _routingAlgorithm = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TimeToCollisionConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TimeToCollisionConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kTimeToCollisionConditionTarget =  GetWriterTimeToCollisionConditionTarget();
                if (kTimeToCollisionConditionTarget)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTimeToCollisionConditionTarget));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TimeToCollisionConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TimeToCollisionConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_alongRoute = GetAlongRoute();
            // Enumeration Type
            const auto kCoordinateSystem = GetCoordinateSystem();
            if ( kCoordinateSystem.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_coordinateSystem = CoordinateSystem::GetFromLiteral(kCoordinateSystem.GetLiteral());
            }
            // Simple type
            clonedObject->_freespace = GetFreespace();
            // Enumeration Type
            const auto kRelativeDistanceType = GetRelativeDistanceType();
            if ( kRelativeDistanceType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_relativeDistanceType = RelativeDistanceType::GetFromLiteral(kRelativeDistanceType.GetLiteral());
            }
            // Enumeration Type
            const auto kRoutingAlgorithm = GetRoutingAlgorithm();
            if ( kRoutingAlgorithm.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_routingAlgorithm = RoutingAlgorithm::GetFromLiteral(kRoutingAlgorithm.GetLiteral());
            }
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            	clonedObject->isSetAlongRoute = isSetAlongRoute;
            	clonedObject->isSetCoordinateSystem = isSetCoordinateSystem;
            	clonedObject->isSetRelativeDistanceType = isSetRelativeDistanceType;
            	clonedObject->isSetRoutingAlgorithm = isSetRoutingAlgorithm;
            // clone children
            const auto kTimeToCollisionConditionTarget =  GetWriterTimeToCollisionConditionTarget();
            if (kTimeToCollisionConditionTarget)
            {
                auto clonedChild = std::dynamic_pointer_cast<TimeToCollisionConditionTargetImpl>(kTimeToCollisionConditionTarget)->Clone();
                auto clonedChildITimeToCollisionConditionTarget = std::dynamic_pointer_cast<ITimeToCollisionConditionTarget>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTimeToCollisionConditionTarget(std::dynamic_pointer_cast<ITimeToCollisionConditionTargetWriter>(clonedChildITimeToCollisionConditionTarget));
            }
            return clonedObject;
        }

        std::string TimeToCollisionConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeToCollisionConditionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TIME_TO_COLLISION_CONDITION_TARGET)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTimeToCollisionConditionTarget());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TimeToCollisionConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeToCollisionConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TimeToCollisionConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__COORDINATE_SYSTEM)
            {
                auto coordinateSystem = GetCoordinateSystem();
                return coordinateSystem.GetLiteral() != "UNKNOWN" ? coordinateSystem.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE)
            {
                auto relativeDistanceType = GetRelativeDistanceType();
                return relativeDistanceType.GetLiteral() != "UNKNOWN" ? relativeDistanceType.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__ROUTING_ALGORITHM)
            {
                auto routingAlgorithm = GetRoutingAlgorithm();
                return routingAlgorithm.GetLiteral() != "UNKNOWN" ? routingAlgorithm.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void TimeToCollisionConditionImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE)
            {
                // Simple type
                _alongRoute = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
            {
                // Simple type
                _freespace = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void TimeToCollisionConditionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void TimeToCollisionConditionImpl::ResetAlongRoute()
	   {
	   		isSetAlongRoute = false; 
			_alongRoute = {};
			
	   }
       bool TimeToCollisionConditionImpl::IsSetAlongRoute() const
	   {
			return isSetAlongRoute;
	   }
       void TimeToCollisionConditionImpl::ResetCoordinateSystem()
	   {
	   		isSetCoordinateSystem = false; 
			_coordinateSystem = {CoordinateSystem::CoordinateSystemEnum::ENTITY};
			
	   }
       bool TimeToCollisionConditionImpl::IsSetCoordinateSystem() const
	   {
			return isSetCoordinateSystem;
	   }
       void TimeToCollisionConditionImpl::ResetRelativeDistanceType()
	   {
	   		isSetRelativeDistanceType = false; 
			_relativeDistanceType = {RelativeDistanceType::RelativeDistanceTypeEnum::EUCLIDIAN_DISTANCE};
			
	   }
       bool TimeToCollisionConditionImpl::IsSetRelativeDistanceType() const
	   {
			return isSetRelativeDistanceType;
	   }
       void TimeToCollisionConditionImpl::ResetRoutingAlgorithm()
	   {
	   		isSetRoutingAlgorithm = false; 
			_routingAlgorithm = {};
			
	   }
       bool TimeToCollisionConditionImpl::IsSetRoutingAlgorithm() const
	   {
			return isSetRoutingAlgorithm;
	   }

        IOpenScenarioFlexElement* TimeToCollisionConditionTargetImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IPosition> TimeToCollisionConditionTargetImpl::GetPosition() const
        {
        	  return _position;
        }
        std::shared_ptr<IEntityRef> TimeToCollisionConditionTargetImpl::GetEntityRef() const
        {
        	  return _entityRef;
        }


        void TimeToCollisionConditionTargetImpl::SetPosition(std::shared_ptr<IPositionWriter> position)
        {
            _position = position;
            _entityRef = {};
			// set the indicator to true
            isSetPosition = true;          
        }

        void TimeToCollisionConditionTargetImpl::SetEntityRef(std::shared_ptr<IEntityRefWriter> entityRef)
        {
            _entityRef = entityRef;
            _position = {};
			// set the indicator to true
            isSetEntityRef = true;          
        }

        std::shared_ptr<void> TimeToCollisionConditionTargetImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TimeToCollisionConditionTargetImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITimeToCollisionConditionTarget).name())
                return std::dynamic_pointer_cast<ITimeToCollisionConditionTarget>(shared_from_this());
            else if (classifier == typeid(ITimeToCollisionConditionTargetWriter).name())
                return std::dynamic_pointer_cast<ITimeToCollisionConditionTargetWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TimeToCollisionConditionTargetImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TimeToCollisionConditionTargetImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TimeToCollisionConditionTargetImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TimeToCollisionConditionTargetImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TimeToCollisionConditionTargetImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TimeToCollisionConditionTargetImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TimeToCollisionConditionTargetImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TimeToCollisionConditionTargetImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TimeToCollisionConditionTargetImpl::GetModelType() const
        {
            return "TimeToCollisionConditionTarget";
        }

            // children
        std::shared_ptr<IPositionWriter> TimeToCollisionConditionTargetImpl::GetWriterPosition() const
        {
            return std::dynamic_pointer_cast<IPositionWriter>(_position);
        }
        std::shared_ptr<IEntityRefWriter> TimeToCollisionConditionTargetImpl::GetWriterEntityRef() const
        {
            return std::dynamic_pointer_cast<IEntityRefWriter>(_entityRef);
        }

        TimeToCollisionConditionTargetImpl::TimeToCollisionConditionTargetImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void TimeToCollisionConditionTargetImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType TimeToCollisionConditionTargetImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TimeToCollisionConditionTargetImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
                const auto kEntityRef =  GetWriterEntityRef();
                if (kEntityRef)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEntityRef));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TimeToCollisionConditionTargetImpl::Clone()
        {
            auto clonedObject = std::make_shared<TimeToCollisionConditionTargetImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            const auto kEntityRef =  GetWriterEntityRef();
            if (kEntityRef)
            {
                auto clonedChild = std::dynamic_pointer_cast<EntityRefImpl>(kEntityRef)->Clone();
                auto clonedChildIEntityRef = std::dynamic_pointer_cast<IEntityRef>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEntityRef(std::dynamic_pointer_cast<IEntityRefWriter>(clonedChildIEntityRef));
            }
            return clonedObject;
        }

        std::string TimeToCollisionConditionTargetImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeToCollisionConditionTargetImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_REF)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEntityRef());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TimeToCollisionConditionTargetImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeToCollisionConditionTargetImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TimeToCollisionConditionTargetImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void TimeToCollisionConditionTargetImpl::ResetPosition()
	   {
	   		isSetPosition = false; 
			_position = {};
			
	   }
       bool TimeToCollisionConditionTargetImpl::IsSetPosition() const
	   {
			return isSetPosition;
	   }
       void TimeToCollisionConditionTargetImpl::ResetEntityRef()
	   {
	   		isSetEntityRef = false; 
			_entityRef = {};
			
	   }
       bool TimeToCollisionConditionTargetImpl::IsSetEntityRef() const
	   {
			return isSetEntityRef;
	   }

        IOpenScenarioFlexElement* TimingImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        ReferenceContext TimingImpl::GetDomainAbsoluteRelative() const
        {
        	  return _domainAbsoluteRelative;
        }
        double TimingImpl::GetOffset() const
        {
        	  return _offset;
        }
        double TimingImpl::GetScale() const
        {
        	  return _scale;
        }


        void TimingImpl::SetDomainAbsoluteRelative(const ReferenceContext domainAbsoluteRelative)
        {
            _domainAbsoluteRelative = domainAbsoluteRelative;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DOMAIN_ABSOLUTE_RELATIVE);
        }

        void TimingImpl::SetOffset(const double offset)
        {
            _offset = offset;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__OFFSET);
        }

        void TimingImpl::SetScale(const double scale)
        {
            _scale = scale;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SCALE);
        }

        std::shared_ptr<void> TimingImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TimingImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITiming).name())
                return std::dynamic_pointer_cast<ITiming>(shared_from_this());
            else if (classifier == typeid(ITimingWriter).name())
                return std::dynamic_pointer_cast<ITimingWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TimingImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TimingImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TimingImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TimingImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__OFFSET)
                {
                    return GetOffset();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__SCALE)
                {
                    return GetScale();
                }
                throw KeyNotSupportedException();

        }

        uint16_t TimingImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TimingImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TimingImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TimingImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TimingImpl::GetModelType() const
        {
            return "Timing";
        }

        void TimingImpl::WriteParameterToDomainAbsoluteRelative(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DOMAIN_ABSOLUTE_RELATIVE, parameterName, nullTextMarker /*no textmarker*/);
            _domainAbsoluteRelative = {};
        }

        void TimingImpl::WriteParameterToOffset(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__OFFSET, parameterName, nullTextMarker /*no textmarker*/);
            _offset = {};
        }

        void TimingImpl::WriteParameterToScale(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SCALE, parameterName, nullTextMarker /*no textmarker*/);
            _scale = {};
        }

        std::string TimingImpl::GetParameterFromDomainAbsoluteRelative() const
        {
            auto domainAbsoluteRelative = OSC_CONSTANTS::ATTRIBUTE__DOMAIN_ABSOLUTE_RELATIVE;
            return GetParameterNameFromAttribute(domainAbsoluteRelative);
        }

        std::string TimingImpl::GetParameterFromOffset() const
        {
            auto offset = OSC_CONSTANTS::ATTRIBUTE__OFFSET;
            return GetParameterNameFromAttribute(offset);
        }

        std::string TimingImpl::GetParameterFromScale() const
        {
            auto scale = OSC_CONSTANTS::ATTRIBUTE__SCALE;
            return GetParameterNameFromAttribute(scale);
        }

        bool TimingImpl::IsDomainAbsoluteRelativeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DOMAIN_ABSOLUTE_RELATIVE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TimingImpl::IsOffsetParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__OFFSET);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TimingImpl::IsScaleParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__SCALE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        TimingImpl::TimingImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DOMAIN_ABSOLUTE_RELATIVE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__OFFSET, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SCALE, SimpleType::DOUBLE);
        }

        void TimingImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DOMAIN_ABSOLUTE_RELATIVE)
            {
                // Enumeration Type
                const auto kResult = ReferenceContext::GetFromLiteral(parameterLiteralValue);
                if (kResult != ReferenceContext::UNKNOWN)
                {
                    _domainAbsoluteRelative = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__OFFSET)
            {
                // Simple type
                _offset = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SCALE)
            {
                // Simple type
                _scale = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TimingImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TimingImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TimingImpl::Clone()
        {
            auto clonedObject = std::make_shared<TimingImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kDomainAbsoluteRelative = GetDomainAbsoluteRelative();
            if ( kDomainAbsoluteRelative.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_domainAbsoluteRelative = ReferenceContext::GetFromLiteral(kDomainAbsoluteRelative.GetLiteral());
            }
            // Simple type
            clonedObject->_offset = GetOffset();
            // Simple type
            clonedObject->_scale = GetScale();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string TimingImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimingImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TimingImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimingImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TimingImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__DOMAIN_ABSOLUTE_RELATIVE)
            {
                auto domainAbsoluteRelative = GetDomainAbsoluteRelative();
                return domainAbsoluteRelative.GetLiteral() != "UNKNOWN" ? domainAbsoluteRelative.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void TimingImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__OFFSET)
            {
                // Simple type
                _offset = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SCALE)
            {
                // Simple type
                _scale = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* TrafficActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string TrafficActionImpl::GetTrafficName() const
        {
        	  return _trafficName;
        }
        std::shared_ptr<ITrafficSourceAction> TrafficActionImpl::GetTrafficSourceAction() const
        {
        	  return _trafficSourceAction;
        }
        std::shared_ptr<ITrafficSinkAction> TrafficActionImpl::GetTrafficSinkAction() const
        {
        	  return _trafficSinkAction;
        }
        std::shared_ptr<ITrafficSwarmAction> TrafficActionImpl::GetTrafficSwarmAction() const
        {
        	  return _trafficSwarmAction;
        }
        std::shared_ptr<ITrafficStopAction> TrafficActionImpl::GetTrafficStopAction() const
        {
        	  return _trafficStopAction;
        }


        void TrafficActionImpl::SetTrafficName(const std::string trafficName)
        {
            _trafficName = trafficName;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_NAME);
			// set the indicator to true
            isSetTrafficName = true;          
        }

        void TrafficActionImpl::SetTrafficSourceAction(std::shared_ptr<ITrafficSourceActionWriter> trafficSourceAction)
        {
            _trafficSourceAction = trafficSourceAction;
            _trafficSinkAction = {};
            _trafficSwarmAction = {};
            _trafficStopAction = {};
			// set the indicator to true
            isSetTrafficSourceAction = true;          
        }

        void TrafficActionImpl::SetTrafficSinkAction(std::shared_ptr<ITrafficSinkActionWriter> trafficSinkAction)
        {
            _trafficSinkAction = trafficSinkAction;
            _trafficSourceAction = {};
            _trafficSwarmAction = {};
            _trafficStopAction = {};
			// set the indicator to true
            isSetTrafficSinkAction = true;          
        }

        void TrafficActionImpl::SetTrafficSwarmAction(std::shared_ptr<ITrafficSwarmActionWriter> trafficSwarmAction)
        {
            _trafficSwarmAction = trafficSwarmAction;
            _trafficSourceAction = {};
            _trafficSinkAction = {};
            _trafficStopAction = {};
			// set the indicator to true
            isSetTrafficSwarmAction = true;          
        }

        void TrafficActionImpl::SetTrafficStopAction(std::shared_ptr<ITrafficStopActionWriter> trafficStopAction)
        {
            _trafficStopAction = trafficStopAction;
            _trafficSourceAction = {};
            _trafficSinkAction = {};
            _trafficSwarmAction = {};
			// set the indicator to true
            isSetTrafficStopAction = true;          
        }

        std::shared_ptr<void> TrafficActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrafficActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrafficAction).name())
                return std::dynamic_pointer_cast<ITrafficAction>(shared_from_this());
            else if (classifier == typeid(ITrafficActionWriter).name())
                return std::dynamic_pointer_cast<ITrafficActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrafficActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrafficActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TrafficActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrafficActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TrafficActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrafficActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TrafficActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrafficActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrafficActionImpl::GetModelType() const
        {
            return "TrafficAction";
        }

        void TrafficActionImpl::WriteParameterToTrafficName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_NAME, parameterName, nullTextMarker /*no textmarker*/);
            _trafficName = {};
        }

        std::string TrafficActionImpl::GetParameterFromTrafficName() const
        {
            auto trafficName = OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_NAME;
            return GetParameterNameFromAttribute(trafficName);
        }

        bool TrafficActionImpl::IsTrafficNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<ITrafficSourceActionWriter> TrafficActionImpl::GetWriterTrafficSourceAction() const
        {
            return std::dynamic_pointer_cast<ITrafficSourceActionWriter>(_trafficSourceAction);
        }
        std::shared_ptr<ITrafficSinkActionWriter> TrafficActionImpl::GetWriterTrafficSinkAction() const
        {
            return std::dynamic_pointer_cast<ITrafficSinkActionWriter>(_trafficSinkAction);
        }
        std::shared_ptr<ITrafficSwarmActionWriter> TrafficActionImpl::GetWriterTrafficSwarmAction() const
        {
            return std::dynamic_pointer_cast<ITrafficSwarmActionWriter>(_trafficSwarmAction);
        }
        std::shared_ptr<ITrafficStopActionWriter> TrafficActionImpl::GetWriterTrafficStopAction() const
        {
            return std::dynamic_pointer_cast<ITrafficStopActionWriter>(_trafficStopAction);
        }

        TrafficActionImpl::TrafficActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_NAME, SimpleType::STRING);
        }

        void TrafficActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_NAME)
            {
                // Simple type
                _trafficName = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kTrafficSourceAction =  GetWriterTrafficSourceAction();
                if (kTrafficSourceAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficSourceAction));
                }
                const auto kTrafficSinkAction =  GetWriterTrafficSinkAction();
                if (kTrafficSinkAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficSinkAction));
                }
                const auto kTrafficSwarmAction =  GetWriterTrafficSwarmAction();
                if (kTrafficSwarmAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficSwarmAction));
                }
                const auto kTrafficStopAction =  GetWriterTrafficStopAction();
                if (kTrafficStopAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficStopAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_trafficName = GetTrafficName();
            // clone indicators
            	clonedObject->isSetTrafficName = isSetTrafficName;
            // clone children
            const auto kTrafficSourceAction =  GetWriterTrafficSourceAction();
            if (kTrafficSourceAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficSourceActionImpl>(kTrafficSourceAction)->Clone();
                auto clonedChildITrafficSourceAction = std::dynamic_pointer_cast<ITrafficSourceAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficSourceAction(std::dynamic_pointer_cast<ITrafficSourceActionWriter>(clonedChildITrafficSourceAction));
            }
            const auto kTrafficSinkAction =  GetWriterTrafficSinkAction();
            if (kTrafficSinkAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficSinkActionImpl>(kTrafficSinkAction)->Clone();
                auto clonedChildITrafficSinkAction = std::dynamic_pointer_cast<ITrafficSinkAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficSinkAction(std::dynamic_pointer_cast<ITrafficSinkActionWriter>(clonedChildITrafficSinkAction));
            }
            const auto kTrafficSwarmAction =  GetWriterTrafficSwarmAction();
            if (kTrafficSwarmAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficSwarmActionImpl>(kTrafficSwarmAction)->Clone();
                auto clonedChildITrafficSwarmAction = std::dynamic_pointer_cast<ITrafficSwarmAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficSwarmAction(std::dynamic_pointer_cast<ITrafficSwarmActionWriter>(clonedChildITrafficSwarmAction));
            }
            const auto kTrafficStopAction =  GetWriterTrafficStopAction();
            if (kTrafficStopAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficStopActionImpl>(kTrafficStopAction)->Clone();
                auto clonedChildITrafficStopAction = std::dynamic_pointer_cast<ITrafficStopAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficStopAction(std::dynamic_pointer_cast<ITrafficStopActionWriter>(clonedChildITrafficStopAction));
            }
            return clonedObject;
        }

        std::string TrafficActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_NAME)
            {
                return GetTrafficName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SOURCE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficSourceAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SINK_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficSinkAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SWARM_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficSwarmAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_STOP_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficStopAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void TrafficActionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_NAME)
            {
                // Simple type
                _trafficName = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void TrafficActionImpl::ResetTrafficName()
	   {
	   		isSetTrafficName = false; 
			_trafficName = {};
			
	   }
       bool TrafficActionImpl::IsSetTrafficName() const
	   {
			return isSetTrafficName;
	   }
       void TrafficActionImpl::ResetTrafficSourceAction()
	   {
	   		isSetTrafficSourceAction = false; 
			_trafficSourceAction = {};
			
	   }
       bool TrafficActionImpl::IsSetTrafficSourceAction() const
	   {
			return isSetTrafficSourceAction;
	   }
       void TrafficActionImpl::ResetTrafficSinkAction()
	   {
	   		isSetTrafficSinkAction = false; 
			_trafficSinkAction = {};
			
	   }
       bool TrafficActionImpl::IsSetTrafficSinkAction() const
	   {
			return isSetTrafficSinkAction;
	   }
       void TrafficActionImpl::ResetTrafficSwarmAction()
	   {
	   		isSetTrafficSwarmAction = false; 
			_trafficSwarmAction = {};
			
	   }
       bool TrafficActionImpl::IsSetTrafficSwarmAction() const
	   {
			return isSetTrafficSwarmAction;
	   }
       void TrafficActionImpl::ResetTrafficStopAction()
	   {
	   		isSetTrafficStopAction = false; 
			_trafficStopAction = {};
			
	   }
       bool TrafficActionImpl::IsSetTrafficStopAction() const
	   {
			return isSetTrafficStopAction;
	   }

        IOpenScenarioFlexElement* TrafficDefinitionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string TrafficDefinitionImpl::GetName() const
        {
        	  return _name;
        }
        std::shared_ptr<IVehicleCategoryDistribution> TrafficDefinitionImpl::GetVehicleCategoryDistribution() const
        {
        	  return _vehicleCategoryDistribution;
        }
        std::shared_ptr<IVehicleRoleDistribution> TrafficDefinitionImpl::GetVehicleRoleDistribution() const
        {
        	  return _vehicleRoleDistribution;
        }
        std::shared_ptr<IControllerDistribution> TrafficDefinitionImpl::GetControllerDistribution() const
        {
        	  return _controllerDistribution;
        }


        void TrafficDefinitionImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void TrafficDefinitionImpl::SetVehicleCategoryDistribution(std::shared_ptr<IVehicleCategoryDistributionWriter> vehicleCategoryDistribution)
        {
            _vehicleCategoryDistribution = vehicleCategoryDistribution;
        }

        void TrafficDefinitionImpl::SetVehicleRoleDistribution(std::shared_ptr<IVehicleRoleDistributionWriter> vehicleRoleDistribution)
        {
            _vehicleRoleDistribution = vehicleRoleDistribution;
			// set the indicator to true
            isSetVehicleRoleDistribution = true;          
        }

        void TrafficDefinitionImpl::SetControllerDistribution(std::shared_ptr<IControllerDistributionWriter> controllerDistribution)
        {
            _controllerDistribution = controllerDistribution;
        }

        std::shared_ptr<void> TrafficDefinitionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrafficDefinitionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrafficDefinition).name())
                return std::dynamic_pointer_cast<ITrafficDefinition>(shared_from_this());
            else if (classifier == typeid(ITrafficDefinitionWriter).name())
                return std::dynamic_pointer_cast<ITrafficDefinitionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrafficDefinitionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrafficDefinitionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TrafficDefinitionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrafficDefinitionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TrafficDefinitionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrafficDefinitionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TrafficDefinitionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrafficDefinitionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrafficDefinitionImpl::GetModelType() const
        {
            return "TrafficDefinition";
        }

        void TrafficDefinitionImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        std::string TrafficDefinitionImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        bool TrafficDefinitionImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IVehicleCategoryDistributionWriter> TrafficDefinitionImpl::GetWriterVehicleCategoryDistribution() const
        {
            return std::dynamic_pointer_cast<IVehicleCategoryDistributionWriter>(_vehicleCategoryDistribution);
        }
        std::shared_ptr<IVehicleRoleDistributionWriter> TrafficDefinitionImpl::GetWriterVehicleRoleDistribution() const
        {
            return std::dynamic_pointer_cast<IVehicleRoleDistributionWriter>(_vehicleRoleDistribution);
        }
        std::shared_ptr<IControllerDistributionWriter> TrafficDefinitionImpl::GetWriterControllerDistribution() const
        {
            return std::dynamic_pointer_cast<IControllerDistributionWriter>(_controllerDistribution);
        }

        TrafficDefinitionImpl::TrafficDefinitionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        void TrafficDefinitionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficDefinitionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficDefinitionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kVehicleCategoryDistribution =  GetWriterVehicleCategoryDistribution();
                if (kVehicleCategoryDistribution)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kVehicleCategoryDistribution));
                }
                const auto kVehicleRoleDistribution =  GetWriterVehicleRoleDistribution();
                if (kVehicleRoleDistribution)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kVehicleRoleDistribution));
                }
                const auto kControllerDistribution =  GetWriterControllerDistribution();
                if (kControllerDistribution)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kControllerDistribution));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficDefinitionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficDefinitionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone indicators
            // clone children
            const auto kVehicleCategoryDistribution =  GetWriterVehicleCategoryDistribution();
            if (kVehicleCategoryDistribution)
            {
                auto clonedChild = std::dynamic_pointer_cast<VehicleCategoryDistributionImpl>(kVehicleCategoryDistribution)->Clone();
                auto clonedChildIVehicleCategoryDistribution = std::dynamic_pointer_cast<IVehicleCategoryDistribution>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetVehicleCategoryDistribution(std::dynamic_pointer_cast<IVehicleCategoryDistributionWriter>(clonedChildIVehicleCategoryDistribution));
            }
            const auto kVehicleRoleDistribution =  GetWriterVehicleRoleDistribution();
            if (kVehicleRoleDistribution)
            {
                auto clonedChild = std::dynamic_pointer_cast<VehicleRoleDistributionImpl>(kVehicleRoleDistribution)->Clone();
                auto clonedChildIVehicleRoleDistribution = std::dynamic_pointer_cast<IVehicleRoleDistribution>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetVehicleRoleDistribution(std::dynamic_pointer_cast<IVehicleRoleDistributionWriter>(clonedChildIVehicleRoleDistribution));
            }
            const auto kControllerDistribution =  GetWriterControllerDistribution();
            if (kControllerDistribution)
            {
                auto clonedChild = std::dynamic_pointer_cast<ControllerDistributionImpl>(kControllerDistribution)->Clone();
                auto clonedChildIControllerDistribution = std::dynamic_pointer_cast<IControllerDistribution>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetControllerDistribution(std::dynamic_pointer_cast<IControllerDistributionWriter>(clonedChildIControllerDistribution));
            }
            return clonedObject;
        }

        std::string TrafficDefinitionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficDefinitionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__VEHICLE_CATEGORY_DISTRIBUTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetVehicleCategoryDistribution());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__VEHICLE_ROLE_DISTRIBUTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetVehicleRoleDistribution());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CONTROLLER_DISTRIBUTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetControllerDistribution());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficDefinitionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficDefinitionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficDefinitionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void TrafficDefinitionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void TrafficDefinitionImpl::ResetVehicleRoleDistribution()
	   {
	   		isSetVehicleRoleDistribution = false; 
			_vehicleRoleDistribution = {};
			
	   }
       bool TrafficDefinitionImpl::IsSetVehicleRoleDistribution() const
	   {
			return isSetVehicleRoleDistribution;
	   }

        IOpenScenarioFlexElement* TrafficSignalActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<ITrafficSignalControllerAction> TrafficSignalActionImpl::GetTrafficSignalControllerAction() const
        {
        	  return _trafficSignalControllerAction;
        }
        std::shared_ptr<ITrafficSignalStateAction> TrafficSignalActionImpl::GetTrafficSignalStateAction() const
        {
        	  return _trafficSignalStateAction;
        }


        void TrafficSignalActionImpl::SetTrafficSignalControllerAction(std::shared_ptr<ITrafficSignalControllerActionWriter> trafficSignalControllerAction)
        {
            _trafficSignalControllerAction = trafficSignalControllerAction;
            _trafficSignalStateAction = {};
			// set the indicator to true
            isSetTrafficSignalControllerAction = true;          
        }

        void TrafficSignalActionImpl::SetTrafficSignalStateAction(std::shared_ptr<ITrafficSignalStateActionWriter> trafficSignalStateAction)
        {
            _trafficSignalStateAction = trafficSignalStateAction;
            _trafficSignalControllerAction = {};
			// set the indicator to true
            isSetTrafficSignalStateAction = true;          
        }

        std::shared_ptr<void> TrafficSignalActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrafficSignalActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrafficSignalAction).name())
                return std::dynamic_pointer_cast<ITrafficSignalAction>(shared_from_this());
            else if (classifier == typeid(ITrafficSignalActionWriter).name())
                return std::dynamic_pointer_cast<ITrafficSignalActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrafficSignalActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrafficSignalActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TrafficSignalActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrafficSignalActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TrafficSignalActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrafficSignalActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TrafficSignalActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrafficSignalActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrafficSignalActionImpl::GetModelType() const
        {
            return "TrafficSignalAction";
        }

            // children
        std::shared_ptr<ITrafficSignalControllerActionWriter> TrafficSignalActionImpl::GetWriterTrafficSignalControllerAction() const
        {
            return std::dynamic_pointer_cast<ITrafficSignalControllerActionWriter>(_trafficSignalControllerAction);
        }
        std::shared_ptr<ITrafficSignalStateActionWriter> TrafficSignalActionImpl::GetWriterTrafficSignalStateAction() const
        {
            return std::dynamic_pointer_cast<ITrafficSignalStateActionWriter>(_trafficSignalStateAction);
        }

        TrafficSignalActionImpl::TrafficSignalActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void TrafficSignalActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType TrafficSignalActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSignalActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kTrafficSignalControllerAction =  GetWriterTrafficSignalControllerAction();
                if (kTrafficSignalControllerAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficSignalControllerAction));
                }
                const auto kTrafficSignalStateAction =  GetWriterTrafficSignalStateAction();
                if (kTrafficSignalStateAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficSignalStateAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSignalActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSignalActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kTrafficSignalControllerAction =  GetWriterTrafficSignalControllerAction();
            if (kTrafficSignalControllerAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficSignalControllerActionImpl>(kTrafficSignalControllerAction)->Clone();
                auto clonedChildITrafficSignalControllerAction = std::dynamic_pointer_cast<ITrafficSignalControllerAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficSignalControllerAction(std::dynamic_pointer_cast<ITrafficSignalControllerActionWriter>(clonedChildITrafficSignalControllerAction));
            }
            const auto kTrafficSignalStateAction =  GetWriterTrafficSignalStateAction();
            if (kTrafficSignalStateAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficSignalStateActionImpl>(kTrafficSignalStateAction)->Clone();
                auto clonedChildITrafficSignalStateAction = std::dynamic_pointer_cast<ITrafficSignalStateAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficSignalStateAction(std::dynamic_pointer_cast<ITrafficSignalStateActionWriter>(clonedChildITrafficSignalStateAction));
            }
            return clonedObject;
        }

        std::string TrafficSignalActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SIGNAL_CONTROLLER_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficSignalControllerAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SIGNAL_STATE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficSignalStateAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSignalActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficSignalActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void TrafficSignalActionImpl::ResetTrafficSignalControllerAction()
	   {
	   		isSetTrafficSignalControllerAction = false; 
			_trafficSignalControllerAction = {};
			
	   }
       bool TrafficSignalActionImpl::IsSetTrafficSignalControllerAction() const
	   {
			return isSetTrafficSignalControllerAction;
	   }
       void TrafficSignalActionImpl::ResetTrafficSignalStateAction()
	   {
	   		isSetTrafficSignalStateAction = false; 
			_trafficSignalStateAction = {};
			
	   }
       bool TrafficSignalActionImpl::IsSetTrafficSignalStateAction() const
	   {
			return isSetTrafficSignalStateAction;
	   }

        IOpenScenarioFlexElement* TrafficSignalConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string TrafficSignalConditionImpl::GetName() const
        {
        	  return _name;
        }
        std::string TrafficSignalConditionImpl::GetState() const
        {
        	  return _state;
        }


        void TrafficSignalConditionImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void TrafficSignalConditionImpl::SetState(const std::string state)
        {
            _state = state;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STATE);
        }

        std::shared_ptr<void> TrafficSignalConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrafficSignalConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrafficSignalCondition).name())
                return std::dynamic_pointer_cast<ITrafficSignalCondition>(shared_from_this());
            else if (classifier == typeid(ITrafficSignalConditionWriter).name())
                return std::dynamic_pointer_cast<ITrafficSignalConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrafficSignalConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrafficSignalConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TrafficSignalConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrafficSignalConditionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TrafficSignalConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrafficSignalConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TrafficSignalConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrafficSignalConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrafficSignalConditionImpl::GetModelType() const
        {
            return "TrafficSignalCondition";
        }

        void TrafficSignalConditionImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        void TrafficSignalConditionImpl::WriteParameterToState(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STATE, parameterName, nullTextMarker /*no textmarker*/);
            _state = {};
        }

        std::string TrafficSignalConditionImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        std::string TrafficSignalConditionImpl::GetParameterFromState() const
        {
            auto state = OSC_CONSTANTS::ATTRIBUTE__STATE;
            return GetParameterNameFromAttribute(state);
        }

        bool TrafficSignalConditionImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TrafficSignalConditionImpl::IsStateParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__STATE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        TrafficSignalConditionImpl::TrafficSignalConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__STATE, SimpleType::STRING);
        }

        void TrafficSignalConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                // Simple type
                _state = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSignalConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSignalConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSignalConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSignalConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // Simple type
            clonedObject->_state = GetState();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string TrafficSignalConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                return GetState();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSignalConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficSignalConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void TrafficSignalConditionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                // Simple type
                _state = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* TrafficSignalControllerImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double TrafficSignalControllerImpl::GetDelay() const
        {
        	  return _delay;
        }
        std::string TrafficSignalControllerImpl::GetName() const
        {
        	  return _name;
        }
        std::string TrafficSignalControllerImpl::GetReference() const
        {
        	  return _reference;
        }
        std::vector<std::shared_ptr<IPhase>> TrafficSignalControllerImpl::GetPhases() const
        {
            std::vector<std::shared_ptr<IPhase>> temp;
            for(auto&& elm: _phases)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IPhaseWriter>> TrafficSignalControllerImpl::GetWriterPhases() const
        {
            return _phases;
        }

        int TrafficSignalControllerImpl::GetPhasesSize() const
        {
            return static_cast<int>(_phases.size());
        }

        std::shared_ptr<IPhase> TrafficSignalControllerImpl::GetPhasesAtIndex(unsigned int index) const
        {
            if (index >= 0 && _phases.size() > index)
            {
                return _phases[index];
            }
            return nullptr;
        }


        void TrafficSignalControllerImpl::SetDelay(const double delay)
        {
            _delay = delay;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DELAY);
			// set the indicator to true
            isSetDelay = true;          
        }

        void TrafficSignalControllerImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void TrafficSignalControllerImpl::SetReference(const std::string reference)
        {
            _reference = reference;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__REFERENCE);
			// set the indicator to true
            isSetReference = true;          
        }

        void TrafficSignalControllerImpl::SetPhases(std::vector<std::shared_ptr<IPhaseWriter>>& phases)
        {
            _phases = phases;
			// set the indicator to true
            isSetPhases = true;          
        }

        std::shared_ptr<void> TrafficSignalControllerImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrafficSignalControllerImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrafficSignalController).name())
                return std::dynamic_pointer_cast<ITrafficSignalController>(shared_from_this());
            else if (classifier == typeid(ITrafficSignalControllerWriter).name())
                return std::dynamic_pointer_cast<ITrafficSignalControllerWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrafficSignalControllerImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrafficSignalControllerImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TrafficSignalControllerImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrafficSignalControllerImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__DELAY)
                {
                    return GetDelay();
                }
                throw KeyNotSupportedException();

        }

        uint16_t TrafficSignalControllerImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrafficSignalControllerImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TrafficSignalControllerImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrafficSignalControllerImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrafficSignalControllerImpl::GetModelType() const
        {
            return "TrafficSignalController";
        }

        void TrafficSignalControllerImpl::WriteParameterToDelay(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DELAY, parameterName, nullTextMarker /*no textmarker*/);
            _delay = {};
        }

        void TrafficSignalControllerImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        void TrafficSignalControllerImpl::WriteParameterToReference(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__REFERENCE, parameterName, nullTextMarker /*no textmarker*/);
            _reference = {};
        }

        std::string TrafficSignalControllerImpl::GetParameterFromDelay() const
        {
            auto delay = OSC_CONSTANTS::ATTRIBUTE__DELAY;
            return GetParameterNameFromAttribute(delay);
        }

        std::string TrafficSignalControllerImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        std::string TrafficSignalControllerImpl::GetParameterFromReference() const
        {
            auto reference = OSC_CONSTANTS::ATTRIBUTE__REFERENCE;
            return GetParameterNameFromAttribute(reference);
        }

        bool TrafficSignalControllerImpl::IsDelayParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DELAY);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TrafficSignalControllerImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TrafficSignalControllerImpl::IsReferenceParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__REFERENCE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        TrafficSignalControllerImpl::TrafficSignalControllerImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DELAY, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__REFERENCE, SimpleType::STRING);
        }

        void TrafficSignalControllerImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DELAY)
            {
                // Simple type
                _delay = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__REFERENCE)
            {
                // Simple type
                _reference = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSignalControllerImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSignalControllerImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto phases =  GetWriterPhases();
                if (!phases.empty())
                {
                    for(auto&& item : phases)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSignalControllerImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSignalControllerImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_delay = GetDelay();
            // Simple type
            clonedObject->_name = GetName();
            // Simple type
            clonedObject->_reference = GetReference();
            // clone indicators
            	clonedObject->isSetDelay = isSetDelay;
            	clonedObject->isSetReference = isSetReference;
            // clone children
            const auto kPhases =  GetWriterPhases();
            if (!kPhases.empty())
            {
                std::vector<std::shared_ptr<IPhaseWriter>> clonedList;
                for(auto&& kItem : kPhases)
                {
                    auto clonedChild = std::dynamic_pointer_cast<PhaseImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IPhaseWriter>(clonedChild));
                }
                clonedObject->SetPhases(clonedList);
            }
            return clonedObject;
        }

        std::string TrafficSignalControllerImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__REFERENCE)
            {
                return GetReference();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalControllerImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSignalControllerImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__PHASE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetPhases())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalControllerImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficSignalControllerImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void TrafficSignalControllerImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__REFERENCE)
            {
                // Simple type
                _reference = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void TrafficSignalControllerImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DELAY)
            {
                // Simple type
                _delay = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void TrafficSignalControllerImpl::ResetDelay()
	   {
	   		isSetDelay = false; 
			_delay = {};
			
	   }
       bool TrafficSignalControllerImpl::IsSetDelay() const
	   {
			return isSetDelay;
	   }
       void TrafficSignalControllerImpl::ResetReference()
	   {
	   		isSetReference = false; 
			_reference = {};
			
	   }
       bool TrafficSignalControllerImpl::IsSetReference() const
	   {
			return isSetReference;
	   }
       void TrafficSignalControllerImpl::ResetPhases()
	   {
	   		isSetPhases = false; 
			_phases = {};
			
	   }
       bool TrafficSignalControllerImpl::IsSetPhases() const
	   {
			return isSetPhases;
	   }

        IOpenScenarioFlexElement* TrafficSignalControllerActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string TrafficSignalControllerActionImpl::GetPhase() const
        {
        	  return _phase;
        }
        std::shared_ptr<INamedReference<ITrafficSignalController>> TrafficSignalControllerActionImpl::GetTrafficSignalControllerRef() const
        {
        	 return _trafficSignalControllerRef;
        }
        std::vector<std::shared_ptr<IPhase>> TrafficSignalControllerActionImpl::GetPhaseRef() const
        {
            std::vector<std::shared_ptr<IPhase>> temp;
            for(auto&& elm: _phaseRef)
                temp.push_back(elm);
            return temp;
        }

        int TrafficSignalControllerActionImpl::GetPhaseRefSize() const
        {
            return static_cast<int>(_phaseRef.size());
        }

        std::shared_ptr<IPhase> TrafficSignalControllerActionImpl::GetPhaseRefAtIndex(unsigned int index) const
        {
            if (index >= 0 && _phaseRef.size() > index)
            {
                return _phaseRef[index];
            }
            return nullptr;
        }


        void TrafficSignalControllerActionImpl::SetPhase(const std::string phase)
        {
            _phase = phase;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PHASE);
        }

        void TrafficSignalControllerActionImpl::SetTrafficSignalControllerRef(std::shared_ptr<INamedReference<ITrafficSignalController>> trafficSignalControllerRef)
        {
            _trafficSignalControllerRef = trafficSignalControllerRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF);
        }

        void TrafficSignalControllerActionImpl::SetPhaseRef(std::vector<std::shared_ptr<IPhase>>& phaseRef)
        {
            _phaseRef = phaseRef;
			// set the indicator to true
            isSetPhaseRef = true;          
        }

        std::shared_ptr<void> TrafficSignalControllerActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrafficSignalControllerActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrafficSignalControllerAction).name())
                return std::dynamic_pointer_cast<ITrafficSignalControllerAction>(shared_from_this());
            else if (classifier == typeid(ITrafficSignalControllerActionWriter).name())
                return std::dynamic_pointer_cast<ITrafficSignalControllerActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrafficSignalControllerActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrafficSignalControllerActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TrafficSignalControllerActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrafficSignalControllerActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TrafficSignalControllerActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrafficSignalControllerActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TrafficSignalControllerActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrafficSignalControllerActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrafficSignalControllerActionImpl::GetModelType() const
        {
            return "TrafficSignalControllerAction";
        }

        void TrafficSignalControllerActionImpl::WriteParameterToPhase(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PHASE, parameterName, nullTextMarker /*no textmarker*/);
            _phase = {};
        }

        void TrafficSignalControllerActionImpl::WriteParameterToTrafficSignalControllerRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF, parameterName, nullTextMarker /*no textmarker*/);
            _trafficSignalControllerRef = {};
        }

        std::string TrafficSignalControllerActionImpl::GetParameterFromPhase() const
        {
            auto phase = OSC_CONSTANTS::ATTRIBUTE__PHASE;
            return GetParameterNameFromAttribute(phase);
        }

        std::string TrafficSignalControllerActionImpl::GetParameterFromTrafficSignalControllerRef() const
        {
            auto trafficSignalControllerRef = OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF;
            return GetParameterNameFromAttribute(trafficSignalControllerRef);
        }

        bool TrafficSignalControllerActionImpl::IsPhaseParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__PHASE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TrafficSignalControllerActionImpl::IsTrafficSignalControllerRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        TrafficSignalControllerActionImpl::TrafficSignalControllerActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PHASE, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF, SimpleType::STRING);
        }

        void TrafficSignalControllerActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PHASE)
            {
                // Simple type
                _phase = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<ITrafficSignalController>>(parameterLiteralValue);
                _trafficSignalControllerRef = std::dynamic_pointer_cast<INamedReference<ITrafficSignalController>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSignalControllerActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSignalControllerActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSignalControllerActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSignalControllerActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_phase = GetPhase();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<ITrafficSignalController>>(*std::dynamic_pointer_cast<NamedReferenceProxy<ITrafficSignalController>>(GetTrafficSignalControllerRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_trafficSignalControllerRef = proxy;
            
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string TrafficSignalControllerActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PHASE)
            {
                return GetPhase();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF)
            {
                // Get the Proxy
                auto trafficSignalControllerRef = GetTrafficSignalControllerRef();
                return trafficSignalControllerRef!= nullptr ? trafficSignalControllerRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalControllerActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSignalControllerActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalControllerActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF)
            {
                // Get the Proxy
                auto trafficSignalControllerRef = GetTrafficSignalControllerRef();
                return trafficSignalControllerRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(trafficSignalControllerRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string TrafficSignalControllerActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void TrafficSignalControllerActionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PHASE)
            {
                // Simple type
                _phase = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void TrafficSignalControllerActionImpl::ResetPhaseRef()
	   {
	   		isSetPhaseRef = false; 
			_phaseRef = {};
			
	   }
       bool TrafficSignalControllerActionImpl::IsSetPhaseRef() const
	   {
			return isSetPhaseRef;
	   }

        IOpenScenarioFlexElement* TrafficSignalControllerConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string TrafficSignalControllerConditionImpl::GetPhase() const
        {
        	  return _phase;
        }
        std::shared_ptr<INamedReference<ITrafficSignalController>> TrafficSignalControllerConditionImpl::GetTrafficSignalControllerRef() const
        {
        	 return _trafficSignalControllerRef;
        }
        std::vector<std::shared_ptr<IPhase>> TrafficSignalControllerConditionImpl::GetPhaseRef() const
        {
            std::vector<std::shared_ptr<IPhase>> temp;
            for(auto&& elm: _phaseRef)
                temp.push_back(elm);
            return temp;
        }

        int TrafficSignalControllerConditionImpl::GetPhaseRefSize() const
        {
            return static_cast<int>(_phaseRef.size());
        }

        std::shared_ptr<IPhase> TrafficSignalControllerConditionImpl::GetPhaseRefAtIndex(unsigned int index) const
        {
            if (index >= 0 && _phaseRef.size() > index)
            {
                return _phaseRef[index];
            }
            return nullptr;
        }


        void TrafficSignalControllerConditionImpl::SetPhase(const std::string phase)
        {
            _phase = phase;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PHASE);
        }

        void TrafficSignalControllerConditionImpl::SetTrafficSignalControllerRef(std::shared_ptr<INamedReference<ITrafficSignalController>> trafficSignalControllerRef)
        {
            _trafficSignalControllerRef = trafficSignalControllerRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF);
        }

        void TrafficSignalControllerConditionImpl::SetPhaseRef(std::vector<std::shared_ptr<IPhase>>& phaseRef)
        {
            _phaseRef = phaseRef;
			// set the indicator to true
            isSetPhaseRef = true;          
        }

        std::shared_ptr<void> TrafficSignalControllerConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrafficSignalControllerConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrafficSignalControllerCondition).name())
                return std::dynamic_pointer_cast<ITrafficSignalControllerCondition>(shared_from_this());
            else if (classifier == typeid(ITrafficSignalControllerConditionWriter).name())
                return std::dynamic_pointer_cast<ITrafficSignalControllerConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrafficSignalControllerConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrafficSignalControllerConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TrafficSignalControllerConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrafficSignalControllerConditionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TrafficSignalControllerConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrafficSignalControllerConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TrafficSignalControllerConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrafficSignalControllerConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrafficSignalControllerConditionImpl::GetModelType() const
        {
            return "TrafficSignalControllerCondition";
        }

        void TrafficSignalControllerConditionImpl::WriteParameterToPhase(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__PHASE, parameterName, nullTextMarker /*no textmarker*/);
            _phase = {};
        }

        void TrafficSignalControllerConditionImpl::WriteParameterToTrafficSignalControllerRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF, parameterName, nullTextMarker /*no textmarker*/);
            _trafficSignalControllerRef = {};
        }

        std::string TrafficSignalControllerConditionImpl::GetParameterFromPhase() const
        {
            auto phase = OSC_CONSTANTS::ATTRIBUTE__PHASE;
            return GetParameterNameFromAttribute(phase);
        }

        std::string TrafficSignalControllerConditionImpl::GetParameterFromTrafficSignalControllerRef() const
        {
            auto trafficSignalControllerRef = OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF;
            return GetParameterNameFromAttribute(trafficSignalControllerRef);
        }

        bool TrafficSignalControllerConditionImpl::IsPhaseParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__PHASE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TrafficSignalControllerConditionImpl::IsTrafficSignalControllerRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        TrafficSignalControllerConditionImpl::TrafficSignalControllerConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PHASE, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF, SimpleType::STRING);
        }

        void TrafficSignalControllerConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PHASE)
            {
                // Simple type
                _phase = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<ITrafficSignalController>>(parameterLiteralValue);
                _trafficSignalControllerRef = std::dynamic_pointer_cast<INamedReference<ITrafficSignalController>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSignalControllerConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSignalControllerConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSignalControllerConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSignalControllerConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_phase = GetPhase();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<ITrafficSignalController>>(*std::dynamic_pointer_cast<NamedReferenceProxy<ITrafficSignalController>>(GetTrafficSignalControllerRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_trafficSignalControllerRef = proxy;
            
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string TrafficSignalControllerConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PHASE)
            {
                return GetPhase();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF)
            {
                // Get the Proxy
                auto trafficSignalControllerRef = GetTrafficSignalControllerRef();
                return trafficSignalControllerRef!= nullptr ? trafficSignalControllerRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalControllerConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSignalControllerConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalControllerConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF)
            {
                // Get the Proxy
                auto trafficSignalControllerRef = GetTrafficSignalControllerRef();
                return trafficSignalControllerRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(trafficSignalControllerRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string TrafficSignalControllerConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void TrafficSignalControllerConditionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PHASE)
            {
                // Simple type
                _phase = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void TrafficSignalControllerConditionImpl::ResetPhaseRef()
	   {
	   		isSetPhaseRef = false; 
			_phaseRef = {};
			
	   }
       bool TrafficSignalControllerConditionImpl::IsSetPhaseRef() const
	   {
			return isSetPhaseRef;
	   }

        IOpenScenarioFlexElement* TrafficSignalGroupStateImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string TrafficSignalGroupStateImpl::GetState() const
        {
        	  return _state;
        }


        void TrafficSignalGroupStateImpl::SetState(const std::string state)
        {
            _state = state;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STATE);
        }

        std::shared_ptr<void> TrafficSignalGroupStateImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrafficSignalGroupStateImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrafficSignalGroupState).name())
                return std::dynamic_pointer_cast<ITrafficSignalGroupState>(shared_from_this());
            else if (classifier == typeid(ITrafficSignalGroupStateWriter).name())
                return std::dynamic_pointer_cast<ITrafficSignalGroupStateWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrafficSignalGroupStateImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrafficSignalGroupStateImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TrafficSignalGroupStateImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrafficSignalGroupStateImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TrafficSignalGroupStateImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrafficSignalGroupStateImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TrafficSignalGroupStateImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrafficSignalGroupStateImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrafficSignalGroupStateImpl::GetModelType() const
        {
            return "TrafficSignalGroupState";
        }

        void TrafficSignalGroupStateImpl::WriteParameterToState(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STATE, parameterName, nullTextMarker /*no textmarker*/);
            _state = {};
        }

        std::string TrafficSignalGroupStateImpl::GetParameterFromState() const
        {
            auto state = OSC_CONSTANTS::ATTRIBUTE__STATE;
            return GetParameterNameFromAttribute(state);
        }

        bool TrafficSignalGroupStateImpl::IsStateParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__STATE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        TrafficSignalGroupStateImpl::TrafficSignalGroupStateImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__STATE, SimpleType::STRING);
        }

        void TrafficSignalGroupStateImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                // Simple type
                _state = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSignalGroupStateImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSignalGroupStateImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSignalGroupStateImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSignalGroupStateImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_state = GetState();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string TrafficSignalGroupStateImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                return GetState();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalGroupStateImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSignalGroupStateImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalGroupStateImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficSignalGroupStateImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void TrafficSignalGroupStateImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                // Simple type
                _state = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* TrafficSignalStateImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string TrafficSignalStateImpl::GetState() const
        {
        	  return _state;
        }
        std::string TrafficSignalStateImpl::GetTrafficSignalId() const
        {
        	  return _trafficSignalId;
        }


        void TrafficSignalStateImpl::SetState(const std::string state)
        {
            _state = state;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STATE);
        }

        void TrafficSignalStateImpl::SetTrafficSignalId(const std::string trafficSignalId)
        {
            _trafficSignalId = trafficSignalId;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_ID);
        }

        std::shared_ptr<void> TrafficSignalStateImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrafficSignalStateImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrafficSignalState).name())
                return std::dynamic_pointer_cast<ITrafficSignalState>(shared_from_this());
            else if (classifier == typeid(ITrafficSignalStateWriter).name())
                return std::dynamic_pointer_cast<ITrafficSignalStateWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrafficSignalStateImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrafficSignalStateImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TrafficSignalStateImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrafficSignalStateImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TrafficSignalStateImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrafficSignalStateImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TrafficSignalStateImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrafficSignalStateImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrafficSignalStateImpl::GetModelType() const
        {
            return "TrafficSignalState";
        }

        void TrafficSignalStateImpl::WriteParameterToState(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STATE, parameterName, nullTextMarker /*no textmarker*/);
            _state = {};
        }

        void TrafficSignalStateImpl::WriteParameterToTrafficSignalId(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_ID, parameterName, nullTextMarker /*no textmarker*/);
            _trafficSignalId = {};
        }

        std::string TrafficSignalStateImpl::GetParameterFromState() const
        {
            auto state = OSC_CONSTANTS::ATTRIBUTE__STATE;
            return GetParameterNameFromAttribute(state);
        }

        std::string TrafficSignalStateImpl::GetParameterFromTrafficSignalId() const
        {
            auto trafficSignalId = OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_ID;
            return GetParameterNameFromAttribute(trafficSignalId);
        }

        bool TrafficSignalStateImpl::IsStateParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__STATE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TrafficSignalStateImpl::IsTrafficSignalIdParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_ID);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        TrafficSignalStateImpl::TrafficSignalStateImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__STATE, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_ID, SimpleType::STRING);
        }

        void TrafficSignalStateImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                // Simple type
                _state = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_ID)
            {
                // Simple type
                _trafficSignalId = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSignalStateImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSignalStateImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSignalStateImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSignalStateImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_state = GetState();
            // Simple type
            clonedObject->_trafficSignalId = GetTrafficSignalId();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string TrafficSignalStateImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                return GetState();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_ID)
            {
                return GetTrafficSignalId();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalStateImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSignalStateImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalStateImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficSignalStateImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void TrafficSignalStateImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                // Simple type
                _state = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_ID)
            {
                // Simple type
                _trafficSignalId = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* TrafficSignalStateActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string TrafficSignalStateActionImpl::GetName() const
        {
        	  return _name;
        }
        std::string TrafficSignalStateActionImpl::GetState() const
        {
        	  return _state;
        }


        void TrafficSignalStateActionImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void TrafficSignalStateActionImpl::SetState(const std::string state)
        {
            _state = state;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STATE);
        }

        std::shared_ptr<void> TrafficSignalStateActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrafficSignalStateActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrafficSignalStateAction).name())
                return std::dynamic_pointer_cast<ITrafficSignalStateAction>(shared_from_this());
            else if (classifier == typeid(ITrafficSignalStateActionWriter).name())
                return std::dynamic_pointer_cast<ITrafficSignalStateActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrafficSignalStateActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrafficSignalStateActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TrafficSignalStateActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrafficSignalStateActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TrafficSignalStateActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrafficSignalStateActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TrafficSignalStateActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrafficSignalStateActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrafficSignalStateActionImpl::GetModelType() const
        {
            return "TrafficSignalStateAction";
        }

        void TrafficSignalStateActionImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        void TrafficSignalStateActionImpl::WriteParameterToState(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__STATE, parameterName, nullTextMarker /*no textmarker*/);
            _state = {};
        }

        std::string TrafficSignalStateActionImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        std::string TrafficSignalStateActionImpl::GetParameterFromState() const
        {
            auto state = OSC_CONSTANTS::ATTRIBUTE__STATE;
            return GetParameterNameFromAttribute(state);
        }

        bool TrafficSignalStateActionImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TrafficSignalStateActionImpl::IsStateParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__STATE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        TrafficSignalStateActionImpl::TrafficSignalStateActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__STATE, SimpleType::STRING);
        }

        void TrafficSignalStateActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                // Simple type
                _state = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSignalStateActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSignalStateActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSignalStateActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSignalStateActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // Simple type
            clonedObject->_state = GetState();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string TrafficSignalStateActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                return GetState();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalStateActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSignalStateActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalStateActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficSignalStateActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void TrafficSignalStateActionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                // Simple type
                _state = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* TrafficSinkActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double TrafficSinkActionImpl::GetRadius() const
        {
        	  return _radius;
        }
        double TrafficSinkActionImpl::GetRate() const
        {
        	  return _rate;
        }
        std::shared_ptr<IPosition> TrafficSinkActionImpl::GetPosition() const
        {
        	  return _position;
        }
        std::shared_ptr<ITrafficDefinition> TrafficSinkActionImpl::GetTrafficDefinition() const
        {
        	  return _trafficDefinition;
        }


        void TrafficSinkActionImpl::SetRadius(const double radius)
        {
            _radius = radius;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RADIUS);
        }

        void TrafficSinkActionImpl::SetRate(const double rate)
        {
            _rate = rate;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RATE);
			// set the indicator to true
            isSetRate = true;          
        }

        void TrafficSinkActionImpl::SetPosition(std::shared_ptr<IPositionWriter> position)
        {
            _position = position;
        }

        void TrafficSinkActionImpl::SetTrafficDefinition(std::shared_ptr<ITrafficDefinitionWriter> trafficDefinition)
        {
            _trafficDefinition = trafficDefinition;
			// set the indicator to true
            isSetTrafficDefinition = true;          
        }

        std::shared_ptr<void> TrafficSinkActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrafficSinkActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrafficSinkAction).name())
                return std::dynamic_pointer_cast<ITrafficSinkAction>(shared_from_this());
            else if (classifier == typeid(ITrafficSinkActionWriter).name())
                return std::dynamic_pointer_cast<ITrafficSinkActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrafficSinkActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrafficSinkActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TrafficSinkActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrafficSinkActionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__RADIUS)
                {
                    return GetRadius();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__RATE)
                {
                    return GetRate();
                }
                throw KeyNotSupportedException();

        }

        uint16_t TrafficSinkActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrafficSinkActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TrafficSinkActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrafficSinkActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrafficSinkActionImpl::GetModelType() const
        {
            return "TrafficSinkAction";
        }

        void TrafficSinkActionImpl::WriteParameterToRadius(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RADIUS, parameterName, nullTextMarker /*no textmarker*/);
            _radius = {};
        }

        void TrafficSinkActionImpl::WriteParameterToRate(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RATE, parameterName, nullTextMarker /*no textmarker*/);
            _rate = {};
        }

        std::string TrafficSinkActionImpl::GetParameterFromRadius() const
        {
            auto radius = OSC_CONSTANTS::ATTRIBUTE__RADIUS;
            return GetParameterNameFromAttribute(radius);
        }

        std::string TrafficSinkActionImpl::GetParameterFromRate() const
        {
            auto rate = OSC_CONSTANTS::ATTRIBUTE__RATE;
            return GetParameterNameFromAttribute(rate);
        }

        bool TrafficSinkActionImpl::IsRadiusParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RADIUS);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TrafficSinkActionImpl::IsRateParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RATE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IPositionWriter> TrafficSinkActionImpl::GetWriterPosition() const
        {
            return std::dynamic_pointer_cast<IPositionWriter>(_position);
        }
        std::shared_ptr<ITrafficDefinitionWriter> TrafficSinkActionImpl::GetWriterTrafficDefinition() const
        {
            return std::dynamic_pointer_cast<ITrafficDefinitionWriter>(_trafficDefinition);
        }

        TrafficSinkActionImpl::TrafficSinkActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RADIUS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RATE, SimpleType::DOUBLE);
        }

        void TrafficSinkActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RADIUS)
            {
                // Simple type
                _radius = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RATE)
            {
                // Simple type
                _rate = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSinkActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSinkActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
                const auto kTrafficDefinition =  GetWriterTrafficDefinition();
                if (kTrafficDefinition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficDefinition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSinkActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSinkActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_radius = GetRadius();
            // Simple type
            clonedObject->_rate = GetRate();
            // clone indicators
            	clonedObject->isSetRate = isSetRate;
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            const auto kTrafficDefinition =  GetWriterTrafficDefinition();
            if (kTrafficDefinition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficDefinitionImpl>(kTrafficDefinition)->Clone();
                auto clonedChildITrafficDefinition = std::dynamic_pointer_cast<ITrafficDefinition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficDefinition(std::dynamic_pointer_cast<ITrafficDefinitionWriter>(clonedChildITrafficDefinition));
            }
            return clonedObject;
        }

        std::string TrafficSinkActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSinkActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_DEFINITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficDefinition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSinkActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSinkActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficSinkActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void TrafficSinkActionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RADIUS)
            {
                // Simple type
                _radius = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RATE)
            {
                // Simple type
                _rate = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void TrafficSinkActionImpl::ResetRate()
	   {
	   		isSetRate = false; 
			_rate = {};
			
	   }
       bool TrafficSinkActionImpl::IsSetRate() const
	   {
			return isSetRate;
	   }
       void TrafficSinkActionImpl::ResetTrafficDefinition()
	   {
	   		isSetTrafficDefinition = false; 
			_trafficDefinition = {};
			
	   }
       bool TrafficSinkActionImpl::IsSetTrafficDefinition() const
	   {
			return isSetTrafficDefinition;
	   }

        IOpenScenarioFlexElement* TrafficSourceActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double TrafficSourceActionImpl::GetRadius() const
        {
        	  return _radius;
        }
        double TrafficSourceActionImpl::GetRate() const
        {
        	  return _rate;
        }
        double TrafficSourceActionImpl::GetSpeed() const
        {
        	  return _speed;
        }
        double TrafficSourceActionImpl::GetVelocity() const
        {
        	  return _velocity;
        }
        std::shared_ptr<IPosition> TrafficSourceActionImpl::GetPosition() const
        {
        	  return _position;
        }
        std::shared_ptr<ITrafficDefinition> TrafficSourceActionImpl::GetTrafficDefinition() const
        {
        	  return _trafficDefinition;
        }


        void TrafficSourceActionImpl::SetRadius(const double radius)
        {
            _radius = radius;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RADIUS);
        }

        void TrafficSourceActionImpl::SetRate(const double rate)
        {
            _rate = rate;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RATE);
        }

        void TrafficSourceActionImpl::SetSpeed(const double speed)
        {
            _speed = speed;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SPEED);
			// set the indicator to true
            isSetSpeed = true;          
        }

        void TrafficSourceActionImpl::SetVelocity(const double velocity)
        {
            _velocity = velocity;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VELOCITY);
			// set the indicator to true
            isSetVelocity = true;          
        }

        void TrafficSourceActionImpl::SetPosition(std::shared_ptr<IPositionWriter> position)
        {
            _position = position;
        }

        void TrafficSourceActionImpl::SetTrafficDefinition(std::shared_ptr<ITrafficDefinitionWriter> trafficDefinition)
        {
            _trafficDefinition = trafficDefinition;
        }

        std::shared_ptr<void> TrafficSourceActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrafficSourceActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrafficSourceAction).name())
                return std::dynamic_pointer_cast<ITrafficSourceAction>(shared_from_this());
            else if (classifier == typeid(ITrafficSourceActionWriter).name())
                return std::dynamic_pointer_cast<ITrafficSourceActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrafficSourceActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrafficSourceActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TrafficSourceActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrafficSourceActionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__RADIUS)
                {
                    return GetRadius();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__RATE)
                {
                    return GetRate();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__SPEED)
                {
                    return GetSpeed();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__VELOCITY)
                {
                    return GetVelocity();
                }
                throw KeyNotSupportedException();

        }

        uint16_t TrafficSourceActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrafficSourceActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TrafficSourceActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrafficSourceActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrafficSourceActionImpl::GetModelType() const
        {
            return "TrafficSourceAction";
        }

        void TrafficSourceActionImpl::WriteParameterToRadius(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RADIUS, parameterName, nullTextMarker /*no textmarker*/);
            _radius = {};
        }

        void TrafficSourceActionImpl::WriteParameterToRate(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RATE, parameterName, nullTextMarker /*no textmarker*/);
            _rate = {};
        }

        void TrafficSourceActionImpl::WriteParameterToSpeed(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SPEED, parameterName, nullTextMarker /*no textmarker*/);
            _speed = {};
        }

        void TrafficSourceActionImpl::WriteParameterToVelocity(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VELOCITY, parameterName, nullTextMarker /*no textmarker*/);
            _velocity = {};
        }

        std::string TrafficSourceActionImpl::GetParameterFromRadius() const
        {
            auto radius = OSC_CONSTANTS::ATTRIBUTE__RADIUS;
            return GetParameterNameFromAttribute(radius);
        }

        std::string TrafficSourceActionImpl::GetParameterFromRate() const
        {
            auto rate = OSC_CONSTANTS::ATTRIBUTE__RATE;
            return GetParameterNameFromAttribute(rate);
        }

        std::string TrafficSourceActionImpl::GetParameterFromSpeed() const
        {
            auto speed = OSC_CONSTANTS::ATTRIBUTE__SPEED;
            return GetParameterNameFromAttribute(speed);
        }

        std::string TrafficSourceActionImpl::GetParameterFromVelocity() const
        {
            auto velocity = OSC_CONSTANTS::ATTRIBUTE__VELOCITY;
            return GetParameterNameFromAttribute(velocity);
        }

        bool TrafficSourceActionImpl::IsRadiusParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RADIUS);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TrafficSourceActionImpl::IsRateParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RATE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TrafficSourceActionImpl::IsSpeedParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__SPEED);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TrafficSourceActionImpl::IsVelocityParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VELOCITY);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IPositionWriter> TrafficSourceActionImpl::GetWriterPosition() const
        {
            return std::dynamic_pointer_cast<IPositionWriter>(_position);
        }
        std::shared_ptr<ITrafficDefinitionWriter> TrafficSourceActionImpl::GetWriterTrafficDefinition() const
        {
            return std::dynamic_pointer_cast<ITrafficDefinitionWriter>(_trafficDefinition);
        }

        TrafficSourceActionImpl::TrafficSourceActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RADIUS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RATE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SPEED, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VELOCITY, SimpleType::DOUBLE);
        }

        void TrafficSourceActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RADIUS)
            {
                // Simple type
                _radius = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RATE)
            {
                // Simple type
                _rate = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SPEED)
            {
                // Simple type
                _speed = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VELOCITY)
            {
                // Simple type
                _velocity = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSourceActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSourceActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
                const auto kTrafficDefinition =  GetWriterTrafficDefinition();
                if (kTrafficDefinition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficDefinition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSourceActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSourceActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_radius = GetRadius();
            // Simple type
            clonedObject->_rate = GetRate();
            // Simple type
            clonedObject->_speed = GetSpeed();
            // Simple type
            clonedObject->_velocity = GetVelocity();
            // clone indicators
            	clonedObject->isSetSpeed = isSetSpeed;
            	clonedObject->isSetVelocity = isSetVelocity;
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            const auto kTrafficDefinition =  GetWriterTrafficDefinition();
            if (kTrafficDefinition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficDefinitionImpl>(kTrafficDefinition)->Clone();
                auto clonedChildITrafficDefinition = std::dynamic_pointer_cast<ITrafficDefinition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficDefinition(std::dynamic_pointer_cast<ITrafficDefinitionWriter>(clonedChildITrafficDefinition));
            }
            return clonedObject;
        }

        std::string TrafficSourceActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSourceActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_DEFINITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficDefinition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSourceActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSourceActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficSourceActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void TrafficSourceActionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RADIUS)
            {
                // Simple type
                _radius = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RATE)
            {
                // Simple type
                _rate = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SPEED)
            {
                // Simple type
                _speed = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VELOCITY)
            {
                // Simple type
                _velocity = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void TrafficSourceActionImpl::ResetSpeed()
	   {
	   		isSetSpeed = false; 
			_speed = {};
			
	   }
       bool TrafficSourceActionImpl::IsSetSpeed() const
	   {
			return isSetSpeed;
	   }
       void TrafficSourceActionImpl::ResetVelocity()
	   {
	   		isSetVelocity = false; 
			_velocity = {};
			
	   }
       bool TrafficSourceActionImpl::IsSetVelocity() const
	   {
			return isSetVelocity;
	   }

        IOpenScenarioFlexElement* TrafficStopActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }


        std::shared_ptr<void> TrafficStopActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrafficStopActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrafficStopAction).name())
                return std::dynamic_pointer_cast<ITrafficStopAction>(shared_from_this());
            else if (classifier == typeid(ITrafficStopActionWriter).name())
                return std::dynamic_pointer_cast<ITrafficStopActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrafficStopActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrafficStopActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TrafficStopActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrafficStopActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TrafficStopActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrafficStopActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TrafficStopActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrafficStopActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrafficStopActionImpl::GetModelType() const
        {
            return "TrafficStopAction";
        }

            // children

        TrafficStopActionImpl::TrafficStopActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void TrafficStopActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType TrafficStopActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficStopActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficStopActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficStopActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string TrafficStopActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficStopActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficStopActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficStopActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficStopActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* TrafficSwarmActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double TrafficSwarmActionImpl::GetInnerRadius() const
        {
        	  return _innerRadius;
        }
        uint32_t TrafficSwarmActionImpl::GetNumberOfVehicles() const
        {
        	  return _numberOfVehicles;
        }
        double TrafficSwarmActionImpl::GetOffset() const
        {
        	  return _offset;
        }
        double TrafficSwarmActionImpl::GetSemiMajorAxis() const
        {
        	  return _semiMajorAxis;
        }
        double TrafficSwarmActionImpl::GetSemiMinorAxis() const
        {
        	  return _semiMinorAxis;
        }
        double TrafficSwarmActionImpl::GetVelocity() const
        {
        	  return _velocity;
        }
        std::shared_ptr<ICentralSwarmObject> TrafficSwarmActionImpl::GetCentralObject() const
        {
        	  return _centralObject;
        }
        std::shared_ptr<ITrafficDefinition> TrafficSwarmActionImpl::GetTrafficDefinition() const
        {
        	  return _trafficDefinition;
        }
        std::shared_ptr<IRange> TrafficSwarmActionImpl::GetInitialSpeedRange() const
        {
        	  return _initialSpeedRange;
        }
        std::shared_ptr<IDirectionOfTravelDistribution> TrafficSwarmActionImpl::GetDirectionOfTravelDistribution() const
        {
        	  return _directionOfTravelDistribution;
        }


        void TrafficSwarmActionImpl::SetInnerRadius(const double innerRadius)
        {
            _innerRadius = innerRadius;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__INNER_RADIUS);
        }

        void TrafficSwarmActionImpl::SetNumberOfVehicles(const uint32_t numberOfVehicles)
        {
            _numberOfVehicles = numberOfVehicles;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NUMBER_OF_VEHICLES);
        }

        void TrafficSwarmActionImpl::SetOffset(const double offset)
        {
            _offset = offset;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__OFFSET);
        }

        void TrafficSwarmActionImpl::SetSemiMajorAxis(const double semiMajorAxis)
        {
            _semiMajorAxis = semiMajorAxis;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SEMI_MAJOR_AXIS);
        }

        void TrafficSwarmActionImpl::SetSemiMinorAxis(const double semiMinorAxis)
        {
            _semiMinorAxis = semiMinorAxis;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SEMI_MINOR_AXIS);
        }

        void TrafficSwarmActionImpl::SetVelocity(const double velocity)
        {
            _velocity = velocity;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VELOCITY);
			// set the indicator to true
            isSetVelocity = true;          
        }

        void TrafficSwarmActionImpl::SetCentralObject(std::shared_ptr<ICentralSwarmObjectWriter> centralObject)
        {
            _centralObject = centralObject;
        }

        void TrafficSwarmActionImpl::SetTrafficDefinition(std::shared_ptr<ITrafficDefinitionWriter> trafficDefinition)
        {
            _trafficDefinition = trafficDefinition;
        }

        void TrafficSwarmActionImpl::SetInitialSpeedRange(std::shared_ptr<IRangeWriter> initialSpeedRange)
        {
            _initialSpeedRange = initialSpeedRange;
			// set the indicator to true
            isSetInitialSpeedRange = true;          
        }

        void TrafficSwarmActionImpl::SetDirectionOfTravelDistribution(std::shared_ptr<IDirectionOfTravelDistributionWriter> directionOfTravelDistribution)
        {
            _directionOfTravelDistribution = directionOfTravelDistribution;
			// set the indicator to true
            isSetDirectionOfTravelDistribution = true;          
        }

        std::shared_ptr<void> TrafficSwarmActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrafficSwarmActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrafficSwarmAction).name())
                return std::dynamic_pointer_cast<ITrafficSwarmAction>(shared_from_this());
            else if (classifier == typeid(ITrafficSwarmActionWriter).name())
                return std::dynamic_pointer_cast<ITrafficSwarmActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrafficSwarmActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrafficSwarmActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__NUMBER_OF_VEHICLES)
                {
                    return GetNumberOfVehicles();
                }
                throw KeyNotSupportedException();

        }

        int TrafficSwarmActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrafficSwarmActionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__INNER_RADIUS)
                {
                    return GetInnerRadius();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__OFFSET)
                {
                    return GetOffset();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__SEMI_MAJOR_AXIS)
                {
                    return GetSemiMajorAxis();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__SEMI_MINOR_AXIS)
                {
                    return GetSemiMinorAxis();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__VELOCITY)
                {
                    return GetVelocity();
                }
                throw KeyNotSupportedException();

        }

        uint16_t TrafficSwarmActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrafficSwarmActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TrafficSwarmActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrafficSwarmActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrafficSwarmActionImpl::GetModelType() const
        {
            return "TrafficSwarmAction";
        }

        void TrafficSwarmActionImpl::WriteParameterToInnerRadius(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__INNER_RADIUS, parameterName, nullTextMarker /*no textmarker*/);
            _innerRadius = {};
        }

        void TrafficSwarmActionImpl::WriteParameterToNumberOfVehicles(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NUMBER_OF_VEHICLES, parameterName, nullTextMarker /*no textmarker*/);
            _numberOfVehicles = {};
        }

        void TrafficSwarmActionImpl::WriteParameterToOffset(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__OFFSET, parameterName, nullTextMarker /*no textmarker*/);
            _offset = {};
        }

        void TrafficSwarmActionImpl::WriteParameterToSemiMajorAxis(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SEMI_MAJOR_AXIS, parameterName, nullTextMarker /*no textmarker*/);
            _semiMajorAxis = {};
        }

        void TrafficSwarmActionImpl::WriteParameterToSemiMinorAxis(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SEMI_MINOR_AXIS, parameterName, nullTextMarker /*no textmarker*/);
            _semiMinorAxis = {};
        }

        void TrafficSwarmActionImpl::WriteParameterToVelocity(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VELOCITY, parameterName, nullTextMarker /*no textmarker*/);
            _velocity = {};
        }

        std::string TrafficSwarmActionImpl::GetParameterFromInnerRadius() const
        {
            auto innerRadius = OSC_CONSTANTS::ATTRIBUTE__INNER_RADIUS;
            return GetParameterNameFromAttribute(innerRadius);
        }

        std::string TrafficSwarmActionImpl::GetParameterFromNumberOfVehicles() const
        {
            auto numberOfVehicles = OSC_CONSTANTS::ATTRIBUTE__NUMBER_OF_VEHICLES;
            return GetParameterNameFromAttribute(numberOfVehicles);
        }

        std::string TrafficSwarmActionImpl::GetParameterFromOffset() const
        {
            auto offset = OSC_CONSTANTS::ATTRIBUTE__OFFSET;
            return GetParameterNameFromAttribute(offset);
        }

        std::string TrafficSwarmActionImpl::GetParameterFromSemiMajorAxis() const
        {
            auto semiMajorAxis = OSC_CONSTANTS::ATTRIBUTE__SEMI_MAJOR_AXIS;
            return GetParameterNameFromAttribute(semiMajorAxis);
        }

        std::string TrafficSwarmActionImpl::GetParameterFromSemiMinorAxis() const
        {
            auto semiMinorAxis = OSC_CONSTANTS::ATTRIBUTE__SEMI_MINOR_AXIS;
            return GetParameterNameFromAttribute(semiMinorAxis);
        }

        std::string TrafficSwarmActionImpl::GetParameterFromVelocity() const
        {
            auto velocity = OSC_CONSTANTS::ATTRIBUTE__VELOCITY;
            return GetParameterNameFromAttribute(velocity);
        }

        bool TrafficSwarmActionImpl::IsInnerRadiusParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__INNER_RADIUS);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TrafficSwarmActionImpl::IsNumberOfVehiclesParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NUMBER_OF_VEHICLES);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TrafficSwarmActionImpl::IsOffsetParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__OFFSET);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TrafficSwarmActionImpl::IsSemiMajorAxisParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__SEMI_MAJOR_AXIS);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TrafficSwarmActionImpl::IsSemiMinorAxisParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__SEMI_MINOR_AXIS);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TrafficSwarmActionImpl::IsVelocityParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VELOCITY);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<ICentralSwarmObjectWriter> TrafficSwarmActionImpl::GetWriterCentralObject() const
        {
            return std::dynamic_pointer_cast<ICentralSwarmObjectWriter>(_centralObject);
        }
        std::shared_ptr<ITrafficDefinitionWriter> TrafficSwarmActionImpl::GetWriterTrafficDefinition() const
        {
            return std::dynamic_pointer_cast<ITrafficDefinitionWriter>(_trafficDefinition);
        }
        std::shared_ptr<IRangeWriter> TrafficSwarmActionImpl::GetWriterInitialSpeedRange() const
        {
            return std::dynamic_pointer_cast<IRangeWriter>(_initialSpeedRange);
        }
        std::shared_ptr<IDirectionOfTravelDistributionWriter> TrafficSwarmActionImpl::GetWriterDirectionOfTravelDistribution() const
        {
            return std::dynamic_pointer_cast<IDirectionOfTravelDistributionWriter>(_directionOfTravelDistribution);
        }

        TrafficSwarmActionImpl::TrafficSwarmActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__INNER_RADIUS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NUMBER_OF_VEHICLES, SimpleType::UNSIGNED_INT);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__OFFSET, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SEMI_MAJOR_AXIS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SEMI_MINOR_AXIS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VELOCITY, SimpleType::DOUBLE);
        }

        void TrafficSwarmActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__INNER_RADIUS)
            {
                // Simple type
                _innerRadius = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NUMBER_OF_VEHICLES)
            {
                // Simple type
                _numberOfVehicles = ParserHelper::ParseUnsignedInt(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__OFFSET)
            {
                // Simple type
                _offset = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SEMI_MAJOR_AXIS)
            {
                // Simple type
                _semiMajorAxis = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SEMI_MINOR_AXIS)
            {
                // Simple type
                _semiMinorAxis = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VELOCITY)
            {
                // Simple type
                _velocity = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSwarmActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSwarmActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kCentralObject =  GetWriterCentralObject();
                if (kCentralObject)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCentralObject));
                }
                const auto kTrafficDefinition =  GetWriterTrafficDefinition();
                if (kTrafficDefinition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficDefinition));
                }
                const auto kInitialSpeedRange =  GetWriterInitialSpeedRange();
                if (kInitialSpeedRange)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kInitialSpeedRange));
                }
                const auto kDirectionOfTravelDistribution =  GetWriterDirectionOfTravelDistribution();
                if (kDirectionOfTravelDistribution)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDirectionOfTravelDistribution));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSwarmActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSwarmActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_innerRadius = GetInnerRadius();
            // Simple type
            clonedObject->_numberOfVehicles = GetNumberOfVehicles();
            // Simple type
            clonedObject->_offset = GetOffset();
            // Simple type
            clonedObject->_semiMajorAxis = GetSemiMajorAxis();
            // Simple type
            clonedObject->_semiMinorAxis = GetSemiMinorAxis();
            // Simple type
            clonedObject->_velocity = GetVelocity();
            // clone indicators
            	clonedObject->isSetVelocity = isSetVelocity;
            // clone children
            const auto kCentralObject =  GetWriterCentralObject();
            if (kCentralObject)
            {
                auto clonedChild = std::dynamic_pointer_cast<CentralSwarmObjectImpl>(kCentralObject)->Clone();
                auto clonedChildICentralSwarmObject = std::dynamic_pointer_cast<ICentralSwarmObject>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCentralObject(std::dynamic_pointer_cast<ICentralSwarmObjectWriter>(clonedChildICentralSwarmObject));
            }
            const auto kTrafficDefinition =  GetWriterTrafficDefinition();
            if (kTrafficDefinition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficDefinitionImpl>(kTrafficDefinition)->Clone();
                auto clonedChildITrafficDefinition = std::dynamic_pointer_cast<ITrafficDefinition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficDefinition(std::dynamic_pointer_cast<ITrafficDefinitionWriter>(clonedChildITrafficDefinition));
            }
            const auto kInitialSpeedRange =  GetWriterInitialSpeedRange();
            if (kInitialSpeedRange)
            {
                auto clonedChild = std::dynamic_pointer_cast<RangeImpl>(kInitialSpeedRange)->Clone();
                auto clonedChildIRange = std::dynamic_pointer_cast<IRange>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetInitialSpeedRange(std::dynamic_pointer_cast<IRangeWriter>(clonedChildIRange));
            }
            const auto kDirectionOfTravelDistribution =  GetWriterDirectionOfTravelDistribution();
            if (kDirectionOfTravelDistribution)
            {
                auto clonedChild = std::dynamic_pointer_cast<DirectionOfTravelDistributionImpl>(kDirectionOfTravelDistribution)->Clone();
                auto clonedChildIDirectionOfTravelDistribution = std::dynamic_pointer_cast<IDirectionOfTravelDistribution>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDirectionOfTravelDistribution(std::dynamic_pointer_cast<IDirectionOfTravelDistributionWriter>(clonedChildIDirectionOfTravelDistribution));
            }
            return clonedObject;
        }

        std::string TrafficSwarmActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSwarmActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CENTRAL_OBJECT)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCentralObject());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_DEFINITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficDefinition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__INITIAL_SPEED_RANGE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetInitialSpeedRange());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIRECTION_OF_TRAVEL_DISTRIBUTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDirectionOfTravelDistribution());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSwarmActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSwarmActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficSwarmActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void TrafficSwarmActionImpl::ResolveUnsignedIntExpression(std::string& attributeKey, unsigned int& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NUMBER_OF_VEHICLES)
            {
                // Simple type
                _numberOfVehicles = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void TrafficSwarmActionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__INNER_RADIUS)
            {
                // Simple type
                _innerRadius = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__OFFSET)
            {
                // Simple type
                _offset = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SEMI_MAJOR_AXIS)
            {
                // Simple type
                _semiMajorAxis = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SEMI_MINOR_AXIS)
            {
                // Simple type
                _semiMinorAxis = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VELOCITY)
            {
                // Simple type
                _velocity = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void TrafficSwarmActionImpl::ResetVelocity()
	   {
	   		isSetVelocity = false; 
			_velocity = {};
			
	   }
       bool TrafficSwarmActionImpl::IsSetVelocity() const
	   {
			return isSetVelocity;
	   }
       void TrafficSwarmActionImpl::ResetInitialSpeedRange()
	   {
	   		isSetInitialSpeedRange = false; 
			_initialSpeedRange = {};
			
	   }
       bool TrafficSwarmActionImpl::IsSetInitialSpeedRange() const
	   {
			return isSetInitialSpeedRange;
	   }
       void TrafficSwarmActionImpl::ResetDirectionOfTravelDistribution()
	   {
	   		isSetDirectionOfTravelDistribution = false; 
			_directionOfTravelDistribution = {};
			
	   }
       bool TrafficSwarmActionImpl::IsSetDirectionOfTravelDistribution() const
	   {
			return isSetDirectionOfTravelDistribution;
	   }

        IOpenScenarioFlexElement* TrajectoryImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool TrajectoryImpl::GetClosed() const
        {
        	  return _closed;
        }
        std::string TrajectoryImpl::GetName() const
        {
        	  return _name;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> TrajectoryImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IParameterDeclarationWriter>> TrajectoryImpl::GetWriterParameterDeclarations() const
        {
            return _parameterDeclarations;
        }

        int TrajectoryImpl::GetParameterDeclarationsSize() const
        {
            return static_cast<int>(_parameterDeclarations.size());
        }

        std::shared_ptr<IParameterDeclaration> TrajectoryImpl::GetParameterDeclarationsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _parameterDeclarations.size() > index)
            {
                return _parameterDeclarations[index];
            }
            return nullptr;
        }
        std::shared_ptr<IShape> TrajectoryImpl::GetShape() const
        {
        	  return _shape;
        }


        void TrajectoryImpl::SetClosed(const bool closed)
        {
            _closed = closed;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CLOSED);
        }

        void TrajectoryImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void TrajectoryImpl::SetParameterDeclarations(std::vector<std::shared_ptr<IParameterDeclarationWriter>>& parameterDeclarations)
        {
            _parameterDeclarations = parameterDeclarations;
			// set the indicator to true
            isSetParameterDeclarations = true;          
        }

        void TrajectoryImpl::SetShape(std::shared_ptr<IShapeWriter> shape)
        {
            _shape = shape;
        }

        std::shared_ptr<void> TrajectoryImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrajectoryImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrajectory).name())
                return std::dynamic_pointer_cast<ITrajectory>(shared_from_this());
            else if (classifier == typeid(ITrajectoryWriter).name())
                return std::dynamic_pointer_cast<ITrajectoryWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrajectoryImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrajectoryImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TrajectoryImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrajectoryImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TrajectoryImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrajectoryImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__CLOSED)
                {
                    return GetClosed();
                }
                throw KeyNotSupportedException();

        }

        DateTime TrajectoryImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrajectoryImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrajectoryImpl::GetModelType() const
        {
            return "Trajectory";
        }

        void TrajectoryImpl::WriteParameterToClosed(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CLOSED, parameterName, nullTextMarker /*no textmarker*/);
            _closed = {};
        }

        void TrajectoryImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        std::string TrajectoryImpl::GetParameterFromClosed() const
        {
            auto closed = OSC_CONSTANTS::ATTRIBUTE__CLOSED;
            return GetParameterNameFromAttribute(closed);
        }

        std::string TrajectoryImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        bool TrajectoryImpl::IsClosedParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CLOSED);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TrajectoryImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IShapeWriter> TrajectoryImpl::GetWriterShape() const
        {
            return std::dynamic_pointer_cast<IShapeWriter>(_shape);
        }

        TrajectoryImpl::TrajectoryImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CLOSED, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        void TrajectoryImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CLOSED)
            {
                // Simple type
                _closed = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrajectoryImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool TrajectoryImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> TrajectoryImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrajectoryImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kShape =  GetWriterShape();
                if (kShape)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kShape));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrajectoryImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrajectoryImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_closed = GetClosed();
            // Simple type
            clonedObject->_name = GetName();
            // clone indicators
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kShape =  GetWriterShape();
            if (kShape)
            {
                auto clonedChild = std::dynamic_pointer_cast<ShapeImpl>(kShape)->Clone();
                auto clonedChildIShape = std::dynamic_pointer_cast<IShape>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetShape(std::dynamic_pointer_cast<IShapeWriter>(clonedChildIShape));
            }
            return clonedObject;
        }

        std::string TrajectoryImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrajectoryImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SHAPE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetShape());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrajectoryImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrajectoryImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrajectoryImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void TrajectoryImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CLOSED)
            {
                // Simple type
                _closed = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void TrajectoryImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void TrajectoryImpl::ResetParameterDeclarations()
	   {
	   		isSetParameterDeclarations = false; 
			_parameterDeclarations = {};
			
	   }
       bool TrajectoryImpl::IsSetParameterDeclarations() const
	   {
			return isSetParameterDeclarations;
	   }

        IOpenScenarioFlexElement* TrajectoryCatalogLocationImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IDirectory> TrajectoryCatalogLocationImpl::GetDirectory() const
        {
        	  return _directory;
        }


        void TrajectoryCatalogLocationImpl::SetDirectory(std::shared_ptr<IDirectoryWriter> directory)
        {
            _directory = directory;
        }

        std::shared_ptr<void> TrajectoryCatalogLocationImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrajectoryCatalogLocationImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrajectoryCatalogLocation).name())
                return std::dynamic_pointer_cast<ITrajectoryCatalogLocation>(shared_from_this());
            else if (classifier == typeid(ITrajectoryCatalogLocationWriter).name())
                return std::dynamic_pointer_cast<ITrajectoryCatalogLocationWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrajectoryCatalogLocationImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrajectoryCatalogLocationImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TrajectoryCatalogLocationImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrajectoryCatalogLocationImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TrajectoryCatalogLocationImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrajectoryCatalogLocationImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TrajectoryCatalogLocationImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrajectoryCatalogLocationImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrajectoryCatalogLocationImpl::GetModelType() const
        {
            return "TrajectoryCatalogLocation";
        }

            // children
        std::shared_ptr<IDirectoryWriter> TrajectoryCatalogLocationImpl::GetWriterDirectory() const
        {
            return std::dynamic_pointer_cast<IDirectoryWriter>(_directory);
        }

        TrajectoryCatalogLocationImpl::TrajectoryCatalogLocationImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void TrajectoryCatalogLocationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType TrajectoryCatalogLocationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrajectoryCatalogLocationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDirectory =  GetWriterDirectory();
                if (kDirectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDirectory));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrajectoryCatalogLocationImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrajectoryCatalogLocationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kDirectory =  GetWriterDirectory();
            if (kDirectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<DirectoryImpl>(kDirectory)->Clone();
                auto clonedChildIDirectory = std::dynamic_pointer_cast<IDirectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDirectory(std::dynamic_pointer_cast<IDirectoryWriter>(clonedChildIDirectory));
            }
            return clonedObject;
        }

        std::string TrajectoryCatalogLocationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrajectoryCatalogLocationImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIRECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDirectory());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrajectoryCatalogLocationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrajectoryCatalogLocationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrajectoryCatalogLocationImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* TrajectoryFollowingModeImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        FollowingMode TrajectoryFollowingModeImpl::GetFollowingMode() const
        {
        	  return _followingMode;
        }


        void TrajectoryFollowingModeImpl::SetFollowingMode(const FollowingMode followingMode)
        {
            _followingMode = followingMode;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE);
        }

        std::shared_ptr<void> TrajectoryFollowingModeImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrajectoryFollowingModeImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrajectoryFollowingMode).name())
                return std::dynamic_pointer_cast<ITrajectoryFollowingMode>(shared_from_this());
            else if (classifier == typeid(ITrajectoryFollowingModeWriter).name())
                return std::dynamic_pointer_cast<ITrajectoryFollowingModeWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrajectoryFollowingModeImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrajectoryFollowingModeImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TrajectoryFollowingModeImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrajectoryFollowingModeImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TrajectoryFollowingModeImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrajectoryFollowingModeImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TrajectoryFollowingModeImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrajectoryFollowingModeImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrajectoryFollowingModeImpl::GetModelType() const
        {
            return "TrajectoryFollowingMode";
        }

        void TrajectoryFollowingModeImpl::WriteParameterToFollowingMode(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE, parameterName, nullTextMarker /*no textmarker*/);
            _followingMode = {};
        }

        std::string TrajectoryFollowingModeImpl::GetParameterFromFollowingMode() const
        {
            auto followingMode = OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE;
            return GetParameterNameFromAttribute(followingMode);
        }

        bool TrajectoryFollowingModeImpl::IsFollowingModeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        TrajectoryFollowingModeImpl::TrajectoryFollowingModeImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE, SimpleType::ENUM_TYPE);
        }

        void TrajectoryFollowingModeImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE)
            {
                // Enumeration Type
                const auto kResult = FollowingMode::GetFromLiteral(parameterLiteralValue);
                if (kResult != FollowingMode::UNKNOWN)
                {
                    _followingMode = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType TrajectoryFollowingModeImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrajectoryFollowingModeImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrajectoryFollowingModeImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrajectoryFollowingModeImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kFollowingMode = GetFollowingMode();
            if ( kFollowingMode.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_followingMode = FollowingMode::GetFromLiteral(kFollowingMode.GetLiteral());
            }
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string TrajectoryFollowingModeImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrajectoryFollowingModeImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrajectoryFollowingModeImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrajectoryFollowingModeImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrajectoryFollowingModeImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE)
            {
                auto followingMode = GetFollowingMode();
                return followingMode.GetLiteral() != "UNKNOWN" ? followingMode.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* TrajectoryPositionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double TrajectoryPositionImpl::GetS() const
        {
        	  return _s;
        }
        double TrajectoryPositionImpl::GetT() const
        {
        	  return _t;
        }
        std::shared_ptr<IOrientation> TrajectoryPositionImpl::GetOrientation() const
        {
        	  return _orientation;
        }
        std::shared_ptr<ITrajectoryRef> TrajectoryPositionImpl::GetTrajectoryRef() const
        {
        	  return _trajectoryRef;
        }


        void TrajectoryPositionImpl::SetS(const double s)
        {
            _s = s;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__S);
        }

        void TrajectoryPositionImpl::SetT(const double t)
        {
            _t = t;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__T);
			// set the indicator to true
            isSetT = true;          
        }

        void TrajectoryPositionImpl::SetOrientation(std::shared_ptr<IOrientationWriter> orientation)
        {
            _orientation = orientation;
			// set the indicator to true
            isSetOrientation = true;          
        }

        void TrajectoryPositionImpl::SetTrajectoryRef(std::shared_ptr<ITrajectoryRefWriter> trajectoryRef)
        {
            _trajectoryRef = trajectoryRef;
        }

        std::shared_ptr<void> TrajectoryPositionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrajectoryPositionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrajectoryPosition).name())
                return std::dynamic_pointer_cast<ITrajectoryPosition>(shared_from_this());
            else if (classifier == typeid(ITrajectoryPositionWriter).name())
                return std::dynamic_pointer_cast<ITrajectoryPositionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrajectoryPositionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrajectoryPositionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TrajectoryPositionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrajectoryPositionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__S)
                {
                    return GetS();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__T)
                {
                    return GetT();
                }
                throw KeyNotSupportedException();

        }

        uint16_t TrajectoryPositionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrajectoryPositionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TrajectoryPositionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrajectoryPositionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrajectoryPositionImpl::GetModelType() const
        {
            return "TrajectoryPosition";
        }

        void TrajectoryPositionImpl::WriteParameterToS(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__S, parameterName, nullTextMarker /*no textmarker*/);
            _s = {};
        }

        void TrajectoryPositionImpl::WriteParameterToT(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__T, parameterName, nullTextMarker /*no textmarker*/);
            _t = {};
        }

        std::string TrajectoryPositionImpl::GetParameterFromS() const
        {
            auto s = OSC_CONSTANTS::ATTRIBUTE__S;
            return GetParameterNameFromAttribute(s);
        }

        std::string TrajectoryPositionImpl::GetParameterFromT() const
        {
            auto t = OSC_CONSTANTS::ATTRIBUTE__T;
            return GetParameterNameFromAttribute(t);
        }

        bool TrajectoryPositionImpl::IsSParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__S);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TrajectoryPositionImpl::IsTParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__T);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IOrientationWriter> TrajectoryPositionImpl::GetWriterOrientation() const
        {
            return std::dynamic_pointer_cast<IOrientationWriter>(_orientation);
        }
        std::shared_ptr<ITrajectoryRefWriter> TrajectoryPositionImpl::GetWriterTrajectoryRef() const
        {
            return std::dynamic_pointer_cast<ITrajectoryRefWriter>(_trajectoryRef);
        }

        TrajectoryPositionImpl::TrajectoryPositionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__S, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__T, SimpleType::DOUBLE);
        }

        void TrajectoryPositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__S)
            {
                // Simple type
                _s = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__T)
            {
                // Simple type
                _t = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrajectoryPositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrajectoryPositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kOrientation =  GetWriterOrientation();
                if (kOrientation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOrientation));
                }
                const auto kTrajectoryRef =  GetWriterTrajectoryRef();
                if (kTrajectoryRef)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrajectoryRef));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrajectoryPositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrajectoryPositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_s = GetS();
            // Simple type
            clonedObject->_t = GetT();
            // clone indicators
            	clonedObject->isSetT = isSetT;
            // clone children
            const auto kOrientation =  GetWriterOrientation();
            if (kOrientation)
            {
                auto clonedChild = std::dynamic_pointer_cast<OrientationImpl>(kOrientation)->Clone();
                auto clonedChildIOrientation = std::dynamic_pointer_cast<IOrientation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOrientation(std::dynamic_pointer_cast<IOrientationWriter>(clonedChildIOrientation));
            }
            const auto kTrajectoryRef =  GetWriterTrajectoryRef();
            if (kTrajectoryRef)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrajectoryRefImpl>(kTrajectoryRef)->Clone();
                auto clonedChildITrajectoryRef = std::dynamic_pointer_cast<ITrajectoryRef>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrajectoryRef(std::dynamic_pointer_cast<ITrajectoryRefWriter>(clonedChildITrajectoryRef));
            }
            return clonedObject;
        }

        std::string TrajectoryPositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrajectoryPositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ORIENTATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOrientation());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAJECTORY_REF)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrajectoryRef());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrajectoryPositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrajectoryPositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrajectoryPositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void TrajectoryPositionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__S)
            {
                // Simple type
                _s = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__T)
            {
                // Simple type
                _t = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void TrajectoryPositionImpl::ResetT()
	   {
	   		isSetT = false; 
			_t = {0};
			
	   }
       bool TrajectoryPositionImpl::IsSetT() const
	   {
			return isSetT;
	   }
       void TrajectoryPositionImpl::ResetOrientation()
	   {
	   		isSetOrientation = false; 
			_orientation = {};
			
	   }
       bool TrajectoryPositionImpl::IsSetOrientation() const
	   {
			return isSetOrientation;
	   }

        IOpenScenarioFlexElement* TrajectoryRefImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<ITrajectory> TrajectoryRefImpl::GetTrajectory() const
        {
        	  return _trajectory;
        }
        std::shared_ptr<ICatalogReference> TrajectoryRefImpl::GetCatalogReference() const
        {
        	  return _catalogReference;
        }


        void TrajectoryRefImpl::SetTrajectory(std::shared_ptr<ITrajectoryWriter> trajectory)
        {
            _trajectory = trajectory;
            _catalogReference = {};
        }

        void TrajectoryRefImpl::SetCatalogReference(std::shared_ptr<ICatalogReferenceWriter> catalogReference)
        {
            _catalogReference = catalogReference;
            _trajectory = {};
        }

        std::shared_ptr<void> TrajectoryRefImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TrajectoryRefImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrajectoryRef).name())
                return std::dynamic_pointer_cast<ITrajectoryRef>(shared_from_this());
            else if (classifier == typeid(ITrajectoryRefWriter).name())
                return std::dynamic_pointer_cast<ITrajectoryRefWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TrajectoryRefImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TrajectoryRefImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TrajectoryRefImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TrajectoryRefImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TrajectoryRefImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TrajectoryRefImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TrajectoryRefImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TrajectoryRefImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TrajectoryRefImpl::GetModelType() const
        {
            return "TrajectoryRef";
        }

            // children
        std::shared_ptr<ITrajectoryWriter> TrajectoryRefImpl::GetWriterTrajectory() const
        {
            return std::dynamic_pointer_cast<ITrajectoryWriter>(_trajectory);
        }
        std::shared_ptr<ICatalogReferenceWriter> TrajectoryRefImpl::GetWriterCatalogReference() const
        {
            return std::dynamic_pointer_cast<ICatalogReferenceWriter>(_catalogReference);
        }

        TrajectoryRefImpl::TrajectoryRefImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void TrajectoryRefImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType TrajectoryRefImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrajectoryRefImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kTrajectory =  GetWriterTrajectory();
                if (kTrajectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrajectory));
                }
                const auto kCatalogReference =  GetWriterCatalogReference();
                if (kCatalogReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogReference));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrajectoryRefImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrajectoryRefImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kTrajectory =  GetWriterTrajectory();
            if (kTrajectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrajectoryImpl>(kTrajectory)->Clone();
                auto clonedChildITrajectory = std::dynamic_pointer_cast<ITrajectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrajectory(std::dynamic_pointer_cast<ITrajectoryWriter>(clonedChildITrajectory));
            }
            const auto kCatalogReference =  GetWriterCatalogReference();
            if (kCatalogReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kCatalogReference)->Clone();
                auto clonedChildICatalogReference = std::dynamic_pointer_cast<ICatalogReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogReference(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChildICatalogReference));
            }
            return clonedObject;
        }

        std::string TrajectoryRefImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrajectoryRefImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAJECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrajectory());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogReference());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrajectoryRefImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrajectoryRefImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrajectoryRefImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* TransitionDynamicsImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        DynamicsDimension TransitionDynamicsImpl::GetDynamicsDimension() const
        {
        	  return _dynamicsDimension;
        }
        DynamicsShape TransitionDynamicsImpl::GetDynamicsShape() const
        {
        	  return _dynamicsShape;
        }
        FollowingMode TransitionDynamicsImpl::GetFollowingMode() const
        {
        	  return _followingMode;
        }
        double TransitionDynamicsImpl::GetValue() const
        {
        	  return _value;
        }


        void TransitionDynamicsImpl::SetDynamicsDimension(const DynamicsDimension dynamicsDimension)
        {
            _dynamicsDimension = dynamicsDimension;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_DIMENSION);
        }

        void TransitionDynamicsImpl::SetDynamicsShape(const DynamicsShape dynamicsShape)
        {
            _dynamicsShape = dynamicsShape;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE);
        }

        void TransitionDynamicsImpl::SetFollowingMode(const FollowingMode followingMode)
        {
            _followingMode = followingMode;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE);
			// set the indicator to true
            isSetFollowingMode = true;          
        }

        void TransitionDynamicsImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> TransitionDynamicsImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TransitionDynamicsImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITransitionDynamics).name())
                return std::dynamic_pointer_cast<ITransitionDynamics>(shared_from_this());
            else if (classifier == typeid(ITransitionDynamicsWriter).name())
                return std::dynamic_pointer_cast<ITransitionDynamicsWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TransitionDynamicsImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TransitionDynamicsImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TransitionDynamicsImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TransitionDynamicsImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t TransitionDynamicsImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TransitionDynamicsImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TransitionDynamicsImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TransitionDynamicsImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TransitionDynamicsImpl::GetModelType() const
        {
            return "TransitionDynamics";
        }

        void TransitionDynamicsImpl::WriteParameterToDynamicsDimension(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_DIMENSION, parameterName, nullTextMarker /*no textmarker*/);
            _dynamicsDimension = {};
        }

        void TransitionDynamicsImpl::WriteParameterToDynamicsShape(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE, parameterName, nullTextMarker /*no textmarker*/);
            _dynamicsShape = {};
        }

        void TransitionDynamicsImpl::WriteParameterToFollowingMode(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE, parameterName, nullTextMarker /*no textmarker*/);
            _followingMode = {};
        }

        void TransitionDynamicsImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string TransitionDynamicsImpl::GetParameterFromDynamicsDimension() const
        {
            auto dynamicsDimension = OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_DIMENSION;
            return GetParameterNameFromAttribute(dynamicsDimension);
        }

        std::string TransitionDynamicsImpl::GetParameterFromDynamicsShape() const
        {
            auto dynamicsShape = OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE;
            return GetParameterNameFromAttribute(dynamicsShape);
        }

        std::string TransitionDynamicsImpl::GetParameterFromFollowingMode() const
        {
            auto followingMode = OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE;
            return GetParameterNameFromAttribute(followingMode);
        }

        std::string TransitionDynamicsImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool TransitionDynamicsImpl::IsDynamicsDimensionParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_DIMENSION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TransitionDynamicsImpl::IsDynamicsShapeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TransitionDynamicsImpl::IsFollowingModeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool TransitionDynamicsImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        TransitionDynamicsImpl::TransitionDynamicsImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_DIMENSION, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void TransitionDynamicsImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_DIMENSION)
            {
                // Enumeration Type
                const auto kResult = DynamicsDimension::GetFromLiteral(parameterLiteralValue);
                if (kResult != DynamicsDimension::UNKNOWN)
                {
                    _dynamicsDimension = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE)
            {
                // Enumeration Type
                const auto kResult = DynamicsShape::GetFromLiteral(parameterLiteralValue);
                if (kResult != DynamicsShape::UNKNOWN)
                {
                    _dynamicsShape = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE)
            {
                // Enumeration Type
                const auto kResult = FollowingMode::GetFromLiteral(parameterLiteralValue);
                if (kResult != FollowingMode::UNKNOWN)
                {
                    _followingMode = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TransitionDynamicsImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TransitionDynamicsImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TransitionDynamicsImpl::Clone()
        {
            auto clonedObject = std::make_shared<TransitionDynamicsImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kDynamicsDimension = GetDynamicsDimension();
            if ( kDynamicsDimension.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_dynamicsDimension = DynamicsDimension::GetFromLiteral(kDynamicsDimension.GetLiteral());
            }
            // Enumeration Type
            const auto kDynamicsShape = GetDynamicsShape();
            if ( kDynamicsShape.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_dynamicsShape = DynamicsShape::GetFromLiteral(kDynamicsShape.GetLiteral());
            }
            // Enumeration Type
            const auto kFollowingMode = GetFollowingMode();
            if ( kFollowingMode.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_followingMode = FollowingMode::GetFromLiteral(kFollowingMode.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            	clonedObject->isSetFollowingMode = isSetFollowingMode;
            // clone children
            return clonedObject;
        }

        std::string TransitionDynamicsImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TransitionDynamicsImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TransitionDynamicsImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TransitionDynamicsImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TransitionDynamicsImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_DIMENSION)
            {
                auto dynamicsDimension = GetDynamicsDimension();
                return dynamicsDimension.GetLiteral() != "UNKNOWN" ? dynamicsDimension.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE)
            {
                auto dynamicsShape = GetDynamicsShape();
                return dynamicsShape.GetLiteral() != "UNKNOWN" ? dynamicsShape.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE)
            {
                auto followingMode = GetFollowingMode();
                return followingMode.GetLiteral() != "UNKNOWN" ? followingMode.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void TransitionDynamicsImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void TransitionDynamicsImpl::ResetFollowingMode()
	   {
	   		isSetFollowingMode = false; 
			_followingMode = {FollowingMode::FollowingModeEnum::POSITION};
			
	   }
       bool TransitionDynamicsImpl::IsSetFollowingMode() const
	   {
			return isSetFollowingMode;
	   }

        IOpenScenarioFlexElement* TraveledDistanceConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double TraveledDistanceConditionImpl::GetValue() const
        {
        	  return _value;
        }


        void TraveledDistanceConditionImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> TraveledDistanceConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TraveledDistanceConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITraveledDistanceCondition).name())
                return std::dynamic_pointer_cast<ITraveledDistanceCondition>(shared_from_this());
            else if (classifier == typeid(ITraveledDistanceConditionWriter).name())
                return std::dynamic_pointer_cast<ITraveledDistanceConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TraveledDistanceConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TraveledDistanceConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TraveledDistanceConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TraveledDistanceConditionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t TraveledDistanceConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TraveledDistanceConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TraveledDistanceConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TraveledDistanceConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TraveledDistanceConditionImpl::GetModelType() const
        {
            return "TraveledDistanceCondition";
        }

        void TraveledDistanceConditionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string TraveledDistanceConditionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool TraveledDistanceConditionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        TraveledDistanceConditionImpl::TraveledDistanceConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void TraveledDistanceConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TraveledDistanceConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TraveledDistanceConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TraveledDistanceConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TraveledDistanceConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string TraveledDistanceConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TraveledDistanceConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TraveledDistanceConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TraveledDistanceConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TraveledDistanceConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void TraveledDistanceConditionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* TriggerImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<IConditionGroup>> TriggerImpl::GetConditionGroups() const
        {
            std::vector<std::shared_ptr<IConditionGroup>> temp;
            for(auto&& elm: _conditionGroups)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IConditionGroupWriter>> TriggerImpl::GetWriterConditionGroups() const
        {
            return _conditionGroups;
        }

        int TriggerImpl::GetConditionGroupsSize() const
        {
            return static_cast<int>(_conditionGroups.size());
        }

        std::shared_ptr<IConditionGroup> TriggerImpl::GetConditionGroupsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _conditionGroups.size() > index)
            {
                return _conditionGroups[index];
            }
            return nullptr;
        }


        void TriggerImpl::SetConditionGroups(std::vector<std::shared_ptr<IConditionGroupWriter>>& conditionGroups)
        {
            _conditionGroups = conditionGroups;
			// set the indicator to true
            isSetConditionGroups = true;          
        }

        std::shared_ptr<void> TriggerImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TriggerImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITrigger).name())
                return std::dynamic_pointer_cast<ITrigger>(shared_from_this());
            else if (classifier == typeid(ITriggerWriter).name())
                return std::dynamic_pointer_cast<ITriggerWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TriggerImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TriggerImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TriggerImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TriggerImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TriggerImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TriggerImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TriggerImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TriggerImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TriggerImpl::GetModelType() const
        {
            return "Trigger";
        }

            // children

        TriggerImpl::TriggerImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void TriggerImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType TriggerImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TriggerImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto conditionGroups =  GetWriterConditionGroups();
                if (!conditionGroups.empty())
                {
                    for(auto&& item : conditionGroups)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TriggerImpl::Clone()
        {
            auto clonedObject = std::make_shared<TriggerImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kConditionGroups =  GetWriterConditionGroups();
            if (!kConditionGroups.empty())
            {
                std::vector<std::shared_ptr<IConditionGroupWriter>> clonedList;
                for(auto&& kItem : kConditionGroups)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ConditionGroupImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IConditionGroupWriter>(clonedChild));
                }
                clonedObject->SetConditionGroups(clonedList);
            }
            return clonedObject;
        }

        std::string TriggerImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TriggerImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TriggerImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__CONDITION_GROUP)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetConditionGroups())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TriggerImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TriggerImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void TriggerImpl::ResetConditionGroups()
	   {
	   		isSetConditionGroups = false; 
			_conditionGroups = {};
			
	   }
       bool TriggerImpl::IsSetConditionGroups() const
	   {
			return isSetConditionGroups;
	   }

        IOpenScenarioFlexElement* TriggeringEntitiesImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        TriggeringEntitiesRule TriggeringEntitiesImpl::GetTriggeringEntitiesRule() const
        {
        	  return _triggeringEntitiesRule;
        }
        std::vector<std::shared_ptr<IEntityRef>> TriggeringEntitiesImpl::GetEntityRefs() const
        {
            std::vector<std::shared_ptr<IEntityRef>> temp;
            for(auto&& elm: _entityRefs)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IEntityRefWriter>> TriggeringEntitiesImpl::GetWriterEntityRefs() const
        {
            return _entityRefs;
        }

        int TriggeringEntitiesImpl::GetEntityRefsSize() const
        {
            return static_cast<int>(_entityRefs.size());
        }

        std::shared_ptr<IEntityRef> TriggeringEntitiesImpl::GetEntityRefsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _entityRefs.size() > index)
            {
                return _entityRefs[index];
            }
            return nullptr;
        }


        void TriggeringEntitiesImpl::SetTriggeringEntitiesRule(const TriggeringEntitiesRule triggeringEntitiesRule)
        {
            _triggeringEntitiesRule = triggeringEntitiesRule;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TRIGGERING_ENTITIES_RULE);
        }

        void TriggeringEntitiesImpl::SetEntityRefs(std::vector<std::shared_ptr<IEntityRefWriter>>& entityRefs)
        {
            _entityRefs = entityRefs;
        }

        std::shared_ptr<void> TriggeringEntitiesImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(TriggeringEntitiesImpl).name())
                return shared_from_this();
            else if (classifier == typeid(ITriggeringEntities).name())
                return std::dynamic_pointer_cast<ITriggeringEntities>(shared_from_this());
            else if (classifier == typeid(ITriggeringEntitiesWriter).name())
                return std::dynamic_pointer_cast<ITriggeringEntitiesWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> TriggeringEntitiesImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t TriggeringEntitiesImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int TriggeringEntitiesImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double TriggeringEntitiesImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t TriggeringEntitiesImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool TriggeringEntitiesImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime TriggeringEntitiesImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> TriggeringEntitiesImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string TriggeringEntitiesImpl::GetModelType() const
        {
            return "TriggeringEntities";
        }

        void TriggeringEntitiesImpl::WriteParameterToTriggeringEntitiesRule(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TRIGGERING_ENTITIES_RULE, parameterName, nullTextMarker /*no textmarker*/);
            _triggeringEntitiesRule = {};
        }

        std::string TriggeringEntitiesImpl::GetParameterFromTriggeringEntitiesRule() const
        {
            auto triggeringEntitiesRule = OSC_CONSTANTS::ATTRIBUTE__TRIGGERING_ENTITIES_RULE;
            return GetParameterNameFromAttribute(triggeringEntitiesRule);
        }

        bool TriggeringEntitiesImpl::IsTriggeringEntitiesRuleParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TRIGGERING_ENTITIES_RULE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        TriggeringEntitiesImpl::TriggeringEntitiesImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TRIGGERING_ENTITIES_RULE, SimpleType::ENUM_TYPE);
        }

        void TriggeringEntitiesImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRIGGERING_ENTITIES_RULE)
            {
                // Enumeration Type
                const auto kResult = TriggeringEntitiesRule::GetFromLiteral(parameterLiteralValue);
                if (kResult != TriggeringEntitiesRule::UNKNOWN)
                {
                    _triggeringEntitiesRule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType TriggeringEntitiesImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TriggeringEntitiesImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto entityRefs =  GetWriterEntityRefs();
                if (!entityRefs.empty())
                {
                    for(auto&& item : entityRefs)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TriggeringEntitiesImpl::Clone()
        {
            auto clonedObject = std::make_shared<TriggeringEntitiesImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kTriggeringEntitiesRule = GetTriggeringEntitiesRule();
            if ( kTriggeringEntitiesRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_triggeringEntitiesRule = TriggeringEntitiesRule::GetFromLiteral(kTriggeringEntitiesRule.GetLiteral());
            }
            // clone indicators
            // clone children
            const auto kEntityRefs =  GetWriterEntityRefs();
            if (!kEntityRefs.empty())
            {
                std::vector<std::shared_ptr<IEntityRefWriter>> clonedList;
                for(auto&& kItem : kEntityRefs)
                {
                    auto clonedChild = std::dynamic_pointer_cast<EntityRefImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IEntityRefWriter>(clonedChild));
                }
                clonedObject->SetEntityRefs(clonedList);
            }
            return clonedObject;
        }

        std::string TriggeringEntitiesImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TriggeringEntitiesImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TriggeringEntitiesImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_REF)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetEntityRefs())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TriggeringEntitiesImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TriggeringEntitiesImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__TRIGGERING_ENTITIES_RULE)
            {
                auto triggeringEntitiesRule = GetTriggeringEntitiesRule();
                return triggeringEntitiesRule.GetLiteral() != "UNKNOWN" ? triggeringEntitiesRule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* UniformDistributionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IRange> UniformDistributionImpl::GetRange() const
        {
        	  return _range;
        }


        void UniformDistributionImpl::SetRange(std::shared_ptr<IRangeWriter> range)
        {
            _range = range;
        }

        std::shared_ptr<void> UniformDistributionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(UniformDistributionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IUniformDistribution).name())
                return std::dynamic_pointer_cast<IUniformDistribution>(shared_from_this());
            else if (classifier == typeid(IUniformDistributionWriter).name())
                return std::dynamic_pointer_cast<IUniformDistributionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> UniformDistributionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t UniformDistributionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int UniformDistributionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double UniformDistributionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t UniformDistributionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool UniformDistributionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime UniformDistributionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> UniformDistributionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string UniformDistributionImpl::GetModelType() const
        {
            return "UniformDistribution";
        }

            // children
        std::shared_ptr<IRangeWriter> UniformDistributionImpl::GetWriterRange() const
        {
            return std::dynamic_pointer_cast<IRangeWriter>(_range);
        }

        UniformDistributionImpl::UniformDistributionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void UniformDistributionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType UniformDistributionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> UniformDistributionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRange =  GetWriterRange();
                if (kRange)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRange));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> UniformDistributionImpl::Clone()
        {
            auto clonedObject = std::make_shared<UniformDistributionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kRange =  GetWriterRange();
            if (kRange)
            {
                auto clonedChild = std::dynamic_pointer_cast<RangeImpl>(kRange)->Clone();
                auto clonedChildIRange = std::dynamic_pointer_cast<IRange>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRange(std::dynamic_pointer_cast<IRangeWriter>(clonedChildIRange));
            }
            return clonedObject;
        }

        std::string UniformDistributionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UniformDistributionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RANGE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRange());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> UniformDistributionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UniformDistributionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string UniformDistributionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* UsedAreaImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<IPosition>> UsedAreaImpl::GetPositions() const
        {
            std::vector<std::shared_ptr<IPosition>> temp;
            for(auto&& elm: _positions)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IPositionWriter>> UsedAreaImpl::GetWriterPositions() const
        {
            return _positions;
        }

        int UsedAreaImpl::GetPositionsSize() const
        {
            return static_cast<int>(_positions.size());
        }

        std::shared_ptr<IPosition> UsedAreaImpl::GetPositionsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _positions.size() > index)
            {
                return _positions[index];
            }
            return nullptr;
        }


        void UsedAreaImpl::SetPositions(std::vector<std::shared_ptr<IPositionWriter>>& positions)
        {
            _positions = positions;
        }

        std::shared_ptr<void> UsedAreaImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(UsedAreaImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IUsedArea).name())
                return std::dynamic_pointer_cast<IUsedArea>(shared_from_this());
            else if (classifier == typeid(IUsedAreaWriter).name())
                return std::dynamic_pointer_cast<IUsedAreaWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> UsedAreaImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t UsedAreaImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int UsedAreaImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double UsedAreaImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t UsedAreaImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool UsedAreaImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime UsedAreaImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> UsedAreaImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string UsedAreaImpl::GetModelType() const
        {
            return "UsedArea";
        }

            // children

        UsedAreaImpl::UsedAreaImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void UsedAreaImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType UsedAreaImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> UsedAreaImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto positions =  GetWriterPositions();
                if (!positions.empty())
                {
                    for(auto&& item : positions)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> UsedAreaImpl::Clone()
        {
            auto clonedObject = std::make_shared<UsedAreaImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kPositions =  GetWriterPositions();
            if (!kPositions.empty())
            {
                std::vector<std::shared_ptr<IPositionWriter>> clonedList;
                for(auto&& kItem : kPositions)
                {
                    auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IPositionWriter>(clonedChild));
                }
                clonedObject->SetPositions(clonedList);
            }
            return clonedObject;
        }

        std::string UsedAreaImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UsedAreaImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> UsedAreaImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetPositions())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UsedAreaImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string UsedAreaImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* UserDefinedActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<ICustomCommandAction> UserDefinedActionImpl::GetCustomCommandAction() const
        {
        	  return _customCommandAction;
        }


        void UserDefinedActionImpl::SetCustomCommandAction(std::shared_ptr<ICustomCommandActionWriter> customCommandAction)
        {
            _customCommandAction = customCommandAction;
        }

        std::shared_ptr<void> UserDefinedActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(UserDefinedActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IUserDefinedAction).name())
                return std::dynamic_pointer_cast<IUserDefinedAction>(shared_from_this());
            else if (classifier == typeid(IUserDefinedActionWriter).name())
                return std::dynamic_pointer_cast<IUserDefinedActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> UserDefinedActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t UserDefinedActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int UserDefinedActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double UserDefinedActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t UserDefinedActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool UserDefinedActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime UserDefinedActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> UserDefinedActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string UserDefinedActionImpl::GetModelType() const
        {
            return "UserDefinedAction";
        }

            // children
        std::shared_ptr<ICustomCommandActionWriter> UserDefinedActionImpl::GetWriterCustomCommandAction() const
        {
            return std::dynamic_pointer_cast<ICustomCommandActionWriter>(_customCommandAction);
        }

        UserDefinedActionImpl::UserDefinedActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void UserDefinedActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType UserDefinedActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> UserDefinedActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kCustomCommandAction =  GetWriterCustomCommandAction();
                if (kCustomCommandAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCustomCommandAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> UserDefinedActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<UserDefinedActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kCustomCommandAction =  GetWriterCustomCommandAction();
            if (kCustomCommandAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<CustomCommandActionImpl>(kCustomCommandAction)->Clone();
                auto clonedChildICustomCommandAction = std::dynamic_pointer_cast<ICustomCommandAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCustomCommandAction(std::dynamic_pointer_cast<ICustomCommandActionWriter>(clonedChildICustomCommandAction));
            }
            return clonedObject;
        }

        std::string UserDefinedActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UserDefinedActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CUSTOM_COMMAND_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCustomCommandAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> UserDefinedActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UserDefinedActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string UserDefinedActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* UserDefinedAnimationImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string UserDefinedAnimationImpl::GetUserDefinedAnimationType() const
        {
        	  return _userDefinedAnimationType;
        }


        void UserDefinedAnimationImpl::SetUserDefinedAnimationType(const std::string userDefinedAnimationType)
        {
            _userDefinedAnimationType = userDefinedAnimationType;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_ANIMATION_TYPE);
        }

        std::shared_ptr<void> UserDefinedAnimationImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(UserDefinedAnimationImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IUserDefinedAnimation).name())
                return std::dynamic_pointer_cast<IUserDefinedAnimation>(shared_from_this());
            else if (classifier == typeid(IUserDefinedAnimationWriter).name())
                return std::dynamic_pointer_cast<IUserDefinedAnimationWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> UserDefinedAnimationImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t UserDefinedAnimationImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int UserDefinedAnimationImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double UserDefinedAnimationImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t UserDefinedAnimationImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool UserDefinedAnimationImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime UserDefinedAnimationImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> UserDefinedAnimationImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string UserDefinedAnimationImpl::GetModelType() const
        {
            return "UserDefinedAnimation";
        }

        void UserDefinedAnimationImpl::WriteParameterToUserDefinedAnimationType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_ANIMATION_TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _userDefinedAnimationType = {};
        }

        std::string UserDefinedAnimationImpl::GetParameterFromUserDefinedAnimationType() const
        {
            auto userDefinedAnimationType = OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_ANIMATION_TYPE;
            return GetParameterNameFromAttribute(userDefinedAnimationType);
        }

        bool UserDefinedAnimationImpl::IsUserDefinedAnimationTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_ANIMATION_TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        UserDefinedAnimationImpl::UserDefinedAnimationImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_ANIMATION_TYPE, SimpleType::STRING);
        }

        void UserDefinedAnimationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_ANIMATION_TYPE)
            {
                // Simple type
                _userDefinedAnimationType = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType UserDefinedAnimationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> UserDefinedAnimationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> UserDefinedAnimationImpl::Clone()
        {
            auto clonedObject = std::make_shared<UserDefinedAnimationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_userDefinedAnimationType = GetUserDefinedAnimationType();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string UserDefinedAnimationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_ANIMATION_TYPE)
            {
                return GetUserDefinedAnimationType();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UserDefinedAnimationImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> UserDefinedAnimationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UserDefinedAnimationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string UserDefinedAnimationImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void UserDefinedAnimationImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_ANIMATION_TYPE)
            {
                // Simple type
                _userDefinedAnimationType = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* UserDefinedComponentImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string UserDefinedComponentImpl::GetUserDefinedComponentType() const
        {
        	  return _userDefinedComponentType;
        }


        void UserDefinedComponentImpl::SetUserDefinedComponentType(const std::string userDefinedComponentType)
        {
            _userDefinedComponentType = userDefinedComponentType;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_COMPONENT_TYPE);
        }

        std::shared_ptr<void> UserDefinedComponentImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(UserDefinedComponentImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IUserDefinedComponent).name())
                return std::dynamic_pointer_cast<IUserDefinedComponent>(shared_from_this());
            else if (classifier == typeid(IUserDefinedComponentWriter).name())
                return std::dynamic_pointer_cast<IUserDefinedComponentWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> UserDefinedComponentImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t UserDefinedComponentImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int UserDefinedComponentImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double UserDefinedComponentImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t UserDefinedComponentImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool UserDefinedComponentImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime UserDefinedComponentImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> UserDefinedComponentImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string UserDefinedComponentImpl::GetModelType() const
        {
            return "UserDefinedComponent";
        }

        void UserDefinedComponentImpl::WriteParameterToUserDefinedComponentType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_COMPONENT_TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _userDefinedComponentType = {};
        }

        std::string UserDefinedComponentImpl::GetParameterFromUserDefinedComponentType() const
        {
            auto userDefinedComponentType = OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_COMPONENT_TYPE;
            return GetParameterNameFromAttribute(userDefinedComponentType);
        }

        bool UserDefinedComponentImpl::IsUserDefinedComponentTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_COMPONENT_TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        UserDefinedComponentImpl::UserDefinedComponentImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_COMPONENT_TYPE, SimpleType::STRING);
        }

        void UserDefinedComponentImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_COMPONENT_TYPE)
            {
                // Simple type
                _userDefinedComponentType = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType UserDefinedComponentImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> UserDefinedComponentImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> UserDefinedComponentImpl::Clone()
        {
            auto clonedObject = std::make_shared<UserDefinedComponentImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_userDefinedComponentType = GetUserDefinedComponentType();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string UserDefinedComponentImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_COMPONENT_TYPE)
            {
                return GetUserDefinedComponentType();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UserDefinedComponentImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> UserDefinedComponentImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UserDefinedComponentImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string UserDefinedComponentImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void UserDefinedComponentImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_COMPONENT_TYPE)
            {
                // Simple type
                _userDefinedComponentType = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* UserDefinedDistributionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string UserDefinedDistributionImpl::GetContent() const
        {
        	  return _content;
        }
        std::string UserDefinedDistributionImpl::GetType() const
        {
        	  return _type;
        }


        void UserDefinedDistributionImpl::SetContent(const std::string content)
        {
            _content = content;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONTENT);
        }

        void UserDefinedDistributionImpl::SetType(const std::string type)
        {
            _type = type;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TYPE);
        }

        std::shared_ptr<void> UserDefinedDistributionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(UserDefinedDistributionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IUserDefinedDistribution).name())
                return std::dynamic_pointer_cast<IUserDefinedDistribution>(shared_from_this());
            else if (classifier == typeid(IUserDefinedDistributionWriter).name())
                return std::dynamic_pointer_cast<IUserDefinedDistributionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> UserDefinedDistributionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t UserDefinedDistributionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int UserDefinedDistributionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double UserDefinedDistributionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t UserDefinedDistributionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool UserDefinedDistributionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime UserDefinedDistributionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> UserDefinedDistributionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string UserDefinedDistributionImpl::GetModelType() const
        {
            return "UserDefinedDistribution";
        }

        void UserDefinedDistributionImpl::WriteParameterToContent(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CONTENT, parameterName, nullTextMarker /*no textmarker*/);
            _content = {};
        }

        void UserDefinedDistributionImpl::WriteParameterToType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _type = {};
        }

        std::string UserDefinedDistributionImpl::GetParameterFromContent() const
        {
            auto content = OSC_CONSTANTS::ATTRIBUTE__CONTENT;
            return GetParameterNameFromAttribute(content);
        }

        std::string UserDefinedDistributionImpl::GetParameterFromType() const
        {
            auto type = OSC_CONSTANTS::ATTRIBUTE__TYPE;
            return GetParameterNameFromAttribute(type);
        }

        bool UserDefinedDistributionImpl::IsContentParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CONTENT);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool UserDefinedDistributionImpl::IsTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        UserDefinedDistributionImpl::UserDefinedDistributionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CONTENT, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TYPE, SimpleType::STRING);
        }

        void UserDefinedDistributionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTENT)
            {
                // Simple type
                _content = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TYPE)
            {
                // Simple type
                _type = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType UserDefinedDistributionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> UserDefinedDistributionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> UserDefinedDistributionImpl::Clone()
        {
            auto clonedObject = std::make_shared<UserDefinedDistributionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_type = GetType();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string UserDefinedDistributionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__CONTENT)
            {
                return GetContent();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__TYPE)
            {
                return GetType();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UserDefinedDistributionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> UserDefinedDistributionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UserDefinedDistributionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string UserDefinedDistributionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void UserDefinedDistributionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTENT)
            {
                // Simple type
                _content = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TYPE)
            {
                // Simple type
                _type = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* UserDefinedLightImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string UserDefinedLightImpl::GetUserDefinedLightType() const
        {
        	  return _userDefinedLightType;
        }


        void UserDefinedLightImpl::SetUserDefinedLightType(const std::string userDefinedLightType)
        {
            _userDefinedLightType = userDefinedLightType;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_LIGHT_TYPE);
        }

        std::shared_ptr<void> UserDefinedLightImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(UserDefinedLightImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IUserDefinedLight).name())
                return std::dynamic_pointer_cast<IUserDefinedLight>(shared_from_this());
            else if (classifier == typeid(IUserDefinedLightWriter).name())
                return std::dynamic_pointer_cast<IUserDefinedLightWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> UserDefinedLightImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t UserDefinedLightImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int UserDefinedLightImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double UserDefinedLightImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t UserDefinedLightImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool UserDefinedLightImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime UserDefinedLightImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> UserDefinedLightImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string UserDefinedLightImpl::GetModelType() const
        {
            return "UserDefinedLight";
        }

        void UserDefinedLightImpl::WriteParameterToUserDefinedLightType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_LIGHT_TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _userDefinedLightType = {};
        }

        std::string UserDefinedLightImpl::GetParameterFromUserDefinedLightType() const
        {
            auto userDefinedLightType = OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_LIGHT_TYPE;
            return GetParameterNameFromAttribute(userDefinedLightType);
        }

        bool UserDefinedLightImpl::IsUserDefinedLightTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_LIGHT_TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        UserDefinedLightImpl::UserDefinedLightImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_LIGHT_TYPE, SimpleType::STRING);
        }

        void UserDefinedLightImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_LIGHT_TYPE)
            {
                // Simple type
                _userDefinedLightType = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType UserDefinedLightImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> UserDefinedLightImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> UserDefinedLightImpl::Clone()
        {
            auto clonedObject = std::make_shared<UserDefinedLightImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_userDefinedLightType = GetUserDefinedLightType();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string UserDefinedLightImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_LIGHT_TYPE)
            {
                return GetUserDefinedLightType();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UserDefinedLightImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> UserDefinedLightImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UserDefinedLightImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string UserDefinedLightImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void UserDefinedLightImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__USER_DEFINED_LIGHT_TYPE)
            {
                // Simple type
                _userDefinedLightType = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* UserDefinedValueConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string UserDefinedValueConditionImpl::GetName() const
        {
        	  return _name;
        }
        Rule UserDefinedValueConditionImpl::GetRule() const
        {
        	  return _rule;
        }
        std::string UserDefinedValueConditionImpl::GetValue() const
        {
        	  return _value;
        }


        void UserDefinedValueConditionImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void UserDefinedValueConditionImpl::SetRule(const Rule rule)
        {
            _rule = rule;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE);
        }

        void UserDefinedValueConditionImpl::SetValue(const std::string value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> UserDefinedValueConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(UserDefinedValueConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IUserDefinedValueCondition).name())
                return std::dynamic_pointer_cast<IUserDefinedValueCondition>(shared_from_this());
            else if (classifier == typeid(IUserDefinedValueConditionWriter).name())
                return std::dynamic_pointer_cast<IUserDefinedValueConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> UserDefinedValueConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t UserDefinedValueConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int UserDefinedValueConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double UserDefinedValueConditionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t UserDefinedValueConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool UserDefinedValueConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime UserDefinedValueConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> UserDefinedValueConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string UserDefinedValueConditionImpl::GetModelType() const
        {
            return "UserDefinedValueCondition";
        }

        void UserDefinedValueConditionImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        void UserDefinedValueConditionImpl::WriteParameterToRule(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE, parameterName, nullTextMarker /*no textmarker*/);
            _rule = {};
        }

        void UserDefinedValueConditionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string UserDefinedValueConditionImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        std::string UserDefinedValueConditionImpl::GetParameterFromRule() const
        {
            auto rule = OSC_CONSTANTS::ATTRIBUTE__RULE;
            return GetParameterNameFromAttribute(rule);
        }

        std::string UserDefinedValueConditionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool UserDefinedValueConditionImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool UserDefinedValueConditionImpl::IsRuleParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RULE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool UserDefinedValueConditionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        UserDefinedValueConditionImpl::UserDefinedValueConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
        }

        void UserDefinedValueConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType UserDefinedValueConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> UserDefinedValueConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> UserDefinedValueConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<UserDefinedValueConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string UserDefinedValueConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UserDefinedValueConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> UserDefinedValueConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UserDefinedValueConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string UserDefinedValueConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void UserDefinedValueConditionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* ValueConstraintImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        Rule ValueConstraintImpl::GetRule() const
        {
        	  return _rule;
        }
        std::string ValueConstraintImpl::GetValue() const
        {
        	  return _value;
        }


        void ValueConstraintImpl::SetRule(const Rule rule)
        {
            _rule = rule;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE);
        }

        void ValueConstraintImpl::SetValue(const std::string value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> ValueConstraintImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ValueConstraintImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IValueConstraint).name())
                return std::dynamic_pointer_cast<IValueConstraint>(shared_from_this());
            else if (classifier == typeid(IValueConstraintWriter).name())
                return std::dynamic_pointer_cast<IValueConstraintWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ValueConstraintImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ValueConstraintImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ValueConstraintImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ValueConstraintImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ValueConstraintImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ValueConstraintImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ValueConstraintImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ValueConstraintImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ValueConstraintImpl::GetModelType() const
        {
            return "ValueConstraint";
        }

        void ValueConstraintImpl::WriteParameterToRule(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE, parameterName, nullTextMarker /*no textmarker*/);
            _rule = {};
        }

        void ValueConstraintImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string ValueConstraintImpl::GetParameterFromRule() const
        {
            auto rule = OSC_CONSTANTS::ATTRIBUTE__RULE;
            return GetParameterNameFromAttribute(rule);
        }

        std::string ValueConstraintImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool ValueConstraintImpl::IsRuleParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RULE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool ValueConstraintImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        ValueConstraintImpl::ValueConstraintImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
        }

        void ValueConstraintImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ValueConstraintImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ValueConstraintImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ValueConstraintImpl::Clone()
        {
            auto clonedObject = std::make_shared<ValueConstraintImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string ValueConstraintImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ValueConstraintImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ValueConstraintImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ValueConstraintImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ValueConstraintImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void ValueConstraintImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}

		bool ValueConstraintImpl::IsTypedStringAttribute(std::string& attributeKey)
		{
			return (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE);
		}


        IOpenScenarioFlexElement* ValueConstraintGroupImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<IValueConstraint>> ValueConstraintGroupImpl::GetConstraints() const
        {
            std::vector<std::shared_ptr<IValueConstraint>> temp;
            for(auto&& elm: _constraints)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IValueConstraintWriter>> ValueConstraintGroupImpl::GetWriterConstraints() const
        {
            return _constraints;
        }

        int ValueConstraintGroupImpl::GetConstraintsSize() const
        {
            return static_cast<int>(_constraints.size());
        }

        std::shared_ptr<IValueConstraint> ValueConstraintGroupImpl::GetConstraintsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _constraints.size() > index)
            {
                return _constraints[index];
            }
            return nullptr;
        }


        void ValueConstraintGroupImpl::SetConstraints(std::vector<std::shared_ptr<IValueConstraintWriter>>& constraints)
        {
            _constraints = constraints;
        }

        std::shared_ptr<void> ValueConstraintGroupImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ValueConstraintGroupImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IValueConstraintGroup).name())
                return std::dynamic_pointer_cast<IValueConstraintGroup>(shared_from_this());
            else if (classifier == typeid(IValueConstraintGroupWriter).name())
                return std::dynamic_pointer_cast<IValueConstraintGroupWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ValueConstraintGroupImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ValueConstraintGroupImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ValueConstraintGroupImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ValueConstraintGroupImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ValueConstraintGroupImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ValueConstraintGroupImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ValueConstraintGroupImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ValueConstraintGroupImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ValueConstraintGroupImpl::GetModelType() const
        {
            return "ValueConstraintGroup";
        }

            // children

        ValueConstraintGroupImpl::ValueConstraintGroupImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ValueConstraintGroupImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ValueConstraintGroupImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ValueConstraintGroupImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto constraints =  GetWriterConstraints();
                if (!constraints.empty())
                {
                    for(auto&& item : constraints)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ValueConstraintGroupImpl::Clone()
        {
            auto clonedObject = std::make_shared<ValueConstraintGroupImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kConstraints =  GetWriterConstraints();
            if (!kConstraints.empty())
            {
                std::vector<std::shared_ptr<IValueConstraintWriter>> clonedList;
                for(auto&& kItem : kConstraints)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ValueConstraintImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IValueConstraintWriter>(clonedChild));
                }
                clonedObject->SetConstraints(clonedList);
            }
            return clonedObject;
        }

        std::string ValueConstraintGroupImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ValueConstraintGroupImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ValueConstraintGroupImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__VALUE_CONSTRAINT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetConstraints())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ValueConstraintGroupImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ValueConstraintGroupImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* ValueSetDistributionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<IParameterValueSet>> ValueSetDistributionImpl::GetParameterValueSets() const
        {
            std::vector<std::shared_ptr<IParameterValueSet>> temp;
            for(auto&& elm: _parameterValueSets)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IParameterValueSetWriter>> ValueSetDistributionImpl::GetWriterParameterValueSets() const
        {
            return _parameterValueSets;
        }

        int ValueSetDistributionImpl::GetParameterValueSetsSize() const
        {
            return static_cast<int>(_parameterValueSets.size());
        }

        std::shared_ptr<IParameterValueSet> ValueSetDistributionImpl::GetParameterValueSetsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _parameterValueSets.size() > index)
            {
                return _parameterValueSets[index];
            }
            return nullptr;
        }


        void ValueSetDistributionImpl::SetParameterValueSets(std::vector<std::shared_ptr<IParameterValueSetWriter>>& parameterValueSets)
        {
            _parameterValueSets = parameterValueSets;
        }

        std::shared_ptr<void> ValueSetDistributionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(ValueSetDistributionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IValueSetDistribution).name())
                return std::dynamic_pointer_cast<IValueSetDistribution>(shared_from_this());
            else if (classifier == typeid(IValueSetDistributionWriter).name())
                return std::dynamic_pointer_cast<IValueSetDistributionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> ValueSetDistributionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t ValueSetDistributionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int ValueSetDistributionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double ValueSetDistributionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t ValueSetDistributionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool ValueSetDistributionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime ValueSetDistributionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> ValueSetDistributionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string ValueSetDistributionImpl::GetModelType() const
        {
            return "ValueSetDistribution";
        }

            // children

        ValueSetDistributionImpl::ValueSetDistributionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void ValueSetDistributionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ValueSetDistributionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ValueSetDistributionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterValueSets =  GetWriterParameterValueSets();
                if (!parameterValueSets.empty())
                {
                    for(auto&& item : parameterValueSets)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ValueSetDistributionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ValueSetDistributionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kParameterValueSets =  GetWriterParameterValueSets();
            if (!kParameterValueSets.empty())
            {
                std::vector<std::shared_ptr<IParameterValueSetWriter>> clonedList;
                for(auto&& kItem : kParameterValueSets)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterValueSetImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterValueSetWriter>(clonedChild));
                }
                clonedObject->SetParameterValueSets(clonedList);
            }
            return clonedObject;
        }

        std::string ValueSetDistributionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ValueSetDistributionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ValueSetDistributionImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_VALUE_SET)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterValueSets())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ValueSetDistributionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ValueSetDistributionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* VariableActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<INamedReference<IVariableDeclaration>> VariableActionImpl::GetVariableRef() const
        {
        	 return _variableRef;
        }
        std::shared_ptr<IVariableSetAction> VariableActionImpl::GetSetAction() const
        {
        	  return _setAction;
        }
        std::shared_ptr<IVariableModifyAction> VariableActionImpl::GetModifyAction() const
        {
        	  return _modifyAction;
        }


        void VariableActionImpl::SetVariableRef(std::shared_ptr<INamedReference<IVariableDeclaration>> variableRef)
        {
            _variableRef = variableRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VARIABLE_REF);
        }

        void VariableActionImpl::SetSetAction(std::shared_ptr<IVariableSetActionWriter> setAction)
        {
            _setAction = setAction;
            _modifyAction = {};
			// set the indicator to true
            isSetSetAction = true;          
        }

        void VariableActionImpl::SetModifyAction(std::shared_ptr<IVariableModifyActionWriter> modifyAction)
        {
            _modifyAction = modifyAction;
            _setAction = {};
			// set the indicator to true
            isSetModifyAction = true;          
        }

        std::shared_ptr<void> VariableActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(VariableActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IVariableAction).name())
                return std::dynamic_pointer_cast<IVariableAction>(shared_from_this());
            else if (classifier == typeid(IVariableActionWriter).name())
                return std::dynamic_pointer_cast<IVariableActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> VariableActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t VariableActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int VariableActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double VariableActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t VariableActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool VariableActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime VariableActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> VariableActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string VariableActionImpl::GetModelType() const
        {
            return "VariableAction";
        }

        void VariableActionImpl::WriteParameterToVariableRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VARIABLE_REF, parameterName, nullTextMarker /*no textmarker*/);
            _variableRef = {};
        }

        std::string VariableActionImpl::GetParameterFromVariableRef() const
        {
            auto variableRef = OSC_CONSTANTS::ATTRIBUTE__VARIABLE_REF;
            return GetParameterNameFromAttribute(variableRef);
        }

        bool VariableActionImpl::IsVariableRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VARIABLE_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IVariableSetActionWriter> VariableActionImpl::GetWriterSetAction() const
        {
            return std::dynamic_pointer_cast<IVariableSetActionWriter>(_setAction);
        }
        std::shared_ptr<IVariableModifyActionWriter> VariableActionImpl::GetWriterModifyAction() const
        {
            return std::dynamic_pointer_cast<IVariableModifyActionWriter>(_modifyAction);
        }

        VariableActionImpl::VariableActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VARIABLE_REF, SimpleType::STRING);
        }

        void VariableActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VARIABLE_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IVariableDeclaration>>(parameterLiteralValue);
                _variableRef = std::dynamic_pointer_cast<INamedReference<IVariableDeclaration>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType VariableActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VariableActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kSetAction =  GetWriterSetAction();
                if (kSetAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSetAction));
                }
                const auto kModifyAction =  GetWriterModifyAction();
                if (kModifyAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kModifyAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VariableActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<VariableActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IVariableDeclaration>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IVariableDeclaration>>(GetVariableRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_variableRef = proxy;
            
            // clone indicators
            // clone children
            const auto kSetAction =  GetWriterSetAction();
            if (kSetAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<VariableSetActionImpl>(kSetAction)->Clone();
                auto clonedChildIVariableSetAction = std::dynamic_pointer_cast<IVariableSetAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSetAction(std::dynamic_pointer_cast<IVariableSetActionWriter>(clonedChildIVariableSetAction));
            }
            const auto kModifyAction =  GetWriterModifyAction();
            if (kModifyAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<VariableModifyActionImpl>(kModifyAction)->Clone();
                auto clonedChildIVariableModifyAction = std::dynamic_pointer_cast<IVariableModifyAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetModifyAction(std::dynamic_pointer_cast<IVariableModifyActionWriter>(clonedChildIVariableModifyAction));
            }
            return clonedObject;
        }

        std::string VariableActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__VARIABLE_REF)
            {
                // Get the Proxy
                auto variableRef = GetVariableRef();
                return variableRef!= nullptr ? variableRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VariableActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SET_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSetAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__MODIFY_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetModifyAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VariableActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VariableActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__VARIABLE_REF)
            {
                // Get the Proxy
                auto variableRef = GetVariableRef();
                return variableRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(variableRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string VariableActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void VariableActionImpl::ResetSetAction()
	   {
	   		isSetSetAction = false; 
			_setAction = {};
			
	   }
       bool VariableActionImpl::IsSetSetAction() const
	   {
			return isSetSetAction;
	   }
       void VariableActionImpl::ResetModifyAction()
	   {
	   		isSetModifyAction = false; 
			_modifyAction = {};
			
	   }
       bool VariableActionImpl::IsSetModifyAction() const
	   {
			return isSetModifyAction;
	   }

        IOpenScenarioFlexElement* VariableAddValueRuleImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double VariableAddValueRuleImpl::GetValue() const
        {
        	  return _value;
        }


        void VariableAddValueRuleImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> VariableAddValueRuleImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(VariableAddValueRuleImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IVariableAddValueRule).name())
                return std::dynamic_pointer_cast<IVariableAddValueRule>(shared_from_this());
            else if (classifier == typeid(IVariableAddValueRuleWriter).name())
                return std::dynamic_pointer_cast<IVariableAddValueRuleWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> VariableAddValueRuleImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t VariableAddValueRuleImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int VariableAddValueRuleImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double VariableAddValueRuleImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t VariableAddValueRuleImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool VariableAddValueRuleImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime VariableAddValueRuleImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> VariableAddValueRuleImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string VariableAddValueRuleImpl::GetModelType() const
        {
            return "VariableAddValueRule";
        }

        void VariableAddValueRuleImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string VariableAddValueRuleImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool VariableAddValueRuleImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        VariableAddValueRuleImpl::VariableAddValueRuleImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void VariableAddValueRuleImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType VariableAddValueRuleImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VariableAddValueRuleImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VariableAddValueRuleImpl::Clone()
        {
            auto clonedObject = std::make_shared<VariableAddValueRuleImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string VariableAddValueRuleImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VariableAddValueRuleImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VariableAddValueRuleImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VariableAddValueRuleImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VariableAddValueRuleImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void VariableAddValueRuleImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* VariableConditionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        Rule VariableConditionImpl::GetRule() const
        {
        	  return _rule;
        }
        std::string VariableConditionImpl::GetValue() const
        {
        	  return _value;
        }
        std::shared_ptr<INamedReference<IVariableDeclaration>> VariableConditionImpl::GetVariableRef() const
        {
        	 return _variableRef;
        }


        void VariableConditionImpl::SetRule(const Rule rule)
        {
            _rule = rule;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE);
        }

        void VariableConditionImpl::SetValue(const std::string value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        void VariableConditionImpl::SetVariableRef(std::shared_ptr<INamedReference<IVariableDeclaration>> variableRef)
        {
            _variableRef = variableRef;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VARIABLE_REF);
        }

        std::shared_ptr<void> VariableConditionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(VariableConditionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IVariableCondition).name())
                return std::dynamic_pointer_cast<IVariableCondition>(shared_from_this());
            else if (classifier == typeid(IVariableConditionWriter).name())
                return std::dynamic_pointer_cast<IVariableConditionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> VariableConditionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t VariableConditionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int VariableConditionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double VariableConditionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t VariableConditionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool VariableConditionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime VariableConditionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> VariableConditionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string VariableConditionImpl::GetModelType() const
        {
            return "VariableCondition";
        }

        void VariableConditionImpl::WriteParameterToRule(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__RULE, parameterName, nullTextMarker /*no textmarker*/);
            _rule = {};
        }

        void VariableConditionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        void VariableConditionImpl::WriteParameterToVariableRef(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VARIABLE_REF, parameterName, nullTextMarker /*no textmarker*/);
            _variableRef = {};
        }

        std::string VariableConditionImpl::GetParameterFromRule() const
        {
            auto rule = OSC_CONSTANTS::ATTRIBUTE__RULE;
            return GetParameterNameFromAttribute(rule);
        }

        std::string VariableConditionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        std::string VariableConditionImpl::GetParameterFromVariableRef() const
        {
            auto variableRef = OSC_CONSTANTS::ATTRIBUTE__VARIABLE_REF;
            return GetParameterNameFromAttribute(variableRef);
        }

        bool VariableConditionImpl::IsRuleParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__RULE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool VariableConditionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool VariableConditionImpl::IsVariableRefParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VARIABLE_REF);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        VariableConditionImpl::VariableConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VARIABLE_REF, SimpleType::STRING);
        }

        void VariableConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VARIABLE_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IVariableDeclaration>>(parameterLiteralValue);
                _variableRef = std::dynamic_pointer_cast<INamedReference<IVariableDeclaration>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType VariableConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VariableConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VariableConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<VariableConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IVariableDeclaration>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IVariableDeclaration>>(GetVariableRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_variableRef = proxy;
            
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string VariableConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__VARIABLE_REF)
            {
                // Get the Proxy
                auto variableRef = GetVariableRef();
                return variableRef!= nullptr ? variableRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VariableConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VariableConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VariableConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__VARIABLE_REF)
            {
                // Get the Proxy
                auto variableRef = GetVariableRef();
                return variableRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(variableRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string VariableConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void VariableConditionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* VariableDeclarationImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string VariableDeclarationImpl::GetName() const
        {
        	  return _name;
        }
        std::string VariableDeclarationImpl::GetValue() const
        {
        	  return _value;
        }
        ParameterType VariableDeclarationImpl::GetVariableType() const
        {
        	  return _variableType;
        }


        void VariableDeclarationImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void VariableDeclarationImpl::SetValue(const std::string value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        void VariableDeclarationImpl::SetVariableType(const ParameterType variableType)
        {
            _variableType = variableType;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VARIABLE_TYPE);
        }

        std::shared_ptr<void> VariableDeclarationImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(VariableDeclarationImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IVariableDeclaration).name())
                return std::dynamic_pointer_cast<IVariableDeclaration>(shared_from_this());
            else if (classifier == typeid(IVariableDeclarationWriter).name())
                return std::dynamic_pointer_cast<IVariableDeclarationWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> VariableDeclarationImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t VariableDeclarationImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int VariableDeclarationImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double VariableDeclarationImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t VariableDeclarationImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool VariableDeclarationImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime VariableDeclarationImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> VariableDeclarationImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string VariableDeclarationImpl::GetModelType() const
        {
            return "VariableDeclaration";
        }

        void VariableDeclarationImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        void VariableDeclarationImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        void VariableDeclarationImpl::WriteParameterToVariableType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VARIABLE_TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _variableType = {};
        }

        std::string VariableDeclarationImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        std::string VariableDeclarationImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        std::string VariableDeclarationImpl::GetParameterFromVariableType() const
        {
            auto variableType = OSC_CONSTANTS::ATTRIBUTE__VARIABLE_TYPE;
            return GetParameterNameFromAttribute(variableType);
        }

        bool VariableDeclarationImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool VariableDeclarationImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool VariableDeclarationImpl::IsVariableTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VARIABLE_TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        VariableDeclarationImpl::VariableDeclarationImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VARIABLE_TYPE, SimpleType::ENUM_TYPE);
        }

        void VariableDeclarationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VARIABLE_TYPE)
            {
                // Enumeration Type
                const auto kResult = ParameterType::GetFromLiteral(parameterLiteralValue);
                if (kResult != ParameterType::UNKNOWN)
                {
                    _variableType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType VariableDeclarationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VariableDeclarationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VariableDeclarationImpl::Clone()
        {
            auto clonedObject = std::make_shared<VariableDeclarationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // Simple type
            clonedObject->_value = GetValue();
            // Enumeration Type
            const auto kVariableType = GetVariableType();
            if ( kVariableType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_variableType = ParameterType::GetFromLiteral(kVariableType.GetLiteral());
            }
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string VariableDeclarationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VariableDeclarationImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VariableDeclarationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VariableDeclarationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VariableDeclarationImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__VARIABLE_TYPE)
            {
                auto variableType = GetVariableType();
                return variableType.GetLiteral() != "UNKNOWN" ? variableType.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void VariableDeclarationImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}

		bool VariableDeclarationImpl::IsTypedStringAttribute(std::string& attributeKey)
		{
			return (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE);
		}


        IOpenScenarioFlexElement* VariableModifyActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IVariableModifyRule> VariableModifyActionImpl::GetRule() const
        {
        	  return _rule;
        }


        void VariableModifyActionImpl::SetRule(std::shared_ptr<IVariableModifyRuleWriter> rule)
        {
            _rule = rule;
        }

        std::shared_ptr<void> VariableModifyActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(VariableModifyActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IVariableModifyAction).name())
                return std::dynamic_pointer_cast<IVariableModifyAction>(shared_from_this());
            else if (classifier == typeid(IVariableModifyActionWriter).name())
                return std::dynamic_pointer_cast<IVariableModifyActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> VariableModifyActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t VariableModifyActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int VariableModifyActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double VariableModifyActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t VariableModifyActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool VariableModifyActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime VariableModifyActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> VariableModifyActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string VariableModifyActionImpl::GetModelType() const
        {
            return "VariableModifyAction";
        }

            // children
        std::shared_ptr<IVariableModifyRuleWriter> VariableModifyActionImpl::GetWriterRule() const
        {
            return std::dynamic_pointer_cast<IVariableModifyRuleWriter>(_rule);
        }

        VariableModifyActionImpl::VariableModifyActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void VariableModifyActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType VariableModifyActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VariableModifyActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRule =  GetWriterRule();
                if (kRule)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRule));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VariableModifyActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<VariableModifyActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kRule =  GetWriterRule();
            if (kRule)
            {
                auto clonedChild = std::dynamic_pointer_cast<VariableModifyRuleImpl>(kRule)->Clone();
                auto clonedChildIVariableModifyRule = std::dynamic_pointer_cast<IVariableModifyRule>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRule(std::dynamic_pointer_cast<IVariableModifyRuleWriter>(clonedChildIVariableModifyRule));
            }
            return clonedObject;
        }

        std::string VariableModifyActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VariableModifyActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RULE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRule());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VariableModifyActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VariableModifyActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VariableModifyActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* VariableModifyRuleImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IVariableAddValueRule> VariableModifyRuleImpl::GetAddValue() const
        {
        	  return _addValue;
        }
        std::shared_ptr<IVariableMultiplyByValueRule> VariableModifyRuleImpl::GetMultiplyByValue() const
        {
        	  return _multiplyByValue;
        }


        void VariableModifyRuleImpl::SetAddValue(std::shared_ptr<IVariableAddValueRuleWriter> addValue)
        {
            _addValue = addValue;
            _multiplyByValue = {};
			// set the indicator to true
            isSetAddValue = true;          
        }

        void VariableModifyRuleImpl::SetMultiplyByValue(std::shared_ptr<IVariableMultiplyByValueRuleWriter> multiplyByValue)
        {
            _multiplyByValue = multiplyByValue;
            _addValue = {};
			// set the indicator to true
            isSetMultiplyByValue = true;          
        }

        std::shared_ptr<void> VariableModifyRuleImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(VariableModifyRuleImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IVariableModifyRule).name())
                return std::dynamic_pointer_cast<IVariableModifyRule>(shared_from_this());
            else if (classifier == typeid(IVariableModifyRuleWriter).name())
                return std::dynamic_pointer_cast<IVariableModifyRuleWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> VariableModifyRuleImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t VariableModifyRuleImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int VariableModifyRuleImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double VariableModifyRuleImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t VariableModifyRuleImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool VariableModifyRuleImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime VariableModifyRuleImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> VariableModifyRuleImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string VariableModifyRuleImpl::GetModelType() const
        {
            return "VariableModifyRule";
        }

            // children
        std::shared_ptr<IVariableAddValueRuleWriter> VariableModifyRuleImpl::GetWriterAddValue() const
        {
            return std::dynamic_pointer_cast<IVariableAddValueRuleWriter>(_addValue);
        }
        std::shared_ptr<IVariableMultiplyByValueRuleWriter> VariableModifyRuleImpl::GetWriterMultiplyByValue() const
        {
            return std::dynamic_pointer_cast<IVariableMultiplyByValueRuleWriter>(_multiplyByValue);
        }

        VariableModifyRuleImpl::VariableModifyRuleImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void VariableModifyRuleImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType VariableModifyRuleImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VariableModifyRuleImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kAddValue =  GetWriterAddValue();
                if (kAddValue)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAddValue));
                }
                const auto kMultiplyByValue =  GetWriterMultiplyByValue();
                if (kMultiplyByValue)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kMultiplyByValue));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VariableModifyRuleImpl::Clone()
        {
            auto clonedObject = std::make_shared<VariableModifyRuleImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kAddValue =  GetWriterAddValue();
            if (kAddValue)
            {
                auto clonedChild = std::dynamic_pointer_cast<VariableAddValueRuleImpl>(kAddValue)->Clone();
                auto clonedChildIVariableAddValueRule = std::dynamic_pointer_cast<IVariableAddValueRule>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAddValue(std::dynamic_pointer_cast<IVariableAddValueRuleWriter>(clonedChildIVariableAddValueRule));
            }
            const auto kMultiplyByValue =  GetWriterMultiplyByValue();
            if (kMultiplyByValue)
            {
                auto clonedChild = std::dynamic_pointer_cast<VariableMultiplyByValueRuleImpl>(kMultiplyByValue)->Clone();
                auto clonedChildIVariableMultiplyByValueRule = std::dynamic_pointer_cast<IVariableMultiplyByValueRule>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetMultiplyByValue(std::dynamic_pointer_cast<IVariableMultiplyByValueRuleWriter>(clonedChildIVariableMultiplyByValueRule));
            }
            return clonedObject;
        }

        std::string VariableModifyRuleImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VariableModifyRuleImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ADD_VALUE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAddValue());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__MULTIPLY_BY_VALUE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetMultiplyByValue());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VariableModifyRuleImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VariableModifyRuleImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VariableModifyRuleImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


       void VariableModifyRuleImpl::ResetAddValue()
	   {
	   		isSetAddValue = false; 
			_addValue = {};
			
	   }
       bool VariableModifyRuleImpl::IsSetAddValue() const
	   {
			return isSetAddValue;
	   }
       void VariableModifyRuleImpl::ResetMultiplyByValue()
	   {
	   		isSetMultiplyByValue = false; 
			_multiplyByValue = {};
			
	   }
       bool VariableModifyRuleImpl::IsSetMultiplyByValue() const
	   {
			return isSetMultiplyByValue;
	   }

        IOpenScenarioFlexElement* VariableMultiplyByValueRuleImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double VariableMultiplyByValueRuleImpl::GetValue() const
        {
        	  return _value;
        }


        void VariableMultiplyByValueRuleImpl::SetValue(const double value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> VariableMultiplyByValueRuleImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(VariableMultiplyByValueRuleImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IVariableMultiplyByValueRule).name())
                return std::dynamic_pointer_cast<IVariableMultiplyByValueRule>(shared_from_this());
            else if (classifier == typeid(IVariableMultiplyByValueRuleWriter).name())
                return std::dynamic_pointer_cast<IVariableMultiplyByValueRuleWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> VariableMultiplyByValueRuleImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t VariableMultiplyByValueRuleImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int VariableMultiplyByValueRuleImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double VariableMultiplyByValueRuleImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
                {
                    return GetValue();
                }
                throw KeyNotSupportedException();

        }

        uint16_t VariableMultiplyByValueRuleImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool VariableMultiplyByValueRuleImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime VariableMultiplyByValueRuleImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> VariableMultiplyByValueRuleImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string VariableMultiplyByValueRuleImpl::GetModelType() const
        {
            return "VariableMultiplyByValueRule";
        }

        void VariableMultiplyByValueRuleImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string VariableMultiplyByValueRuleImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool VariableMultiplyByValueRuleImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        VariableMultiplyByValueRuleImpl::VariableMultiplyByValueRuleImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        void VariableMultiplyByValueRuleImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType VariableMultiplyByValueRuleImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VariableMultiplyByValueRuleImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VariableMultiplyByValueRuleImpl::Clone()
        {
            auto clonedObject = std::make_shared<VariableMultiplyByValueRuleImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string VariableMultiplyByValueRuleImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VariableMultiplyByValueRuleImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VariableMultiplyByValueRuleImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VariableMultiplyByValueRuleImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VariableMultiplyByValueRuleImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void VariableMultiplyByValueRuleImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* VariableSetActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::string VariableSetActionImpl::GetValue() const
        {
        	  return _value;
        }


        void VariableSetActionImpl::SetValue(const std::string value)
        {
            _value = value;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE);
        }

        std::shared_ptr<void> VariableSetActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(VariableSetActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IVariableSetAction).name())
                return std::dynamic_pointer_cast<IVariableSetAction>(shared_from_this());
            else if (classifier == typeid(IVariableSetActionWriter).name())
                return std::dynamic_pointer_cast<IVariableSetActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> VariableSetActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t VariableSetActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int VariableSetActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double VariableSetActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t VariableSetActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool VariableSetActionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime VariableSetActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> VariableSetActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string VariableSetActionImpl::GetModelType() const
        {
            return "VariableSetAction";
        }

        void VariableSetActionImpl::WriteParameterToValue(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VALUE, parameterName, nullTextMarker /*no textmarker*/);
            _value = {};
        }

        std::string VariableSetActionImpl::GetParameterFromValue() const
        {
            auto value = OSC_CONSTANTS::ATTRIBUTE__VALUE;
            return GetParameterNameFromAttribute(value);
        }

        bool VariableSetActionImpl::IsValueParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VALUE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        VariableSetActionImpl::VariableSetActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
        }

        void VariableSetActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType VariableSetActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VariableSetActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VariableSetActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<VariableSetActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string VariableSetActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VariableSetActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VariableSetActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VariableSetActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VariableSetActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void VariableSetActionImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* VehicleImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double VehicleImpl::GetMass() const
        {
        	  return _mass;
        }
        std::string VehicleImpl::GetModel3d() const
        {
        	  return _model3d;
        }
        std::string VehicleImpl::GetName() const
        {
        	  return _name;
        }
        Role VehicleImpl::GetRole() const
        {
        	  return _role;
        }
        VehicleCategory VehicleImpl::GetVehicleCategory() const
        {
        	  return _vehicleCategory;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> VehicleImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IParameterDeclarationWriter>> VehicleImpl::GetWriterParameterDeclarations() const
        {
            return _parameterDeclarations;
        }

        int VehicleImpl::GetParameterDeclarationsSize() const
        {
            return static_cast<int>(_parameterDeclarations.size());
        }

        std::shared_ptr<IParameterDeclaration> VehicleImpl::GetParameterDeclarationsAtIndex(unsigned int index) const
        {
            if (index >= 0 && _parameterDeclarations.size() > index)
            {
                return _parameterDeclarations[index];
            }
            return nullptr;
        }
        std::shared_ptr<IBoundingBox> VehicleImpl::GetBoundingBox() const
        {
        	  return _boundingBox;
        }
        std::shared_ptr<IPerformance> VehicleImpl::GetPerformance() const
        {
        	  return _performance;
        }
        std::shared_ptr<IAxles> VehicleImpl::GetAxles() const
        {
        	  return _axles;
        }
        std::shared_ptr<IProperties> VehicleImpl::GetProperties() const
        {
        	  return _properties;
        }


        void VehicleImpl::SetMass(const double mass)
        {
            _mass = mass;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MASS);
			// set the indicator to true
            isSetMass = true;          
        }

        void VehicleImpl::SetModel3d(const std::string model3d)
        {
            _model3d = model3d;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MODEL3D);
			// set the indicator to true
            isSetModel3d = true;          
        }

        void VehicleImpl::SetName(const std::string name)
        {
            _name = name;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME);
        }

        void VehicleImpl::SetRole(const Role role)
        {
            _role = role;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROLE);
			// set the indicator to true
            isSetRole = true;          
        }

        void VehicleImpl::SetVehicleCategory(const VehicleCategory vehicleCategory)
        {
            _vehicleCategory = vehicleCategory;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VEHICLE_CATEGORY);
        }

        void VehicleImpl::SetParameterDeclarations(std::vector<std::shared_ptr<IParameterDeclarationWriter>>& parameterDeclarations)
        {
            _parameterDeclarations = parameterDeclarations;
			// set the indicator to true
            isSetParameterDeclarations = true;          
        }

        void VehicleImpl::SetBoundingBox(std::shared_ptr<IBoundingBoxWriter> boundingBox)
        {
            _boundingBox = boundingBox;
        }

        void VehicleImpl::SetPerformance(std::shared_ptr<IPerformanceWriter> performance)
        {
            _performance = performance;
        }

        void VehicleImpl::SetAxles(std::shared_ptr<IAxlesWriter> axles)
        {
            _axles = axles;
        }

        void VehicleImpl::SetProperties(std::shared_ptr<IPropertiesWriter> properties)
        {
            _properties = properties;
        }

        std::shared_ptr<void> VehicleImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(VehicleImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IVehicle).name())
                return std::dynamic_pointer_cast<IVehicle>(shared_from_this());
            else if (classifier == typeid(IVehicleWriter).name())
                return std::dynamic_pointer_cast<IVehicleWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> VehicleImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t VehicleImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int VehicleImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double VehicleImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__MASS)
                {
                    return GetMass();
                }
                throw KeyNotSupportedException();

        }

        uint16_t VehicleImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool VehicleImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime VehicleImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> VehicleImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string VehicleImpl::GetModelType() const
        {
            return "Vehicle";
        }

        void VehicleImpl::WriteParameterToMass(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MASS, parameterName, nullTextMarker /*no textmarker*/);
            _mass = {};
        }

        void VehicleImpl::WriteParameterToModel3d(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__MODEL3D, parameterName, nullTextMarker /*no textmarker*/);
            _model3d = {};
        }

        void VehicleImpl::WriteParameterToName(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__NAME, parameterName, nullTextMarker /*no textmarker*/);
            _name = {};
        }

        void VehicleImpl::WriteParameterToRole(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROLE, parameterName, nullTextMarker /*no textmarker*/);
            _role = {};
        }

        void VehicleImpl::WriteParameterToVehicleCategory(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VEHICLE_CATEGORY, parameterName, nullTextMarker /*no textmarker*/);
            _vehicleCategory = {};
        }

        std::string VehicleImpl::GetParameterFromMass() const
        {
            auto mass = OSC_CONSTANTS::ATTRIBUTE__MASS;
            return GetParameterNameFromAttribute(mass);
        }

        std::string VehicleImpl::GetParameterFromModel3d() const
        {
            auto model3d = OSC_CONSTANTS::ATTRIBUTE__MODEL3D;
            return GetParameterNameFromAttribute(model3d);
        }

        std::string VehicleImpl::GetParameterFromName() const
        {
            auto name = OSC_CONSTANTS::ATTRIBUTE__NAME;
            return GetParameterNameFromAttribute(name);
        }

        std::string VehicleImpl::GetParameterFromRole() const
        {
            auto role = OSC_CONSTANTS::ATTRIBUTE__ROLE;
            return GetParameterNameFromAttribute(role);
        }

        std::string VehicleImpl::GetParameterFromVehicleCategory() const
        {
            auto vehicleCategory = OSC_CONSTANTS::ATTRIBUTE__VEHICLE_CATEGORY;
            return GetParameterNameFromAttribute(vehicleCategory);
        }

        bool VehicleImpl::IsMassParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MASS);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool VehicleImpl::IsModel3dParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__MODEL3D);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool VehicleImpl::IsNameParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__NAME);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool VehicleImpl::IsRoleParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ROLE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool VehicleImpl::IsVehicleCategoryParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VEHICLE_CATEGORY);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IBoundingBoxWriter> VehicleImpl::GetWriterBoundingBox() const
        {
            return std::dynamic_pointer_cast<IBoundingBoxWriter>(_boundingBox);
        }
        std::shared_ptr<IPerformanceWriter> VehicleImpl::GetWriterPerformance() const
        {
            return std::dynamic_pointer_cast<IPerformanceWriter>(_performance);
        }
        std::shared_ptr<IAxlesWriter> VehicleImpl::GetWriterAxles() const
        {
            return std::dynamic_pointer_cast<IAxlesWriter>(_axles);
        }
        std::shared_ptr<IPropertiesWriter> VehicleImpl::GetWriterProperties() const
        {
            return std::dynamic_pointer_cast<IPropertiesWriter>(_properties);
        }

        VehicleImpl::VehicleImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MASS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MODEL3D, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ROLE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VEHICLE_CATEGORY, SimpleType::ENUM_TYPE);
        }

        void VehicleImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MASS)
            {
                // Simple type
                _mass = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MODEL3D)
            {
                // Simple type
                _model3d = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ROLE)
            {
                // Enumeration Type
                const auto kResult = Role::GetFromLiteral(parameterLiteralValue);
                if (kResult != Role::UNKNOWN)
                {
                    _role = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VEHICLE_CATEGORY)
            {
                // Enumeration Type
                const auto kResult = VehicleCategory::GetFromLiteral(parameterLiteralValue);
                if (kResult != VehicleCategory::UNKNOWN)
                {
                    _vehicleCategory = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType VehicleImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool VehicleImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> VehicleImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VehicleImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kBoundingBox =  GetWriterBoundingBox();
                if (kBoundingBox)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kBoundingBox));
                }
                const auto kPerformance =  GetWriterPerformance();
                if (kPerformance)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPerformance));
                }
                const auto kAxles =  GetWriterAxles();
                if (kAxles)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAxles));
                }
                const auto kProperties =  GetWriterProperties();
                if (kProperties)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kProperties));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VehicleImpl::Clone()
        {
            auto clonedObject = std::make_shared<VehicleImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_mass = GetMass();
            // Simple type
            clonedObject->_model3d = GetModel3d();
            // Simple type
            clonedObject->_name = GetName();
            // Enumeration Type
            const auto kRole = GetRole();
            if ( kRole.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_role = Role::GetFromLiteral(kRole.GetLiteral());
            }
            // Enumeration Type
            const auto kVehicleCategory = GetVehicleCategory();
            if ( kVehicleCategory.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_vehicleCategory = VehicleCategory::GetFromLiteral(kVehicleCategory.GetLiteral());
            }
            // clone indicators
            	clonedObject->isSetMass = isSetMass;
            	clonedObject->isSetModel3d = isSetModel3d;
            	clonedObject->isSetRole = isSetRole;
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kBoundingBox =  GetWriterBoundingBox();
            if (kBoundingBox)
            {
                auto clonedChild = std::dynamic_pointer_cast<BoundingBoxImpl>(kBoundingBox)->Clone();
                auto clonedChildIBoundingBox = std::dynamic_pointer_cast<IBoundingBox>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetBoundingBox(std::dynamic_pointer_cast<IBoundingBoxWriter>(clonedChildIBoundingBox));
            }
            const auto kPerformance =  GetWriterPerformance();
            if (kPerformance)
            {
                auto clonedChild = std::dynamic_pointer_cast<PerformanceImpl>(kPerformance)->Clone();
                auto clonedChildIPerformance = std::dynamic_pointer_cast<IPerformance>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPerformance(std::dynamic_pointer_cast<IPerformanceWriter>(clonedChildIPerformance));
            }
            const auto kAxles =  GetWriterAxles();
            if (kAxles)
            {
                auto clonedChild = std::dynamic_pointer_cast<AxlesImpl>(kAxles)->Clone();
                auto clonedChildIAxles = std::dynamic_pointer_cast<IAxles>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAxles(std::dynamic_pointer_cast<IAxlesWriter>(clonedChildIAxles));
            }
            const auto kProperties =  GetWriterProperties();
            if (kProperties)
            {
                auto clonedChild = std::dynamic_pointer_cast<PropertiesImpl>(kProperties)->Clone();
                auto clonedChildIProperties = std::dynamic_pointer_cast<IProperties>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetProperties(std::dynamic_pointer_cast<IPropertiesWriter>(clonedChildIProperties));
            }
            return clonedObject;
        }

        std::string VehicleImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__MODEL3D)
            {
                return GetModel3d();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BOUNDING_BOX)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetBoundingBox());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PERFORMANCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPerformance());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__AXLES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAxles());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PROPERTIES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetProperties());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VehicleImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VehicleImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ROLE)
            {
                auto role = GetRole();
                return role.GetLiteral() != "UNKNOWN" ? role.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__VEHICLE_CATEGORY)
            {
                auto vehicleCategory = GetVehicleCategory();
                return vehicleCategory.GetLiteral() != "UNKNOWN" ? vehicleCategory.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void VehicleImpl::ResolveStringExpression(std::string& attributeKey, std::string& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MODEL3D)
            {
                // Simple type
                _model3d = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = value;
                AddResolvedParameter(attributeKey);
            }
		
		}
		void VehicleImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MASS)
            {
                // Simple type
                _mass = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void VehicleImpl::ResetMass()
	   {
	   		isSetMass = false; 
			_mass = {};
			
	   }
       bool VehicleImpl::IsSetMass() const
	   {
			return isSetMass;
	   }
       void VehicleImpl::ResetModel3d()
	   {
	   		isSetModel3d = false; 
			_model3d = {};
			
	   }
       bool VehicleImpl::IsSetModel3d() const
	   {
			return isSetModel3d;
	   }
       void VehicleImpl::ResetRole()
	   {
	   		isSetRole = false; 
			_role = {Role::RoleEnum::NONE};
			
	   }
       bool VehicleImpl::IsSetRole() const
	   {
			return isSetRole;
	   }
       void VehicleImpl::ResetParameterDeclarations()
	   {
	   		isSetParameterDeclarations = false; 
			_parameterDeclarations = {};
			
	   }
       bool VehicleImpl::IsSetParameterDeclarations() const
	   {
			return isSetParameterDeclarations;
	   }

        IOpenScenarioFlexElement* VehicleCatalogLocationImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::shared_ptr<IDirectory> VehicleCatalogLocationImpl::GetDirectory() const
        {
        	  return _directory;
        }


        void VehicleCatalogLocationImpl::SetDirectory(std::shared_ptr<IDirectoryWriter> directory)
        {
            _directory = directory;
        }

        std::shared_ptr<void> VehicleCatalogLocationImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(VehicleCatalogLocationImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IVehicleCatalogLocation).name())
                return std::dynamic_pointer_cast<IVehicleCatalogLocation>(shared_from_this());
            else if (classifier == typeid(IVehicleCatalogLocationWriter).name())
                return std::dynamic_pointer_cast<IVehicleCatalogLocationWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> VehicleCatalogLocationImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t VehicleCatalogLocationImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int VehicleCatalogLocationImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double VehicleCatalogLocationImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t VehicleCatalogLocationImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool VehicleCatalogLocationImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime VehicleCatalogLocationImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> VehicleCatalogLocationImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string VehicleCatalogLocationImpl::GetModelType() const
        {
            return "VehicleCatalogLocation";
        }

            // children
        std::shared_ptr<IDirectoryWriter> VehicleCatalogLocationImpl::GetWriterDirectory() const
        {
            return std::dynamic_pointer_cast<IDirectoryWriter>(_directory);
        }

        VehicleCatalogLocationImpl::VehicleCatalogLocationImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void VehicleCatalogLocationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType VehicleCatalogLocationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VehicleCatalogLocationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDirectory =  GetWriterDirectory();
                if (kDirectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDirectory));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VehicleCatalogLocationImpl::Clone()
        {
            auto clonedObject = std::make_shared<VehicleCatalogLocationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kDirectory =  GetWriterDirectory();
            if (kDirectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<DirectoryImpl>(kDirectory)->Clone();
                auto clonedChildIDirectory = std::dynamic_pointer_cast<IDirectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDirectory(std::dynamic_pointer_cast<IDirectoryWriter>(clonedChildIDirectory));
            }
            return clonedObject;
        }

        std::string VehicleCatalogLocationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleCatalogLocationImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIRECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDirectory());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VehicleCatalogLocationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleCatalogLocationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VehicleCatalogLocationImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* VehicleCategoryDistributionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<IVehicleCategoryDistributionEntry>> VehicleCategoryDistributionImpl::GetVehicleCategoryDistributionEntries() const
        {
            std::vector<std::shared_ptr<IVehicleCategoryDistributionEntry>> temp;
            for(auto&& elm: _vehicleCategoryDistributionEntries)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IVehicleCategoryDistributionEntryWriter>> VehicleCategoryDistributionImpl::GetWriterVehicleCategoryDistributionEntries() const
        {
            return _vehicleCategoryDistributionEntries;
        }

        int VehicleCategoryDistributionImpl::GetVehicleCategoryDistributionEntriesSize() const
        {
            return static_cast<int>(_vehicleCategoryDistributionEntries.size());
        }

        std::shared_ptr<IVehicleCategoryDistributionEntry> VehicleCategoryDistributionImpl::GetVehicleCategoryDistributionEntriesAtIndex(unsigned int index) const
        {
            if (index >= 0 && _vehicleCategoryDistributionEntries.size() > index)
            {
                return _vehicleCategoryDistributionEntries[index];
            }
            return nullptr;
        }


        void VehicleCategoryDistributionImpl::SetVehicleCategoryDistributionEntries(std::vector<std::shared_ptr<IVehicleCategoryDistributionEntryWriter>>& vehicleCategoryDistributionEntries)
        {
            _vehicleCategoryDistributionEntries = vehicleCategoryDistributionEntries;
        }

        std::shared_ptr<void> VehicleCategoryDistributionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(VehicleCategoryDistributionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IVehicleCategoryDistribution).name())
                return std::dynamic_pointer_cast<IVehicleCategoryDistribution>(shared_from_this());
            else if (classifier == typeid(IVehicleCategoryDistributionWriter).name())
                return std::dynamic_pointer_cast<IVehicleCategoryDistributionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> VehicleCategoryDistributionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t VehicleCategoryDistributionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int VehicleCategoryDistributionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double VehicleCategoryDistributionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t VehicleCategoryDistributionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool VehicleCategoryDistributionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime VehicleCategoryDistributionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> VehicleCategoryDistributionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string VehicleCategoryDistributionImpl::GetModelType() const
        {
            return "VehicleCategoryDistribution";
        }

            // children

        VehicleCategoryDistributionImpl::VehicleCategoryDistributionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void VehicleCategoryDistributionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType VehicleCategoryDistributionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VehicleCategoryDistributionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto vehicleCategoryDistributionEntries =  GetWriterVehicleCategoryDistributionEntries();
                if (!vehicleCategoryDistributionEntries.empty())
                {
                    for(auto&& item : vehicleCategoryDistributionEntries)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VehicleCategoryDistributionImpl::Clone()
        {
            auto clonedObject = std::make_shared<VehicleCategoryDistributionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kVehicleCategoryDistributionEntries =  GetWriterVehicleCategoryDistributionEntries();
            if (!kVehicleCategoryDistributionEntries.empty())
            {
                std::vector<std::shared_ptr<IVehicleCategoryDistributionEntryWriter>> clonedList;
                for(auto&& kItem : kVehicleCategoryDistributionEntries)
                {
                    auto clonedChild = std::dynamic_pointer_cast<VehicleCategoryDistributionEntryImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IVehicleCategoryDistributionEntryWriter>(clonedChild));
                }
                clonedObject->SetVehicleCategoryDistributionEntries(clonedList);
            }
            return clonedObject;
        }

        std::string VehicleCategoryDistributionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleCategoryDistributionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VehicleCategoryDistributionImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__VEHICLE_CATEGORY_DISTRIBUTION_ENTRY)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetVehicleCategoryDistributionEntries())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleCategoryDistributionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VehicleCategoryDistributionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* VehicleCategoryDistributionEntryImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        VehicleCategory VehicleCategoryDistributionEntryImpl::GetCategory() const
        {
        	  return _category;
        }
        double VehicleCategoryDistributionEntryImpl::GetWeight() const
        {
        	  return _weight;
        }


        void VehicleCategoryDistributionEntryImpl::SetCategory(const VehicleCategory category)
        {
            _category = category;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CATEGORY);
        }

        void VehicleCategoryDistributionEntryImpl::SetWeight(const double weight)
        {
            _weight = weight;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__WEIGHT);
        }

        std::shared_ptr<void> VehicleCategoryDistributionEntryImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(VehicleCategoryDistributionEntryImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IVehicleCategoryDistributionEntry).name())
                return std::dynamic_pointer_cast<IVehicleCategoryDistributionEntry>(shared_from_this());
            else if (classifier == typeid(IVehicleCategoryDistributionEntryWriter).name())
                return std::dynamic_pointer_cast<IVehicleCategoryDistributionEntryWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> VehicleCategoryDistributionEntryImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t VehicleCategoryDistributionEntryImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int VehicleCategoryDistributionEntryImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double VehicleCategoryDistributionEntryImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
                {
                    return GetWeight();
                }
                throw KeyNotSupportedException();

        }

        uint16_t VehicleCategoryDistributionEntryImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool VehicleCategoryDistributionEntryImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime VehicleCategoryDistributionEntryImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> VehicleCategoryDistributionEntryImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string VehicleCategoryDistributionEntryImpl::GetModelType() const
        {
            return "VehicleCategoryDistributionEntry";
        }

        void VehicleCategoryDistributionEntryImpl::WriteParameterToCategory(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CATEGORY, parameterName, nullTextMarker /*no textmarker*/);
            _category = {};
        }

        void VehicleCategoryDistributionEntryImpl::WriteParameterToWeight(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__WEIGHT, parameterName, nullTextMarker /*no textmarker*/);
            _weight = {};
        }

        std::string VehicleCategoryDistributionEntryImpl::GetParameterFromCategory() const
        {
            auto category = OSC_CONSTANTS::ATTRIBUTE__CATEGORY;
            return GetParameterNameFromAttribute(category);
        }

        std::string VehicleCategoryDistributionEntryImpl::GetParameterFromWeight() const
        {
            auto weight = OSC_CONSTANTS::ATTRIBUTE__WEIGHT;
            return GetParameterNameFromAttribute(weight);
        }

        bool VehicleCategoryDistributionEntryImpl::IsCategoryParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CATEGORY);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool VehicleCategoryDistributionEntryImpl::IsWeightParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__WEIGHT);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        VehicleCategoryDistributionEntryImpl::VehicleCategoryDistributionEntryImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CATEGORY, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__WEIGHT, SimpleType::DOUBLE);
        }

        void VehicleCategoryDistributionEntryImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CATEGORY)
            {
                // Enumeration Type
                const auto kResult = VehicleCategory::GetFromLiteral(parameterLiteralValue);
                if (kResult != VehicleCategory::UNKNOWN)
                {
                    _category = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
            {
                // Simple type
                _weight = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType VehicleCategoryDistributionEntryImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VehicleCategoryDistributionEntryImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VehicleCategoryDistributionEntryImpl::Clone()
        {
            auto clonedObject = std::make_shared<VehicleCategoryDistributionEntryImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kCategory = GetCategory();
            if ( kCategory.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_category = VehicleCategory::GetFromLiteral(kCategory.GetLiteral());
            }
            // Simple type
            clonedObject->_weight = GetWeight();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string VehicleCategoryDistributionEntryImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleCategoryDistributionEntryImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VehicleCategoryDistributionEntryImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleCategoryDistributionEntryImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VehicleCategoryDistributionEntryImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__CATEGORY)
            {
                auto category = GetCategory();
                return category.GetLiteral() != "UNKNOWN" ? category.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void VehicleCategoryDistributionEntryImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
            {
                // Simple type
                _weight = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* VehicleComponentImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        VehicleComponentType VehicleComponentImpl::GetVehicleComponentType() const
        {
        	  return _vehicleComponentType;
        }


        void VehicleComponentImpl::SetVehicleComponentType(const VehicleComponentType vehicleComponentType)
        {
            _vehicleComponentType = vehicleComponentType;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VEHICLE_COMPONENT_TYPE);
        }

        std::shared_ptr<void> VehicleComponentImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(VehicleComponentImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IVehicleComponent).name())
                return std::dynamic_pointer_cast<IVehicleComponent>(shared_from_this());
            else if (classifier == typeid(IVehicleComponentWriter).name())
                return std::dynamic_pointer_cast<IVehicleComponentWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> VehicleComponentImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t VehicleComponentImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int VehicleComponentImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double VehicleComponentImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t VehicleComponentImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool VehicleComponentImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime VehicleComponentImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> VehicleComponentImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string VehicleComponentImpl::GetModelType() const
        {
            return "VehicleComponent";
        }

        void VehicleComponentImpl::WriteParameterToVehicleComponentType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VEHICLE_COMPONENT_TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _vehicleComponentType = {};
        }

        std::string VehicleComponentImpl::GetParameterFromVehicleComponentType() const
        {
            auto vehicleComponentType = OSC_CONSTANTS::ATTRIBUTE__VEHICLE_COMPONENT_TYPE;
            return GetParameterNameFromAttribute(vehicleComponentType);
        }

        bool VehicleComponentImpl::IsVehicleComponentTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VEHICLE_COMPONENT_TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        VehicleComponentImpl::VehicleComponentImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VEHICLE_COMPONENT_TYPE, SimpleType::ENUM_TYPE);
        }

        void VehicleComponentImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VEHICLE_COMPONENT_TYPE)
            {
                // Enumeration Type
                const auto kResult = VehicleComponentType::GetFromLiteral(parameterLiteralValue);
                if (kResult != VehicleComponentType::UNKNOWN)
                {
                    _vehicleComponentType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType VehicleComponentImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VehicleComponentImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VehicleComponentImpl::Clone()
        {
            auto clonedObject = std::make_shared<VehicleComponentImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kVehicleComponentType = GetVehicleComponentType();
            if ( kVehicleComponentType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_vehicleComponentType = VehicleComponentType::GetFromLiteral(kVehicleComponentType.GetLiteral());
            }
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string VehicleComponentImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleComponentImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VehicleComponentImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleComponentImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VehicleComponentImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__VEHICLE_COMPONENT_TYPE)
            {
                auto vehicleComponentType = GetVehicleComponentType();
                return vehicleComponentType.GetLiteral() != "UNKNOWN" ? vehicleComponentType.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* VehicleLightImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        VehicleLightType VehicleLightImpl::GetVehicleLightType() const
        {
        	  return _vehicleLightType;
        }


        void VehicleLightImpl::SetVehicleLightType(const VehicleLightType vehicleLightType)
        {
            _vehicleLightType = vehicleLightType;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VEHICLE_LIGHT_TYPE);
        }

        std::shared_ptr<void> VehicleLightImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(VehicleLightImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IVehicleLight).name())
                return std::dynamic_pointer_cast<IVehicleLight>(shared_from_this());
            else if (classifier == typeid(IVehicleLightWriter).name())
                return std::dynamic_pointer_cast<IVehicleLightWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> VehicleLightImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t VehicleLightImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int VehicleLightImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double VehicleLightImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t VehicleLightImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool VehicleLightImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime VehicleLightImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> VehicleLightImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string VehicleLightImpl::GetModelType() const
        {
            return "VehicleLight";
        }

        void VehicleLightImpl::WriteParameterToVehicleLightType(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__VEHICLE_LIGHT_TYPE, parameterName, nullTextMarker /*no textmarker*/);
            _vehicleLightType = {};
        }

        std::string VehicleLightImpl::GetParameterFromVehicleLightType() const
        {
            auto vehicleLightType = OSC_CONSTANTS::ATTRIBUTE__VEHICLE_LIGHT_TYPE;
            return GetParameterNameFromAttribute(vehicleLightType);
        }

        bool VehicleLightImpl::IsVehicleLightTypeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__VEHICLE_LIGHT_TYPE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        VehicleLightImpl::VehicleLightImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VEHICLE_LIGHT_TYPE, SimpleType::ENUM_TYPE);
        }

        void VehicleLightImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VEHICLE_LIGHT_TYPE)
            {
                // Enumeration Type
                const auto kResult = VehicleLightType::GetFromLiteral(parameterLiteralValue);
                if (kResult != VehicleLightType::UNKNOWN)
                {
                    _vehicleLightType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType VehicleLightImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VehicleLightImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VehicleLightImpl::Clone()
        {
            auto clonedObject = std::make_shared<VehicleLightImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kVehicleLightType = GetVehicleLightType();
            if ( kVehicleLightType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_vehicleLightType = VehicleLightType::GetFromLiteral(kVehicleLightType.GetLiteral());
            }
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string VehicleLightImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleLightImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VehicleLightImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleLightImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VehicleLightImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__VEHICLE_LIGHT_TYPE)
            {
                auto vehicleLightType = GetVehicleLightType();
                return vehicleLightType.GetLiteral() != "UNKNOWN" ? vehicleLightType.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* VehicleRoleDistributionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        std::vector<std::shared_ptr<IVehicleRoleDistributionEntry>> VehicleRoleDistributionImpl::GetVehicleRoleDistributionEntries() const
        {
            std::vector<std::shared_ptr<IVehicleRoleDistributionEntry>> temp;
            for(auto&& elm: _vehicleRoleDistributionEntries)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IVehicleRoleDistributionEntryWriter>> VehicleRoleDistributionImpl::GetWriterVehicleRoleDistributionEntries() const
        {
            return _vehicleRoleDistributionEntries;
        }

        int VehicleRoleDistributionImpl::GetVehicleRoleDistributionEntriesSize() const
        {
            return static_cast<int>(_vehicleRoleDistributionEntries.size());
        }

        std::shared_ptr<IVehicleRoleDistributionEntry> VehicleRoleDistributionImpl::GetVehicleRoleDistributionEntriesAtIndex(unsigned int index) const
        {
            if (index >= 0 && _vehicleRoleDistributionEntries.size() > index)
            {
                return _vehicleRoleDistributionEntries[index];
            }
            return nullptr;
        }


        void VehicleRoleDistributionImpl::SetVehicleRoleDistributionEntries(std::vector<std::shared_ptr<IVehicleRoleDistributionEntryWriter>>& vehicleRoleDistributionEntries)
        {
            _vehicleRoleDistributionEntries = vehicleRoleDistributionEntries;
        }

        std::shared_ptr<void> VehicleRoleDistributionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(VehicleRoleDistributionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IVehicleRoleDistribution).name())
                return std::dynamic_pointer_cast<IVehicleRoleDistribution>(shared_from_this());
            else if (classifier == typeid(IVehicleRoleDistributionWriter).name())
                return std::dynamic_pointer_cast<IVehicleRoleDistributionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> VehicleRoleDistributionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t VehicleRoleDistributionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int VehicleRoleDistributionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double VehicleRoleDistributionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t VehicleRoleDistributionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool VehicleRoleDistributionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime VehicleRoleDistributionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> VehicleRoleDistributionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string VehicleRoleDistributionImpl::GetModelType() const
        {
            return "VehicleRoleDistribution";
        }

            // children

        VehicleRoleDistributionImpl::VehicleRoleDistributionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        void VehicleRoleDistributionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType VehicleRoleDistributionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VehicleRoleDistributionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto vehicleRoleDistributionEntries =  GetWriterVehicleRoleDistributionEntries();
                if (!vehicleRoleDistributionEntries.empty())
                {
                    for(auto&& item : vehicleRoleDistributionEntries)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VehicleRoleDistributionImpl::Clone()
        {
            auto clonedObject = std::make_shared<VehicleRoleDistributionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // clone indicators
            // clone children
            const auto kVehicleRoleDistributionEntries =  GetWriterVehicleRoleDistributionEntries();
            if (!kVehicleRoleDistributionEntries.empty())
            {
                std::vector<std::shared_ptr<IVehicleRoleDistributionEntryWriter>> clonedList;
                for(auto&& kItem : kVehicleRoleDistributionEntries)
                {
                    auto clonedChild = std::dynamic_pointer_cast<VehicleRoleDistributionEntryImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IVehicleRoleDistributionEntryWriter>(clonedChild));
                }
                clonedObject->SetVehicleRoleDistributionEntries(clonedList);
            }
            return clonedObject;
        }

        std::string VehicleRoleDistributionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleRoleDistributionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VehicleRoleDistributionImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__VEHICLE_ROLE_DISTRIBUTION_ENTRY)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetVehicleRoleDistributionEntries())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleRoleDistributionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VehicleRoleDistributionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* VehicleRoleDistributionEntryImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        Role VehicleRoleDistributionEntryImpl::GetRole() const
        {
        	  return _role;
        }
        double VehicleRoleDistributionEntryImpl::GetWeight() const
        {
        	  return _weight;
        }


        void VehicleRoleDistributionEntryImpl::SetRole(const Role role)
        {
            _role = role;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROLE);
        }

        void VehicleRoleDistributionEntryImpl::SetWeight(const double weight)
        {
            _weight = weight;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__WEIGHT);
        }

        std::shared_ptr<void> VehicleRoleDistributionEntryImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(VehicleRoleDistributionEntryImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IVehicleRoleDistributionEntry).name())
                return std::dynamic_pointer_cast<IVehicleRoleDistributionEntry>(shared_from_this());
            else if (classifier == typeid(IVehicleRoleDistributionEntryWriter).name())
                return std::dynamic_pointer_cast<IVehicleRoleDistributionEntryWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> VehicleRoleDistributionEntryImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t VehicleRoleDistributionEntryImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int VehicleRoleDistributionEntryImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double VehicleRoleDistributionEntryImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
                {
                    return GetWeight();
                }
                throw KeyNotSupportedException();

        }

        uint16_t VehicleRoleDistributionEntryImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool VehicleRoleDistributionEntryImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime VehicleRoleDistributionEntryImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> VehicleRoleDistributionEntryImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string VehicleRoleDistributionEntryImpl::GetModelType() const
        {
            return "VehicleRoleDistributionEntry";
        }

        void VehicleRoleDistributionEntryImpl::WriteParameterToRole(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROLE, parameterName, nullTextMarker /*no textmarker*/);
            _role = {};
        }

        void VehicleRoleDistributionEntryImpl::WriteParameterToWeight(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__WEIGHT, parameterName, nullTextMarker /*no textmarker*/);
            _weight = {};
        }

        std::string VehicleRoleDistributionEntryImpl::GetParameterFromRole() const
        {
            auto role = OSC_CONSTANTS::ATTRIBUTE__ROLE;
            return GetParameterNameFromAttribute(role);
        }

        std::string VehicleRoleDistributionEntryImpl::GetParameterFromWeight() const
        {
            auto weight = OSC_CONSTANTS::ATTRIBUTE__WEIGHT;
            return GetParameterNameFromAttribute(weight);
        }

        bool VehicleRoleDistributionEntryImpl::IsRoleParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ROLE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool VehicleRoleDistributionEntryImpl::IsWeightParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__WEIGHT);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        VehicleRoleDistributionEntryImpl::VehicleRoleDistributionEntryImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ROLE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__WEIGHT, SimpleType::DOUBLE);
        }

        void VehicleRoleDistributionEntryImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ROLE)
            {
                // Enumeration Type
                const auto kResult = Role::GetFromLiteral(parameterLiteralValue);
                if (kResult != Role::UNKNOWN)
                {
                    _role = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
            {
                // Simple type
                _weight = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType VehicleRoleDistributionEntryImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VehicleRoleDistributionEntryImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VehicleRoleDistributionEntryImpl::Clone()
        {
            auto clonedObject = std::make_shared<VehicleRoleDistributionEntryImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kRole = GetRole();
            if ( kRole.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_role = Role::GetFromLiteral(kRole.GetLiteral());
            }
            // Simple type
            clonedObject->_weight = GetWeight();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string VehicleRoleDistributionEntryImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleRoleDistributionEntryImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VehicleRoleDistributionEntryImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleRoleDistributionEntryImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VehicleRoleDistributionEntryImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ROLE)
            {
                auto role = GetRole();
                return role.GetLiteral() != "UNKNOWN" ? role.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void VehicleRoleDistributionEntryImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
            {
                // Simple type
                _weight = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* VertexImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double VertexImpl::GetTime() const
        {
        	  return _time;
        }
        std::shared_ptr<IPosition> VertexImpl::GetPosition() const
        {
        	  return _position;
        }


        void VertexImpl::SetTime(const double time)
        {
            _time = time;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TIME);
			// set the indicator to true
            isSetTime = true;          
        }

        void VertexImpl::SetPosition(std::shared_ptr<IPositionWriter> position)
        {
            _position = position;
        }

        std::shared_ptr<void> VertexImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(VertexImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IVertex).name())
                return std::dynamic_pointer_cast<IVertex>(shared_from_this());
            else if (classifier == typeid(IVertexWriter).name())
                return std::dynamic_pointer_cast<IVertexWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> VertexImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t VertexImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int VertexImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double VertexImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__TIME)
                {
                    return GetTime();
                }
                throw KeyNotSupportedException();

        }

        uint16_t VertexImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool VertexImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime VertexImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> VertexImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string VertexImpl::GetModelType() const
        {
            return "Vertex";
        }

        void VertexImpl::WriteParameterToTime(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TIME, parameterName, nullTextMarker /*no textmarker*/);
            _time = {};
        }

        std::string VertexImpl::GetParameterFromTime() const
        {
            auto time = OSC_CONSTANTS::ATTRIBUTE__TIME;
            return GetParameterNameFromAttribute(time);
        }

        bool VertexImpl::IsTimeParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TIME);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IPositionWriter> VertexImpl::GetWriterPosition() const
        {
            return std::dynamic_pointer_cast<IPositionWriter>(_position);
        }

        VertexImpl::VertexImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TIME, SimpleType::DOUBLE);
        }

        void VertexImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TIME)
            {
                // Simple type
                _time = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType VertexImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VertexImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VertexImpl::Clone()
        {
            auto clonedObject = std::make_shared<VertexImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_time = GetTime();
            // clone indicators
            	clonedObject->isSetTime = isSetTime;
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            return clonedObject;
        }

        std::string VertexImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VertexImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VertexImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VertexImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VertexImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void VertexImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TIME)
            {
                // Simple type
                _time = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void VertexImpl::ResetTime()
	   {
	   		isSetTime = false; 
			_time = {};
			
	   }
       bool VertexImpl::IsSetTime() const
	   {
			return isSetTime;
	   }

        IOpenScenarioFlexElement* VisibilityActionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        bool VisibilityActionImpl::GetGraphics() const
        {
        	  return _graphics;
        }
        bool VisibilityActionImpl::GetSensors() const
        {
        	  return _sensors;
        }
        bool VisibilityActionImpl::GetTraffic() const
        {
        	  return _traffic;
        }
        std::shared_ptr<ISensorReferenceSet> VisibilityActionImpl::GetSensorReferenceSet() const
        {
        	  return _sensorReferenceSet;
        }


        void VisibilityActionImpl::SetGraphics(const bool graphics)
        {
            _graphics = graphics;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__GRAPHICS);
        }

        void VisibilityActionImpl::SetSensors(const bool sensors)
        {
            _sensors = sensors;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SENSORS);
        }

        void VisibilityActionImpl::SetTraffic(const bool traffic)
        {
            _traffic = traffic;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC);
        }

        void VisibilityActionImpl::SetSensorReferenceSet(std::shared_ptr<ISensorReferenceSetWriter> sensorReferenceSet)
        {
            _sensorReferenceSet = sensorReferenceSet;
			// set the indicator to true
            isSetSensorReferenceSet = true;          
        }

        std::shared_ptr<void> VisibilityActionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(VisibilityActionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IVisibilityAction).name())
                return std::dynamic_pointer_cast<IVisibilityAction>(shared_from_this());
            else if (classifier == typeid(IVisibilityActionWriter).name())
                return std::dynamic_pointer_cast<IVisibilityActionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> VisibilityActionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t VisibilityActionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int VisibilityActionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double VisibilityActionImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t VisibilityActionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool VisibilityActionImpl::GetBooleanProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__GRAPHICS)
                {
                    return GetGraphics();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__SENSORS)
                {
                    return GetSensors();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC)
                {
                    return GetTraffic();
                }
                throw KeyNotSupportedException();

        }

        DateTime VisibilityActionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> VisibilityActionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string VisibilityActionImpl::GetModelType() const
        {
            return "VisibilityAction";
        }

        void VisibilityActionImpl::WriteParameterToGraphics(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__GRAPHICS, parameterName, nullTextMarker /*no textmarker*/);
            _graphics = {};
        }

        void VisibilityActionImpl::WriteParameterToSensors(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SENSORS, parameterName, nullTextMarker /*no textmarker*/);
            _sensors = {};
        }

        void VisibilityActionImpl::WriteParameterToTraffic(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC, parameterName, nullTextMarker /*no textmarker*/);
            _traffic = {};
        }

        std::string VisibilityActionImpl::GetParameterFromGraphics() const
        {
            auto graphics = OSC_CONSTANTS::ATTRIBUTE__GRAPHICS;
            return GetParameterNameFromAttribute(graphics);
        }

        std::string VisibilityActionImpl::GetParameterFromSensors() const
        {
            auto sensors = OSC_CONSTANTS::ATTRIBUTE__SENSORS;
            return GetParameterNameFromAttribute(sensors);
        }

        std::string VisibilityActionImpl::GetParameterFromTraffic() const
        {
            auto traffic = OSC_CONSTANTS::ATTRIBUTE__TRAFFIC;
            return GetParameterNameFromAttribute(traffic);
        }

        bool VisibilityActionImpl::IsGraphicsParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__GRAPHICS);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool VisibilityActionImpl::IsSensorsParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__SENSORS);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool VisibilityActionImpl::IsTrafficParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TRAFFIC);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<ISensorReferenceSetWriter> VisibilityActionImpl::GetWriterSensorReferenceSet() const
        {
            return std::dynamic_pointer_cast<ISensorReferenceSetWriter>(_sensorReferenceSet);
        }

        VisibilityActionImpl::VisibilityActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__GRAPHICS, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SENSORS, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC, SimpleType::BOOLEAN);
        }

        void VisibilityActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__GRAPHICS)
            {
                // Simple type
                _graphics = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SENSORS)
            {
                // Simple type
                _sensors = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC)
            {
                // Simple type
                _traffic = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType VisibilityActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VisibilityActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kSensorReferenceSet =  GetWriterSensorReferenceSet();
                if (kSensorReferenceSet)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSensorReferenceSet));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VisibilityActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<VisibilityActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_graphics = GetGraphics();
            // Simple type
            clonedObject->_sensors = GetSensors();
            // Simple type
            clonedObject->_traffic = GetTraffic();
            // clone indicators
            // clone children
            const auto kSensorReferenceSet =  GetWriterSensorReferenceSet();
            if (kSensorReferenceSet)
            {
                auto clonedChild = std::dynamic_pointer_cast<SensorReferenceSetImpl>(kSensorReferenceSet)->Clone();
                auto clonedChildISensorReferenceSet = std::dynamic_pointer_cast<ISensorReferenceSet>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSensorReferenceSet(std::dynamic_pointer_cast<ISensorReferenceSetWriter>(clonedChildISensorReferenceSet));
            }
            return clonedObject;
        }

        std::string VisibilityActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VisibilityActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SENSOR_REFERENCE_SET)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSensorReferenceSet());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VisibilityActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VisibilityActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VisibilityActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void VisibilityActionImpl::ResolveBooleanExpression(std::string& attributeKey, bool& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__GRAPHICS)
            {
                // Simple type
                _graphics = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SENSORS)
            {
                // Simple type
                _sensors = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC)
            {
                // Simple type
                _traffic = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void VisibilityActionImpl::ResetSensorReferenceSet()
	   {
	   		isSetSensorReferenceSet = false; 
			_sensorReferenceSet = {};
			
	   }
       bool VisibilityActionImpl::IsSetSensorReferenceSet() const
	   {
			return isSetSensorReferenceSet;
	   }

        IOpenScenarioFlexElement* WaypointImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        RouteStrategy WaypointImpl::GetRouteStrategy() const
        {
        	  return _routeStrategy;
        }
        std::shared_ptr<IPosition> WaypointImpl::GetPosition() const
        {
        	  return _position;
        }


        void WaypointImpl::SetRouteStrategy(const RouteStrategy routeStrategy)
        {
            _routeStrategy = routeStrategy;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROUTE_STRATEGY);
        }

        void WaypointImpl::SetPosition(std::shared_ptr<IPositionWriter> position)
        {
            _position = position;
        }

        std::shared_ptr<void> WaypointImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(WaypointImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IWaypoint).name())
                return std::dynamic_pointer_cast<IWaypoint>(shared_from_this());
            else if (classifier == typeid(IWaypointWriter).name())
                return std::dynamic_pointer_cast<IWaypointWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> WaypointImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t WaypointImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int WaypointImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double WaypointImpl::GetDoubleProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        uint16_t WaypointImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool WaypointImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime WaypointImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> WaypointImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string WaypointImpl::GetModelType() const
        {
            return "Waypoint";
        }

        void WaypointImpl::WriteParameterToRouteStrategy(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ROUTE_STRATEGY, parameterName, nullTextMarker /*no textmarker*/);
            _routeStrategy = {};
        }

        std::string WaypointImpl::GetParameterFromRouteStrategy() const
        {
            auto routeStrategy = OSC_CONSTANTS::ATTRIBUTE__ROUTE_STRATEGY;
            return GetParameterNameFromAttribute(routeStrategy);
        }

        bool WaypointImpl::IsRouteStrategyParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ROUTE_STRATEGY);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<IPositionWriter> WaypointImpl::GetWriterPosition() const
        {
            return std::dynamic_pointer_cast<IPositionWriter>(_position);
        }

        WaypointImpl::WaypointImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ROUTE_STRATEGY, SimpleType::ENUM_TYPE);
        }

        void WaypointImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ROUTE_STRATEGY)
            {
                // Enumeration Type
                const auto kResult = RouteStrategy::GetFromLiteral(parameterLiteralValue);
                if (kResult != RouteStrategy::UNKNOWN)
                {
                    _routeStrategy = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType WaypointImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> WaypointImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> WaypointImpl::Clone()
        {
            auto clonedObject = std::make_shared<WaypointImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Enumeration Type
            const auto kRouteStrategy = GetRouteStrategy();
            if ( kRouteStrategy.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_routeStrategy = RouteStrategy::GetFromLiteral(kRouteStrategy.GetLiteral());
            }
            // clone indicators
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            return clonedObject;
        }

        std::string WaypointImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> WaypointImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> WaypointImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> WaypointImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string WaypointImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ROUTE_STRATEGY)
            {
                auto routeStrategy = GetRouteStrategy();
                return routeStrategy.GetLiteral() != "UNKNOWN" ? routeStrategy.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }



        IOpenScenarioFlexElement* WeatherImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double WeatherImpl::GetAtmosphericPressure() const
        {
        	  return _atmosphericPressure;
        }
        CloudState WeatherImpl::GetCloudState() const
        {
        	  return _cloudState;
        }
        FractionalCloudCover WeatherImpl::GetFractionalCloudCover() const
        {
        	  return _fractionalCloudCover;
        }
        double WeatherImpl::GetTemperature() const
        {
        	  return _temperature;
        }
        std::shared_ptr<ISun> WeatherImpl::GetSun() const
        {
        	  return _sun;
        }
        std::shared_ptr<IFog> WeatherImpl::GetFog() const
        {
        	  return _fog;
        }
        std::shared_ptr<IPrecipitation> WeatherImpl::GetPrecipitation() const
        {
        	  return _precipitation;
        }
        std::shared_ptr<IWind> WeatherImpl::GetWind() const
        {
        	  return _wind;
        }
        std::shared_ptr<IDomeImage> WeatherImpl::GetDomeImage() const
        {
        	  return _domeImage;
        }


        void WeatherImpl::SetAtmosphericPressure(const double atmosphericPressure)
        {
            _atmosphericPressure = atmosphericPressure;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ATMOSPHERIC_PRESSURE);
			// set the indicator to true
            isSetAtmosphericPressure = true;          
        }

        void WeatherImpl::SetCloudState(const CloudState cloudState)
        {
            _cloudState = cloudState;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CLOUD_STATE);
			// set the indicator to true
            isSetCloudState = true;          
        }

        void WeatherImpl::SetFractionalCloudCover(const FractionalCloudCover fractionalCloudCover)
        {
            _fractionalCloudCover = fractionalCloudCover;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FRACTIONAL_CLOUD_COVER);
			// set the indicator to true
            isSetFractionalCloudCover = true;          
        }

        void WeatherImpl::SetTemperature(const double temperature)
        {
            _temperature = temperature;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TEMPERATURE);
			// set the indicator to true
            isSetTemperature = true;          
        }

        void WeatherImpl::SetSun(std::shared_ptr<ISunWriter> sun)
        {
            _sun = sun;
			// set the indicator to true
            isSetSun = true;          
        }

        void WeatherImpl::SetFog(std::shared_ptr<IFogWriter> fog)
        {
            _fog = fog;
			// set the indicator to true
            isSetFog = true;          
        }

        void WeatherImpl::SetPrecipitation(std::shared_ptr<IPrecipitationWriter> precipitation)
        {
            _precipitation = precipitation;
			// set the indicator to true
            isSetPrecipitation = true;          
        }

        void WeatherImpl::SetWind(std::shared_ptr<IWindWriter> wind)
        {
            _wind = wind;
			// set the indicator to true
            isSetWind = true;          
        }

        void WeatherImpl::SetDomeImage(std::shared_ptr<IDomeImageWriter> domeImage)
        {
            _domeImage = domeImage;
			// set the indicator to true
            isSetDomeImage = true;          
        }

        std::shared_ptr<void> WeatherImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(WeatherImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IWeather).name())
                return std::dynamic_pointer_cast<IWeather>(shared_from_this());
            else if (classifier == typeid(IWeatherWriter).name())
                return std::dynamic_pointer_cast<IWeatherWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> WeatherImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t WeatherImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int WeatherImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double WeatherImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__ATMOSPHERIC_PRESSURE)
                {
                    return GetAtmosphericPressure();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__TEMPERATURE)
                {
                    return GetTemperature();
                }
                throw KeyNotSupportedException();

        }

        uint16_t WeatherImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool WeatherImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime WeatherImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> WeatherImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string WeatherImpl::GetModelType() const
        {
            return "Weather";
        }

        void WeatherImpl::WriteParameterToAtmosphericPressure(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__ATMOSPHERIC_PRESSURE, parameterName, nullTextMarker /*no textmarker*/);
            _atmosphericPressure = {};
        }

        void WeatherImpl::WriteParameterToCloudState(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__CLOUD_STATE, parameterName, nullTextMarker /*no textmarker*/);
            _cloudState = {};
        }

        void WeatherImpl::WriteParameterToFractionalCloudCover(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__FRACTIONAL_CLOUD_COVER, parameterName, nullTextMarker /*no textmarker*/);
            _fractionalCloudCover = {};
        }

        void WeatherImpl::WriteParameterToTemperature(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__TEMPERATURE, parameterName, nullTextMarker /*no textmarker*/);
            _temperature = {};
        }

        std::string WeatherImpl::GetParameterFromAtmosphericPressure() const
        {
            auto atmosphericPressure = OSC_CONSTANTS::ATTRIBUTE__ATMOSPHERIC_PRESSURE;
            return GetParameterNameFromAttribute(atmosphericPressure);
        }

        std::string WeatherImpl::GetParameterFromCloudState() const
        {
            auto cloudState = OSC_CONSTANTS::ATTRIBUTE__CLOUD_STATE;
            return GetParameterNameFromAttribute(cloudState);
        }

        std::string WeatherImpl::GetParameterFromFractionalCloudCover() const
        {
            auto fractionalCloudCover = OSC_CONSTANTS::ATTRIBUTE__FRACTIONAL_CLOUD_COVER;
            return GetParameterNameFromAttribute(fractionalCloudCover);
        }

        std::string WeatherImpl::GetParameterFromTemperature() const
        {
            auto temperature = OSC_CONSTANTS::ATTRIBUTE__TEMPERATURE;
            return GetParameterNameFromAttribute(temperature);
        }

        bool WeatherImpl::IsAtmosphericPressureParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__ATMOSPHERIC_PRESSURE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool WeatherImpl::IsCloudStateParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__CLOUD_STATE);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool WeatherImpl::IsFractionalCloudCoverParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__FRACTIONAL_CLOUD_COVER);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool WeatherImpl::IsTemperatureParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__TEMPERATURE);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children
        std::shared_ptr<ISunWriter> WeatherImpl::GetWriterSun() const
        {
            return std::dynamic_pointer_cast<ISunWriter>(_sun);
        }
        std::shared_ptr<IFogWriter> WeatherImpl::GetWriterFog() const
        {
            return std::dynamic_pointer_cast<IFogWriter>(_fog);
        }
        std::shared_ptr<IPrecipitationWriter> WeatherImpl::GetWriterPrecipitation() const
        {
            return std::dynamic_pointer_cast<IPrecipitationWriter>(_precipitation);
        }
        std::shared_ptr<IWindWriter> WeatherImpl::GetWriterWind() const
        {
            return std::dynamic_pointer_cast<IWindWriter>(_wind);
        }
        std::shared_ptr<IDomeImageWriter> WeatherImpl::GetWriterDomeImage() const
        {
            return std::dynamic_pointer_cast<IDomeImageWriter>(_domeImage);
        }

        WeatherImpl::WeatherImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ATMOSPHERIC_PRESSURE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CLOUD_STATE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FRACTIONAL_CLOUD_COVER, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TEMPERATURE, SimpleType::DOUBLE);
        }

        void WeatherImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ATMOSPHERIC_PRESSURE)
            {
                // Simple type
                _atmosphericPressure = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CLOUD_STATE)
            {
                // Enumeration Type
                const auto kResult = CloudState::GetFromLiteral(parameterLiteralValue);
                if (kResult != CloudState::UNKNOWN)
                {
                    _cloudState = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FRACTIONAL_CLOUD_COVER)
            {
                // Enumeration Type
                const auto kResult = FractionalCloudCover::GetFromLiteral(parameterLiteralValue);
                if (kResult != FractionalCloudCover::UNKNOWN)
                {
                    _fractionalCloudCover = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TEMPERATURE)
            {
                // Simple type
                _temperature = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType WeatherImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> WeatherImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kSun =  GetWriterSun();
                if (kSun)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSun));
                }
                const auto kFog =  GetWriterFog();
                if (kFog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kFog));
                }
                const auto kPrecipitation =  GetWriterPrecipitation();
                if (kPrecipitation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPrecipitation));
                }
                const auto kWind =  GetWriterWind();
                if (kWind)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kWind));
                }
                const auto kDomeImage =  GetWriterDomeImage();
                if (kDomeImage)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDomeImage));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> WeatherImpl::Clone()
        {
            auto clonedObject = std::make_shared<WeatherImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_atmosphericPressure = GetAtmosphericPressure();
            // Enumeration Type
            const auto kCloudState = GetCloudState();
            if ( kCloudState.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_cloudState = CloudState::GetFromLiteral(kCloudState.GetLiteral());
            }
            // Enumeration Type
            const auto kFractionalCloudCover = GetFractionalCloudCover();
            if ( kFractionalCloudCover.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_fractionalCloudCover = FractionalCloudCover::GetFromLiteral(kFractionalCloudCover.GetLiteral());
            }
            // Simple type
            clonedObject->_temperature = GetTemperature();
            // clone indicators
            	clonedObject->isSetAtmosphericPressure = isSetAtmosphericPressure;
            	clonedObject->isSetCloudState = isSetCloudState;
            	clonedObject->isSetFractionalCloudCover = isSetFractionalCloudCover;
            	clonedObject->isSetTemperature = isSetTemperature;
            // clone children
            const auto kSun =  GetWriterSun();
            if (kSun)
            {
                auto clonedChild = std::dynamic_pointer_cast<SunImpl>(kSun)->Clone();
                auto clonedChildISun = std::dynamic_pointer_cast<ISun>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSun(std::dynamic_pointer_cast<ISunWriter>(clonedChildISun));
            }
            const auto kFog =  GetWriterFog();
            if (kFog)
            {
                auto clonedChild = std::dynamic_pointer_cast<FogImpl>(kFog)->Clone();
                auto clonedChildIFog = std::dynamic_pointer_cast<IFog>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetFog(std::dynamic_pointer_cast<IFogWriter>(clonedChildIFog));
            }
            const auto kPrecipitation =  GetWriterPrecipitation();
            if (kPrecipitation)
            {
                auto clonedChild = std::dynamic_pointer_cast<PrecipitationImpl>(kPrecipitation)->Clone();
                auto clonedChildIPrecipitation = std::dynamic_pointer_cast<IPrecipitation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPrecipitation(std::dynamic_pointer_cast<IPrecipitationWriter>(clonedChildIPrecipitation));
            }
            const auto kWind =  GetWriterWind();
            if (kWind)
            {
                auto clonedChild = std::dynamic_pointer_cast<WindImpl>(kWind)->Clone();
                auto clonedChildIWind = std::dynamic_pointer_cast<IWind>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetWind(std::dynamic_pointer_cast<IWindWriter>(clonedChildIWind));
            }
            const auto kDomeImage =  GetWriterDomeImage();
            if (kDomeImage)
            {
                auto clonedChild = std::dynamic_pointer_cast<DomeImageImpl>(kDomeImage)->Clone();
                auto clonedChildIDomeImage = std::dynamic_pointer_cast<IDomeImage>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDomeImage(std::dynamic_pointer_cast<IDomeImageWriter>(clonedChildIDomeImage));
            }
            return clonedObject;
        }

        std::string WeatherImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> WeatherImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SUN)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSun());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__FOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetFog());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PRECIPITATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPrecipitation());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__WIND)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetWind());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DOME_IMAGE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDomeImage());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> WeatherImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> WeatherImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string WeatherImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__CLOUD_STATE)
            {
                auto cloudState = GetCloudState();
                return cloudState.GetLiteral() != "UNKNOWN" ? cloudState.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__FRACTIONAL_CLOUD_COVER)
            {
                auto fractionalCloudCover = GetFractionalCloudCover();
                return fractionalCloudCover.GetLiteral() != "UNKNOWN" ? fractionalCloudCover.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }
		void WeatherImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ATMOSPHERIC_PRESSURE)
            {
                // Simple type
                _atmosphericPressure = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TEMPERATURE)
            {
                // Simple type
                _temperature = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void WeatherImpl::ResetAtmosphericPressure()
	   {
	   		isSetAtmosphericPressure = false; 
			_atmosphericPressure = {};
			
	   }
       bool WeatherImpl::IsSetAtmosphericPressure() const
	   {
			return isSetAtmosphericPressure;
	   }
       void WeatherImpl::ResetCloudState()
	   {
	   		isSetCloudState = false; 
			_cloudState = {};
			
	   }
       bool WeatherImpl::IsSetCloudState() const
	   {
			return isSetCloudState;
	   }
       void WeatherImpl::ResetFractionalCloudCover()
	   {
	   		isSetFractionalCloudCover = false; 
			_fractionalCloudCover = {};
			
	   }
       bool WeatherImpl::IsSetFractionalCloudCover() const
	   {
			return isSetFractionalCloudCover;
	   }
       void WeatherImpl::ResetTemperature()
	   {
	   		isSetTemperature = false; 
			_temperature = {};
			
	   }
       bool WeatherImpl::IsSetTemperature() const
	   {
			return isSetTemperature;
	   }
       void WeatherImpl::ResetSun()
	   {
	   		isSetSun = false; 
			_sun = {};
			
	   }
       bool WeatherImpl::IsSetSun() const
	   {
			return isSetSun;
	   }
       void WeatherImpl::ResetFog()
	   {
	   		isSetFog = false; 
			_fog = {};
			
	   }
       bool WeatherImpl::IsSetFog() const
	   {
			return isSetFog;
	   }
       void WeatherImpl::ResetPrecipitation()
	   {
	   		isSetPrecipitation = false; 
			_precipitation = {};
			
	   }
       bool WeatherImpl::IsSetPrecipitation() const
	   {
			return isSetPrecipitation;
	   }
       void WeatherImpl::ResetWind()
	   {
	   		isSetWind = false; 
			_wind = {};
			
	   }
       bool WeatherImpl::IsSetWind() const
	   {
			return isSetWind;
	   }
       void WeatherImpl::ResetDomeImage()
	   {
	   		isSetDomeImage = false; 
			_domeImage = {};
			
	   }
       bool WeatherImpl::IsSetDomeImage() const
	   {
			return isSetDomeImage;
	   }

        IOpenScenarioFlexElement* WindImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double WindImpl::GetDirection() const
        {
        	  return _direction;
        }
        double WindImpl::GetSpeed() const
        {
        	  return _speed;
        }


        void WindImpl::SetDirection(const double direction)
        {
            _direction = direction;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DIRECTION);
        }

        void WindImpl::SetSpeed(const double speed)
        {
            _speed = speed;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SPEED);
        }

        std::shared_ptr<void> WindImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(WindImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IWind).name())
                return std::dynamic_pointer_cast<IWind>(shared_from_this());
            else if (classifier == typeid(IWindWriter).name())
                return std::dynamic_pointer_cast<IWindWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> WindImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t WindImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int WindImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double WindImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__DIRECTION)
                {
                    return GetDirection();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__SPEED)
                {
                    return GetSpeed();
                }
                throw KeyNotSupportedException();

        }

        uint16_t WindImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool WindImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime WindImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> WindImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string WindImpl::GetModelType() const
        {
            return "Wind";
        }

        void WindImpl::WriteParameterToDirection(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__DIRECTION, parameterName, nullTextMarker /*no textmarker*/);
            _direction = {};
        }

        void WindImpl::WriteParameterToSpeed(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__SPEED, parameterName, nullTextMarker /*no textmarker*/);
            _speed = {};
        }

        std::string WindImpl::GetParameterFromDirection() const
        {
            auto direction = OSC_CONSTANTS::ATTRIBUTE__DIRECTION;
            return GetParameterNameFromAttribute(direction);
        }

        std::string WindImpl::GetParameterFromSpeed() const
        {
            auto speed = OSC_CONSTANTS::ATTRIBUTE__SPEED;
            return GetParameterNameFromAttribute(speed);
        }

        bool WindImpl::IsDirectionParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__DIRECTION);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool WindImpl::IsSpeedParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__SPEED);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        WindImpl::WindImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DIRECTION, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SPEED, SimpleType::DOUBLE);
        }

        void WindImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DIRECTION)
            {
                // Simple type
                _direction = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SPEED)
            {
                // Simple type
                _speed = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType WindImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> WindImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> WindImpl::Clone()
        {
            auto clonedObject = std::make_shared<WindImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_direction = GetDirection();
            // Simple type
            clonedObject->_speed = GetSpeed();
            // clone indicators
            // clone children
            return clonedObject;
        }

        std::string WindImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> WindImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> WindImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> WindImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string WindImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void WindImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DIRECTION)
            {
                // Simple type
                _direction = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SPEED)
            {
                // Simple type
                _speed = value;
                AddResolvedParameter(attributeKey);
            }
		
		}



        IOpenScenarioFlexElement* WorldPositionImpl::GetOpenScenarioFlexElement()
        {
            return this;
        }
        double WorldPositionImpl::GetH() const
        {
        	  return _h;
        }
        double WorldPositionImpl::GetP() const
        {
        	  return _p;
        }
        double WorldPositionImpl::GetR() const
        {
        	  return _r;
        }
        double WorldPositionImpl::GetX() const
        {
        	  return _x;
        }
        double WorldPositionImpl::GetY() const
        {
        	  return _y;
        }
        double WorldPositionImpl::GetZ() const
        {
        	  return _z;
        }


        void WorldPositionImpl::SetH(const double h)
        {
            _h = h;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__H);
			// set the indicator to true
            isSetH = true;          
        }

        void WorldPositionImpl::SetP(const double p)
        {
            _p = p;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__P);
			// set the indicator to true
            isSetP = true;          
        }

        void WorldPositionImpl::SetR(const double r)
        {
            _r = r;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__R);
			// set the indicator to true
            isSetR = true;          
        }

        void WorldPositionImpl::SetX(const double x)
        {
            _x = x;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__X);
        }

        void WorldPositionImpl::SetY(const double y)
        {
            _y = y;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__Y);
        }

        void WorldPositionImpl::SetZ(const double z)
        {
            _z = z;
            //RemoveAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__Z);
			// set the indicator to true
            isSetZ = true;          
        }

        std::shared_ptr<void> WorldPositionImpl::GetAdapter(const std::string classifier)
        {
            if (classifier == typeid(WorldPositionImpl).name())
                return shared_from_this();
            else if (classifier == typeid(IWorldPosition).name())
                return std::dynamic_pointer_cast<IWorldPosition>(shared_from_this());
            else if (classifier == typeid(IWorldPositionWriter).name())
                return std::dynamic_pointer_cast<IWorldPositionWriter>(shared_from_this());
            return BaseImpl::GetAdapter(classifier);
        }

        std::weak_ptr<IOpenScenarioModelElement> WorldPositionImpl::GetParent() const
        {
            return BaseImpl::GetParent();
        }

        // Implement the IOpenScenarioFlexElement interface


        uint32_t WorldPositionImpl::GetUnsignedIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        int WorldPositionImpl::GetIntProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        double WorldPositionImpl::GetDoubleProperty(std::string key) const
        {
            if (key.empty())
                {
                    throw KeyNotSupportedException();
                }
     
                if (key == OSC_CONSTANTS::ATTRIBUTE__H)
                {
                    return GetH();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__P)
                {
                    return GetP();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__R)
                {
                    return GetR();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__X)
                {
                    return GetX();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__Y)
                {
                    return GetY();
                }    else 
                if (key == OSC_CONSTANTS::ATTRIBUTE__Z)
                {
                    return GetZ();
                }
                throw KeyNotSupportedException();

        }

        uint16_t WorldPositionImpl::GetUnsignedShortProperty(std::string key) const
        {
            throw KeyNotSupportedException();

            }
 
            bool WorldPositionImpl::GetBooleanProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

        DateTime WorldPositionImpl::GetDateTimeProperty(std::string key) const
        {
            throw KeyNotSupportedException();

        }

 
        std::weak_ptr<IOpenScenarioFlexElement> WorldPositionImpl::GetParentFlexElement() const
        {
            return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParent().lock());
        }


        std::string WorldPositionImpl::GetModelType() const
        {
            return "WorldPosition";
        }

        void WorldPositionImpl::WriteParameterToH(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__H, parameterName, nullTextMarker /*no textmarker*/);
            _h = {};
        }

        void WorldPositionImpl::WriteParameterToP(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__P, parameterName, nullTextMarker /*no textmarker*/);
            _p = {};
        }

        void WorldPositionImpl::WriteParameterToR(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__R, parameterName, nullTextMarker /*no textmarker*/);
            _r = {};
        }

        void WorldPositionImpl::WriteParameterToX(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__X, parameterName, nullTextMarker /*no textmarker*/);
            _x = {};
        }

        void WorldPositionImpl::WriteParameterToY(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__Y, parameterName, nullTextMarker /*no textmarker*/);
            _y = {};
        }

        void WorldPositionImpl::WriteParameterToZ(std::string& parameterName)
        {
            Textmarker nullTextMarker(-1, -1, "");
            SetAttributeParameter(OSC_CONSTANTS::ATTRIBUTE__Z, parameterName, nullTextMarker /*no textmarker*/);
            _z = {};
        }

        std::string WorldPositionImpl::GetParameterFromH() const
        {
            auto h = OSC_CONSTANTS::ATTRIBUTE__H;
            return GetParameterNameFromAttribute(h);
        }

        std::string WorldPositionImpl::GetParameterFromP() const
        {
            auto p = OSC_CONSTANTS::ATTRIBUTE__P;
            return GetParameterNameFromAttribute(p);
        }

        std::string WorldPositionImpl::GetParameterFromR() const
        {
            auto r = OSC_CONSTANTS::ATTRIBUTE__R;
            return GetParameterNameFromAttribute(r);
        }

        std::string WorldPositionImpl::GetParameterFromX() const
        {
            auto x = OSC_CONSTANTS::ATTRIBUTE__X;
            return GetParameterNameFromAttribute(x);
        }

        std::string WorldPositionImpl::GetParameterFromY() const
        {
            auto y = OSC_CONSTANTS::ATTRIBUTE__Y;
            return GetParameterNameFromAttribute(y);
        }

        std::string WorldPositionImpl::GetParameterFromZ() const
        {
            auto z = OSC_CONSTANTS::ATTRIBUTE__Z;
            return GetParameterNameFromAttribute(z);
        }

        bool WorldPositionImpl::IsHParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__H);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool WorldPositionImpl::IsPParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__P);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool WorldPositionImpl::IsRParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__R);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool WorldPositionImpl::IsXParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__X);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool WorldPositionImpl::IsYParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__Y);
            if (kIt != keys.end())
                return true;
            return false;
        }

        bool WorldPositionImpl::IsZParameterized()
        {
            auto keys = GetParameterizedAttributeKeys();
            const auto kIt = std::find(keys.begin(), keys.end(), OSC_CONSTANTS::ATTRIBUTE__Z);
            if (kIt != keys.end())
                return true;
            return false;
        }

            // children

        WorldPositionImpl::WorldPositionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__H, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__P, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__R, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__X, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__Y, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__Z, SimpleType::DOUBLE);
        }

        void WorldPositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__H)
            {
                // Simple type
                _h = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__P)
            {
                // Simple type
                _p = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__R)
            {
                // Simple type
                _r = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__X)
            {
                // Simple type
                _x = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__Y)
            {
                // Simple type
                _y = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__Z)
            {
                // Simple type
                _z = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType WorldPositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> WorldPositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> WorldPositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<WorldPositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
			CloneAttributeKeyToParameterNameMap(*clonedObject);
				
            // clone attributes;
            // Simple type
            clonedObject->_h = GetH();
            // Simple type
            clonedObject->_p = GetP();
            // Simple type
            clonedObject->_r = GetR();
            // Simple type
            clonedObject->_x = GetX();
            // Simple type
            clonedObject->_y = GetY();
            // Simple type
            clonedObject->_z = GetZ();
            // clone indicators
            	clonedObject->isSetH = isSetH;
            	clonedObject->isSetP = isSetP;
            	clonedObject->isSetR = isSetR;
            	clonedObject->isSetZ = isSetZ;
            // clone children
            return clonedObject;
        }

        std::string WorldPositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> WorldPositionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> WorldPositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> WorldPositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string WorldPositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }
		void WorldPositionImpl::ResolveDoubleExpression(std::string& attributeKey, double& value)
		{
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__H)
            {
                // Simple type
                _h = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__P)
            {
                // Simple type
                _p = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__R)
            {
                // Simple type
                _r = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__X)
            {
                // Simple type
                _x = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__Y)
            {
                // Simple type
                _y = value;
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__Z)
            {
                // Simple type
                _z = value;
                AddResolvedParameter(attributeKey);
            }
		
		}


       void WorldPositionImpl::ResetH()
	   {
	   		isSetH = false; 
			_h = {0};
			
	   }
       bool WorldPositionImpl::IsSetH() const
	   {
			return isSetH;
	   }
       void WorldPositionImpl::ResetP()
	   {
	   		isSetP = false; 
			_p = {0};
			
	   }
       bool WorldPositionImpl::IsSetP() const
	   {
			return isSetP;
	   }
       void WorldPositionImpl::ResetR()
	   {
	   		isSetR = false; 
			_r = {0};
			
	   }
       bool WorldPositionImpl::IsSetR() const
	   {
			return isSetR;
	   }
       void WorldPositionImpl::ResetZ()
	   {
	   		isSetZ = false; 
			_z = {0};
			
	   }
       bool WorldPositionImpl::IsSetZ() const
	   {
			return isSetZ;
	   }
    }
}

 
