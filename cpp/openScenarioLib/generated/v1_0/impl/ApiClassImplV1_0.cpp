/*
 * Copyright 2020 RA Consulting
 *
 * RA Consulting GmbH licenses this file under the Apache License, 
 * Version 2.0 (the "License"); you may not use this file except 
 * in compliance with the License. 
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 
#include "ApiClassImplV1_0.h"
#include "OscConstantsV1_0.h"
#include "FileContentMessage.h"
#include "IOpenScenarioModelElement.h"
#include "ErrorLevel.h"
#include "NamedReferenceProxy.h"

namespace NET_ASAM_OPENSCENARIO
{
    namespace v1_0
    {

        AbsoluteSpeedImpl::AbsoluteSpeedImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        double AbsoluteSpeedImpl::GetValue() const
        {
            return _value;
        }

        void AbsoluteSpeedImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType AbsoluteSpeedImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AbsoluteSpeedImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AbsoluteSpeedImpl::Clone()
        {
            auto clonedObject = std::make_shared<AbsoluteSpeedImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string AbsoluteSpeedImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AbsoluteSpeedImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AbsoluteSpeedImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AbsoluteSpeedImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AbsoluteSpeedImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        AbsoluteTargetLaneImpl::AbsoluteTargetLaneImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
        }

        std::string AbsoluteTargetLaneImpl::GetValue() const
        {
            return _value;
        }

        void AbsoluteTargetLaneImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType AbsoluteTargetLaneImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AbsoluteTargetLaneImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AbsoluteTargetLaneImpl::Clone()
        {
            auto clonedObject = std::make_shared<AbsoluteTargetLaneImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string AbsoluteTargetLaneImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AbsoluteTargetLaneImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AbsoluteTargetLaneImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AbsoluteTargetLaneImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AbsoluteTargetLaneImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        AbsoluteTargetLaneOffsetImpl::AbsoluteTargetLaneOffsetImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        double AbsoluteTargetLaneOffsetImpl::GetValue() const
        {
            return _value;
        }

        void AbsoluteTargetLaneOffsetImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType AbsoluteTargetLaneOffsetImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AbsoluteTargetLaneOffsetImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AbsoluteTargetLaneOffsetImpl::Clone()
        {
            auto clonedObject = std::make_shared<AbsoluteTargetLaneOffsetImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string AbsoluteTargetLaneOffsetImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AbsoluteTargetLaneOffsetImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AbsoluteTargetLaneOffsetImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AbsoluteTargetLaneOffsetImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AbsoluteTargetLaneOffsetImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        AbsoluteTargetSpeedImpl::AbsoluteTargetSpeedImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        double AbsoluteTargetSpeedImpl::GetValue() const
        {
            return _value;
        }

        void AbsoluteTargetSpeedImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType AbsoluteTargetSpeedImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AbsoluteTargetSpeedImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AbsoluteTargetSpeedImpl::Clone()
        {
            auto clonedObject = std::make_shared<AbsoluteTargetSpeedImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string AbsoluteTargetSpeedImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AbsoluteTargetSpeedImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AbsoluteTargetSpeedImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AbsoluteTargetSpeedImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AbsoluteTargetSpeedImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        AccelerationConditionImpl::AccelerationConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        Rule AccelerationConditionImpl::GetRule() const
        {
            return _rule;
        }
        double AccelerationConditionImpl::GetValue() const
        {
            return _value;
        }

        void AccelerationConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType AccelerationConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AccelerationConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AccelerationConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<AccelerationConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string AccelerationConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AccelerationConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AccelerationConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AccelerationConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AccelerationConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        AcquirePositionActionImpl::AcquirePositionActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IPosition> AcquirePositionActionImpl::GetPosition() const
        {
            return _position;
        }

        void AcquirePositionActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType AcquirePositionActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AcquirePositionActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AcquirePositionActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<AcquirePositionActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            return clonedObject;
        }

        std::string AcquirePositionActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AcquirePositionActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AcquirePositionActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AcquirePositionActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AcquirePositionActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ActImpl::ActImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        std::string ActImpl::GetName() const
        {
            return _name;
        }
        std::vector<std::shared_ptr<IManeuverGroup>> ActImpl::GetManeuverGroups() const
        {
            std::vector<std::shared_ptr<IManeuverGroup>> temp;
            for(auto&& elm: _maneuverGroups)
                temp.push_back(elm);
            return temp;
        }
        std::shared_ptr<ITrigger> ActImpl::GetStartTrigger() const
        {
            return _startTrigger;
        }
        std::shared_ptr<ITrigger> ActImpl::GetStopTrigger() const
        {
            return _stopTrigger;
        }

        void ActImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ActImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ActImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto maneuverGroups =  GetWriterManeuverGroups();
                if (!maneuverGroups.empty())
                {
                    for(auto&& item : maneuverGroups)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kStartTrigger =  GetWriterStartTrigger();
                if (kStartTrigger)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kStartTrigger));
                }
                const auto kStopTrigger =  GetWriterStopTrigger();
                if (kStopTrigger)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kStopTrigger));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ActImpl::Clone()
        {
            auto clonedObject = std::make_shared<ActImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone children
            const auto kManeuverGroups =  GetWriterManeuverGroups();
            if (!kManeuverGroups.empty())
            {
                std::vector<std::shared_ptr<IManeuverGroupWriter>> clonedList;
                for(auto&& kItem : kManeuverGroups)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ManeuverGroupImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IManeuverGroupWriter>(clonedChild));
                }
                clonedObject->SetManeuverGroups(clonedList);
            }
            const auto kStartTrigger =  GetWriterStartTrigger();
            if (kStartTrigger)
            {
                auto clonedChild = std::dynamic_pointer_cast<TriggerImpl>(kStartTrigger)->Clone();
                auto clonedChildITrigger = std::dynamic_pointer_cast<ITrigger>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetStartTrigger(std::dynamic_pointer_cast<ITriggerWriter>(clonedChildITrigger));
            }
            const auto kStopTrigger =  GetWriterStopTrigger();
            if (kStopTrigger)
            {
                auto clonedChild = std::dynamic_pointer_cast<TriggerImpl>(kStopTrigger)->Clone();
                auto clonedChildITrigger = std::dynamic_pointer_cast<ITrigger>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetStopTrigger(std::dynamic_pointer_cast<ITriggerWriter>(clonedChildITrigger));
            }
            return clonedObject;
        }

        std::string ActImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ActImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__START_TRIGGER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetStartTrigger());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__STOP_TRIGGER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetStopTrigger());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ActImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__MANEUVER_GROUP)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetManeuverGroups())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ActImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ActImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ActionImpl::ActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        std::string ActionImpl::GetName() const
        {
            return _name;
        }
        std::shared_ptr<IGlobalAction> ActionImpl::GetGlobalAction() const
        {
            return _globalAction;
        }
        std::shared_ptr<IUserDefinedAction> ActionImpl::GetUserDefinedAction() const
        {
            return _userDefinedAction;
        }
        std::shared_ptr<IPrivateAction> ActionImpl::GetPrivateAction() const
        {
            return _privateAction;
        }

        void ActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kGlobalAction =  GetWriterGlobalAction();
                if (kGlobalAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kGlobalAction));
                }
                const auto kUserDefinedAction =  GetWriterUserDefinedAction();
                if (kUserDefinedAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kUserDefinedAction));
                }
                const auto kPrivateAction =  GetWriterPrivateAction();
                if (kPrivateAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPrivateAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone children
            const auto kGlobalAction =  GetWriterGlobalAction();
            if (kGlobalAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<GlobalActionImpl>(kGlobalAction)->Clone();
                auto clonedChildIGlobalAction = std::dynamic_pointer_cast<IGlobalAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetGlobalAction(std::dynamic_pointer_cast<IGlobalActionWriter>(clonedChildIGlobalAction));
            }
            const auto kUserDefinedAction =  GetWriterUserDefinedAction();
            if (kUserDefinedAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<UserDefinedActionImpl>(kUserDefinedAction)->Clone();
                auto clonedChildIUserDefinedAction = std::dynamic_pointer_cast<IUserDefinedAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetUserDefinedAction(std::dynamic_pointer_cast<IUserDefinedActionWriter>(clonedChildIUserDefinedAction));
            }
            const auto kPrivateAction =  GetWriterPrivateAction();
            if (kPrivateAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<PrivateActionImpl>(kPrivateAction)->Clone();
                auto clonedChildIPrivateAction = std::dynamic_pointer_cast<IPrivateAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPrivateAction(std::dynamic_pointer_cast<IPrivateActionWriter>(clonedChildIPrivateAction));
            }
            return clonedObject;
        }

        std::string ActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__GLOBAL_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetGlobalAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__USER_DEFINED_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetUserDefinedAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PRIVATE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPrivateAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ActivateControllerActionImpl::ActivateControllerActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LATERAL, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LONGITUDINAL, SimpleType::BOOLEAN);
        }

        bool ActivateControllerActionImpl::GetLateral() const
        {
            return _lateral;
        }
        bool ActivateControllerActionImpl::GetLongitudinal() const
        {
            return _longitudinal;
        }

        void ActivateControllerActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LATERAL)
            {
                // Simple type
                _lateral = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LONGITUDINAL)
            {
                // Simple type
                _longitudinal = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ActivateControllerActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ActivateControllerActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ActivateControllerActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ActivateControllerActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_lateral = GetLateral();
            // Simple type
            clonedObject->_longitudinal = GetLongitudinal();
            // clone children
            return clonedObject;
        }

        std::string ActivateControllerActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ActivateControllerActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ActivateControllerActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ActivateControllerActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ActivateControllerActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ActorsImpl::ActorsImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SELECT_TRIGGERING_ENTITIES, SimpleType::BOOLEAN);
        }

        bool ActorsImpl::GetSelectTriggeringEntities() const
        {
            return _selectTriggeringEntities;
        }
        std::vector<std::shared_ptr<IEntityRef>> ActorsImpl::GetEntityRefs() const
        {
            std::vector<std::shared_ptr<IEntityRef>> temp;
            for(auto&& elm: _entityRefs)
                temp.push_back(elm);
            return temp;
        }

        void ActorsImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SELECT_TRIGGERING_ENTITIES)
            {
                // Simple type
                _selectTriggeringEntities = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ActorsImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ActorsImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto entityRefs =  GetWriterEntityRefs();
                if (!entityRefs.empty())
                {
                    for(auto&& item : entityRefs)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ActorsImpl::Clone()
        {
            auto clonedObject = std::make_shared<ActorsImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_selectTriggeringEntities = GetSelectTriggeringEntities();
            // clone children
            const auto kEntityRefs =  GetWriterEntityRefs();
            if (!kEntityRefs.empty())
            {
                std::vector<std::shared_ptr<IEntityRefWriter>> clonedList;
                for(auto&& kItem : kEntityRefs)
                {
                    auto clonedChild = std::dynamic_pointer_cast<EntityRefImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IEntityRefWriter>(clonedChild));
                }
                clonedObject->SetEntityRefs(clonedList);
            }
            return clonedObject;
        }

        std::string ActorsImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ActorsImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ActorsImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_REF)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetEntityRefs())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ActorsImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ActorsImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        AddEntityActionImpl::AddEntityActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IPosition> AddEntityActionImpl::GetPosition() const
        {
            return _position;
        }

        void AddEntityActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType AddEntityActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AddEntityActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AddEntityActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<AddEntityActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            return clonedObject;
        }

        std::string AddEntityActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AddEntityActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AddEntityActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AddEntityActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AddEntityActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        AssignControllerActionImpl::AssignControllerActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IController> AssignControllerActionImpl::GetController() const
        {
            return _controller;
        }
        std::shared_ptr<ICatalogReference> AssignControllerActionImpl::GetCatalogReference() const
        {
            return _catalogReference;
        }

        void AssignControllerActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType AssignControllerActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AssignControllerActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kController =  GetWriterController();
                if (kController)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kController));
                }
                const auto kCatalogReference =  GetWriterCatalogReference();
                if (kCatalogReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogReference));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AssignControllerActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<AssignControllerActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kController =  GetWriterController();
            if (kController)
            {
                auto clonedChild = std::dynamic_pointer_cast<ControllerImpl>(kController)->Clone();
                auto clonedChildIController = std::dynamic_pointer_cast<IController>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetController(std::dynamic_pointer_cast<IControllerWriter>(clonedChildIController));
            }
            const auto kCatalogReference =  GetWriterCatalogReference();
            if (kCatalogReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kCatalogReference)->Clone();
                auto clonedChildICatalogReference = std::dynamic_pointer_cast<ICatalogReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogReference(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChildICatalogReference));
            }
            return clonedObject;
        }

        std::string AssignControllerActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AssignControllerActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CONTROLLER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetController());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogReference());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AssignControllerActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AssignControllerActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AssignControllerActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        AssignRouteActionImpl::AssignRouteActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IRoute> AssignRouteActionImpl::GetRoute() const
        {
            return _route;
        }
        std::shared_ptr<ICatalogReference> AssignRouteActionImpl::GetCatalogReference() const
        {
            return _catalogReference;
        }

        void AssignRouteActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType AssignRouteActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AssignRouteActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRoute =  GetWriterRoute();
                if (kRoute)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRoute));
                }
                const auto kCatalogReference =  GetWriterCatalogReference();
                if (kCatalogReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogReference));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AssignRouteActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<AssignRouteActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kRoute =  GetWriterRoute();
            if (kRoute)
            {
                auto clonedChild = std::dynamic_pointer_cast<RouteImpl>(kRoute)->Clone();
                auto clonedChildIRoute = std::dynamic_pointer_cast<IRoute>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRoute(std::dynamic_pointer_cast<IRouteWriter>(clonedChildIRoute));
            }
            const auto kCatalogReference =  GetWriterCatalogReference();
            if (kCatalogReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kCatalogReference)->Clone();
                auto clonedChildICatalogReference = std::dynamic_pointer_cast<ICatalogReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogReference(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChildICatalogReference));
            }
            return clonedObject;
        }

        std::string AssignRouteActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AssignRouteActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ROUTE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRoute());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogReference());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AssignRouteActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AssignRouteActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AssignRouteActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        AxleImpl::AxleImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_STEERING, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__POSITION_X, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__POSITION_Z, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TRACK_WIDTH, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__WHEEL_DIAMETER, SimpleType::DOUBLE);
        }

        double AxleImpl::GetMaxSteering() const
        {
            return _maxSteering;
        }
        double AxleImpl::GetPositionX() const
        {
            return _positionX;
        }
        double AxleImpl::GetPositionZ() const
        {
            return _positionZ;
        }
        double AxleImpl::GetTrackWidth() const
        {
            return _trackWidth;
        }
        double AxleImpl::GetWheelDiameter() const
        {
            return _wheelDiameter;
        }

        void AxleImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_STEERING)
            {
                // Simple type
                _maxSteering = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__POSITION_X)
            {
                // Simple type
                _positionX = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__POSITION_Z)
            {
                // Simple type
                _positionZ = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRACK_WIDTH)
            {
                // Simple type
                _trackWidth = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WHEEL_DIAMETER)
            {
                // Simple type
                _wheelDiameter = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType AxleImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AxleImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AxleImpl::Clone()
        {
            auto clonedObject = std::make_shared<AxleImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_maxSteering = GetMaxSteering();
            // Simple type
            clonedObject->_positionX = GetPositionX();
            // Simple type
            clonedObject->_positionZ = GetPositionZ();
            // Simple type
            clonedObject->_trackWidth = GetTrackWidth();
            // Simple type
            clonedObject->_wheelDiameter = GetWheelDiameter();
            // clone children
            return clonedObject;
        }

        std::string AxleImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AxleImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AxleImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AxleImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AxleImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        AxlesImpl::AxlesImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IAxle> AxlesImpl::GetFrontAxle() const
        {
            return _frontAxle;
        }
        std::shared_ptr<IAxle> AxlesImpl::GetRearAxle() const
        {
            return _rearAxle;
        }
        std::vector<std::shared_ptr<IAxle>> AxlesImpl::GetAdditionalAxles() const
        {
            std::vector<std::shared_ptr<IAxle>> temp;
            for(auto&& elm: _additionalAxles)
                temp.push_back(elm);
            return temp;
        }

        void AxlesImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType AxlesImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> AxlesImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kFrontAxle =  GetWriterFrontAxle();
                if (kFrontAxle)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kFrontAxle));
                }
                const auto kRearAxle =  GetWriterRearAxle();
                if (kRearAxle)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRearAxle));
                }
                auto additionalAxles =  GetWriterAdditionalAxles();
                if (!additionalAxles.empty())
                {
                    for(auto&& item : additionalAxles)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> AxlesImpl::Clone()
        {
            auto clonedObject = std::make_shared<AxlesImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kFrontAxle =  GetWriterFrontAxle();
            if (kFrontAxle)
            {
                auto clonedChild = std::dynamic_pointer_cast<AxleImpl>(kFrontAxle)->Clone();
                auto clonedChildIAxle = std::dynamic_pointer_cast<IAxle>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetFrontAxle(std::dynamic_pointer_cast<IAxleWriter>(clonedChildIAxle));
            }
            const auto kRearAxle =  GetWriterRearAxle();
            if (kRearAxle)
            {
                auto clonedChild = std::dynamic_pointer_cast<AxleImpl>(kRearAxle)->Clone();
                auto clonedChildIAxle = std::dynamic_pointer_cast<IAxle>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRearAxle(std::dynamic_pointer_cast<IAxleWriter>(clonedChildIAxle));
            }
            const auto kAdditionalAxles =  GetWriterAdditionalAxles();
            if (!kAdditionalAxles.empty())
            {
                std::vector<std::shared_ptr<IAxleWriter>> clonedList;
                for(auto&& kItem : kAdditionalAxles)
                {
                    auto clonedChild = std::dynamic_pointer_cast<AxleImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IAxleWriter>(clonedChild));
                }
                clonedObject->SetAdditionalAxles(clonedList);
            }
            return clonedObject;
        }

        std::string AxlesImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AxlesImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__FRONT_AXLE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetFrontAxle());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__REAR_AXLE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRearAxle());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> AxlesImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__ADDITIONAL_AXLE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetAdditionalAxles())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> AxlesImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string AxlesImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        BoundingBoxImpl::BoundingBoxImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<ICenter> BoundingBoxImpl::GetCenter() const
        {
            return _center;
        }
        std::shared_ptr<IDimensions> BoundingBoxImpl::GetDimensions() const
        {
            return _dimensions;
        }

        void BoundingBoxImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType BoundingBoxImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> BoundingBoxImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kCenter =  GetWriterCenter();
                if (kCenter)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCenter));
                }
                const auto kDimensions =  GetWriterDimensions();
                if (kDimensions)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDimensions));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> BoundingBoxImpl::Clone()
        {
            auto clonedObject = std::make_shared<BoundingBoxImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kCenter =  GetWriterCenter();
            if (kCenter)
            {
                auto clonedChild = std::dynamic_pointer_cast<CenterImpl>(kCenter)->Clone();
                auto clonedChildICenter = std::dynamic_pointer_cast<ICenter>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCenter(std::dynamic_pointer_cast<ICenterWriter>(clonedChildICenter));
            }
            const auto kDimensions =  GetWriterDimensions();
            if (kDimensions)
            {
                auto clonedChild = std::dynamic_pointer_cast<DimensionsImpl>(kDimensions)->Clone();
                auto clonedChildIDimensions = std::dynamic_pointer_cast<IDimensions>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDimensions(std::dynamic_pointer_cast<IDimensionsWriter>(clonedChildIDimensions));
            }
            return clonedObject;
        }

        std::string BoundingBoxImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> BoundingBoxImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CENTER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCenter());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIMENSIONS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDimensions());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> BoundingBoxImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> BoundingBoxImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string BoundingBoxImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ByEntityConditionImpl::ByEntityConditionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<ITriggeringEntities> ByEntityConditionImpl::GetTriggeringEntities() const
        {
            return _triggeringEntities;
        }
        std::shared_ptr<IEntityCondition> ByEntityConditionImpl::GetEntityCondition() const
        {
            return _entityCondition;
        }

        void ByEntityConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ByEntityConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ByEntityConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kTriggeringEntities =  GetWriterTriggeringEntities();
                if (kTriggeringEntities)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTriggeringEntities));
                }
                const auto kEntityCondition =  GetWriterEntityCondition();
                if (kEntityCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEntityCondition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ByEntityConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ByEntityConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kTriggeringEntities =  GetWriterTriggeringEntities();
            if (kTriggeringEntities)
            {
                auto clonedChild = std::dynamic_pointer_cast<TriggeringEntitiesImpl>(kTriggeringEntities)->Clone();
                auto clonedChildITriggeringEntities = std::dynamic_pointer_cast<ITriggeringEntities>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTriggeringEntities(std::dynamic_pointer_cast<ITriggeringEntitiesWriter>(clonedChildITriggeringEntities));
            }
            const auto kEntityCondition =  GetWriterEntityCondition();
            if (kEntityCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<EntityConditionImpl>(kEntityCondition)->Clone();
                auto clonedChildIEntityCondition = std::dynamic_pointer_cast<IEntityCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEntityCondition(std::dynamic_pointer_cast<IEntityConditionWriter>(clonedChildIEntityCondition));
            }
            return clonedObject;
        }

        std::string ByEntityConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ByEntityConditionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRIGGERING_ENTITIES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTriggeringEntities());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEntityCondition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ByEntityConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ByEntityConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ByEntityConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ByObjectTypeImpl::ByObjectTypeImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TYPE, SimpleType::ENUM_TYPE);
        }

        ObjectType ByObjectTypeImpl::GetType() const
        {
            return _type;
        }

        void ByObjectTypeImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TYPE)
            {
                // Enumeration Type
                const auto kResult = ObjectType::GetFromLiteral(parameterLiteralValue);
                if (kResult != ObjectType::UNKNOWN)
                {
                    _type = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType ByObjectTypeImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ByObjectTypeImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ByObjectTypeImpl::Clone()
        {
            auto clonedObject = std::make_shared<ByObjectTypeImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Enumeration Type
            const auto kType = GetType();
            if ( kType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_type = ObjectType::GetFromLiteral(kType.GetLiteral());
            }
            // clone children
            return clonedObject;
        }

        std::string ByObjectTypeImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ByObjectTypeImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ByObjectTypeImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ByObjectTypeImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ByObjectTypeImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__TYPE)
            {
                auto type = GetType();
                return type.GetLiteral() != "UNKNOWN" ? type.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        ByTypeImpl::ByTypeImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__OBJECT_TYPE, SimpleType::ENUM_TYPE);
        }

        ObjectType ByTypeImpl::GetObjectType() const
        {
            return _objectType;
        }

        void ByTypeImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__OBJECT_TYPE)
            {
                // Enumeration Type
                const auto kResult = ObjectType::GetFromLiteral(parameterLiteralValue);
                if (kResult != ObjectType::UNKNOWN)
                {
                    _objectType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType ByTypeImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ByTypeImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ByTypeImpl::Clone()
        {
            auto clonedObject = std::make_shared<ByTypeImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Enumeration Type
            const auto kObjectType = GetObjectType();
            if ( kObjectType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_objectType = ObjectType::GetFromLiteral(kObjectType.GetLiteral());
            }
            // clone children
            return clonedObject;
        }

        std::string ByTypeImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ByTypeImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ByTypeImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ByTypeImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ByTypeImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__OBJECT_TYPE)
            {
                auto objectType = GetObjectType();
                return objectType.GetLiteral() != "UNKNOWN" ? objectType.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        ByValueConditionImpl::ByValueConditionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IParameterCondition> ByValueConditionImpl::GetParameterCondition() const
        {
            return _parameterCondition;
        }
        std::shared_ptr<ITimeOfDayCondition> ByValueConditionImpl::GetTimeOfDayCondition() const
        {
            return _timeOfDayCondition;
        }
        std::shared_ptr<ISimulationTimeCondition> ByValueConditionImpl::GetSimulationTimeCondition() const
        {
            return _simulationTimeCondition;
        }
        std::shared_ptr<IStoryboardElementStateCondition> ByValueConditionImpl::GetStoryboardElementStateCondition() const
        {
            return _storyboardElementStateCondition;
        }
        std::shared_ptr<IUserDefinedValueCondition> ByValueConditionImpl::GetUserDefinedValueCondition() const
        {
            return _userDefinedValueCondition;
        }
        std::shared_ptr<ITrafficSignalCondition> ByValueConditionImpl::GetTrafficSignalCondition() const
        {
            return _trafficSignalCondition;
        }
        std::shared_ptr<ITrafficSignalControllerCondition> ByValueConditionImpl::GetTrafficSignalControllerCondition() const
        {
            return _trafficSignalControllerCondition;
        }

        void ByValueConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ByValueConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ByValueConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kParameterCondition =  GetWriterParameterCondition();
                if (kParameterCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kParameterCondition));
                }
                const auto kTimeOfDayCondition =  GetWriterTimeOfDayCondition();
                if (kTimeOfDayCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTimeOfDayCondition));
                }
                const auto kSimulationTimeCondition =  GetWriterSimulationTimeCondition();
                if (kSimulationTimeCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSimulationTimeCondition));
                }
                const auto kStoryboardElementStateCondition =  GetWriterStoryboardElementStateCondition();
                if (kStoryboardElementStateCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kStoryboardElementStateCondition));
                }
                const auto kUserDefinedValueCondition =  GetWriterUserDefinedValueCondition();
                if (kUserDefinedValueCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kUserDefinedValueCondition));
                }
                const auto kTrafficSignalCondition =  GetWriterTrafficSignalCondition();
                if (kTrafficSignalCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficSignalCondition));
                }
                const auto kTrafficSignalControllerCondition =  GetWriterTrafficSignalControllerCondition();
                if (kTrafficSignalControllerCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficSignalControllerCondition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ByValueConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ByValueConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kParameterCondition =  GetWriterParameterCondition();
            if (kParameterCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<ParameterConditionImpl>(kParameterCondition)->Clone();
                auto clonedChildIParameterCondition = std::dynamic_pointer_cast<IParameterCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetParameterCondition(std::dynamic_pointer_cast<IParameterConditionWriter>(clonedChildIParameterCondition));
            }
            const auto kTimeOfDayCondition =  GetWriterTimeOfDayCondition();
            if (kTimeOfDayCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TimeOfDayConditionImpl>(kTimeOfDayCondition)->Clone();
                auto clonedChildITimeOfDayCondition = std::dynamic_pointer_cast<ITimeOfDayCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTimeOfDayCondition(std::dynamic_pointer_cast<ITimeOfDayConditionWriter>(clonedChildITimeOfDayCondition));
            }
            const auto kSimulationTimeCondition =  GetWriterSimulationTimeCondition();
            if (kSimulationTimeCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<SimulationTimeConditionImpl>(kSimulationTimeCondition)->Clone();
                auto clonedChildISimulationTimeCondition = std::dynamic_pointer_cast<ISimulationTimeCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSimulationTimeCondition(std::dynamic_pointer_cast<ISimulationTimeConditionWriter>(clonedChildISimulationTimeCondition));
            }
            const auto kStoryboardElementStateCondition =  GetWriterStoryboardElementStateCondition();
            if (kStoryboardElementStateCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<StoryboardElementStateConditionImpl>(kStoryboardElementStateCondition)->Clone();
                auto clonedChildIStoryboardElementStateCondition = std::dynamic_pointer_cast<IStoryboardElementStateCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetStoryboardElementStateCondition(std::dynamic_pointer_cast<IStoryboardElementStateConditionWriter>(clonedChildIStoryboardElementStateCondition));
            }
            const auto kUserDefinedValueCondition =  GetWriterUserDefinedValueCondition();
            if (kUserDefinedValueCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<UserDefinedValueConditionImpl>(kUserDefinedValueCondition)->Clone();
                auto clonedChildIUserDefinedValueCondition = std::dynamic_pointer_cast<IUserDefinedValueCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetUserDefinedValueCondition(std::dynamic_pointer_cast<IUserDefinedValueConditionWriter>(clonedChildIUserDefinedValueCondition));
            }
            const auto kTrafficSignalCondition =  GetWriterTrafficSignalCondition();
            if (kTrafficSignalCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficSignalConditionImpl>(kTrafficSignalCondition)->Clone();
                auto clonedChildITrafficSignalCondition = std::dynamic_pointer_cast<ITrafficSignalCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficSignalCondition(std::dynamic_pointer_cast<ITrafficSignalConditionWriter>(clonedChildITrafficSignalCondition));
            }
            const auto kTrafficSignalControllerCondition =  GetWriterTrafficSignalControllerCondition();
            if (kTrafficSignalControllerCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficSignalControllerConditionImpl>(kTrafficSignalControllerCondition)->Clone();
                auto clonedChildITrafficSignalControllerCondition = std::dynamic_pointer_cast<ITrafficSignalControllerCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficSignalControllerCondition(std::dynamic_pointer_cast<ITrafficSignalControllerConditionWriter>(clonedChildITrafficSignalControllerCondition));
            }
            return clonedObject;
        }

        std::string ByValueConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ByValueConditionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParameterCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TIME_OF_DAY_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTimeOfDayCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SIMULATION_TIME_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSimulationTimeCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__STORYBOARD_ELEMENT_STATE_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetStoryboardElementStateCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__USER_DEFINED_VALUE_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetUserDefinedValueCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SIGNAL_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficSignalCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SIGNAL_CONTROLLER_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficSignalControllerCondition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ByValueConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ByValueConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ByValueConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        CatalogImpl::CatalogImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        std::string CatalogImpl::GetName() const
        {
            return _name;
        }
        std::vector<std::shared_ptr<IVehicle>> CatalogImpl::GetVehicles() const
        {
            std::vector<std::shared_ptr<IVehicle>> temp;
            for(auto&& elm: _vehicles)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IController>> CatalogImpl::GetControllers() const
        {
            std::vector<std::shared_ptr<IController>> temp;
            for(auto&& elm: _controllers)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IPedestrian>> CatalogImpl::GetPedestrians() const
        {
            std::vector<std::shared_ptr<IPedestrian>> temp;
            for(auto&& elm: _pedestrians)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IMiscObject>> CatalogImpl::GetMiscObjects() const
        {
            std::vector<std::shared_ptr<IMiscObject>> temp;
            for(auto&& elm: _miscObjects)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IEnvironment>> CatalogImpl::GetEnvironments() const
        {
            std::vector<std::shared_ptr<IEnvironment>> temp;
            for(auto&& elm: _environments)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IManeuver>> CatalogImpl::GetManeuvers() const
        {
            std::vector<std::shared_ptr<IManeuver>> temp;
            for(auto&& elm: _maneuvers)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<ITrajectory>> CatalogImpl::GetTrajectories() const
        {
            std::vector<std::shared_ptr<ITrajectory>> temp;
            for(auto&& elm: _trajectories)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IRoute>> CatalogImpl::GetRoutes() const
        {
            std::vector<std::shared_ptr<IRoute>> temp;
            for(auto&& elm: _routes)
                temp.push_back(elm);
            return temp;
        }

        void CatalogImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType CatalogImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> CatalogImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto vehicles =  GetWriterVehicles();
                if (!vehicles.empty())
                {
                    for(auto&& item : vehicles)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto controllers =  GetWriterControllers();
                if (!controllers.empty())
                {
                    for(auto&& item : controllers)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto pedestrians =  GetWriterPedestrians();
                if (!pedestrians.empty())
                {
                    for(auto&& item : pedestrians)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto miscObjects =  GetWriterMiscObjects();
                if (!miscObjects.empty())
                {
                    for(auto&& item : miscObjects)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto environments =  GetWriterEnvironments();
                if (!environments.empty())
                {
                    for(auto&& item : environments)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto maneuvers =  GetWriterManeuvers();
                if (!maneuvers.empty())
                {
                    for(auto&& item : maneuvers)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto trajectories =  GetWriterTrajectories();
                if (!trajectories.empty())
                {
                    for(auto&& item : trajectories)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto routes =  GetWriterRoutes();
                if (!routes.empty())
                {
                    for(auto&& item : routes)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> CatalogImpl::Clone()
        {
            auto clonedObject = std::make_shared<CatalogImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone children
            const auto kVehicles =  GetWriterVehicles();
            if (!kVehicles.empty())
            {
                std::vector<std::shared_ptr<IVehicleWriter>> clonedList;
                for(auto&& kItem : kVehicles)
                {
                    auto clonedChild = std::dynamic_pointer_cast<VehicleImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IVehicleWriter>(clonedChild));
                }
                clonedObject->SetVehicles(clonedList);
            }
            const auto kControllers =  GetWriterControllers();
            if (!kControllers.empty())
            {
                std::vector<std::shared_ptr<IControllerWriter>> clonedList;
                for(auto&& kItem : kControllers)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ControllerImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IControllerWriter>(clonedChild));
                }
                clonedObject->SetControllers(clonedList);
            }
            const auto kPedestrians =  GetWriterPedestrians();
            if (!kPedestrians.empty())
            {
                std::vector<std::shared_ptr<IPedestrianWriter>> clonedList;
                for(auto&& kItem : kPedestrians)
                {
                    auto clonedChild = std::dynamic_pointer_cast<PedestrianImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IPedestrianWriter>(clonedChild));
                }
                clonedObject->SetPedestrians(clonedList);
            }
            const auto kMiscObjects =  GetWriterMiscObjects();
            if (!kMiscObjects.empty())
            {
                std::vector<std::shared_ptr<IMiscObjectWriter>> clonedList;
                for(auto&& kItem : kMiscObjects)
                {
                    auto clonedChild = std::dynamic_pointer_cast<MiscObjectImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IMiscObjectWriter>(clonedChild));
                }
                clonedObject->SetMiscObjects(clonedList);
            }
            const auto kEnvironments =  GetWriterEnvironments();
            if (!kEnvironments.empty())
            {
                std::vector<std::shared_ptr<IEnvironmentWriter>> clonedList;
                for(auto&& kItem : kEnvironments)
                {
                    auto clonedChild = std::dynamic_pointer_cast<EnvironmentImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IEnvironmentWriter>(clonedChild));
                }
                clonedObject->SetEnvironments(clonedList);
            }
            const auto kManeuvers =  GetWriterManeuvers();
            if (!kManeuvers.empty())
            {
                std::vector<std::shared_ptr<IManeuverWriter>> clonedList;
                for(auto&& kItem : kManeuvers)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ManeuverImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IManeuverWriter>(clonedChild));
                }
                clonedObject->SetManeuvers(clonedList);
            }
            const auto kTrajectories =  GetWriterTrajectories();
            if (!kTrajectories.empty())
            {
                std::vector<std::shared_ptr<ITrajectoryWriter>> clonedList;
                for(auto&& kItem : kTrajectories)
                {
                    auto clonedChild = std::dynamic_pointer_cast<TrajectoryImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<ITrajectoryWriter>(clonedChild));
                }
                clonedObject->SetTrajectories(clonedList);
            }
            const auto kRoutes =  GetWriterRoutes();
            if (!kRoutes.empty())
            {
                std::vector<std::shared_ptr<IRouteWriter>> clonedList;
                for(auto&& kItem : kRoutes)
                {
                    auto clonedChild = std::dynamic_pointer_cast<RouteImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IRouteWriter>(clonedChild));
                }
                clonedObject->SetRoutes(clonedList);
            }
            return clonedObject;
        }

        std::string CatalogImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CatalogImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> CatalogImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__VEHICLE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetVehicles())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__CONTROLLER)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetControllers())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__PEDESTRIAN)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetPedestrians())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__MISC_OBJECT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetMiscObjects())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__ENVIRONMENT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetEnvironments())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__MANEUVER)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetManeuvers())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__TRAJECTORY)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetTrajectories())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__ROUTE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetRoutes())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CatalogImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string CatalogImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        CatalogDefinitionImpl::CatalogDefinitionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<ICatalog> CatalogDefinitionImpl::GetCatalog() const
        {
            return _catalog;
        }

        void CatalogDefinitionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType CatalogDefinitionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> CatalogDefinitionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kCatalog =  GetWriterCatalog();
                if (kCatalog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalog));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> CatalogDefinitionImpl::Clone()
        {
            auto clonedObject = std::make_shared<CatalogDefinitionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kCatalog =  GetWriterCatalog();
            if (kCatalog)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogImpl>(kCatalog)->Clone();
                auto clonedChildICatalog = std::dynamic_pointer_cast<ICatalog>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalog(std::dynamic_pointer_cast<ICatalogWriter>(clonedChildICatalog));
            }
            return clonedObject;
        }

        std::string CatalogDefinitionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CatalogDefinitionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalog());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> CatalogDefinitionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CatalogDefinitionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string CatalogDefinitionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        CatalogLocationsImpl::CatalogLocationsImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IVehicleCatalogLocation> CatalogLocationsImpl::GetVehicleCatalog() const
        {
            return _vehicleCatalog;
        }
        std::shared_ptr<IControllerCatalogLocation> CatalogLocationsImpl::GetControllerCatalog() const
        {
            return _controllerCatalog;
        }
        std::shared_ptr<IPedestrianCatalogLocation> CatalogLocationsImpl::GetPedestrianCatalog() const
        {
            return _pedestrianCatalog;
        }
        std::shared_ptr<IMiscObjectCatalogLocation> CatalogLocationsImpl::GetMiscObjectCatalog() const
        {
            return _miscObjectCatalog;
        }
        std::shared_ptr<IEnvironmentCatalogLocation> CatalogLocationsImpl::GetEnvironmentCatalog() const
        {
            return _environmentCatalog;
        }
        std::shared_ptr<IManeuverCatalogLocation> CatalogLocationsImpl::GetManeuverCatalog() const
        {
            return _maneuverCatalog;
        }
        std::shared_ptr<ITrajectoryCatalogLocation> CatalogLocationsImpl::GetTrajectoryCatalog() const
        {
            return _trajectoryCatalog;
        }
        std::shared_ptr<IRouteCatalogLocation> CatalogLocationsImpl::GetRouteCatalog() const
        {
            return _routeCatalog;
        }

        void CatalogLocationsImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType CatalogLocationsImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> CatalogLocationsImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kVehicleCatalog =  GetWriterVehicleCatalog();
                if (kVehicleCatalog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kVehicleCatalog));
                }
                const auto kControllerCatalog =  GetWriterControllerCatalog();
                if (kControllerCatalog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kControllerCatalog));
                }
                const auto kPedestrianCatalog =  GetWriterPedestrianCatalog();
                if (kPedestrianCatalog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPedestrianCatalog));
                }
                const auto kMiscObjectCatalog =  GetWriterMiscObjectCatalog();
                if (kMiscObjectCatalog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kMiscObjectCatalog));
                }
                const auto kEnvironmentCatalog =  GetWriterEnvironmentCatalog();
                if (kEnvironmentCatalog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEnvironmentCatalog));
                }
                const auto kManeuverCatalog =  GetWriterManeuverCatalog();
                if (kManeuverCatalog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kManeuverCatalog));
                }
                const auto kTrajectoryCatalog =  GetWriterTrajectoryCatalog();
                if (kTrajectoryCatalog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrajectoryCatalog));
                }
                const auto kRouteCatalog =  GetWriterRouteCatalog();
                if (kRouteCatalog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRouteCatalog));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> CatalogLocationsImpl::Clone()
        {
            auto clonedObject = std::make_shared<CatalogLocationsImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kVehicleCatalog =  GetWriterVehicleCatalog();
            if (kVehicleCatalog)
            {
                auto clonedChild = std::dynamic_pointer_cast<VehicleCatalogLocationImpl>(kVehicleCatalog)->Clone();
                auto clonedChildIVehicleCatalogLocation = std::dynamic_pointer_cast<IVehicleCatalogLocation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetVehicleCatalog(std::dynamic_pointer_cast<IVehicleCatalogLocationWriter>(clonedChildIVehicleCatalogLocation));
            }
            const auto kControllerCatalog =  GetWriterControllerCatalog();
            if (kControllerCatalog)
            {
                auto clonedChild = std::dynamic_pointer_cast<ControllerCatalogLocationImpl>(kControllerCatalog)->Clone();
                auto clonedChildIControllerCatalogLocation = std::dynamic_pointer_cast<IControllerCatalogLocation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetControllerCatalog(std::dynamic_pointer_cast<IControllerCatalogLocationWriter>(clonedChildIControllerCatalogLocation));
            }
            const auto kPedestrianCatalog =  GetWriterPedestrianCatalog();
            if (kPedestrianCatalog)
            {
                auto clonedChild = std::dynamic_pointer_cast<PedestrianCatalogLocationImpl>(kPedestrianCatalog)->Clone();
                auto clonedChildIPedestrianCatalogLocation = std::dynamic_pointer_cast<IPedestrianCatalogLocation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPedestrianCatalog(std::dynamic_pointer_cast<IPedestrianCatalogLocationWriter>(clonedChildIPedestrianCatalogLocation));
            }
            const auto kMiscObjectCatalog =  GetWriterMiscObjectCatalog();
            if (kMiscObjectCatalog)
            {
                auto clonedChild = std::dynamic_pointer_cast<MiscObjectCatalogLocationImpl>(kMiscObjectCatalog)->Clone();
                auto clonedChildIMiscObjectCatalogLocation = std::dynamic_pointer_cast<IMiscObjectCatalogLocation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetMiscObjectCatalog(std::dynamic_pointer_cast<IMiscObjectCatalogLocationWriter>(clonedChildIMiscObjectCatalogLocation));
            }
            const auto kEnvironmentCatalog =  GetWriterEnvironmentCatalog();
            if (kEnvironmentCatalog)
            {
                auto clonedChild = std::dynamic_pointer_cast<EnvironmentCatalogLocationImpl>(kEnvironmentCatalog)->Clone();
                auto clonedChildIEnvironmentCatalogLocation = std::dynamic_pointer_cast<IEnvironmentCatalogLocation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEnvironmentCatalog(std::dynamic_pointer_cast<IEnvironmentCatalogLocationWriter>(clonedChildIEnvironmentCatalogLocation));
            }
            const auto kManeuverCatalog =  GetWriterManeuverCatalog();
            if (kManeuverCatalog)
            {
                auto clonedChild = std::dynamic_pointer_cast<ManeuverCatalogLocationImpl>(kManeuverCatalog)->Clone();
                auto clonedChildIManeuverCatalogLocation = std::dynamic_pointer_cast<IManeuverCatalogLocation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetManeuverCatalog(std::dynamic_pointer_cast<IManeuverCatalogLocationWriter>(clonedChildIManeuverCatalogLocation));
            }
            const auto kTrajectoryCatalog =  GetWriterTrajectoryCatalog();
            if (kTrajectoryCatalog)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrajectoryCatalogLocationImpl>(kTrajectoryCatalog)->Clone();
                auto clonedChildITrajectoryCatalogLocation = std::dynamic_pointer_cast<ITrajectoryCatalogLocation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrajectoryCatalog(std::dynamic_pointer_cast<ITrajectoryCatalogLocationWriter>(clonedChildITrajectoryCatalogLocation));
            }
            const auto kRouteCatalog =  GetWriterRouteCatalog();
            if (kRouteCatalog)
            {
                auto clonedChild = std::dynamic_pointer_cast<RouteCatalogLocationImpl>(kRouteCatalog)->Clone();
                auto clonedChildIRouteCatalogLocation = std::dynamic_pointer_cast<IRouteCatalogLocation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRouteCatalog(std::dynamic_pointer_cast<IRouteCatalogLocationWriter>(clonedChildIRouteCatalogLocation));
            }
            return clonedObject;
        }

        std::string CatalogLocationsImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CatalogLocationsImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__VEHICLE_CATALOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetVehicleCatalog());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CONTROLLER_CATALOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetControllerCatalog());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PEDESTRIAN_CATALOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPedestrianCatalog());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__MISC_OBJECT_CATALOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetMiscObjectCatalog());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ENVIRONMENT_CATALOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEnvironmentCatalog());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__MANEUVER_CATALOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetManeuverCatalog());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAJECTORY_CATALOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrajectoryCatalog());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ROUTE_CATALOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRouteCatalog());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> CatalogLocationsImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CatalogLocationsImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string CatalogLocationsImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        CatalogReferenceImpl::CatalogReferenceImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CATALOG_NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTRY_NAME, SimpleType::STRING);
        }

        std::string CatalogReferenceImpl::GetCatalogName() const
        {
            return _catalogName;
        }
        std::string CatalogReferenceImpl::GetEntryName() const
        {
            return _entryName;
        }
        std::vector<std::shared_ptr<IParameterAssignment>> CatalogReferenceImpl::GetParameterAssignments() const
        {
            std::vector<std::shared_ptr<IParameterAssignment>> temp;
            for(auto&& elm: _parameterAssignments)
                temp.push_back(elm);
            return temp;
        }
        std::shared_ptr<ICatalogElement> CatalogReferenceImpl::GetRef() const
        {
            return _ref;
        }

        void CatalogReferenceImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CATALOG_NAME)
            {
                // Simple type
                _catalogName = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTRY_NAME)
            {
                // Simple type
                _entryName = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType CatalogReferenceImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> CatalogReferenceImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterAssignments =  GetWriterParameterAssignments();
                if (!parameterAssignments.empty())
                {
                    for(auto&& item : parameterAssignments)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> CatalogReferenceImpl::Clone()
        {
            auto clonedObject = std::make_shared<CatalogReferenceImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_catalogName = GetCatalogName();
            // Simple type
            clonedObject->_entryName = GetEntryName();
            // clone children
            const auto kParameterAssignments =  GetWriterParameterAssignments();
            if (!kParameterAssignments.empty())
            {
                std::vector<std::shared_ptr<IParameterAssignmentWriter>> clonedList;
                for(auto&& kItem : kParameterAssignments)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterAssignmentImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterAssignmentWriter>(clonedChild));
                }
                clonedObject->SetParameterAssignments(clonedList);
            }
            return clonedObject;
        }

        std::string CatalogReferenceImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__CATALOG_NAME)
            {
                return GetCatalogName();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTRY_NAME)
            {
                return GetEntryName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CatalogReferenceImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> CatalogReferenceImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_ASSIGNMENT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterAssignments())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CatalogReferenceImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string CatalogReferenceImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        CenterImpl::CenterImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__X, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__Y, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__Z, SimpleType::DOUBLE);
        }

        double CenterImpl::GetX() const
        {
            return _x;
        }
        double CenterImpl::GetY() const
        {
            return _y;
        }
        double CenterImpl::GetZ() const
        {
            return _z;
        }

        void CenterImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__X)
            {
                // Simple type
                _x = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__Y)
            {
                // Simple type
                _y = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__Z)
            {
                // Simple type
                _z = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType CenterImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> CenterImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> CenterImpl::Clone()
        {
            auto clonedObject = std::make_shared<CenterImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_x = GetX();
            // Simple type
            clonedObject->_y = GetY();
            // Simple type
            clonedObject->_z = GetZ();
            // clone children
            return clonedObject;
        }

        std::string CenterImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CenterImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> CenterImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CenterImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string CenterImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        CentralSwarmObjectImpl::CentralSwarmObjectImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
        }

        std::shared_ptr<INamedReference<IEntity>> CentralSwarmObjectImpl::GetEntityRef() const
        {
            return _entityRef;
        }

        void CentralSwarmObjectImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType CentralSwarmObjectImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> CentralSwarmObjectImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> CentralSwarmObjectImpl::Clone()
        {
            auto clonedObject = std::make_shared<CentralSwarmObjectImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // clone children
            return clonedObject;
        }

        std::string CentralSwarmObjectImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CentralSwarmObjectImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> CentralSwarmObjectImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CentralSwarmObjectImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string CentralSwarmObjectImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ClothoidImpl::ClothoidImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CURVATURE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CURVATURE_DOT, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LENGTH, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__START_TIME, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__STOP_TIME, SimpleType::DOUBLE);
        }

        double ClothoidImpl::GetCurvature() const
        {
            return _curvature;
        }
        double ClothoidImpl::GetCurvatureDot() const
        {
            return _curvatureDot;
        }
        double ClothoidImpl::GetLength() const
        {
            return _length;
        }
        double ClothoidImpl::GetStartTime() const
        {
            return _startTime;
        }
        double ClothoidImpl::GetStopTime() const
        {
            return _stopTime;
        }
        std::shared_ptr<IPosition> ClothoidImpl::GetPosition() const
        {
            return _position;
        }

        void ClothoidImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CURVATURE)
            {
                // Simple type
                _curvature = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CURVATURE_DOT)
            {
                // Simple type
                _curvatureDot = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LENGTH)
            {
                // Simple type
                _length = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__START_TIME)
            {
                // Simple type
                _startTime = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STOP_TIME)
            {
                // Simple type
                _stopTime = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ClothoidImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ClothoidImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ClothoidImpl::Clone()
        {
            auto clonedObject = std::make_shared<ClothoidImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_curvature = GetCurvature();
            // Simple type
            clonedObject->_curvatureDot = GetCurvatureDot();
            // Simple type
            clonedObject->_length = GetLength();
            // Simple type
            clonedObject->_startTime = GetStartTime();
            // Simple type
            clonedObject->_stopTime = GetStopTime();
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            return clonedObject;
        }

        std::string ClothoidImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ClothoidImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ClothoidImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ClothoidImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ClothoidImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        CollisionConditionImpl::CollisionConditionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IEntityRef> CollisionConditionImpl::GetEntityRef() const
        {
            return _entityRef;
        }
        std::shared_ptr<IByObjectType> CollisionConditionImpl::GetByType() const
        {
            return _byType;
        }

        void CollisionConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType CollisionConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> CollisionConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kEntityRef =  GetWriterEntityRef();
                if (kEntityRef)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEntityRef));
                }
                const auto kByType =  GetWriterByType();
                if (kByType)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kByType));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> CollisionConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<CollisionConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kEntityRef =  GetWriterEntityRef();
            if (kEntityRef)
            {
                auto clonedChild = std::dynamic_pointer_cast<EntityRefImpl>(kEntityRef)->Clone();
                auto clonedChildIEntityRef = std::dynamic_pointer_cast<IEntityRef>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEntityRef(std::dynamic_pointer_cast<IEntityRefWriter>(clonedChildIEntityRef));
            }
            const auto kByType =  GetWriterByType();
            if (kByType)
            {
                auto clonedChild = std::dynamic_pointer_cast<ByObjectTypeImpl>(kByType)->Clone();
                auto clonedChildIByObjectType = std::dynamic_pointer_cast<IByObjectType>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetByType(std::dynamic_pointer_cast<IByObjectTypeWriter>(clonedChildIByObjectType));
            }
            return clonedObject;
        }

        std::string CollisionConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CollisionConditionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_REF)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEntityRef());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BY_TYPE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetByType());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> CollisionConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CollisionConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string CollisionConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ConditionImpl::ConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CONDITION_EDGE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DELAY, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        ConditionEdge ConditionImpl::GetConditionEdge() const
        {
            return _conditionEdge;
        }
        double ConditionImpl::GetDelay() const
        {
            return _delay;
        }
        std::string ConditionImpl::GetName() const
        {
            return _name;
        }
        std::shared_ptr<IByEntityCondition> ConditionImpl::GetByEntityCondition() const
        {
            return _byEntityCondition;
        }
        std::shared_ptr<IByValueCondition> ConditionImpl::GetByValueCondition() const
        {
            return _byValueCondition;
        }

        void ConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONDITION_EDGE)
            {
                // Enumeration Type
                const auto kResult = ConditionEdge::GetFromLiteral(parameterLiteralValue);
                if (kResult != ConditionEdge::UNKNOWN)
                {
                    _conditionEdge = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DELAY)
            {
                // Simple type
                _delay = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kByEntityCondition =  GetWriterByEntityCondition();
                if (kByEntityCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kByEntityCondition));
                }
                const auto kByValueCondition =  GetWriterByValueCondition();
                if (kByValueCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kByValueCondition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Enumeration Type
            const auto kConditionEdge = GetConditionEdge();
            if ( kConditionEdge.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_conditionEdge = ConditionEdge::GetFromLiteral(kConditionEdge.GetLiteral());
            }
            // Simple type
            clonedObject->_delay = GetDelay();
            // Simple type
            clonedObject->_name = GetName();
            // clone children
            const auto kByEntityCondition =  GetWriterByEntityCondition();
            if (kByEntityCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<ByEntityConditionImpl>(kByEntityCondition)->Clone();
                auto clonedChildIByEntityCondition = std::dynamic_pointer_cast<IByEntityCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetByEntityCondition(std::dynamic_pointer_cast<IByEntityConditionWriter>(clonedChildIByEntityCondition));
            }
            const auto kByValueCondition =  GetWriterByValueCondition();
            if (kByValueCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<ByValueConditionImpl>(kByValueCondition)->Clone();
                auto clonedChildIByValueCondition = std::dynamic_pointer_cast<IByValueCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetByValueCondition(std::dynamic_pointer_cast<IByValueConditionWriter>(clonedChildIByValueCondition));
            }
            return clonedObject;
        }

        std::string ConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ConditionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BY_ENTITY_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetByEntityCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BY_VALUE_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetByValueCondition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__CONDITION_EDGE)
            {
                auto conditionEdge = GetConditionEdge();
                return conditionEdge.GetLiteral() != "UNKNOWN" ? conditionEdge.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        ConditionGroupImpl::ConditionGroupImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::vector<std::shared_ptr<ICondition>> ConditionGroupImpl::GetConditions() const
        {
            std::vector<std::shared_ptr<ICondition>> temp;
            for(auto&& elm: _conditions)
                temp.push_back(elm);
            return temp;
        }

        void ConditionGroupImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ConditionGroupImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ConditionGroupImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto conditions =  GetWriterConditions();
                if (!conditions.empty())
                {
                    for(auto&& item : conditions)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ConditionGroupImpl::Clone()
        {
            auto clonedObject = std::make_shared<ConditionGroupImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kConditions =  GetWriterConditions();
            if (!kConditions.empty())
            {
                std::vector<std::shared_ptr<IConditionWriter>> clonedList;
                for(auto&& kItem : kConditions)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ConditionImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IConditionWriter>(clonedChild));
                }
                clonedObject->SetConditions(clonedList);
            }
            return clonedObject;
        }

        std::string ConditionGroupImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ConditionGroupImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ConditionGroupImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__CONDITION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetConditions())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ConditionGroupImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ConditionGroupImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ControlPointImpl::ControlPointImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TIME, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__WEIGHT, SimpleType::DOUBLE);
        }

        double ControlPointImpl::GetTime() const
        {
            return _time;
        }
        double ControlPointImpl::GetWeight() const
        {
            return _weight;
        }
        std::shared_ptr<IPosition> ControlPointImpl::GetPosition() const
        {
            return _position;
        }

        void ControlPointImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TIME)
            {
                // Simple type
                _time = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
            {
                // Simple type
                _weight = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ControlPointImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ControlPointImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ControlPointImpl::Clone()
        {
            auto clonedObject = std::make_shared<ControlPointImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_time = GetTime();
            // Simple type
            clonedObject->_weight = GetWeight();
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            return clonedObject;
        }

        std::string ControlPointImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControlPointImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ControlPointImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControlPointImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ControlPointImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ControllerImpl::ControllerImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        std::string ControllerImpl::GetName() const
        {
            return _name;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> ControllerImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::shared_ptr<IProperties> ControllerImpl::GetProperties() const
        {
            return _properties;
        }

        void ControllerImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ControllerImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool ControllerImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> ControllerImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ControllerImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kProperties =  GetWriterProperties();
                if (kProperties)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kProperties));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ControllerImpl::Clone()
        {
            auto clonedObject = std::make_shared<ControllerImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kProperties =  GetWriterProperties();
            if (kProperties)
            {
                auto clonedChild = std::dynamic_pointer_cast<PropertiesImpl>(kProperties)->Clone();
                auto clonedChildIProperties = std::dynamic_pointer_cast<IProperties>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetProperties(std::dynamic_pointer_cast<IPropertiesWriter>(clonedChildIProperties));
            }
            return clonedObject;
        }

        std::string ControllerImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PROPERTIES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetProperties());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ControllerImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ControllerImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ControllerActionImpl::ControllerActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IAssignControllerAction> ControllerActionImpl::GetAssignControllerAction() const
        {
            return _assignControllerAction;
        }
        std::shared_ptr<IOverrideControllerValueAction> ControllerActionImpl::GetOverrideControllerValueAction() const
        {
            return _overrideControllerValueAction;
        }

        void ControllerActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ControllerActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ControllerActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kAssignControllerAction =  GetWriterAssignControllerAction();
                if (kAssignControllerAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAssignControllerAction));
                }
                const auto kOverrideControllerValueAction =  GetWriterOverrideControllerValueAction();
                if (kOverrideControllerValueAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOverrideControllerValueAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ControllerActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ControllerActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kAssignControllerAction =  GetWriterAssignControllerAction();
            if (kAssignControllerAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<AssignControllerActionImpl>(kAssignControllerAction)->Clone();
                auto clonedChildIAssignControllerAction = std::dynamic_pointer_cast<IAssignControllerAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAssignControllerAction(std::dynamic_pointer_cast<IAssignControllerActionWriter>(clonedChildIAssignControllerAction));
            }
            const auto kOverrideControllerValueAction =  GetWriterOverrideControllerValueAction();
            if (kOverrideControllerValueAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<OverrideControllerValueActionImpl>(kOverrideControllerValueAction)->Clone();
                auto clonedChildIOverrideControllerValueAction = std::dynamic_pointer_cast<IOverrideControllerValueAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOverrideControllerValueAction(std::dynamic_pointer_cast<IOverrideControllerValueActionWriter>(clonedChildIOverrideControllerValueAction));
            }
            return clonedObject;
        }

        std::string ControllerActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ASSIGN_CONTROLLER_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAssignControllerAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__OVERRIDE_CONTROLLER_VALUE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOverrideControllerValueAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ControllerActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ControllerActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ControllerCatalogLocationImpl::ControllerCatalogLocationImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IDirectory> ControllerCatalogLocationImpl::GetDirectory() const
        {
            return _directory;
        }

        void ControllerCatalogLocationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ControllerCatalogLocationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ControllerCatalogLocationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDirectory =  GetWriterDirectory();
                if (kDirectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDirectory));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ControllerCatalogLocationImpl::Clone()
        {
            auto clonedObject = std::make_shared<ControllerCatalogLocationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kDirectory =  GetWriterDirectory();
            if (kDirectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<DirectoryImpl>(kDirectory)->Clone();
                auto clonedChildIDirectory = std::dynamic_pointer_cast<IDirectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDirectory(std::dynamic_pointer_cast<IDirectoryWriter>(clonedChildIDirectory));
            }
            return clonedObject;
        }

        std::string ControllerCatalogLocationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerCatalogLocationImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIRECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDirectory());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ControllerCatalogLocationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerCatalogLocationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ControllerCatalogLocationImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ControllerDistributionImpl::ControllerDistributionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::vector<std::shared_ptr<IControllerDistributionEntry>> ControllerDistributionImpl::GetControllerDistributionEntries() const
        {
            std::vector<std::shared_ptr<IControllerDistributionEntry>> temp;
            for(auto&& elm: _controllerDistributionEntries)
                temp.push_back(elm);
            return temp;
        }

        void ControllerDistributionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ControllerDistributionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ControllerDistributionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto controllerDistributionEntries =  GetWriterControllerDistributionEntries();
                if (!controllerDistributionEntries.empty())
                {
                    for(auto&& item : controllerDistributionEntries)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ControllerDistributionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ControllerDistributionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kControllerDistributionEntries =  GetWriterControllerDistributionEntries();
            if (!kControllerDistributionEntries.empty())
            {
                std::vector<std::shared_ptr<IControllerDistributionEntryWriter>> clonedList;
                for(auto&& kItem : kControllerDistributionEntries)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ControllerDistributionEntryImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IControllerDistributionEntryWriter>(clonedChild));
                }
                clonedObject->SetControllerDistributionEntries(clonedList);
            }
            return clonedObject;
        }

        std::string ControllerDistributionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerDistributionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ControllerDistributionImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__CONTROLLER_DISTRIBUTION_ENTRY)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetControllerDistributionEntries())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerDistributionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ControllerDistributionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ControllerDistributionEntryImpl::ControllerDistributionEntryImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__WEIGHT, SimpleType::DOUBLE);
        }

        double ControllerDistributionEntryImpl::GetWeight() const
        {
            return _weight;
        }
        std::shared_ptr<IController> ControllerDistributionEntryImpl::GetController() const
        {
            return _controller;
        }
        std::shared_ptr<ICatalogReference> ControllerDistributionEntryImpl::GetCatalogReference() const
        {
            return _catalogReference;
        }

        void ControllerDistributionEntryImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
            {
                // Simple type
                _weight = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ControllerDistributionEntryImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ControllerDistributionEntryImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kController =  GetWriterController();
                if (kController)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kController));
                }
                const auto kCatalogReference =  GetWriterCatalogReference();
                if (kCatalogReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogReference));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ControllerDistributionEntryImpl::Clone()
        {
            auto clonedObject = std::make_shared<ControllerDistributionEntryImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_weight = GetWeight();
            // clone children
            const auto kController =  GetWriterController();
            if (kController)
            {
                auto clonedChild = std::dynamic_pointer_cast<ControllerImpl>(kController)->Clone();
                auto clonedChildIController = std::dynamic_pointer_cast<IController>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetController(std::dynamic_pointer_cast<IControllerWriter>(clonedChildIController));
            }
            const auto kCatalogReference =  GetWriterCatalogReference();
            if (kCatalogReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kCatalogReference)->Clone();
                auto clonedChildICatalogReference = std::dynamic_pointer_cast<ICatalogReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogReference(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChildICatalogReference));
            }
            return clonedObject;
        }

        std::string ControllerDistributionEntryImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerDistributionEntryImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CONTROLLER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetController());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogReference());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ControllerDistributionEntryImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ControllerDistributionEntryImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ControllerDistributionEntryImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        CustomCommandActionImpl::CustomCommandActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CONTENT, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TYPE, SimpleType::STRING);
        }

        std::string CustomCommandActionImpl::GetContent() const
        {
            return _content;
        }
        std::string CustomCommandActionImpl::GetType() const
        {
            return _type;
        }

        void CustomCommandActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTENT)
            {
                // Simple type
                _content = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TYPE)
            {
                // Simple type
                _type = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType CustomCommandActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> CustomCommandActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> CustomCommandActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<CustomCommandActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_type = GetType();
            // clone children
            return clonedObject;
        }

        std::string CustomCommandActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__CONTENT)
            {
                return GetContent();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__TYPE)
            {
                return GetType();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CustomCommandActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> CustomCommandActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> CustomCommandActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string CustomCommandActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        DeleteEntityActionImpl::DeleteEntityActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }


        void DeleteEntityActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType DeleteEntityActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DeleteEntityActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DeleteEntityActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<DeleteEntityActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            return clonedObject;
        }

        std::string DeleteEntityActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DeleteEntityActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DeleteEntityActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DeleteEntityActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DeleteEntityActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        DimensionsImpl::DimensionsImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__HEIGHT, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LENGTH, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__WIDTH, SimpleType::DOUBLE);
        }

        double DimensionsImpl::GetHeight() const
        {
            return _height;
        }
        double DimensionsImpl::GetLength() const
        {
            return _length;
        }
        double DimensionsImpl::GetWidth() const
        {
            return _width;
        }

        void DimensionsImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__HEIGHT)
            {
                // Simple type
                _height = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LENGTH)
            {
                // Simple type
                _length = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WIDTH)
            {
                // Simple type
                _width = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType DimensionsImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DimensionsImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DimensionsImpl::Clone()
        {
            auto clonedObject = std::make_shared<DimensionsImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_height = GetHeight();
            // Simple type
            clonedObject->_length = GetLength();
            // Simple type
            clonedObject->_width = GetWidth();
            // clone children
            return clonedObject;
        }

        std::string DimensionsImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DimensionsImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DimensionsImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DimensionsImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DimensionsImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        DirectoryImpl::DirectoryImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PATH, SimpleType::STRING);
        }

        std::string DirectoryImpl::GetPath() const
        {
            return _path;
        }

        void DirectoryImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PATH)
            {
                // Simple type
                _path = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType DirectoryImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DirectoryImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DirectoryImpl::Clone()
        {
            auto clonedObject = std::make_shared<DirectoryImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_path = GetPath();
            // clone children
            return clonedObject;
        }

        std::string DirectoryImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PATH)
            {
                return GetPath();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DirectoryImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DirectoryImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DirectoryImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DirectoryImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        DistanceConditionImpl::DistanceConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FREESPACE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        bool DistanceConditionImpl::GetAlongRoute() const
        {
            return _alongRoute;
        }
        bool DistanceConditionImpl::GetFreespace() const
        {
            return _freespace;
        }
        Rule DistanceConditionImpl::GetRule() const
        {
            return _rule;
        }
        double DistanceConditionImpl::GetValue() const
        {
            return _value;
        }
        std::shared_ptr<IPosition> DistanceConditionImpl::GetPosition() const
        {
            return _position;
        }

        void DistanceConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE)
            {
                // Simple type
                _alongRoute = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
            {
                // Simple type
                _freespace = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType DistanceConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DistanceConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DistanceConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<DistanceConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_alongRoute = GetAlongRoute();
            // Simple type
            clonedObject->_freespace = GetFreespace();
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            return clonedObject;
        }

        std::string DistanceConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DistanceConditionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DistanceConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DistanceConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DistanceConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        DynamicConstraintsImpl::DynamicConstraintsImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED, SimpleType::DOUBLE);
        }

        double DynamicConstraintsImpl::GetMaxAcceleration() const
        {
            return _maxAcceleration;
        }
        double DynamicConstraintsImpl::GetMaxDeceleration() const
        {
            return _maxDeceleration;
        }
        double DynamicConstraintsImpl::GetMaxSpeed() const
        {
            return _maxSpeed;
        }

        void DynamicConstraintsImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION)
            {
                // Simple type
                _maxAcceleration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION)
            {
                // Simple type
                _maxDeceleration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED)
            {
                // Simple type
                _maxSpeed = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType DynamicConstraintsImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> DynamicConstraintsImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> DynamicConstraintsImpl::Clone()
        {
            auto clonedObject = std::make_shared<DynamicConstraintsImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_maxAcceleration = GetMaxAcceleration();
            // Simple type
            clonedObject->_maxDeceleration = GetMaxDeceleration();
            // Simple type
            clonedObject->_maxSpeed = GetMaxSpeed();
            // clone children
            return clonedObject;
        }

        std::string DynamicConstraintsImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DynamicConstraintsImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> DynamicConstraintsImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> DynamicConstraintsImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string DynamicConstraintsImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        EndOfRoadConditionImpl::EndOfRoadConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DURATION, SimpleType::DOUBLE);
        }

        double EndOfRoadConditionImpl::GetDuration() const
        {
            return _duration;
        }

        void EndOfRoadConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DURATION)
            {
                // Simple type
                _duration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType EndOfRoadConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EndOfRoadConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EndOfRoadConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<EndOfRoadConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_duration = GetDuration();
            // clone children
            return clonedObject;
        }

        std::string EndOfRoadConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EndOfRoadConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EndOfRoadConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EndOfRoadConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string EndOfRoadConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        EntitiesImpl::EntitiesImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::vector<std::shared_ptr<IScenarioObject>> EntitiesImpl::GetScenarioObjects() const
        {
            std::vector<std::shared_ptr<IScenarioObject>> temp;
            for(auto&& elm: _scenarioObjects)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IEntitySelection>> EntitiesImpl::GetEntitySelections() const
        {
            std::vector<std::shared_ptr<IEntitySelection>> temp;
            for(auto&& elm: _entitySelections)
                temp.push_back(elm);
            return temp;
        }

        void EntitiesImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType EntitiesImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EntitiesImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto scenarioObjects =  GetWriterScenarioObjects();
                if (!scenarioObjects.empty())
                {
                    for(auto&& item : scenarioObjects)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto entitySelections =  GetWriterEntitySelections();
                if (!entitySelections.empty())
                {
                    for(auto&& item : entitySelections)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EntitiesImpl::Clone()
        {
            auto clonedObject = std::make_shared<EntitiesImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kScenarioObjects =  GetWriterScenarioObjects();
            if (!kScenarioObjects.empty())
            {
                std::vector<std::shared_ptr<IScenarioObjectWriter>> clonedList;
                for(auto&& kItem : kScenarioObjects)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ScenarioObjectImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IScenarioObjectWriter>(clonedChild));
                }
                clonedObject->SetScenarioObjects(clonedList);
            }
            const auto kEntitySelections =  GetWriterEntitySelections();
            if (!kEntitySelections.empty())
            {
                std::vector<std::shared_ptr<IEntitySelectionWriter>> clonedList;
                for(auto&& kItem : kEntitySelections)
                {
                    auto clonedChild = std::dynamic_pointer_cast<EntitySelectionImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IEntitySelectionWriter>(clonedChild));
                }
                clonedObject->SetEntitySelections(clonedList);
            }
            return clonedObject;
        }

        std::string EntitiesImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntitiesImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EntitiesImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__SCENARIO_OBJECT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetScenarioObjects())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_SELECTION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetEntitySelections())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntitiesImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string EntitiesImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        EntityActionImpl::EntityActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
        }

        std::shared_ptr<INamedReference<IEntity>> EntityActionImpl::GetEntityRef() const
        {
            return _entityRef;
        }
        std::shared_ptr<IAddEntityAction> EntityActionImpl::GetAddEntityAction() const
        {
            return _addEntityAction;
        }
        std::shared_ptr<IDeleteEntityAction> EntityActionImpl::GetDeleteEntityAction() const
        {
            return _deleteEntityAction;
        }

        void EntityActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType EntityActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EntityActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kAddEntityAction =  GetWriterAddEntityAction();
                if (kAddEntityAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAddEntityAction));
                }
                const auto kDeleteEntityAction =  GetWriterDeleteEntityAction();
                if (kDeleteEntityAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDeleteEntityAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EntityActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<EntityActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // clone children
            const auto kAddEntityAction =  GetWriterAddEntityAction();
            if (kAddEntityAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<AddEntityActionImpl>(kAddEntityAction)->Clone();
                auto clonedChildIAddEntityAction = std::dynamic_pointer_cast<IAddEntityAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAddEntityAction(std::dynamic_pointer_cast<IAddEntityActionWriter>(clonedChildIAddEntityAction));
            }
            const auto kDeleteEntityAction =  GetWriterDeleteEntityAction();
            if (kDeleteEntityAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<DeleteEntityActionImpl>(kDeleteEntityAction)->Clone();
                auto clonedChildIDeleteEntityAction = std::dynamic_pointer_cast<IDeleteEntityAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDeleteEntityAction(std::dynamic_pointer_cast<IDeleteEntityActionWriter>(clonedChildIDeleteEntityAction));
            }
            return clonedObject;
        }

        std::string EntityActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntityActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ADD_ENTITY_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAddEntityAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DELETE_ENTITY_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDeleteEntityAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EntityActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntityActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string EntityActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        EntityConditionImpl::EntityConditionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IEndOfRoadCondition> EntityConditionImpl::GetEndOfRoadCondition() const
        {
            return _endOfRoadCondition;
        }
        std::shared_ptr<ICollisionCondition> EntityConditionImpl::GetCollisionCondition() const
        {
            return _collisionCondition;
        }
        std::shared_ptr<IOffroadCondition> EntityConditionImpl::GetOffroadCondition() const
        {
            return _offroadCondition;
        }
        std::shared_ptr<ITimeHeadwayCondition> EntityConditionImpl::GetTimeHeadwayCondition() const
        {
            return _timeHeadwayCondition;
        }
        std::shared_ptr<ITimeToCollisionCondition> EntityConditionImpl::GetTimeToCollisionCondition() const
        {
            return _timeToCollisionCondition;
        }
        std::shared_ptr<IAccelerationCondition> EntityConditionImpl::GetAccelerationCondition() const
        {
            return _accelerationCondition;
        }
        std::shared_ptr<IStandStillCondition> EntityConditionImpl::GetStandStillCondition() const
        {
            return _standStillCondition;
        }
        std::shared_ptr<ISpeedCondition> EntityConditionImpl::GetSpeedCondition() const
        {
            return _speedCondition;
        }
        std::shared_ptr<IRelativeSpeedCondition> EntityConditionImpl::GetRelativeSpeedCondition() const
        {
            return _relativeSpeedCondition;
        }
        std::shared_ptr<ITraveledDistanceCondition> EntityConditionImpl::GetTraveledDistanceCondition() const
        {
            return _traveledDistanceCondition;
        }
        std::shared_ptr<IReachPositionCondition> EntityConditionImpl::GetReachPositionCondition() const
        {
            return _reachPositionCondition;
        }
        std::shared_ptr<IDistanceCondition> EntityConditionImpl::GetDistanceCondition() const
        {
            return _distanceCondition;
        }
        std::shared_ptr<IRelativeDistanceCondition> EntityConditionImpl::GetRelativeDistanceCondition() const
        {
            return _relativeDistanceCondition;
        }

        void EntityConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType EntityConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EntityConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kEndOfRoadCondition =  GetWriterEndOfRoadCondition();
                if (kEndOfRoadCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEndOfRoadCondition));
                }
                const auto kCollisionCondition =  GetWriterCollisionCondition();
                if (kCollisionCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCollisionCondition));
                }
                const auto kOffroadCondition =  GetWriterOffroadCondition();
                if (kOffroadCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOffroadCondition));
                }
                const auto kTimeHeadwayCondition =  GetWriterTimeHeadwayCondition();
                if (kTimeHeadwayCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTimeHeadwayCondition));
                }
                const auto kTimeToCollisionCondition =  GetWriterTimeToCollisionCondition();
                if (kTimeToCollisionCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTimeToCollisionCondition));
                }
                const auto kAccelerationCondition =  GetWriterAccelerationCondition();
                if (kAccelerationCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAccelerationCondition));
                }
                const auto kStandStillCondition =  GetWriterStandStillCondition();
                if (kStandStillCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kStandStillCondition));
                }
                const auto kSpeedCondition =  GetWriterSpeedCondition();
                if (kSpeedCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSpeedCondition));
                }
                const auto kRelativeSpeedCondition =  GetWriterRelativeSpeedCondition();
                if (kRelativeSpeedCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeSpeedCondition));
                }
                const auto kTraveledDistanceCondition =  GetWriterTraveledDistanceCondition();
                if (kTraveledDistanceCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTraveledDistanceCondition));
                }
                const auto kReachPositionCondition =  GetWriterReachPositionCondition();
                if (kReachPositionCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kReachPositionCondition));
                }
                const auto kDistanceCondition =  GetWriterDistanceCondition();
                if (kDistanceCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDistanceCondition));
                }
                const auto kRelativeDistanceCondition =  GetWriterRelativeDistanceCondition();
                if (kRelativeDistanceCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeDistanceCondition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EntityConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<EntityConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kEndOfRoadCondition =  GetWriterEndOfRoadCondition();
            if (kEndOfRoadCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<EndOfRoadConditionImpl>(kEndOfRoadCondition)->Clone();
                auto clonedChildIEndOfRoadCondition = std::dynamic_pointer_cast<IEndOfRoadCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEndOfRoadCondition(std::dynamic_pointer_cast<IEndOfRoadConditionWriter>(clonedChildIEndOfRoadCondition));
            }
            const auto kCollisionCondition =  GetWriterCollisionCondition();
            if (kCollisionCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<CollisionConditionImpl>(kCollisionCondition)->Clone();
                auto clonedChildICollisionCondition = std::dynamic_pointer_cast<ICollisionCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCollisionCondition(std::dynamic_pointer_cast<ICollisionConditionWriter>(clonedChildICollisionCondition));
            }
            const auto kOffroadCondition =  GetWriterOffroadCondition();
            if (kOffroadCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<OffroadConditionImpl>(kOffroadCondition)->Clone();
                auto clonedChildIOffroadCondition = std::dynamic_pointer_cast<IOffroadCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOffroadCondition(std::dynamic_pointer_cast<IOffroadConditionWriter>(clonedChildIOffroadCondition));
            }
            const auto kTimeHeadwayCondition =  GetWriterTimeHeadwayCondition();
            if (kTimeHeadwayCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TimeHeadwayConditionImpl>(kTimeHeadwayCondition)->Clone();
                auto clonedChildITimeHeadwayCondition = std::dynamic_pointer_cast<ITimeHeadwayCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTimeHeadwayCondition(std::dynamic_pointer_cast<ITimeHeadwayConditionWriter>(clonedChildITimeHeadwayCondition));
            }
            const auto kTimeToCollisionCondition =  GetWriterTimeToCollisionCondition();
            if (kTimeToCollisionCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TimeToCollisionConditionImpl>(kTimeToCollisionCondition)->Clone();
                auto clonedChildITimeToCollisionCondition = std::dynamic_pointer_cast<ITimeToCollisionCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTimeToCollisionCondition(std::dynamic_pointer_cast<ITimeToCollisionConditionWriter>(clonedChildITimeToCollisionCondition));
            }
            const auto kAccelerationCondition =  GetWriterAccelerationCondition();
            if (kAccelerationCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<AccelerationConditionImpl>(kAccelerationCondition)->Clone();
                auto clonedChildIAccelerationCondition = std::dynamic_pointer_cast<IAccelerationCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAccelerationCondition(std::dynamic_pointer_cast<IAccelerationConditionWriter>(clonedChildIAccelerationCondition));
            }
            const auto kStandStillCondition =  GetWriterStandStillCondition();
            if (kStandStillCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<StandStillConditionImpl>(kStandStillCondition)->Clone();
                auto clonedChildIStandStillCondition = std::dynamic_pointer_cast<IStandStillCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetStandStillCondition(std::dynamic_pointer_cast<IStandStillConditionWriter>(clonedChildIStandStillCondition));
            }
            const auto kSpeedCondition =  GetWriterSpeedCondition();
            if (kSpeedCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<SpeedConditionImpl>(kSpeedCondition)->Clone();
                auto clonedChildISpeedCondition = std::dynamic_pointer_cast<ISpeedCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSpeedCondition(std::dynamic_pointer_cast<ISpeedConditionWriter>(clonedChildISpeedCondition));
            }
            const auto kRelativeSpeedCondition =  GetWriterRelativeSpeedCondition();
            if (kRelativeSpeedCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeSpeedConditionImpl>(kRelativeSpeedCondition)->Clone();
                auto clonedChildIRelativeSpeedCondition = std::dynamic_pointer_cast<IRelativeSpeedCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeSpeedCondition(std::dynamic_pointer_cast<IRelativeSpeedConditionWriter>(clonedChildIRelativeSpeedCondition));
            }
            const auto kTraveledDistanceCondition =  GetWriterTraveledDistanceCondition();
            if (kTraveledDistanceCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TraveledDistanceConditionImpl>(kTraveledDistanceCondition)->Clone();
                auto clonedChildITraveledDistanceCondition = std::dynamic_pointer_cast<ITraveledDistanceCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTraveledDistanceCondition(std::dynamic_pointer_cast<ITraveledDistanceConditionWriter>(clonedChildITraveledDistanceCondition));
            }
            const auto kReachPositionCondition =  GetWriterReachPositionCondition();
            if (kReachPositionCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<ReachPositionConditionImpl>(kReachPositionCondition)->Clone();
                auto clonedChildIReachPositionCondition = std::dynamic_pointer_cast<IReachPositionCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetReachPositionCondition(std::dynamic_pointer_cast<IReachPositionConditionWriter>(clonedChildIReachPositionCondition));
            }
            const auto kDistanceCondition =  GetWriterDistanceCondition();
            if (kDistanceCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<DistanceConditionImpl>(kDistanceCondition)->Clone();
                auto clonedChildIDistanceCondition = std::dynamic_pointer_cast<IDistanceCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDistanceCondition(std::dynamic_pointer_cast<IDistanceConditionWriter>(clonedChildIDistanceCondition));
            }
            const auto kRelativeDistanceCondition =  GetWriterRelativeDistanceCondition();
            if (kRelativeDistanceCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeDistanceConditionImpl>(kRelativeDistanceCondition)->Clone();
                auto clonedChildIRelativeDistanceCondition = std::dynamic_pointer_cast<IRelativeDistanceCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeDistanceCondition(std::dynamic_pointer_cast<IRelativeDistanceConditionWriter>(clonedChildIRelativeDistanceCondition));
            }
            return clonedObject;
        }

        std::string EntityConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntityConditionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__END_OF_ROAD_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEndOfRoadCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__COLLISION_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCollisionCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__OFFROAD_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOffroadCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TIME_HEADWAY_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTimeHeadwayCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TIME_TO_COLLISION_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTimeToCollisionCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ACCELERATION_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAccelerationCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__STAND_STILL_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetStandStillCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SPEED_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSpeedCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_SPEED_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeSpeedCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAVELED_DISTANCE_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTraveledDistanceCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__REACH_POSITION_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetReachPositionCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DISTANCE_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDistanceCondition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_DISTANCE_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeDistanceCondition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EntityConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntityConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string EntityConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        EntityObjectImpl::EntityObjectImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<ICatalogReference> EntityObjectImpl::GetCatalogReference() const
        {
            return _catalogReference;
        }
        std::shared_ptr<IVehicle> EntityObjectImpl::GetVehicle() const
        {
            return _vehicle;
        }
        std::shared_ptr<IPedestrian> EntityObjectImpl::GetPedestrian() const
        {
            return _pedestrian;
        }
        std::shared_ptr<IMiscObject> EntityObjectImpl::GetMiscObject() const
        {
            return _miscObject;
        }

        void EntityObjectImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType EntityObjectImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EntityObjectImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kCatalogReference =  GetWriterCatalogReference();
                if (kCatalogReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogReference));
                }
                const auto kVehicle =  GetWriterVehicle();
                if (kVehicle)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kVehicle));
                }
                const auto kPedestrian =  GetWriterPedestrian();
                if (kPedestrian)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPedestrian));
                }
                const auto kMiscObject =  GetWriterMiscObject();
                if (kMiscObject)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kMiscObject));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EntityObjectImpl::Clone()
        {
            auto clonedObject = std::make_shared<EntityObjectImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kCatalogReference =  GetWriterCatalogReference();
            if (kCatalogReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kCatalogReference)->Clone();
                auto clonedChildICatalogReference = std::dynamic_pointer_cast<ICatalogReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogReference(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChildICatalogReference));
            }
            const auto kVehicle =  GetWriterVehicle();
            if (kVehicle)
            {
                auto clonedChild = std::dynamic_pointer_cast<VehicleImpl>(kVehicle)->Clone();
                auto clonedChildIVehicle = std::dynamic_pointer_cast<IVehicle>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetVehicle(std::dynamic_pointer_cast<IVehicleWriter>(clonedChildIVehicle));
            }
            const auto kPedestrian =  GetWriterPedestrian();
            if (kPedestrian)
            {
                auto clonedChild = std::dynamic_pointer_cast<PedestrianImpl>(kPedestrian)->Clone();
                auto clonedChildIPedestrian = std::dynamic_pointer_cast<IPedestrian>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPedestrian(std::dynamic_pointer_cast<IPedestrianWriter>(clonedChildIPedestrian));
            }
            const auto kMiscObject =  GetWriterMiscObject();
            if (kMiscObject)
            {
                auto clonedChild = std::dynamic_pointer_cast<MiscObjectImpl>(kMiscObject)->Clone();
                auto clonedChildIMiscObject = std::dynamic_pointer_cast<IMiscObject>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetMiscObject(std::dynamic_pointer_cast<IMiscObjectWriter>(clonedChildIMiscObject));
            }
            return clonedObject;
        }

        std::string EntityObjectImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntityObjectImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogReference());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__VEHICLE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetVehicle());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PEDESTRIAN)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPedestrian());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__MISC_OBJECT)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetMiscObject());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EntityObjectImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntityObjectImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string EntityObjectImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        EntityRefImpl::EntityRefImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
        }

        std::shared_ptr<INamedReference<IEntity>> EntityRefImpl::GetEntityRef() const
        {
            return _entityRef;
        }

        void EntityRefImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType EntityRefImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EntityRefImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EntityRefImpl::Clone()
        {
            auto clonedObject = std::make_shared<EntityRefImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // clone children
            return clonedObject;
        }

        std::string EntityRefImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntityRefImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EntityRefImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntityRefImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string EntityRefImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        EntitySelectionImpl::EntitySelectionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        std::string EntitySelectionImpl::GetName() const
        {
            return _name;
        }
        std::shared_ptr<ISelectedEntities> EntitySelectionImpl::GetMembers() const
        {
            return _members;
        }

        void EntitySelectionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType EntitySelectionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EntitySelectionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kMembers =  GetWriterMembers();
                if (kMembers)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kMembers));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EntitySelectionImpl::Clone()
        {
            auto clonedObject = std::make_shared<EntitySelectionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone children
            const auto kMembers =  GetWriterMembers();
            if (kMembers)
            {
                auto clonedChild = std::dynamic_pointer_cast<SelectedEntitiesImpl>(kMembers)->Clone();
                auto clonedChildISelectedEntities = std::dynamic_pointer_cast<ISelectedEntities>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetMembers(std::dynamic_pointer_cast<ISelectedEntitiesWriter>(clonedChildISelectedEntities));
            }
            return clonedObject;
        }

        std::string EntitySelectionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntitySelectionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__MEMBERS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetMembers());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EntitySelectionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EntitySelectionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string EntitySelectionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        EnvironmentImpl::EnvironmentImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        std::string EnvironmentImpl::GetName() const
        {
            return _name;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> EnvironmentImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::shared_ptr<ITimeOfDay> EnvironmentImpl::GetTimeOfDay() const
        {
            return _timeOfDay;
        }
        std::shared_ptr<IWeather> EnvironmentImpl::GetWeather() const
        {
            return _weather;
        }
        std::shared_ptr<IRoadCondition> EnvironmentImpl::GetRoadCondition() const
        {
            return _roadCondition;
        }

        void EnvironmentImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType EnvironmentImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool EnvironmentImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> EnvironmentImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EnvironmentImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kTimeOfDay =  GetWriterTimeOfDay();
                if (kTimeOfDay)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTimeOfDay));
                }
                const auto kWeather =  GetWriterWeather();
                if (kWeather)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kWeather));
                }
                const auto kRoadCondition =  GetWriterRoadCondition();
                if (kRoadCondition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRoadCondition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EnvironmentImpl::Clone()
        {
            auto clonedObject = std::make_shared<EnvironmentImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kTimeOfDay =  GetWriterTimeOfDay();
            if (kTimeOfDay)
            {
                auto clonedChild = std::dynamic_pointer_cast<TimeOfDayImpl>(kTimeOfDay)->Clone();
                auto clonedChildITimeOfDay = std::dynamic_pointer_cast<ITimeOfDay>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTimeOfDay(std::dynamic_pointer_cast<ITimeOfDayWriter>(clonedChildITimeOfDay));
            }
            const auto kWeather =  GetWriterWeather();
            if (kWeather)
            {
                auto clonedChild = std::dynamic_pointer_cast<WeatherImpl>(kWeather)->Clone();
                auto clonedChildIWeather = std::dynamic_pointer_cast<IWeather>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetWeather(std::dynamic_pointer_cast<IWeatherWriter>(clonedChildIWeather));
            }
            const auto kRoadCondition =  GetWriterRoadCondition();
            if (kRoadCondition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RoadConditionImpl>(kRoadCondition)->Clone();
                auto clonedChildIRoadCondition = std::dynamic_pointer_cast<IRoadCondition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRoadCondition(std::dynamic_pointer_cast<IRoadConditionWriter>(clonedChildIRoadCondition));
            }
            return clonedObject;
        }

        std::string EnvironmentImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EnvironmentImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TIME_OF_DAY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTimeOfDay());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__WEATHER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetWeather());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ROAD_CONDITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRoadCondition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EnvironmentImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EnvironmentImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string EnvironmentImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        EnvironmentActionImpl::EnvironmentActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IEnvironment> EnvironmentActionImpl::GetEnvironment() const
        {
            return _environment;
        }
        std::shared_ptr<ICatalogReference> EnvironmentActionImpl::GetCatalogReference() const
        {
            return _catalogReference;
        }

        void EnvironmentActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType EnvironmentActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EnvironmentActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kEnvironment =  GetWriterEnvironment();
                if (kEnvironment)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEnvironment));
                }
                const auto kCatalogReference =  GetWriterCatalogReference();
                if (kCatalogReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogReference));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EnvironmentActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<EnvironmentActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kEnvironment =  GetWriterEnvironment();
            if (kEnvironment)
            {
                auto clonedChild = std::dynamic_pointer_cast<EnvironmentImpl>(kEnvironment)->Clone();
                auto clonedChildIEnvironment = std::dynamic_pointer_cast<IEnvironment>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEnvironment(std::dynamic_pointer_cast<IEnvironmentWriter>(clonedChildIEnvironment));
            }
            const auto kCatalogReference =  GetWriterCatalogReference();
            if (kCatalogReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kCatalogReference)->Clone();
                auto clonedChildICatalogReference = std::dynamic_pointer_cast<ICatalogReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogReference(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChildICatalogReference));
            }
            return clonedObject;
        }

        std::string EnvironmentActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EnvironmentActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ENVIRONMENT)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEnvironment());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogReference());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EnvironmentActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EnvironmentActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string EnvironmentActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        EnvironmentCatalogLocationImpl::EnvironmentCatalogLocationImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IDirectory> EnvironmentCatalogLocationImpl::GetDirectory() const
        {
            return _directory;
        }

        void EnvironmentCatalogLocationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType EnvironmentCatalogLocationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EnvironmentCatalogLocationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDirectory =  GetWriterDirectory();
                if (kDirectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDirectory));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EnvironmentCatalogLocationImpl::Clone()
        {
            auto clonedObject = std::make_shared<EnvironmentCatalogLocationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kDirectory =  GetWriterDirectory();
            if (kDirectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<DirectoryImpl>(kDirectory)->Clone();
                auto clonedChildIDirectory = std::dynamic_pointer_cast<IDirectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDirectory(std::dynamic_pointer_cast<IDirectoryWriter>(clonedChildIDirectory));
            }
            return clonedObject;
        }

        std::string EnvironmentCatalogLocationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EnvironmentCatalogLocationImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIRECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDirectory());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EnvironmentCatalogLocationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EnvironmentCatalogLocationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string EnvironmentCatalogLocationImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        EventImpl::EventImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT, SimpleType::UNSIGNED_INT);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PRIORITY, SimpleType::ENUM_TYPE);
        }

        uint32_t EventImpl::GetMaximumExecutionCount() const
        {
            return _maximumExecutionCount;
        }
        std::string EventImpl::GetName() const
        {
            return _name;
        }
        Priority EventImpl::GetPriority() const
        {
            return _priority;
        }
        std::vector<std::shared_ptr<IAction>> EventImpl::GetActions() const
        {
            std::vector<std::shared_ptr<IAction>> temp;
            for(auto&& elm: _actions)
                temp.push_back(elm);
            return temp;
        }
        std::shared_ptr<ITrigger> EventImpl::GetStartTrigger() const
        {
            return _startTrigger;
        }

        void EventImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT)
            {
                // Simple type
                _maximumExecutionCount = ParserHelper::ParseUnsignedInt(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PRIORITY)
            {
                // Enumeration Type
                const auto kResult = Priority::GetFromLiteral(parameterLiteralValue);
                if (kResult != Priority::UNKNOWN)
                {
                    _priority = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType EventImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> EventImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto actions =  GetWriterActions();
                if (!actions.empty())
                {
                    for(auto&& item : actions)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kStartTrigger =  GetWriterStartTrigger();
                if (kStartTrigger)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kStartTrigger));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> EventImpl::Clone()
        {
            auto clonedObject = std::make_shared<EventImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_maximumExecutionCount = GetMaximumExecutionCount();
            // Simple type
            clonedObject->_name = GetName();
            // Enumeration Type
            const auto kPriority = GetPriority();
            if ( kPriority.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_priority = Priority::GetFromLiteral(kPriority.GetLiteral());
            }
            // clone children
            const auto kActions =  GetWriterActions();
            if (!kActions.empty())
            {
                std::vector<std::shared_ptr<IActionWriter>> clonedList;
                for(auto&& kItem : kActions)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ActionImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IActionWriter>(clonedChild));
                }
                clonedObject->SetActions(clonedList);
            }
            const auto kStartTrigger =  GetWriterStartTrigger();
            if (kStartTrigger)
            {
                auto clonedChild = std::dynamic_pointer_cast<TriggerImpl>(kStartTrigger)->Clone();
                auto clonedChildITrigger = std::dynamic_pointer_cast<ITrigger>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetStartTrigger(std::dynamic_pointer_cast<ITriggerWriter>(clonedChildITrigger));
            }
            return clonedObject;
        }

        std::string EventImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EventImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__START_TRIGGER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetStartTrigger());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> EventImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__ACTION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetActions())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> EventImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string EventImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PRIORITY)
            {
                auto priority = GetPriority();
                return priority.GetLiteral() != "UNKNOWN" ? priority.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        FileImpl::FileImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FILEPATH, SimpleType::STRING);
        }

        std::string FileImpl::GetFilepath() const
        {
            return _filepath;
        }

        void FileImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FILEPATH)
            {
                // Simple type
                _filepath = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType FileImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> FileImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> FileImpl::Clone()
        {
            auto clonedObject = std::make_shared<FileImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_filepath = GetFilepath();
            // clone children
            return clonedObject;
        }

        std::string FileImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__FILEPATH)
            {
                return GetFilepath();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FileImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> FileImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FileImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string FileImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        FileHeaderImpl::FileHeaderImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__AUTHOR, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DATE, SimpleType::DATE_TIME);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DESCRIPTION, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__REV_MAJOR, SimpleType::UNSIGNED_SHORT);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__REV_MINOR, SimpleType::UNSIGNED_SHORT);
        }

        std::string FileHeaderImpl::GetAuthor() const
        {
            return _author;
        }
        DateTime FileHeaderImpl::GetDate() const
        {
            return _date;
        }
        std::string FileHeaderImpl::GetDescription() const
        {
            return _description;
        }
        uint16_t FileHeaderImpl::GetRevMajor() const
        {
            return _revMajor;
        }
        uint16_t FileHeaderImpl::GetRevMinor() const
        {
            return _revMinor;
        }

        void FileHeaderImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__AUTHOR)
            {
                // Simple type
                _author = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DATE)
            {
                // Simple type
                _date = ParserHelper::ParseDateTime(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DESCRIPTION)
            {
                // Simple type
                _description = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__REV_MAJOR)
            {
                // Simple type
                _revMajor = ParserHelper::ParseUnsignedShort(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__REV_MINOR)
            {
                // Simple type
                _revMinor = ParserHelper::ParseUnsignedShort(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType FileHeaderImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> FileHeaderImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> FileHeaderImpl::Clone()
        {
            auto clonedObject = std::make_shared<FileHeaderImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_author = GetAuthor();
            // Simple type
            clonedObject->_date = GetDate();
            // Simple type
            clonedObject->_description = GetDescription();
            // Simple type
            clonedObject->_revMajor = GetRevMajor();
            // Simple type
            clonedObject->_revMinor = GetRevMinor();
            // clone children
            return clonedObject;
        }

        std::string FileHeaderImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__AUTHOR)
            {
                return GetAuthor();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__DESCRIPTION)
            {
                return GetDescription();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FileHeaderImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> FileHeaderImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FileHeaderImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string FileHeaderImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        FinalSpeedImpl::FinalSpeedImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IAbsoluteSpeed> FinalSpeedImpl::GetAbsoluteSpeed() const
        {
            return _absoluteSpeed;
        }
        std::shared_ptr<IRelativeSpeedToMaster> FinalSpeedImpl::GetRelativeSpeedToMaster() const
        {
            return _relativeSpeedToMaster;
        }

        void FinalSpeedImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType FinalSpeedImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> FinalSpeedImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kAbsoluteSpeed =  GetWriterAbsoluteSpeed();
                if (kAbsoluteSpeed)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAbsoluteSpeed));
                }
                const auto kRelativeSpeedToMaster =  GetWriterRelativeSpeedToMaster();
                if (kRelativeSpeedToMaster)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeSpeedToMaster));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> FinalSpeedImpl::Clone()
        {
            auto clonedObject = std::make_shared<FinalSpeedImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kAbsoluteSpeed =  GetWriterAbsoluteSpeed();
            if (kAbsoluteSpeed)
            {
                auto clonedChild = std::dynamic_pointer_cast<AbsoluteSpeedImpl>(kAbsoluteSpeed)->Clone();
                auto clonedChildIAbsoluteSpeed = std::dynamic_pointer_cast<IAbsoluteSpeed>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAbsoluteSpeed(std::dynamic_pointer_cast<IAbsoluteSpeedWriter>(clonedChildIAbsoluteSpeed));
            }
            const auto kRelativeSpeedToMaster =  GetWriterRelativeSpeedToMaster();
            if (kRelativeSpeedToMaster)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeSpeedToMasterImpl>(kRelativeSpeedToMaster)->Clone();
                auto clonedChildIRelativeSpeedToMaster = std::dynamic_pointer_cast<IRelativeSpeedToMaster>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeSpeedToMaster(std::dynamic_pointer_cast<IRelativeSpeedToMasterWriter>(clonedChildIRelativeSpeedToMaster));
            }
            return clonedObject;
        }

        std::string FinalSpeedImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FinalSpeedImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ABSOLUTE_SPEED)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAbsoluteSpeed());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_SPEED_TO_MASTER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeSpeedToMaster());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> FinalSpeedImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FinalSpeedImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string FinalSpeedImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        FogImpl::FogImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VISUAL_RANGE, SimpleType::DOUBLE);
        }

        double FogImpl::GetVisualRange() const
        {
            return _visualRange;
        }
        std::shared_ptr<IBoundingBox> FogImpl::GetBoundingBox() const
        {
            return _boundingBox;
        }

        void FogImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VISUAL_RANGE)
            {
                // Simple type
                _visualRange = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType FogImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> FogImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kBoundingBox =  GetWriterBoundingBox();
                if (kBoundingBox)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kBoundingBox));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> FogImpl::Clone()
        {
            auto clonedObject = std::make_shared<FogImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_visualRange = GetVisualRange();
            // clone children
            const auto kBoundingBox =  GetWriterBoundingBox();
            if (kBoundingBox)
            {
                auto clonedChild = std::dynamic_pointer_cast<BoundingBoxImpl>(kBoundingBox)->Clone();
                auto clonedChildIBoundingBox = std::dynamic_pointer_cast<IBoundingBox>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetBoundingBox(std::dynamic_pointer_cast<IBoundingBoxWriter>(clonedChildIBoundingBox));
            }
            return clonedObject;
        }

        std::string FogImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FogImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BOUNDING_BOX)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetBoundingBox());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> FogImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FogImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string FogImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        FollowTrajectoryActionImpl::FollowTrajectoryActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<ITrajectory> FollowTrajectoryActionImpl::GetTrajectory() const
        {
            return _trajectory;
        }
        std::shared_ptr<ICatalogReference> FollowTrajectoryActionImpl::GetCatalogReference() const
        {
            return _catalogReference;
        }
        std::shared_ptr<ITimeReference> FollowTrajectoryActionImpl::GetTimeReference() const
        {
            return _timeReference;
        }
        std::shared_ptr<ITrajectoryFollowingMode> FollowTrajectoryActionImpl::GetTrajectoryFollowingMode() const
        {
            return _trajectoryFollowingMode;
        }

        void FollowTrajectoryActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType FollowTrajectoryActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> FollowTrajectoryActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kTrajectory =  GetWriterTrajectory();
                if (kTrajectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrajectory));
                }
                const auto kCatalogReference =  GetWriterCatalogReference();
                if (kCatalogReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogReference));
                }
                const auto kTimeReference =  GetWriterTimeReference();
                if (kTimeReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTimeReference));
                }
                const auto kTrajectoryFollowingMode =  GetWriterTrajectoryFollowingMode();
                if (kTrajectoryFollowingMode)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrajectoryFollowingMode));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> FollowTrajectoryActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<FollowTrajectoryActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kTrajectory =  GetWriterTrajectory();
            if (kTrajectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrajectoryImpl>(kTrajectory)->Clone();
                auto clonedChildITrajectory = std::dynamic_pointer_cast<ITrajectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrajectory(std::dynamic_pointer_cast<ITrajectoryWriter>(clonedChildITrajectory));
            }
            const auto kCatalogReference =  GetWriterCatalogReference();
            if (kCatalogReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kCatalogReference)->Clone();
                auto clonedChildICatalogReference = std::dynamic_pointer_cast<ICatalogReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogReference(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChildICatalogReference));
            }
            const auto kTimeReference =  GetWriterTimeReference();
            if (kTimeReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<TimeReferenceImpl>(kTimeReference)->Clone();
                auto clonedChildITimeReference = std::dynamic_pointer_cast<ITimeReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTimeReference(std::dynamic_pointer_cast<ITimeReferenceWriter>(clonedChildITimeReference));
            }
            const auto kTrajectoryFollowingMode =  GetWriterTrajectoryFollowingMode();
            if (kTrajectoryFollowingMode)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrajectoryFollowingModeImpl>(kTrajectoryFollowingMode)->Clone();
                auto clonedChildITrajectoryFollowingMode = std::dynamic_pointer_cast<ITrajectoryFollowingMode>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrajectoryFollowingMode(std::dynamic_pointer_cast<ITrajectoryFollowingModeWriter>(clonedChildITrajectoryFollowingMode));
            }
            return clonedObject;
        }

        std::string FollowTrajectoryActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FollowTrajectoryActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAJECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrajectory());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogReference());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TIME_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTimeReference());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAJECTORY_FOLLOWING_MODE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrajectoryFollowingMode());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> FollowTrajectoryActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> FollowTrajectoryActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string FollowTrajectoryActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        GlobalActionImpl::GlobalActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IEnvironmentAction> GlobalActionImpl::GetEnvironmentAction() const
        {
            return _environmentAction;
        }
        std::shared_ptr<IEntityAction> GlobalActionImpl::GetEntityAction() const
        {
            return _entityAction;
        }
        std::shared_ptr<IParameterAction> GlobalActionImpl::GetParameterAction() const
        {
            return _parameterAction;
        }
        std::shared_ptr<IInfrastructureAction> GlobalActionImpl::GetInfrastructureAction() const
        {
            return _infrastructureAction;
        }
        std::shared_ptr<ITrafficAction> GlobalActionImpl::GetTrafficAction() const
        {
            return _trafficAction;
        }

        void GlobalActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType GlobalActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> GlobalActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kEnvironmentAction =  GetWriterEnvironmentAction();
                if (kEnvironmentAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEnvironmentAction));
                }
                const auto kEntityAction =  GetWriterEntityAction();
                if (kEntityAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEntityAction));
                }
                const auto kParameterAction =  GetWriterParameterAction();
                if (kParameterAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kParameterAction));
                }
                const auto kInfrastructureAction =  GetWriterInfrastructureAction();
                if (kInfrastructureAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kInfrastructureAction));
                }
                const auto kTrafficAction =  GetWriterTrafficAction();
                if (kTrafficAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> GlobalActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<GlobalActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kEnvironmentAction =  GetWriterEnvironmentAction();
            if (kEnvironmentAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<EnvironmentActionImpl>(kEnvironmentAction)->Clone();
                auto clonedChildIEnvironmentAction = std::dynamic_pointer_cast<IEnvironmentAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEnvironmentAction(std::dynamic_pointer_cast<IEnvironmentActionWriter>(clonedChildIEnvironmentAction));
            }
            const auto kEntityAction =  GetWriterEntityAction();
            if (kEntityAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<EntityActionImpl>(kEntityAction)->Clone();
                auto clonedChildIEntityAction = std::dynamic_pointer_cast<IEntityAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEntityAction(std::dynamic_pointer_cast<IEntityActionWriter>(clonedChildIEntityAction));
            }
            const auto kParameterAction =  GetWriterParameterAction();
            if (kParameterAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<ParameterActionImpl>(kParameterAction)->Clone();
                auto clonedChildIParameterAction = std::dynamic_pointer_cast<IParameterAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetParameterAction(std::dynamic_pointer_cast<IParameterActionWriter>(clonedChildIParameterAction));
            }
            const auto kInfrastructureAction =  GetWriterInfrastructureAction();
            if (kInfrastructureAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<InfrastructureActionImpl>(kInfrastructureAction)->Clone();
                auto clonedChildIInfrastructureAction = std::dynamic_pointer_cast<IInfrastructureAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetInfrastructureAction(std::dynamic_pointer_cast<IInfrastructureActionWriter>(clonedChildIInfrastructureAction));
            }
            const auto kTrafficAction =  GetWriterTrafficAction();
            if (kTrafficAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficActionImpl>(kTrafficAction)->Clone();
                auto clonedChildITrafficAction = std::dynamic_pointer_cast<ITrafficAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficAction(std::dynamic_pointer_cast<ITrafficActionWriter>(clonedChildITrafficAction));
            }
            return clonedObject;
        }

        std::string GlobalActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> GlobalActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ENVIRONMENT_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEnvironmentAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEntityAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParameterAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__INFRASTRUCTURE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetInfrastructureAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> GlobalActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> GlobalActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string GlobalActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        InRoutePositionImpl::InRoutePositionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IPositionOfCurrentEntity> InRoutePositionImpl::GetFromCurrentEntity() const
        {
            return _fromCurrentEntity;
        }
        std::shared_ptr<IPositionInRoadCoordinates> InRoutePositionImpl::GetFromRoadCoordinates() const
        {
            return _fromRoadCoordinates;
        }
        std::shared_ptr<IPositionInLaneCoordinates> InRoutePositionImpl::GetFromLaneCoordinates() const
        {
            return _fromLaneCoordinates;
        }

        void InRoutePositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType InRoutePositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> InRoutePositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kFromCurrentEntity =  GetWriterFromCurrentEntity();
                if (kFromCurrentEntity)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kFromCurrentEntity));
                }
                const auto kFromRoadCoordinates =  GetWriterFromRoadCoordinates();
                if (kFromRoadCoordinates)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kFromRoadCoordinates));
                }
                const auto kFromLaneCoordinates =  GetWriterFromLaneCoordinates();
                if (kFromLaneCoordinates)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kFromLaneCoordinates));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> InRoutePositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<InRoutePositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kFromCurrentEntity =  GetWriterFromCurrentEntity();
            if (kFromCurrentEntity)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionOfCurrentEntityImpl>(kFromCurrentEntity)->Clone();
                auto clonedChildIPositionOfCurrentEntity = std::dynamic_pointer_cast<IPositionOfCurrentEntity>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetFromCurrentEntity(std::dynamic_pointer_cast<IPositionOfCurrentEntityWriter>(clonedChildIPositionOfCurrentEntity));
            }
            const auto kFromRoadCoordinates =  GetWriterFromRoadCoordinates();
            if (kFromRoadCoordinates)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionInRoadCoordinatesImpl>(kFromRoadCoordinates)->Clone();
                auto clonedChildIPositionInRoadCoordinates = std::dynamic_pointer_cast<IPositionInRoadCoordinates>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetFromRoadCoordinates(std::dynamic_pointer_cast<IPositionInRoadCoordinatesWriter>(clonedChildIPositionInRoadCoordinates));
            }
            const auto kFromLaneCoordinates =  GetWriterFromLaneCoordinates();
            if (kFromLaneCoordinates)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionInLaneCoordinatesImpl>(kFromLaneCoordinates)->Clone();
                auto clonedChildIPositionInLaneCoordinates = std::dynamic_pointer_cast<IPositionInLaneCoordinates>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetFromLaneCoordinates(std::dynamic_pointer_cast<IPositionInLaneCoordinatesWriter>(clonedChildIPositionInLaneCoordinates));
            }
            return clonedObject;
        }

        std::string InRoutePositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> InRoutePositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__FROM_CURRENT_ENTITY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetFromCurrentEntity());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__FROM_ROAD_COORDINATES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetFromRoadCoordinates());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__FROM_LANE_COORDINATES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetFromLaneCoordinates());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> InRoutePositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> InRoutePositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string InRoutePositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        InfrastructureActionImpl::InfrastructureActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<ITrafficSignalAction> InfrastructureActionImpl::GetTrafficSignalAction() const
        {
            return _trafficSignalAction;
        }

        void InfrastructureActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType InfrastructureActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> InfrastructureActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kTrafficSignalAction =  GetWriterTrafficSignalAction();
                if (kTrafficSignalAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficSignalAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> InfrastructureActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<InfrastructureActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kTrafficSignalAction =  GetWriterTrafficSignalAction();
            if (kTrafficSignalAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficSignalActionImpl>(kTrafficSignalAction)->Clone();
                auto clonedChildITrafficSignalAction = std::dynamic_pointer_cast<ITrafficSignalAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficSignalAction(std::dynamic_pointer_cast<ITrafficSignalActionWriter>(clonedChildITrafficSignalAction));
            }
            return clonedObject;
        }

        std::string InfrastructureActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> InfrastructureActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SIGNAL_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficSignalAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> InfrastructureActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> InfrastructureActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string InfrastructureActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        InitImpl::InitImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IInitActions> InitImpl::GetActions() const
        {
            return _actions;
        }

        void InitImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType InitImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> InitImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kActions =  GetWriterActions();
                if (kActions)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kActions));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> InitImpl::Clone()
        {
            auto clonedObject = std::make_shared<InitImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kActions =  GetWriterActions();
            if (kActions)
            {
                auto clonedChild = std::dynamic_pointer_cast<InitActionsImpl>(kActions)->Clone();
                auto clonedChildIInitActions = std::dynamic_pointer_cast<IInitActions>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetActions(std::dynamic_pointer_cast<IInitActionsWriter>(clonedChildIInitActions));
            }
            return clonedObject;
        }

        std::string InitImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> InitImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ACTIONS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetActions());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> InitImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> InitImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string InitImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        InitActionsImpl::InitActionsImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::vector<std::shared_ptr<IGlobalAction>> InitActionsImpl::GetGlobalActions() const
        {
            std::vector<std::shared_ptr<IGlobalAction>> temp;
            for(auto&& elm: _globalActions)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IUserDefinedAction>> InitActionsImpl::GetUserDefinedActions() const
        {
            std::vector<std::shared_ptr<IUserDefinedAction>> temp;
            for(auto&& elm: _userDefinedActions)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IPrivate>> InitActionsImpl::GetPrivates() const
        {
            std::vector<std::shared_ptr<IPrivate>> temp;
            for(auto&& elm: _privates)
                temp.push_back(elm);
            return temp;
        }

        void InitActionsImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType InitActionsImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> InitActionsImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto globalActions =  GetWriterGlobalActions();
                if (!globalActions.empty())
                {
                    for(auto&& item : globalActions)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto userDefinedActions =  GetWriterUserDefinedActions();
                if (!userDefinedActions.empty())
                {
                    for(auto&& item : userDefinedActions)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto privates =  GetWriterPrivates();
                if (!privates.empty())
                {
                    for(auto&& item : privates)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> InitActionsImpl::Clone()
        {
            auto clonedObject = std::make_shared<InitActionsImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kGlobalActions =  GetWriterGlobalActions();
            if (!kGlobalActions.empty())
            {
                std::vector<std::shared_ptr<IGlobalActionWriter>> clonedList;
                for(auto&& kItem : kGlobalActions)
                {
                    auto clonedChild = std::dynamic_pointer_cast<GlobalActionImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IGlobalActionWriter>(clonedChild));
                }
                clonedObject->SetGlobalActions(clonedList);
            }
            const auto kUserDefinedActions =  GetWriterUserDefinedActions();
            if (!kUserDefinedActions.empty())
            {
                std::vector<std::shared_ptr<IUserDefinedActionWriter>> clonedList;
                for(auto&& kItem : kUserDefinedActions)
                {
                    auto clonedChild = std::dynamic_pointer_cast<UserDefinedActionImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IUserDefinedActionWriter>(clonedChild));
                }
                clonedObject->SetUserDefinedActions(clonedList);
            }
            const auto kPrivates =  GetWriterPrivates();
            if (!kPrivates.empty())
            {
                std::vector<std::shared_ptr<IPrivateWriter>> clonedList;
                for(auto&& kItem : kPrivates)
                {
                    auto clonedChild = std::dynamic_pointer_cast<PrivateImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IPrivateWriter>(clonedChild));
                }
                clonedObject->SetPrivates(clonedList);
            }
            return clonedObject;
        }

        std::string InitActionsImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> InitActionsImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> InitActionsImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__GLOBAL_ACTION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetGlobalActions())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__USER_DEFINED_ACTION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetUserDefinedActions())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__PRIVATE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetPrivates())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> InitActionsImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string InitActionsImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        KnotImpl::KnotImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        double KnotImpl::GetValue() const
        {
            return _value;
        }

        void KnotImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType KnotImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> KnotImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> KnotImpl::Clone()
        {
            auto clonedObject = std::make_shared<KnotImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string KnotImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> KnotImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> KnotImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> KnotImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string KnotImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        LaneChangeActionImpl::LaneChangeActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TARGET_LANE_OFFSET, SimpleType::DOUBLE);
        }

        double LaneChangeActionImpl::GetTargetLaneOffset() const
        {
            return _targetLaneOffset;
        }
        std::shared_ptr<ITransitionDynamics> LaneChangeActionImpl::GetLaneChangeActionDynamics() const
        {
            return _laneChangeActionDynamics;
        }
        std::shared_ptr<ILaneChangeTarget> LaneChangeActionImpl::GetLaneChangeTarget() const
        {
            return _laneChangeTarget;
        }

        void LaneChangeActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TARGET_LANE_OFFSET)
            {
                // Simple type
                _targetLaneOffset = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType LaneChangeActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LaneChangeActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kLaneChangeActionDynamics =  GetWriterLaneChangeActionDynamics();
                if (kLaneChangeActionDynamics)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLaneChangeActionDynamics));
                }
                const auto kLaneChangeTarget =  GetWriterLaneChangeTarget();
                if (kLaneChangeTarget)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLaneChangeTarget));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LaneChangeActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<LaneChangeActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_targetLaneOffset = GetTargetLaneOffset();
            // clone children
            const auto kLaneChangeActionDynamics =  GetWriterLaneChangeActionDynamics();
            if (kLaneChangeActionDynamics)
            {
                auto clonedChild = std::dynamic_pointer_cast<TransitionDynamicsImpl>(kLaneChangeActionDynamics)->Clone();
                auto clonedChildITransitionDynamics = std::dynamic_pointer_cast<ITransitionDynamics>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLaneChangeActionDynamics(std::dynamic_pointer_cast<ITransitionDynamicsWriter>(clonedChildITransitionDynamics));
            }
            const auto kLaneChangeTarget =  GetWriterLaneChangeTarget();
            if (kLaneChangeTarget)
            {
                auto clonedChild = std::dynamic_pointer_cast<LaneChangeTargetImpl>(kLaneChangeTarget)->Clone();
                auto clonedChildILaneChangeTarget = std::dynamic_pointer_cast<ILaneChangeTarget>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLaneChangeTarget(std::dynamic_pointer_cast<ILaneChangeTargetWriter>(clonedChildILaneChangeTarget));
            }
            return clonedObject;
        }

        std::string LaneChangeActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneChangeActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LANE_CHANGE_ACTION_DYNAMICS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLaneChangeActionDynamics());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LANE_CHANGE_TARGET)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLaneChangeTarget());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LaneChangeActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneChangeActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LaneChangeActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        LaneChangeTargetImpl::LaneChangeTargetImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IRelativeTargetLane> LaneChangeTargetImpl::GetRelativeTargetLane() const
        {
            return _relativeTargetLane;
        }
        std::shared_ptr<IAbsoluteTargetLane> LaneChangeTargetImpl::GetAbsoluteTargetLane() const
        {
            return _absoluteTargetLane;
        }

        void LaneChangeTargetImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType LaneChangeTargetImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LaneChangeTargetImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRelativeTargetLane =  GetWriterRelativeTargetLane();
                if (kRelativeTargetLane)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeTargetLane));
                }
                const auto kAbsoluteTargetLane =  GetWriterAbsoluteTargetLane();
                if (kAbsoluteTargetLane)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAbsoluteTargetLane));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LaneChangeTargetImpl::Clone()
        {
            auto clonedObject = std::make_shared<LaneChangeTargetImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kRelativeTargetLane =  GetWriterRelativeTargetLane();
            if (kRelativeTargetLane)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeTargetLaneImpl>(kRelativeTargetLane)->Clone();
                auto clonedChildIRelativeTargetLane = std::dynamic_pointer_cast<IRelativeTargetLane>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeTargetLane(std::dynamic_pointer_cast<IRelativeTargetLaneWriter>(clonedChildIRelativeTargetLane));
            }
            const auto kAbsoluteTargetLane =  GetWriterAbsoluteTargetLane();
            if (kAbsoluteTargetLane)
            {
                auto clonedChild = std::dynamic_pointer_cast<AbsoluteTargetLaneImpl>(kAbsoluteTargetLane)->Clone();
                auto clonedChildIAbsoluteTargetLane = std::dynamic_pointer_cast<IAbsoluteTargetLane>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAbsoluteTargetLane(std::dynamic_pointer_cast<IAbsoluteTargetLaneWriter>(clonedChildIAbsoluteTargetLane));
            }
            return clonedObject;
        }

        std::string LaneChangeTargetImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneChangeTargetImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_TARGET_LANE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeTargetLane());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ABSOLUTE_TARGET_LANE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAbsoluteTargetLane());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LaneChangeTargetImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneChangeTargetImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LaneChangeTargetImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        LaneOffsetActionImpl::LaneOffsetActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS, SimpleType::BOOLEAN);
        }

        bool LaneOffsetActionImpl::GetContinuous() const
        {
            return _continuous;
        }
        std::shared_ptr<ILaneOffsetActionDynamics> LaneOffsetActionImpl::GetLaneOffsetActionDynamics() const
        {
            return _laneOffsetActionDynamics;
        }
        std::shared_ptr<ILaneOffsetTarget> LaneOffsetActionImpl::GetLaneOffsetTarget() const
        {
            return _laneOffsetTarget;
        }

        void LaneOffsetActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS)
            {
                // Simple type
                _continuous = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType LaneOffsetActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LaneOffsetActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kLaneOffsetActionDynamics =  GetWriterLaneOffsetActionDynamics();
                if (kLaneOffsetActionDynamics)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLaneOffsetActionDynamics));
                }
                const auto kLaneOffsetTarget =  GetWriterLaneOffsetTarget();
                if (kLaneOffsetTarget)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLaneOffsetTarget));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LaneOffsetActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<LaneOffsetActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_continuous = GetContinuous();
            // clone children
            const auto kLaneOffsetActionDynamics =  GetWriterLaneOffsetActionDynamics();
            if (kLaneOffsetActionDynamics)
            {
                auto clonedChild = std::dynamic_pointer_cast<LaneOffsetActionDynamicsImpl>(kLaneOffsetActionDynamics)->Clone();
                auto clonedChildILaneOffsetActionDynamics = std::dynamic_pointer_cast<ILaneOffsetActionDynamics>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLaneOffsetActionDynamics(std::dynamic_pointer_cast<ILaneOffsetActionDynamicsWriter>(clonedChildILaneOffsetActionDynamics));
            }
            const auto kLaneOffsetTarget =  GetWriterLaneOffsetTarget();
            if (kLaneOffsetTarget)
            {
                auto clonedChild = std::dynamic_pointer_cast<LaneOffsetTargetImpl>(kLaneOffsetTarget)->Clone();
                auto clonedChildILaneOffsetTarget = std::dynamic_pointer_cast<ILaneOffsetTarget>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLaneOffsetTarget(std::dynamic_pointer_cast<ILaneOffsetTargetWriter>(clonedChildILaneOffsetTarget));
            }
            return clonedObject;
        }

        std::string LaneOffsetActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneOffsetActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LANE_OFFSET_ACTION_DYNAMICS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLaneOffsetActionDynamics());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LANE_OFFSET_TARGET)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLaneOffsetTarget());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LaneOffsetActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneOffsetActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LaneOffsetActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        LaneOffsetActionDynamicsImpl::LaneOffsetActionDynamicsImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_LATERAL_ACC, SimpleType::DOUBLE);
        }

        DynamicsShape LaneOffsetActionDynamicsImpl::GetDynamicsShape() const
        {
            return _dynamicsShape;
        }
        double LaneOffsetActionDynamicsImpl::GetMaxLateralAcc() const
        {
            return _maxLateralAcc;
        }

        void LaneOffsetActionDynamicsImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE)
            {
                // Enumeration Type
                const auto kResult = DynamicsShape::GetFromLiteral(parameterLiteralValue);
                if (kResult != DynamicsShape::UNKNOWN)
                {
                    _dynamicsShape = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_LATERAL_ACC)
            {
                // Simple type
                _maxLateralAcc = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType LaneOffsetActionDynamicsImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LaneOffsetActionDynamicsImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LaneOffsetActionDynamicsImpl::Clone()
        {
            auto clonedObject = std::make_shared<LaneOffsetActionDynamicsImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Enumeration Type
            const auto kDynamicsShape = GetDynamicsShape();
            if ( kDynamicsShape.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_dynamicsShape = DynamicsShape::GetFromLiteral(kDynamicsShape.GetLiteral());
            }
            // Simple type
            clonedObject->_maxLateralAcc = GetMaxLateralAcc();
            // clone children
            return clonedObject;
        }

        std::string LaneOffsetActionDynamicsImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneOffsetActionDynamicsImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LaneOffsetActionDynamicsImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneOffsetActionDynamicsImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LaneOffsetActionDynamicsImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE)
            {
                auto dynamicsShape = GetDynamicsShape();
                return dynamicsShape.GetLiteral() != "UNKNOWN" ? dynamicsShape.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        LaneOffsetTargetImpl::LaneOffsetTargetImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IRelativeTargetLaneOffset> LaneOffsetTargetImpl::GetRelativeTargetLaneOffset() const
        {
            return _relativeTargetLaneOffset;
        }
        std::shared_ptr<IAbsoluteTargetLaneOffset> LaneOffsetTargetImpl::GetAbsoluteTargetLaneOffset() const
        {
            return _absoluteTargetLaneOffset;
        }

        void LaneOffsetTargetImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType LaneOffsetTargetImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LaneOffsetTargetImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRelativeTargetLaneOffset =  GetWriterRelativeTargetLaneOffset();
                if (kRelativeTargetLaneOffset)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeTargetLaneOffset));
                }
                const auto kAbsoluteTargetLaneOffset =  GetWriterAbsoluteTargetLaneOffset();
                if (kAbsoluteTargetLaneOffset)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAbsoluteTargetLaneOffset));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LaneOffsetTargetImpl::Clone()
        {
            auto clonedObject = std::make_shared<LaneOffsetTargetImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kRelativeTargetLaneOffset =  GetWriterRelativeTargetLaneOffset();
            if (kRelativeTargetLaneOffset)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeTargetLaneOffsetImpl>(kRelativeTargetLaneOffset)->Clone();
                auto clonedChildIRelativeTargetLaneOffset = std::dynamic_pointer_cast<IRelativeTargetLaneOffset>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeTargetLaneOffset(std::dynamic_pointer_cast<IRelativeTargetLaneOffsetWriter>(clonedChildIRelativeTargetLaneOffset));
            }
            const auto kAbsoluteTargetLaneOffset =  GetWriterAbsoluteTargetLaneOffset();
            if (kAbsoluteTargetLaneOffset)
            {
                auto clonedChild = std::dynamic_pointer_cast<AbsoluteTargetLaneOffsetImpl>(kAbsoluteTargetLaneOffset)->Clone();
                auto clonedChildIAbsoluteTargetLaneOffset = std::dynamic_pointer_cast<IAbsoluteTargetLaneOffset>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAbsoluteTargetLaneOffset(std::dynamic_pointer_cast<IAbsoluteTargetLaneOffsetWriter>(clonedChildIAbsoluteTargetLaneOffset));
            }
            return clonedObject;
        }

        std::string LaneOffsetTargetImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneOffsetTargetImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_TARGET_LANE_OFFSET)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeTargetLaneOffset());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ABSOLUTE_TARGET_LANE_OFFSET)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAbsoluteTargetLaneOffset());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LaneOffsetTargetImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LaneOffsetTargetImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LaneOffsetTargetImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        LanePositionImpl::LanePositionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LANE_ID, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__OFFSET, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ROAD_ID, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__S, SimpleType::DOUBLE);
        }

        std::string LanePositionImpl::GetLaneId() const
        {
            return _laneId;
        }
        double LanePositionImpl::GetOffset() const
        {
            return _offset;
        }
        std::string LanePositionImpl::GetRoadId() const
        {
            return _roadId;
        }
        double LanePositionImpl::GetS() const
        {
            return _s;
        }
        std::shared_ptr<IOrientation> LanePositionImpl::GetOrientation() const
        {
            return _orientation;
        }

        void LanePositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LANE_ID)
            {
                // Simple type
                _laneId = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__OFFSET)
            {
                // Simple type
                _offset = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ROAD_ID)
            {
                // Simple type
                _roadId = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__S)
            {
                // Simple type
                _s = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType LanePositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LanePositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kOrientation =  GetWriterOrientation();
                if (kOrientation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOrientation));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LanePositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<LanePositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_laneId = GetLaneId();
            // Simple type
            clonedObject->_offset = GetOffset();
            // Simple type
            clonedObject->_roadId = GetRoadId();
            // Simple type
            clonedObject->_s = GetS();
            // clone children
            const auto kOrientation =  GetWriterOrientation();
            if (kOrientation)
            {
                auto clonedChild = std::dynamic_pointer_cast<OrientationImpl>(kOrientation)->Clone();
                auto clonedChildIOrientation = std::dynamic_pointer_cast<IOrientation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOrientation(std::dynamic_pointer_cast<IOrientationWriter>(clonedChildIOrientation));
            }
            return clonedObject;
        }

        std::string LanePositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__LANE_ID)
            {
                return GetLaneId();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__ROAD_ID)
            {
                return GetRoadId();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LanePositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ORIENTATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOrientation());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LanePositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LanePositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LanePositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        LateralActionImpl::LateralActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<ILaneChangeAction> LateralActionImpl::GetLaneChangeAction() const
        {
            return _laneChangeAction;
        }
        std::shared_ptr<ILaneOffsetAction> LateralActionImpl::GetLaneOffsetAction() const
        {
            return _laneOffsetAction;
        }
        std::shared_ptr<ILateralDistanceAction> LateralActionImpl::GetLateralDistanceAction() const
        {
            return _lateralDistanceAction;
        }

        void LateralActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType LateralActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LateralActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kLaneChangeAction =  GetWriterLaneChangeAction();
                if (kLaneChangeAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLaneChangeAction));
                }
                const auto kLaneOffsetAction =  GetWriterLaneOffsetAction();
                if (kLaneOffsetAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLaneOffsetAction));
                }
                const auto kLateralDistanceAction =  GetWriterLateralDistanceAction();
                if (kLateralDistanceAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLateralDistanceAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LateralActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<LateralActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kLaneChangeAction =  GetWriterLaneChangeAction();
            if (kLaneChangeAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<LaneChangeActionImpl>(kLaneChangeAction)->Clone();
                auto clonedChildILaneChangeAction = std::dynamic_pointer_cast<ILaneChangeAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLaneChangeAction(std::dynamic_pointer_cast<ILaneChangeActionWriter>(clonedChildILaneChangeAction));
            }
            const auto kLaneOffsetAction =  GetWriterLaneOffsetAction();
            if (kLaneOffsetAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<LaneOffsetActionImpl>(kLaneOffsetAction)->Clone();
                auto clonedChildILaneOffsetAction = std::dynamic_pointer_cast<ILaneOffsetAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLaneOffsetAction(std::dynamic_pointer_cast<ILaneOffsetActionWriter>(clonedChildILaneOffsetAction));
            }
            const auto kLateralDistanceAction =  GetWriterLateralDistanceAction();
            if (kLateralDistanceAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<LateralDistanceActionImpl>(kLateralDistanceAction)->Clone();
                auto clonedChildILateralDistanceAction = std::dynamic_pointer_cast<ILateralDistanceAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLateralDistanceAction(std::dynamic_pointer_cast<ILateralDistanceActionWriter>(clonedChildILateralDistanceAction));
            }
            return clonedObject;
        }

        std::string LateralActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LateralActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LANE_CHANGE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLaneChangeAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LANE_OFFSET_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLaneOffsetAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LATERAL_DISTANCE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLateralDistanceAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LateralActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LateralActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LateralActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        LateralDistanceActionImpl::LateralDistanceActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DISTANCE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FREESPACE, SimpleType::BOOLEAN);
        }

        bool LateralDistanceActionImpl::GetContinuous() const
        {
            return _continuous;
        }
        double LateralDistanceActionImpl::GetDistance() const
        {
            return _distance;
        }
        std::shared_ptr<INamedReference<IEntity>> LateralDistanceActionImpl::GetEntityRef() const
        {
            return _entityRef;
        }
        bool LateralDistanceActionImpl::GetFreespace() const
        {
            return _freespace;
        }
        std::shared_ptr<IDynamicConstraints> LateralDistanceActionImpl::GetDynamicConstraints() const
        {
            return _dynamicConstraints;
        }

        void LateralDistanceActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS)
            {
                // Simple type
                _continuous = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DISTANCE)
            {
                // Simple type
                _distance = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
            {
                // Simple type
                _freespace = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType LateralDistanceActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LateralDistanceActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDynamicConstraints =  GetWriterDynamicConstraints();
                if (kDynamicConstraints)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDynamicConstraints));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LateralDistanceActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<LateralDistanceActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_continuous = GetContinuous();
            // Simple type
            clonedObject->_distance = GetDistance();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Simple type
            clonedObject->_freespace = GetFreespace();
            // clone children
            const auto kDynamicConstraints =  GetWriterDynamicConstraints();
            if (kDynamicConstraints)
            {
                auto clonedChild = std::dynamic_pointer_cast<DynamicConstraintsImpl>(kDynamicConstraints)->Clone();
                auto clonedChildIDynamicConstraints = std::dynamic_pointer_cast<IDynamicConstraints>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDynamicConstraints(std::dynamic_pointer_cast<IDynamicConstraintsWriter>(clonedChildIDynamicConstraints));
            }
            return clonedObject;
        }

        std::string LateralDistanceActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LateralDistanceActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DYNAMIC_CONSTRAINTS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDynamicConstraints());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LateralDistanceActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LateralDistanceActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string LateralDistanceActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        LongitudinalActionImpl::LongitudinalActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<ISpeedAction> LongitudinalActionImpl::GetSpeedAction() const
        {
            return _speedAction;
        }
        std::shared_ptr<ILongitudinalDistanceAction> LongitudinalActionImpl::GetLongitudinalDistanceAction() const
        {
            return _longitudinalDistanceAction;
        }

        void LongitudinalActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType LongitudinalActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LongitudinalActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kSpeedAction =  GetWriterSpeedAction();
                if (kSpeedAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSpeedAction));
                }
                const auto kLongitudinalDistanceAction =  GetWriterLongitudinalDistanceAction();
                if (kLongitudinalDistanceAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLongitudinalDistanceAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LongitudinalActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<LongitudinalActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kSpeedAction =  GetWriterSpeedAction();
            if (kSpeedAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<SpeedActionImpl>(kSpeedAction)->Clone();
                auto clonedChildISpeedAction = std::dynamic_pointer_cast<ISpeedAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSpeedAction(std::dynamic_pointer_cast<ISpeedActionWriter>(clonedChildISpeedAction));
            }
            const auto kLongitudinalDistanceAction =  GetWriterLongitudinalDistanceAction();
            if (kLongitudinalDistanceAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<LongitudinalDistanceActionImpl>(kLongitudinalDistanceAction)->Clone();
                auto clonedChildILongitudinalDistanceAction = std::dynamic_pointer_cast<ILongitudinalDistanceAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLongitudinalDistanceAction(std::dynamic_pointer_cast<ILongitudinalDistanceActionWriter>(clonedChildILongitudinalDistanceAction));
            }
            return clonedObject;
        }

        std::string LongitudinalActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LongitudinalActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SPEED_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSpeedAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LONGITUDINAL_DISTANCE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLongitudinalDistanceAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LongitudinalActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LongitudinalActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string LongitudinalActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        LongitudinalDistanceActionImpl::LongitudinalDistanceActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DISTANCE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FREESPACE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TIME_GAP, SimpleType::DOUBLE);
        }

        bool LongitudinalDistanceActionImpl::GetContinuous() const
        {
            return _continuous;
        }
        double LongitudinalDistanceActionImpl::GetDistance() const
        {
            return _distance;
        }
        std::shared_ptr<INamedReference<IEntity>> LongitudinalDistanceActionImpl::GetEntityRef() const
        {
            return _entityRef;
        }
        bool LongitudinalDistanceActionImpl::GetFreespace() const
        {
            return _freespace;
        }
        double LongitudinalDistanceActionImpl::GetTimeGap() const
        {
            return _timeGap;
        }
        std::shared_ptr<IDynamicConstraints> LongitudinalDistanceActionImpl::GetDynamicConstraints() const
        {
            return _dynamicConstraints;
        }

        void LongitudinalDistanceActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS)
            {
                // Simple type
                _continuous = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DISTANCE)
            {
                // Simple type
                _distance = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
            {
                // Simple type
                _freespace = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TIME_GAP)
            {
                // Simple type
                _timeGap = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType LongitudinalDistanceActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> LongitudinalDistanceActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDynamicConstraints =  GetWriterDynamicConstraints();
                if (kDynamicConstraints)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDynamicConstraints));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> LongitudinalDistanceActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<LongitudinalDistanceActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_continuous = GetContinuous();
            // Simple type
            clonedObject->_distance = GetDistance();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Simple type
            clonedObject->_freespace = GetFreespace();
            // Simple type
            clonedObject->_timeGap = GetTimeGap();
            // clone children
            const auto kDynamicConstraints =  GetWriterDynamicConstraints();
            if (kDynamicConstraints)
            {
                auto clonedChild = std::dynamic_pointer_cast<DynamicConstraintsImpl>(kDynamicConstraints)->Clone();
                auto clonedChildIDynamicConstraints = std::dynamic_pointer_cast<IDynamicConstraints>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDynamicConstraints(std::dynamic_pointer_cast<IDynamicConstraintsWriter>(clonedChildIDynamicConstraints));
            }
            return clonedObject;
        }

        std::string LongitudinalDistanceActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LongitudinalDistanceActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DYNAMIC_CONSTRAINTS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDynamicConstraints());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> LongitudinalDistanceActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> LongitudinalDistanceActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string LongitudinalDistanceActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ManeuverImpl::ManeuverImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        std::string ManeuverImpl::GetName() const
        {
            return _name;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> ManeuverImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IEvent>> ManeuverImpl::GetEvents() const
        {
            std::vector<std::shared_ptr<IEvent>> temp;
            for(auto&& elm: _events)
                temp.push_back(elm);
            return temp;
        }

        void ManeuverImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ManeuverImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool ManeuverImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> ManeuverImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ManeuverImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto events =  GetWriterEvents();
                if (!events.empty())
                {
                    for(auto&& item : events)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ManeuverImpl::Clone()
        {
            auto clonedObject = std::make_shared<ManeuverImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kEvents =  GetWriterEvents();
            if (!kEvents.empty())
            {
                std::vector<std::shared_ptr<IEventWriter>> clonedList;
                for(auto&& kItem : kEvents)
                {
                    auto clonedChild = std::dynamic_pointer_cast<EventImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IEventWriter>(clonedChild));
                }
                clonedObject->SetEvents(clonedList);
            }
            return clonedObject;
        }

        std::string ManeuverImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ManeuverImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ManeuverImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__EVENT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetEvents())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ManeuverImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ManeuverImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ManeuverCatalogLocationImpl::ManeuverCatalogLocationImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IDirectory> ManeuverCatalogLocationImpl::GetDirectory() const
        {
            return _directory;
        }

        void ManeuverCatalogLocationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ManeuverCatalogLocationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ManeuverCatalogLocationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDirectory =  GetWriterDirectory();
                if (kDirectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDirectory));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ManeuverCatalogLocationImpl::Clone()
        {
            auto clonedObject = std::make_shared<ManeuverCatalogLocationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kDirectory =  GetWriterDirectory();
            if (kDirectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<DirectoryImpl>(kDirectory)->Clone();
                auto clonedChildIDirectory = std::dynamic_pointer_cast<IDirectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDirectory(std::dynamic_pointer_cast<IDirectoryWriter>(clonedChildIDirectory));
            }
            return clonedObject;
        }

        std::string ManeuverCatalogLocationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ManeuverCatalogLocationImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIRECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDirectory());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ManeuverCatalogLocationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ManeuverCatalogLocationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ManeuverCatalogLocationImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ManeuverGroupImpl::ManeuverGroupImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT, SimpleType::UNSIGNED_INT);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        uint32_t ManeuverGroupImpl::GetMaximumExecutionCount() const
        {
            return _maximumExecutionCount;
        }
        std::string ManeuverGroupImpl::GetName() const
        {
            return _name;
        }
        std::shared_ptr<IActors> ManeuverGroupImpl::GetActors() const
        {
            return _actors;
        }
        std::vector<std::shared_ptr<ICatalogReference>> ManeuverGroupImpl::GetCatalogReferences() const
        {
            std::vector<std::shared_ptr<ICatalogReference>> temp;
            for(auto&& elm: _catalogReferences)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IManeuver>> ManeuverGroupImpl::GetManeuvers() const
        {
            std::vector<std::shared_ptr<IManeuver>> temp;
            for(auto&& elm: _maneuvers)
                temp.push_back(elm);
            return temp;
        }

        void ManeuverGroupImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAXIMUM_EXECUTION_COUNT)
            {
                // Simple type
                _maximumExecutionCount = ParserHelper::ParseUnsignedInt(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ManeuverGroupImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ManeuverGroupImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kActors =  GetWriterActors();
                if (kActors)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kActors));
                }
                auto catalogReferences =  GetWriterCatalogReferences();
                if (!catalogReferences.empty())
                {
                    for(auto&& item : catalogReferences)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto maneuvers =  GetWriterManeuvers();
                if (!maneuvers.empty())
                {
                    for(auto&& item : maneuvers)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ManeuverGroupImpl::Clone()
        {
            auto clonedObject = std::make_shared<ManeuverGroupImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_maximumExecutionCount = GetMaximumExecutionCount();
            // Simple type
            clonedObject->_name = GetName();
            // clone children
            const auto kActors =  GetWriterActors();
            if (kActors)
            {
                auto clonedChild = std::dynamic_pointer_cast<ActorsImpl>(kActors)->Clone();
                auto clonedChildIActors = std::dynamic_pointer_cast<IActors>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetActors(std::dynamic_pointer_cast<IActorsWriter>(clonedChildIActors));
            }
            const auto kCatalogReferences =  GetWriterCatalogReferences();
            if (!kCatalogReferences.empty())
            {
                std::vector<std::shared_ptr<ICatalogReferenceWriter>> clonedList;
                for(auto&& kItem : kCatalogReferences)
                {
                    auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChild));
                }
                clonedObject->SetCatalogReferences(clonedList);
            }
            const auto kManeuvers =  GetWriterManeuvers();
            if (!kManeuvers.empty())
            {
                std::vector<std::shared_ptr<IManeuverWriter>> clonedList;
                for(auto&& kItem : kManeuvers)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ManeuverImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IManeuverWriter>(clonedChild));
                }
                clonedObject->SetManeuvers(clonedList);
            }
            return clonedObject;
        }

        std::string ManeuverGroupImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ManeuverGroupImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ACTORS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetActors());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ManeuverGroupImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetCatalogReferences())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__MANEUVER)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetManeuvers())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ManeuverGroupImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ManeuverGroupImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        MiscObjectImpl::MiscObjectImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MASS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MISC_OBJECT_CATEGORY, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        double MiscObjectImpl::GetMass() const
        {
            return _mass;
        }
        MiscObjectCategory MiscObjectImpl::GetMiscObjectCategory() const
        {
            return _miscObjectCategory;
        }
        std::string MiscObjectImpl::GetName() const
        {
            return _name;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> MiscObjectImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::shared_ptr<IBoundingBox> MiscObjectImpl::GetBoundingBox() const
        {
            return _boundingBox;
        }
        std::shared_ptr<IProperties> MiscObjectImpl::GetProperties() const
        {
            return _properties;
        }

        void MiscObjectImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MASS)
            {
                // Simple type
                _mass = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MISC_OBJECT_CATEGORY)
            {
                // Enumeration Type
                const auto kResult = MiscObjectCategory::GetFromLiteral(parameterLiteralValue);
                if (kResult != MiscObjectCategory::UNKNOWN)
                {
                    _miscObjectCategory = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType MiscObjectImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool MiscObjectImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> MiscObjectImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> MiscObjectImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kBoundingBox =  GetWriterBoundingBox();
                if (kBoundingBox)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kBoundingBox));
                }
                const auto kProperties =  GetWriterProperties();
                if (kProperties)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kProperties));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> MiscObjectImpl::Clone()
        {
            auto clonedObject = std::make_shared<MiscObjectImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_mass = GetMass();
            // Enumeration Type
            const auto kMiscObjectCategory = GetMiscObjectCategory();
            if ( kMiscObjectCategory.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_miscObjectCategory = MiscObjectCategory::GetFromLiteral(kMiscObjectCategory.GetLiteral());
            }
            // Simple type
            clonedObject->_name = GetName();
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kBoundingBox =  GetWriterBoundingBox();
            if (kBoundingBox)
            {
                auto clonedChild = std::dynamic_pointer_cast<BoundingBoxImpl>(kBoundingBox)->Clone();
                auto clonedChildIBoundingBox = std::dynamic_pointer_cast<IBoundingBox>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetBoundingBox(std::dynamic_pointer_cast<IBoundingBoxWriter>(clonedChildIBoundingBox));
            }
            const auto kProperties =  GetWriterProperties();
            if (kProperties)
            {
                auto clonedChild = std::dynamic_pointer_cast<PropertiesImpl>(kProperties)->Clone();
                auto clonedChildIProperties = std::dynamic_pointer_cast<IProperties>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetProperties(std::dynamic_pointer_cast<IPropertiesWriter>(clonedChildIProperties));
            }
            return clonedObject;
        }

        std::string MiscObjectImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> MiscObjectImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BOUNDING_BOX)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetBoundingBox());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PROPERTIES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetProperties());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> MiscObjectImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> MiscObjectImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string MiscObjectImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__MISC_OBJECT_CATEGORY)
            {
                auto miscObjectCategory = GetMiscObjectCategory();
                return miscObjectCategory.GetLiteral() != "UNKNOWN" ? miscObjectCategory.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        MiscObjectCatalogLocationImpl::MiscObjectCatalogLocationImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IDirectory> MiscObjectCatalogLocationImpl::GetDirectory() const
        {
            return _directory;
        }

        void MiscObjectCatalogLocationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType MiscObjectCatalogLocationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> MiscObjectCatalogLocationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDirectory =  GetWriterDirectory();
                if (kDirectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDirectory));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> MiscObjectCatalogLocationImpl::Clone()
        {
            auto clonedObject = std::make_shared<MiscObjectCatalogLocationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kDirectory =  GetWriterDirectory();
            if (kDirectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<DirectoryImpl>(kDirectory)->Clone();
                auto clonedChildIDirectory = std::dynamic_pointer_cast<IDirectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDirectory(std::dynamic_pointer_cast<IDirectoryWriter>(clonedChildIDirectory));
            }
            return clonedObject;
        }

        std::string MiscObjectCatalogLocationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> MiscObjectCatalogLocationImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIRECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDirectory());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> MiscObjectCatalogLocationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> MiscObjectCatalogLocationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string MiscObjectCatalogLocationImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ModifyRuleImpl::ModifyRuleImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IParameterAddValueRule> ModifyRuleImpl::GetAddValue() const
        {
            return _addValue;
        }
        std::shared_ptr<IParameterMultiplyByValueRule> ModifyRuleImpl::GetMultiplyByValue() const
        {
            return _multiplyByValue;
        }

        void ModifyRuleImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ModifyRuleImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ModifyRuleImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kAddValue =  GetWriterAddValue();
                if (kAddValue)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAddValue));
                }
                const auto kMultiplyByValue =  GetWriterMultiplyByValue();
                if (kMultiplyByValue)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kMultiplyByValue));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ModifyRuleImpl::Clone()
        {
            auto clonedObject = std::make_shared<ModifyRuleImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kAddValue =  GetWriterAddValue();
            if (kAddValue)
            {
                auto clonedChild = std::dynamic_pointer_cast<ParameterAddValueRuleImpl>(kAddValue)->Clone();
                auto clonedChildIParameterAddValueRule = std::dynamic_pointer_cast<IParameterAddValueRule>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAddValue(std::dynamic_pointer_cast<IParameterAddValueRuleWriter>(clonedChildIParameterAddValueRule));
            }
            const auto kMultiplyByValue =  GetWriterMultiplyByValue();
            if (kMultiplyByValue)
            {
                auto clonedChild = std::dynamic_pointer_cast<ParameterMultiplyByValueRuleImpl>(kMultiplyByValue)->Clone();
                auto clonedChildIParameterMultiplyByValueRule = std::dynamic_pointer_cast<IParameterMultiplyByValueRule>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetMultiplyByValue(std::dynamic_pointer_cast<IParameterMultiplyByValueRuleWriter>(clonedChildIParameterMultiplyByValueRule));
            }
            return clonedObject;
        }

        std::string ModifyRuleImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ModifyRuleImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ADD_VALUE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAddValue());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__MULTIPLY_BY_VALUE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetMultiplyByValue());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ModifyRuleImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ModifyRuleImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ModifyRuleImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        NoneImpl::NoneImpl()
        {
            /**
            * Filling the property to type map
            */
        }


        void NoneImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType NoneImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> NoneImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> NoneImpl::Clone()
        {
            auto clonedObject = std::make_shared<NoneImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            return clonedObject;
        }

        std::string NoneImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> NoneImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> NoneImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> NoneImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string NoneImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        NurbsImpl::NurbsImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ORDER, SimpleType::UNSIGNED_INT);
        }

        uint32_t NurbsImpl::GetOrder() const
        {
            return _order;
        }
        std::vector<std::shared_ptr<IControlPoint>> NurbsImpl::GetControlPoints() const
        {
            std::vector<std::shared_ptr<IControlPoint>> temp;
            for(auto&& elm: _controlPoints)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IKnot>> NurbsImpl::GetKnots() const
        {
            std::vector<std::shared_ptr<IKnot>> temp;
            for(auto&& elm: _knots)
                temp.push_back(elm);
            return temp;
        }

        void NurbsImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ORDER)
            {
                // Simple type
                _order = ParserHelper::ParseUnsignedInt(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType NurbsImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> NurbsImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto controlPoints =  GetWriterControlPoints();
                if (!controlPoints.empty())
                {
                    for(auto&& item : controlPoints)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto knots =  GetWriterKnots();
                if (!knots.empty())
                {
                    for(auto&& item : knots)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> NurbsImpl::Clone()
        {
            auto clonedObject = std::make_shared<NurbsImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_order = GetOrder();
            // clone children
            const auto kControlPoints =  GetWriterControlPoints();
            if (!kControlPoints.empty())
            {
                std::vector<std::shared_ptr<IControlPointWriter>> clonedList;
                for(auto&& kItem : kControlPoints)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ControlPointImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IControlPointWriter>(clonedChild));
                }
                clonedObject->SetControlPoints(clonedList);
            }
            const auto kKnots =  GetWriterKnots();
            if (!kKnots.empty())
            {
                std::vector<std::shared_ptr<IKnotWriter>> clonedList;
                for(auto&& kItem : kKnots)
                {
                    auto clonedChild = std::dynamic_pointer_cast<KnotImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IKnotWriter>(clonedChild));
                }
                clonedObject->SetKnots(clonedList);
            }
            return clonedObject;
        }

        std::string NurbsImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> NurbsImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> NurbsImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__CONTROL_POINT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetControlPoints())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__KNOT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetKnots())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> NurbsImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string NurbsImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ObjectControllerImpl::ObjectControllerImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<ICatalogReference> ObjectControllerImpl::GetCatalogReference() const
        {
            return _catalogReference;
        }
        std::shared_ptr<IController> ObjectControllerImpl::GetController() const
        {
            return _controller;
        }

        void ObjectControllerImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ObjectControllerImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ObjectControllerImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kCatalogReference =  GetWriterCatalogReference();
                if (kCatalogReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogReference));
                }
                const auto kController =  GetWriterController();
                if (kController)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kController));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ObjectControllerImpl::Clone()
        {
            auto clonedObject = std::make_shared<ObjectControllerImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kCatalogReference =  GetWriterCatalogReference();
            if (kCatalogReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kCatalogReference)->Clone();
                auto clonedChildICatalogReference = std::dynamic_pointer_cast<ICatalogReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogReference(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChildICatalogReference));
            }
            const auto kController =  GetWriterController();
            if (kController)
            {
                auto clonedChild = std::dynamic_pointer_cast<ControllerImpl>(kController)->Clone();
                auto clonedChildIController = std::dynamic_pointer_cast<IController>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetController(std::dynamic_pointer_cast<IControllerWriter>(clonedChildIController));
            }
            return clonedObject;
        }

        std::string ObjectControllerImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ObjectControllerImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogReference());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CONTROLLER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetController());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ObjectControllerImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ObjectControllerImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ObjectControllerImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        OffroadConditionImpl::OffroadConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DURATION, SimpleType::DOUBLE);
        }

        double OffroadConditionImpl::GetDuration() const
        {
            return _duration;
        }

        void OffroadConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DURATION)
            {
                // Simple type
                _duration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType OffroadConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OffroadConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OffroadConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<OffroadConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_duration = GetDuration();
            // clone children
            return clonedObject;
        }

        std::string OffroadConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OffroadConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OffroadConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OffroadConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OffroadConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        OpenScenarioImpl::OpenScenarioImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IFileHeader> OpenScenarioImpl::GetFileHeader() const
        {
            return _fileHeader;
        }
        std::shared_ptr<IOpenScenarioCategory> OpenScenarioImpl::GetOpenScenarioCategory() const
        {
            return _openScenarioCategory;
        }

        void OpenScenarioImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType OpenScenarioImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OpenScenarioImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kFileHeader =  GetWriterFileHeader();
                if (kFileHeader)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kFileHeader));
                }
                const auto kOpenScenarioCategory =  GetWriterOpenScenarioCategory();
                if (kOpenScenarioCategory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOpenScenarioCategory));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OpenScenarioImpl::Clone()
        {
            auto clonedObject = std::make_shared<OpenScenarioImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kFileHeader =  GetWriterFileHeader();
            if (kFileHeader)
            {
                auto clonedChild = std::dynamic_pointer_cast<FileHeaderImpl>(kFileHeader)->Clone();
                auto clonedChildIFileHeader = std::dynamic_pointer_cast<IFileHeader>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetFileHeader(std::dynamic_pointer_cast<IFileHeaderWriter>(clonedChildIFileHeader));
            }
            const auto kOpenScenarioCategory =  GetWriterOpenScenarioCategory();
            if (kOpenScenarioCategory)
            {
                auto clonedChild = std::dynamic_pointer_cast<OpenScenarioCategoryImpl>(kOpenScenarioCategory)->Clone();
                auto clonedChildIOpenScenarioCategory = std::dynamic_pointer_cast<IOpenScenarioCategory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOpenScenarioCategory(std::dynamic_pointer_cast<IOpenScenarioCategoryWriter>(clonedChildIOpenScenarioCategory));
            }
            return clonedObject;
        }

        std::string OpenScenarioImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OpenScenarioImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__FILE_HEADER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetFileHeader());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__OPEN_SCENARIO_CATEGORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOpenScenarioCategory());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OpenScenarioImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OpenScenarioImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OpenScenarioImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        OpenScenarioCategoryImpl::OpenScenarioCategoryImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IScenarioDefinition> OpenScenarioCategoryImpl::GetScenarioDefinition() const
        {
            return _scenarioDefinition;
        }
        std::shared_ptr<ICatalogDefinition> OpenScenarioCategoryImpl::GetCatalogDefinition() const
        {
            return _catalogDefinition;
        }

        void OpenScenarioCategoryImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType OpenScenarioCategoryImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OpenScenarioCategoryImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kScenarioDefinition =  GetWriterScenarioDefinition();
                if (kScenarioDefinition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kScenarioDefinition));
                }
                const auto kCatalogDefinition =  GetWriterCatalogDefinition();
                if (kCatalogDefinition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogDefinition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OpenScenarioCategoryImpl::Clone()
        {
            auto clonedObject = std::make_shared<OpenScenarioCategoryImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kScenarioDefinition =  GetWriterScenarioDefinition();
            if (kScenarioDefinition)
            {
                auto clonedChild = std::dynamic_pointer_cast<ScenarioDefinitionImpl>(kScenarioDefinition)->Clone();
                auto clonedChildIScenarioDefinition = std::dynamic_pointer_cast<IScenarioDefinition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetScenarioDefinition(std::dynamic_pointer_cast<IScenarioDefinitionWriter>(clonedChildIScenarioDefinition));
            }
            const auto kCatalogDefinition =  GetWriterCatalogDefinition();
            if (kCatalogDefinition)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogDefinitionImpl>(kCatalogDefinition)->Clone();
                auto clonedChildICatalogDefinition = std::dynamic_pointer_cast<ICatalogDefinition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogDefinition(std::dynamic_pointer_cast<ICatalogDefinitionWriter>(clonedChildICatalogDefinition));
            }
            return clonedObject;
        }

        std::string OpenScenarioCategoryImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OpenScenarioCategoryImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SCENARIO_DEFINITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetScenarioDefinition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_DEFINITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogDefinition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OpenScenarioCategoryImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OpenScenarioCategoryImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OpenScenarioCategoryImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        OrientationImpl::OrientationImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__H, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__P, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__R, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TYPE, SimpleType::ENUM_TYPE);
        }

        double OrientationImpl::GetH() const
        {
            return _h;
        }
        double OrientationImpl::GetP() const
        {
            return _p;
        }
        double OrientationImpl::GetR() const
        {
            return _r;
        }
        ReferenceContext OrientationImpl::GetType() const
        {
            return _type;
        }

        void OrientationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__H)
            {
                // Simple type
                _h = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__P)
            {
                // Simple type
                _p = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__R)
            {
                // Simple type
                _r = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TYPE)
            {
                // Enumeration Type
                const auto kResult = ReferenceContext::GetFromLiteral(parameterLiteralValue);
                if (kResult != ReferenceContext::UNKNOWN)
                {
                    _type = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType OrientationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OrientationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OrientationImpl::Clone()
        {
            auto clonedObject = std::make_shared<OrientationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_h = GetH();
            // Simple type
            clonedObject->_p = GetP();
            // Simple type
            clonedObject->_r = GetR();
            // Enumeration Type
            const auto kType = GetType();
            if ( kType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_type = ReferenceContext::GetFromLiteral(kType.GetLiteral());
            }
            // clone children
            return clonedObject;
        }

        std::string OrientationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OrientationImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OrientationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OrientationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OrientationImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__TYPE)
            {
                auto type = GetType();
                return type.GetLiteral() != "UNKNOWN" ? type.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        OverrideBrakeActionImpl::OverrideBrakeActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ACTIVE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        bool OverrideBrakeActionImpl::GetActive() const
        {
            return _active;
        }
        double OverrideBrakeActionImpl::GetValue() const
        {
            return _value;
        }

        void OverrideBrakeActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
            {
                // Simple type
                _active = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType OverrideBrakeActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OverrideBrakeActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OverrideBrakeActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<OverrideBrakeActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_active = GetActive();
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string OverrideBrakeActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideBrakeActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OverrideBrakeActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideBrakeActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OverrideBrakeActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        OverrideClutchActionImpl::OverrideClutchActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ACTIVE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        bool OverrideClutchActionImpl::GetActive() const
        {
            return _active;
        }
        double OverrideClutchActionImpl::GetValue() const
        {
            return _value;
        }

        void OverrideClutchActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
            {
                // Simple type
                _active = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType OverrideClutchActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OverrideClutchActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OverrideClutchActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<OverrideClutchActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_active = GetActive();
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string OverrideClutchActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideClutchActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OverrideClutchActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideClutchActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OverrideClutchActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        OverrideControllerValueActionImpl::OverrideControllerValueActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IOverrideThrottleAction> OverrideControllerValueActionImpl::GetThrottle() const
        {
            return _throttle;
        }
        std::shared_ptr<IOverrideBrakeAction> OverrideControllerValueActionImpl::GetBrake() const
        {
            return _brake;
        }
        std::shared_ptr<IOverrideClutchAction> OverrideControllerValueActionImpl::GetClutch() const
        {
            return _clutch;
        }
        std::shared_ptr<IOverrideParkingBrakeAction> OverrideControllerValueActionImpl::GetParkingBrake() const
        {
            return _parkingBrake;
        }
        std::shared_ptr<IOverrideSteeringWheelAction> OverrideControllerValueActionImpl::GetSteeringWheel() const
        {
            return _steeringWheel;
        }
        std::shared_ptr<IOverrideGearAction> OverrideControllerValueActionImpl::GetGear() const
        {
            return _gear;
        }

        void OverrideControllerValueActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType OverrideControllerValueActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OverrideControllerValueActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kThrottle =  GetWriterThrottle();
                if (kThrottle)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kThrottle));
                }
                const auto kBrake =  GetWriterBrake();
                if (kBrake)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kBrake));
                }
                const auto kClutch =  GetWriterClutch();
                if (kClutch)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kClutch));
                }
                const auto kParkingBrake =  GetWriterParkingBrake();
                if (kParkingBrake)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kParkingBrake));
                }
                const auto kSteeringWheel =  GetWriterSteeringWheel();
                if (kSteeringWheel)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSteeringWheel));
                }
                const auto kGear =  GetWriterGear();
                if (kGear)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kGear));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OverrideControllerValueActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<OverrideControllerValueActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kThrottle =  GetWriterThrottle();
            if (kThrottle)
            {
                auto clonedChild = std::dynamic_pointer_cast<OverrideThrottleActionImpl>(kThrottle)->Clone();
                auto clonedChildIOverrideThrottleAction = std::dynamic_pointer_cast<IOverrideThrottleAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetThrottle(std::dynamic_pointer_cast<IOverrideThrottleActionWriter>(clonedChildIOverrideThrottleAction));
            }
            const auto kBrake =  GetWriterBrake();
            if (kBrake)
            {
                auto clonedChild = std::dynamic_pointer_cast<OverrideBrakeActionImpl>(kBrake)->Clone();
                auto clonedChildIOverrideBrakeAction = std::dynamic_pointer_cast<IOverrideBrakeAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetBrake(std::dynamic_pointer_cast<IOverrideBrakeActionWriter>(clonedChildIOverrideBrakeAction));
            }
            const auto kClutch =  GetWriterClutch();
            if (kClutch)
            {
                auto clonedChild = std::dynamic_pointer_cast<OverrideClutchActionImpl>(kClutch)->Clone();
                auto clonedChildIOverrideClutchAction = std::dynamic_pointer_cast<IOverrideClutchAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetClutch(std::dynamic_pointer_cast<IOverrideClutchActionWriter>(clonedChildIOverrideClutchAction));
            }
            const auto kParkingBrake =  GetWriterParkingBrake();
            if (kParkingBrake)
            {
                auto clonedChild = std::dynamic_pointer_cast<OverrideParkingBrakeActionImpl>(kParkingBrake)->Clone();
                auto clonedChildIOverrideParkingBrakeAction = std::dynamic_pointer_cast<IOverrideParkingBrakeAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetParkingBrake(std::dynamic_pointer_cast<IOverrideParkingBrakeActionWriter>(clonedChildIOverrideParkingBrakeAction));
            }
            const auto kSteeringWheel =  GetWriterSteeringWheel();
            if (kSteeringWheel)
            {
                auto clonedChild = std::dynamic_pointer_cast<OverrideSteeringWheelActionImpl>(kSteeringWheel)->Clone();
                auto clonedChildIOverrideSteeringWheelAction = std::dynamic_pointer_cast<IOverrideSteeringWheelAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSteeringWheel(std::dynamic_pointer_cast<IOverrideSteeringWheelActionWriter>(clonedChildIOverrideSteeringWheelAction));
            }
            const auto kGear =  GetWriterGear();
            if (kGear)
            {
                auto clonedChild = std::dynamic_pointer_cast<OverrideGearActionImpl>(kGear)->Clone();
                auto clonedChildIOverrideGearAction = std::dynamic_pointer_cast<IOverrideGearAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetGear(std::dynamic_pointer_cast<IOverrideGearActionWriter>(clonedChildIOverrideGearAction));
            }
            return clonedObject;
        }

        std::string OverrideControllerValueActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideControllerValueActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__THROTTLE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetThrottle());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BRAKE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetBrake());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CLUTCH)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetClutch());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PARKING_BRAKE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetParkingBrake());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__STEERING_WHEEL)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSteeringWheel());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__GEAR)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetGear());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OverrideControllerValueActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideControllerValueActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OverrideControllerValueActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        OverrideGearActionImpl::OverrideGearActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ACTIVE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NUMBER, SimpleType::DOUBLE);
        }

        bool OverrideGearActionImpl::GetActive() const
        {
            return _active;
        }
        double OverrideGearActionImpl::GetNumber() const
        {
            return _number;
        }

        void OverrideGearActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
            {
                // Simple type
                _active = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NUMBER)
            {
                // Simple type
                _number = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType OverrideGearActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OverrideGearActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OverrideGearActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<OverrideGearActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_active = GetActive();
            // Simple type
            clonedObject->_number = GetNumber();
            // clone children
            return clonedObject;
        }

        std::string OverrideGearActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideGearActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OverrideGearActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideGearActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OverrideGearActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        OverrideParkingBrakeActionImpl::OverrideParkingBrakeActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ACTIVE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        bool OverrideParkingBrakeActionImpl::GetActive() const
        {
            return _active;
        }
        double OverrideParkingBrakeActionImpl::GetValue() const
        {
            return _value;
        }

        void OverrideParkingBrakeActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
            {
                // Simple type
                _active = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType OverrideParkingBrakeActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OverrideParkingBrakeActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OverrideParkingBrakeActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<OverrideParkingBrakeActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_active = GetActive();
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string OverrideParkingBrakeActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideParkingBrakeActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OverrideParkingBrakeActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideParkingBrakeActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OverrideParkingBrakeActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        OverrideSteeringWheelActionImpl::OverrideSteeringWheelActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ACTIVE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        bool OverrideSteeringWheelActionImpl::GetActive() const
        {
            return _active;
        }
        double OverrideSteeringWheelActionImpl::GetValue() const
        {
            return _value;
        }

        void OverrideSteeringWheelActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
            {
                // Simple type
                _active = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType OverrideSteeringWheelActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OverrideSteeringWheelActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OverrideSteeringWheelActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<OverrideSteeringWheelActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_active = GetActive();
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string OverrideSteeringWheelActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideSteeringWheelActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OverrideSteeringWheelActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideSteeringWheelActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OverrideSteeringWheelActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        OverrideThrottleActionImpl::OverrideThrottleActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ACTIVE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        bool OverrideThrottleActionImpl::GetActive() const
        {
            return _active;
        }
        double OverrideThrottleActionImpl::GetValue() const
        {
            return _value;
        }

        void OverrideThrottleActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ACTIVE)
            {
                // Simple type
                _active = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType OverrideThrottleActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> OverrideThrottleActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> OverrideThrottleActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<OverrideThrottleActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_active = GetActive();
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string OverrideThrottleActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideThrottleActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> OverrideThrottleActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> OverrideThrottleActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string OverrideThrottleActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ParameterActionImpl::ParameterActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF, SimpleType::STRING);
        }

        std::shared_ptr<INamedReference<IParameterDeclaration>> ParameterActionImpl::GetParameterRef() const
        {
            return _parameterRef;
        }
        std::shared_ptr<IParameterSetAction> ParameterActionImpl::GetSetAction() const
        {
            return _setAction;
        }
        std::shared_ptr<IParameterModifyAction> ParameterActionImpl::GetModifyAction() const
        {
            return _modifyAction;
        }

        void ParameterActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IParameterDeclaration>>(parameterLiteralValue);
                _parameterRef = std::dynamic_pointer_cast<INamedReference<IParameterDeclaration>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ParameterActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kSetAction =  GetWriterSetAction();
                if (kSetAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSetAction));
                }
                const auto kModifyAction =  GetWriterModifyAction();
                if (kModifyAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kModifyAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IParameterDeclaration>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IParameterDeclaration>>(GetParameterRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_parameterRef = proxy;
            
            // clone children
            const auto kSetAction =  GetWriterSetAction();
            if (kSetAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<ParameterSetActionImpl>(kSetAction)->Clone();
                auto clonedChildIParameterSetAction = std::dynamic_pointer_cast<IParameterSetAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSetAction(std::dynamic_pointer_cast<IParameterSetActionWriter>(clonedChildIParameterSetAction));
            }
            const auto kModifyAction =  GetWriterModifyAction();
            if (kModifyAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<ParameterModifyActionImpl>(kModifyAction)->Clone();
                auto clonedChildIParameterModifyAction = std::dynamic_pointer_cast<IParameterModifyAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetModifyAction(std::dynamic_pointer_cast<IParameterModifyActionWriter>(clonedChildIParameterModifyAction));
            }
            return clonedObject;
        }

        std::string ParameterActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF)
            {
                // Get the Proxy
                auto parameterRef = GetParameterRef();
                return parameterRef!= nullptr ? parameterRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SET_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSetAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__MODIFY_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetModifyAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF)
            {
                // Get the Proxy
                auto parameterRef = GetParameterRef();
                return parameterRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(parameterRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string ParameterActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ParameterAddValueRuleImpl::ParameterAddValueRuleImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        double ParameterAddValueRuleImpl::GetValue() const
        {
            return _value;
        }

        void ParameterAddValueRuleImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ParameterAddValueRuleImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterAddValueRuleImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterAddValueRuleImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterAddValueRuleImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string ParameterAddValueRuleImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterAddValueRuleImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterAddValueRuleImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterAddValueRuleImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ParameterAddValueRuleImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ParameterAssignmentImpl::ParameterAssignmentImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
        }

        std::shared_ptr<INamedReference<IParameterDeclaration>> ParameterAssignmentImpl::GetParameterRef() const
        {
            return _parameterRef;
        }
        std::string ParameterAssignmentImpl::GetValue() const
        {
            return _value;
        }

        void ParameterAssignmentImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ParameterAssignmentImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterAssignmentImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterAssignmentImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterAssignmentImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IParameterDeclaration>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IParameterDeclaration>>(GetParameterRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_parameterRef = proxy;
            
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string ParameterAssignmentImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF)
            {
                // Get the Proxy
                auto parameterRef = GetParameterRef();
                return parameterRef!= nullptr ? parameterRef->GetNameRef() : "";
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterAssignmentImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterAssignmentImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterAssignmentImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF)
            {
                // Get the Proxy
                auto parameterRef = GetParameterRef();
                return parameterRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(parameterRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string ParameterAssignmentImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ParameterConditionImpl::ParameterConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
        }

        std::shared_ptr<INamedReference<IParameterDeclaration>> ParameterConditionImpl::GetParameterRef() const
        {
            return _parameterRef;
        }
        Rule ParameterConditionImpl::GetRule() const
        {
            return _rule;
        }
        std::string ParameterConditionImpl::GetValue() const
        {
            return _value;
        }

        void ParameterConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IParameterDeclaration>>(parameterLiteralValue);
                _parameterRef = std::dynamic_pointer_cast<INamedReference<IParameterDeclaration>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ParameterConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IParameterDeclaration>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IParameterDeclaration>>(GetParameterRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_parameterRef = proxy;
            
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string ParameterConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF)
            {
                // Get the Proxy
                auto parameterRef = GetParameterRef();
                return parameterRef!= nullptr ? parameterRef->GetNameRef() : "";
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_REF)
            {
                // Get the Proxy
                auto parameterRef = GetParameterRef();
                return parameterRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(parameterRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string ParameterConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        ParameterDeclarationImpl::ParameterDeclarationImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PARAMETER_TYPE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
        }

        std::string ParameterDeclarationImpl::GetName() const
        {
            return _name;
        }
        ParameterType ParameterDeclarationImpl::GetParameterType() const
        {
            return _parameterType;
        }
        std::string ParameterDeclarationImpl::GetValue() const
        {
            return _value;
        }

        void ParameterDeclarationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_TYPE)
            {
                // Enumeration Type
                const auto kResult = ParameterType::GetFromLiteral(parameterLiteralValue);
                if (kResult != ParameterType::UNKNOWN)
                {
                    _parameterType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ParameterDeclarationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterDeclarationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterDeclarationImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterDeclarationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // Enumeration Type
            const auto kParameterType = GetParameterType();
            if ( kParameterType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_parameterType = ParameterType::GetFromLiteral(kParameterType.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string ParameterDeclarationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterDeclarationImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterDeclarationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterDeclarationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ParameterDeclarationImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PARAMETER_TYPE)
            {
                auto parameterType = GetParameterType();
                return parameterType.GetLiteral() != "UNKNOWN" ? parameterType.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        ParameterModifyActionImpl::ParameterModifyActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IModifyRule> ParameterModifyActionImpl::GetRule() const
        {
            return _rule;
        }

        void ParameterModifyActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ParameterModifyActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterModifyActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRule =  GetWriterRule();
                if (kRule)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRule));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterModifyActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterModifyActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kRule =  GetWriterRule();
            if (kRule)
            {
                auto clonedChild = std::dynamic_pointer_cast<ModifyRuleImpl>(kRule)->Clone();
                auto clonedChildIModifyRule = std::dynamic_pointer_cast<IModifyRule>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRule(std::dynamic_pointer_cast<IModifyRuleWriter>(clonedChildIModifyRule));
            }
            return clonedObject;
        }

        std::string ParameterModifyActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterModifyActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RULE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRule());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterModifyActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterModifyActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ParameterModifyActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ParameterMultiplyByValueRuleImpl::ParameterMultiplyByValueRuleImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        double ParameterMultiplyByValueRuleImpl::GetValue() const
        {
            return _value;
        }

        void ParameterMultiplyByValueRuleImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ParameterMultiplyByValueRuleImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterMultiplyByValueRuleImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterMultiplyByValueRuleImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterMultiplyByValueRuleImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string ParameterMultiplyByValueRuleImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterMultiplyByValueRuleImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterMultiplyByValueRuleImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterMultiplyByValueRuleImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ParameterMultiplyByValueRuleImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ParameterSetActionImpl::ParameterSetActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
        }

        std::string ParameterSetActionImpl::GetValue() const
        {
            return _value;
        }

        void ParameterSetActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ParameterSetActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ParameterSetActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ParameterSetActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ParameterSetActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string ParameterSetActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterSetActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ParameterSetActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ParameterSetActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ParameterSetActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        PedestrianImpl::PedestrianImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MASS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MODEL, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PEDESTRIAN_CATEGORY, SimpleType::ENUM_TYPE);
        }

        double PedestrianImpl::GetMass() const
        {
            return _mass;
        }
        std::string PedestrianImpl::GetModel() const
        {
            return _model;
        }
        std::string PedestrianImpl::GetName() const
        {
            return _name;
        }
        PedestrianCategory PedestrianImpl::GetPedestrianCategory() const
        {
            return _pedestrianCategory;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> PedestrianImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::shared_ptr<IBoundingBox> PedestrianImpl::GetBoundingBox() const
        {
            return _boundingBox;
        }
        std::shared_ptr<IProperties> PedestrianImpl::GetProperties() const
        {
            return _properties;
        }

        void PedestrianImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MASS)
            {
                // Simple type
                _mass = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MODEL)
            {
                // Simple type
                _model = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PEDESTRIAN_CATEGORY)
            {
                // Enumeration Type
                const auto kResult = PedestrianCategory::GetFromLiteral(parameterLiteralValue);
                if (kResult != PedestrianCategory::UNKNOWN)
                {
                    _pedestrianCategory = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType PedestrianImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool PedestrianImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> PedestrianImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PedestrianImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kBoundingBox =  GetWriterBoundingBox();
                if (kBoundingBox)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kBoundingBox));
                }
                const auto kProperties =  GetWriterProperties();
                if (kProperties)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kProperties));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PedestrianImpl::Clone()
        {
            auto clonedObject = std::make_shared<PedestrianImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_mass = GetMass();
            // Simple type
            clonedObject->_model = GetModel();
            // Simple type
            clonedObject->_name = GetName();
            // Enumeration Type
            const auto kPedestrianCategory = GetPedestrianCategory();
            if ( kPedestrianCategory.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_pedestrianCategory = PedestrianCategory::GetFromLiteral(kPedestrianCategory.GetLiteral());
            }
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kBoundingBox =  GetWriterBoundingBox();
            if (kBoundingBox)
            {
                auto clonedChild = std::dynamic_pointer_cast<BoundingBoxImpl>(kBoundingBox)->Clone();
                auto clonedChildIBoundingBox = std::dynamic_pointer_cast<IBoundingBox>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetBoundingBox(std::dynamic_pointer_cast<IBoundingBoxWriter>(clonedChildIBoundingBox));
            }
            const auto kProperties =  GetWriterProperties();
            if (kProperties)
            {
                auto clonedChild = std::dynamic_pointer_cast<PropertiesImpl>(kProperties)->Clone();
                auto clonedChildIProperties = std::dynamic_pointer_cast<IProperties>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetProperties(std::dynamic_pointer_cast<IPropertiesWriter>(clonedChildIProperties));
            }
            return clonedObject;
        }

        std::string PedestrianImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__MODEL)
            {
                return GetModel();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PedestrianImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BOUNDING_BOX)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetBoundingBox());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PROPERTIES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetProperties());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PedestrianImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PedestrianImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PedestrianImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PEDESTRIAN_CATEGORY)
            {
                auto pedestrianCategory = GetPedestrianCategory();
                return pedestrianCategory.GetLiteral() != "UNKNOWN" ? pedestrianCategory.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        PedestrianCatalogLocationImpl::PedestrianCatalogLocationImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IDirectory> PedestrianCatalogLocationImpl::GetDirectory() const
        {
            return _directory;
        }

        void PedestrianCatalogLocationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType PedestrianCatalogLocationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PedestrianCatalogLocationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDirectory =  GetWriterDirectory();
                if (kDirectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDirectory));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PedestrianCatalogLocationImpl::Clone()
        {
            auto clonedObject = std::make_shared<PedestrianCatalogLocationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kDirectory =  GetWriterDirectory();
            if (kDirectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<DirectoryImpl>(kDirectory)->Clone();
                auto clonedChildIDirectory = std::dynamic_pointer_cast<IDirectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDirectory(std::dynamic_pointer_cast<IDirectoryWriter>(clonedChildIDirectory));
            }
            return clonedObject;
        }

        std::string PedestrianCatalogLocationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PedestrianCatalogLocationImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIRECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDirectory());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PedestrianCatalogLocationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PedestrianCatalogLocationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PedestrianCatalogLocationImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        PerformanceImpl::PerformanceImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED, SimpleType::DOUBLE);
        }

        double PerformanceImpl::GetMaxAcceleration() const
        {
            return _maxAcceleration;
        }
        double PerformanceImpl::GetMaxDeceleration() const
        {
            return _maxDeceleration;
        }
        double PerformanceImpl::GetMaxSpeed() const
        {
            return _maxSpeed;
        }

        void PerformanceImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_ACCELERATION)
            {
                // Simple type
                _maxAcceleration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_DECELERATION)
            {
                // Simple type
                _maxDeceleration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MAX_SPEED)
            {
                // Simple type
                _maxSpeed = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType PerformanceImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PerformanceImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PerformanceImpl::Clone()
        {
            auto clonedObject = std::make_shared<PerformanceImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_maxAcceleration = GetMaxAcceleration();
            // Simple type
            clonedObject->_maxDeceleration = GetMaxDeceleration();
            // Simple type
            clonedObject->_maxSpeed = GetMaxSpeed();
            // clone children
            return clonedObject;
        }

        std::string PerformanceImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PerformanceImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PerformanceImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PerformanceImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PerformanceImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        PhaseImpl::PhaseImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DURATION, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        double PhaseImpl::GetDuration() const
        {
            return _duration;
        }
        std::string PhaseImpl::GetName() const
        {
            return _name;
        }
        std::vector<std::shared_ptr<ITrafficSignalState>> PhaseImpl::GetTrafficSignalStates() const
        {
            std::vector<std::shared_ptr<ITrafficSignalState>> temp;
            for(auto&& elm: _trafficSignalStates)
                temp.push_back(elm);
            return temp;
        }

        void PhaseImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DURATION)
            {
                // Simple type
                _duration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType PhaseImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PhaseImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto trafficSignalStates =  GetWriterTrafficSignalStates();
                if (!trafficSignalStates.empty())
                {
                    for(auto&& item : trafficSignalStates)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PhaseImpl::Clone()
        {
            auto clonedObject = std::make_shared<PhaseImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_duration = GetDuration();
            // Simple type
            clonedObject->_name = GetName();
            // clone children
            const auto kTrafficSignalStates =  GetWriterTrafficSignalStates();
            if (!kTrafficSignalStates.empty())
            {
                std::vector<std::shared_ptr<ITrafficSignalStateWriter>> clonedList;
                for(auto&& kItem : kTrafficSignalStates)
                {
                    auto clonedChild = std::dynamic_pointer_cast<TrafficSignalStateImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<ITrafficSignalStateWriter>(clonedChild));
                }
                clonedObject->SetTrafficSignalStates(clonedList);
            }
            return clonedObject;
        }

        std::string PhaseImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PhaseImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PhaseImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SIGNAL_STATE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetTrafficSignalStates())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PhaseImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PhaseImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        PolylineImpl::PolylineImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::vector<std::shared_ptr<IVertex>> PolylineImpl::GetVertices() const
        {
            std::vector<std::shared_ptr<IVertex>> temp;
            for(auto&& elm: _vertices)
                temp.push_back(elm);
            return temp;
        }

        void PolylineImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType PolylineImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PolylineImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto vertices =  GetWriterVertices();
                if (!vertices.empty())
                {
                    for(auto&& item : vertices)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PolylineImpl::Clone()
        {
            auto clonedObject = std::make_shared<PolylineImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kVertices =  GetWriterVertices();
            if (!kVertices.empty())
            {
                std::vector<std::shared_ptr<IVertexWriter>> clonedList;
                for(auto&& kItem : kVertices)
                {
                    auto clonedChild = std::dynamic_pointer_cast<VertexImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IVertexWriter>(clonedChild));
                }
                clonedObject->SetVertices(clonedList);
            }
            return clonedObject;
        }

        std::string PolylineImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PolylineImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PolylineImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__VERTEX)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetVertices())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PolylineImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PolylineImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        PositionImpl::PositionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IWorldPosition> PositionImpl::GetWorldPosition() const
        {
            return _worldPosition;
        }
        std::shared_ptr<IRelativeWorldPosition> PositionImpl::GetRelativeWorldPosition() const
        {
            return _relativeWorldPosition;
        }
        std::shared_ptr<IRelativeObjectPosition> PositionImpl::GetRelativeObjectPosition() const
        {
            return _relativeObjectPosition;
        }
        std::shared_ptr<IRoadPosition> PositionImpl::GetRoadPosition() const
        {
            return _roadPosition;
        }
        std::shared_ptr<IRelativeRoadPosition> PositionImpl::GetRelativeRoadPosition() const
        {
            return _relativeRoadPosition;
        }
        std::shared_ptr<ILanePosition> PositionImpl::GetLanePosition() const
        {
            return _lanePosition;
        }
        std::shared_ptr<IRelativeLanePosition> PositionImpl::GetRelativeLanePosition() const
        {
            return _relativeLanePosition;
        }
        std::shared_ptr<IRoutePosition> PositionImpl::GetRoutePosition() const
        {
            return _routePosition;
        }

        void PositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType PositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kWorldPosition =  GetWriterWorldPosition();
                if (kWorldPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kWorldPosition));
                }
                const auto kRelativeWorldPosition =  GetWriterRelativeWorldPosition();
                if (kRelativeWorldPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeWorldPosition));
                }
                const auto kRelativeObjectPosition =  GetWriterRelativeObjectPosition();
                if (kRelativeObjectPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeObjectPosition));
                }
                const auto kRoadPosition =  GetWriterRoadPosition();
                if (kRoadPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRoadPosition));
                }
                const auto kRelativeRoadPosition =  GetWriterRelativeRoadPosition();
                if (kRelativeRoadPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeRoadPosition));
                }
                const auto kLanePosition =  GetWriterLanePosition();
                if (kLanePosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLanePosition));
                }
                const auto kRelativeLanePosition =  GetWriterRelativeLanePosition();
                if (kRelativeLanePosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeLanePosition));
                }
                const auto kRoutePosition =  GetWriterRoutePosition();
                if (kRoutePosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRoutePosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<PositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kWorldPosition =  GetWriterWorldPosition();
            if (kWorldPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<WorldPositionImpl>(kWorldPosition)->Clone();
                auto clonedChildIWorldPosition = std::dynamic_pointer_cast<IWorldPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetWorldPosition(std::dynamic_pointer_cast<IWorldPositionWriter>(clonedChildIWorldPosition));
            }
            const auto kRelativeWorldPosition =  GetWriterRelativeWorldPosition();
            if (kRelativeWorldPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeWorldPositionImpl>(kRelativeWorldPosition)->Clone();
                auto clonedChildIRelativeWorldPosition = std::dynamic_pointer_cast<IRelativeWorldPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeWorldPosition(std::dynamic_pointer_cast<IRelativeWorldPositionWriter>(clonedChildIRelativeWorldPosition));
            }
            const auto kRelativeObjectPosition =  GetWriterRelativeObjectPosition();
            if (kRelativeObjectPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeObjectPositionImpl>(kRelativeObjectPosition)->Clone();
                auto clonedChildIRelativeObjectPosition = std::dynamic_pointer_cast<IRelativeObjectPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeObjectPosition(std::dynamic_pointer_cast<IRelativeObjectPositionWriter>(clonedChildIRelativeObjectPosition));
            }
            const auto kRoadPosition =  GetWriterRoadPosition();
            if (kRoadPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RoadPositionImpl>(kRoadPosition)->Clone();
                auto clonedChildIRoadPosition = std::dynamic_pointer_cast<IRoadPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRoadPosition(std::dynamic_pointer_cast<IRoadPositionWriter>(clonedChildIRoadPosition));
            }
            const auto kRelativeRoadPosition =  GetWriterRelativeRoadPosition();
            if (kRelativeRoadPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeRoadPositionImpl>(kRelativeRoadPosition)->Clone();
                auto clonedChildIRelativeRoadPosition = std::dynamic_pointer_cast<IRelativeRoadPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeRoadPosition(std::dynamic_pointer_cast<IRelativeRoadPositionWriter>(clonedChildIRelativeRoadPosition));
            }
            const auto kLanePosition =  GetWriterLanePosition();
            if (kLanePosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<LanePositionImpl>(kLanePosition)->Clone();
                auto clonedChildILanePosition = std::dynamic_pointer_cast<ILanePosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLanePosition(std::dynamic_pointer_cast<ILanePositionWriter>(clonedChildILanePosition));
            }
            const auto kRelativeLanePosition =  GetWriterRelativeLanePosition();
            if (kRelativeLanePosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeLanePositionImpl>(kRelativeLanePosition)->Clone();
                auto clonedChildIRelativeLanePosition = std::dynamic_pointer_cast<IRelativeLanePosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeLanePosition(std::dynamic_pointer_cast<IRelativeLanePositionWriter>(clonedChildIRelativeLanePosition));
            }
            const auto kRoutePosition =  GetWriterRoutePosition();
            if (kRoutePosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<RoutePositionImpl>(kRoutePosition)->Clone();
                auto clonedChildIRoutePosition = std::dynamic_pointer_cast<IRoutePosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRoutePosition(std::dynamic_pointer_cast<IRoutePositionWriter>(clonedChildIRoutePosition));
            }
            return clonedObject;
        }

        std::string PositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__WORLD_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetWorldPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_WORLD_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeWorldPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_OBJECT_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeObjectPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ROAD_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRoadPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_ROAD_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeRoadPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LANE_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLanePosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_LANE_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeLanePosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ROUTE_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRoutePosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        PositionInLaneCoordinatesImpl::PositionInLaneCoordinatesImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LANE_ID, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__LANE_OFFSET, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PATH_S, SimpleType::DOUBLE);
        }

        std::string PositionInLaneCoordinatesImpl::GetLaneId() const
        {
            return _laneId;
        }
        double PositionInLaneCoordinatesImpl::GetLaneOffset() const
        {
            return _laneOffset;
        }
        double PositionInLaneCoordinatesImpl::GetPathS() const
        {
            return _pathS;
        }

        void PositionInLaneCoordinatesImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LANE_ID)
            {
                // Simple type
                _laneId = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__LANE_OFFSET)
            {
                // Simple type
                _laneOffset = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PATH_S)
            {
                // Simple type
                _pathS = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType PositionInLaneCoordinatesImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PositionInLaneCoordinatesImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PositionInLaneCoordinatesImpl::Clone()
        {
            auto clonedObject = std::make_shared<PositionInLaneCoordinatesImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_laneId = GetLaneId();
            // Simple type
            clonedObject->_laneOffset = GetLaneOffset();
            // Simple type
            clonedObject->_pathS = GetPathS();
            // clone children
            return clonedObject;
        }

        std::string PositionInLaneCoordinatesImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__LANE_ID)
            {
                return GetLaneId();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PositionInLaneCoordinatesImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PositionInLaneCoordinatesImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PositionInLaneCoordinatesImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PositionInLaneCoordinatesImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        PositionInRoadCoordinatesImpl::PositionInRoadCoordinatesImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PATH_S, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__T, SimpleType::DOUBLE);
        }

        double PositionInRoadCoordinatesImpl::GetPathS() const
        {
            return _pathS;
        }
        double PositionInRoadCoordinatesImpl::GetT() const
        {
            return _t;
        }

        void PositionInRoadCoordinatesImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PATH_S)
            {
                // Simple type
                _pathS = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__T)
            {
                // Simple type
                _t = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType PositionInRoadCoordinatesImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PositionInRoadCoordinatesImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PositionInRoadCoordinatesImpl::Clone()
        {
            auto clonedObject = std::make_shared<PositionInRoadCoordinatesImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_pathS = GetPathS();
            // Simple type
            clonedObject->_t = GetT();
            // clone children
            return clonedObject;
        }

        std::string PositionInRoadCoordinatesImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PositionInRoadCoordinatesImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PositionInRoadCoordinatesImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PositionInRoadCoordinatesImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PositionInRoadCoordinatesImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        PositionOfCurrentEntityImpl::PositionOfCurrentEntityImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
        }

        std::shared_ptr<INamedReference<IEntity>> PositionOfCurrentEntityImpl::GetEntityRef() const
        {
            return _entityRef;
        }

        void PositionOfCurrentEntityImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType PositionOfCurrentEntityImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PositionOfCurrentEntityImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PositionOfCurrentEntityImpl::Clone()
        {
            auto clonedObject = std::make_shared<PositionOfCurrentEntityImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // clone children
            return clonedObject;
        }

        std::string PositionOfCurrentEntityImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PositionOfCurrentEntityImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PositionOfCurrentEntityImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PositionOfCurrentEntityImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string PositionOfCurrentEntityImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        PrecipitationImpl::PrecipitationImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__INTENSITY, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PRECIPITATION_TYPE, SimpleType::ENUM_TYPE);
        }

        double PrecipitationImpl::GetIntensity() const
        {
            return _intensity;
        }
        PrecipitationType PrecipitationImpl::GetPrecipitationType() const
        {
            return _precipitationType;
        }

        void PrecipitationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__INTENSITY)
            {
                // Simple type
                _intensity = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PRECIPITATION_TYPE)
            {
                // Enumeration Type
                const auto kResult = PrecipitationType::GetFromLiteral(parameterLiteralValue);
                if (kResult != PrecipitationType::UNKNOWN)
                {
                    _precipitationType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType PrecipitationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PrecipitationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PrecipitationImpl::Clone()
        {
            auto clonedObject = std::make_shared<PrecipitationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_intensity = GetIntensity();
            // Enumeration Type
            const auto kPrecipitationType = GetPrecipitationType();
            if ( kPrecipitationType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_precipitationType = PrecipitationType::GetFromLiteral(kPrecipitationType.GetLiteral());
            }
            // clone children
            return clonedObject;
        }

        std::string PrecipitationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PrecipitationImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PrecipitationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PrecipitationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PrecipitationImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PRECIPITATION_TYPE)
            {
                auto precipitationType = GetPrecipitationType();
                return precipitationType.GetLiteral() != "UNKNOWN" ? precipitationType.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        PrivateImpl::PrivateImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
        }

        std::shared_ptr<INamedReference<IEntity>> PrivateImpl::GetEntityRef() const
        {
            return _entityRef;
        }
        std::vector<std::shared_ptr<IPrivateAction>> PrivateImpl::GetPrivateActions() const
        {
            std::vector<std::shared_ptr<IPrivateAction>> temp;
            for(auto&& elm: _privateActions)
                temp.push_back(elm);
            return temp;
        }

        void PrivateImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType PrivateImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PrivateImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto privateActions =  GetWriterPrivateActions();
                if (!privateActions.empty())
                {
                    for(auto&& item : privateActions)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PrivateImpl::Clone()
        {
            auto clonedObject = std::make_shared<PrivateImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // clone children
            const auto kPrivateActions =  GetWriterPrivateActions();
            if (!kPrivateActions.empty())
            {
                std::vector<std::shared_ptr<IPrivateActionWriter>> clonedList;
                for(auto&& kItem : kPrivateActions)
                {
                    auto clonedChild = std::dynamic_pointer_cast<PrivateActionImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IPrivateActionWriter>(clonedChild));
                }
                clonedObject->SetPrivateActions(clonedList);
            }
            return clonedObject;
        }

        std::string PrivateImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PrivateImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PrivateImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__PRIVATE_ACTION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetPrivateActions())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PrivateImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string PrivateImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        PrivateActionImpl::PrivateActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<ILongitudinalAction> PrivateActionImpl::GetLongitudinalAction() const
        {
            return _longitudinalAction;
        }
        std::shared_ptr<ILateralAction> PrivateActionImpl::GetLateralAction() const
        {
            return _lateralAction;
        }
        std::shared_ptr<IVisibilityAction> PrivateActionImpl::GetVisibilityAction() const
        {
            return _visibilityAction;
        }
        std::shared_ptr<ISynchronizeAction> PrivateActionImpl::GetSynchronizeAction() const
        {
            return _synchronizeAction;
        }
        std::shared_ptr<IActivateControllerAction> PrivateActionImpl::GetActivateControllerAction() const
        {
            return _activateControllerAction;
        }
        std::shared_ptr<IControllerAction> PrivateActionImpl::GetControllerAction() const
        {
            return _controllerAction;
        }
        std::shared_ptr<ITeleportAction> PrivateActionImpl::GetTeleportAction() const
        {
            return _teleportAction;
        }
        std::shared_ptr<IRoutingAction> PrivateActionImpl::GetRoutingAction() const
        {
            return _routingAction;
        }

        void PrivateActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType PrivateActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PrivateActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kLongitudinalAction =  GetWriterLongitudinalAction();
                if (kLongitudinalAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLongitudinalAction));
                }
                const auto kLateralAction =  GetWriterLateralAction();
                if (kLateralAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLateralAction));
                }
                const auto kVisibilityAction =  GetWriterVisibilityAction();
                if (kVisibilityAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kVisibilityAction));
                }
                const auto kSynchronizeAction =  GetWriterSynchronizeAction();
                if (kSynchronizeAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSynchronizeAction));
                }
                const auto kActivateControllerAction =  GetWriterActivateControllerAction();
                if (kActivateControllerAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kActivateControllerAction));
                }
                const auto kControllerAction =  GetWriterControllerAction();
                if (kControllerAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kControllerAction));
                }
                const auto kTeleportAction =  GetWriterTeleportAction();
                if (kTeleportAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTeleportAction));
                }
                const auto kRoutingAction =  GetWriterRoutingAction();
                if (kRoutingAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRoutingAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PrivateActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<PrivateActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kLongitudinalAction =  GetWriterLongitudinalAction();
            if (kLongitudinalAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<LongitudinalActionImpl>(kLongitudinalAction)->Clone();
                auto clonedChildILongitudinalAction = std::dynamic_pointer_cast<ILongitudinalAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLongitudinalAction(std::dynamic_pointer_cast<ILongitudinalActionWriter>(clonedChildILongitudinalAction));
            }
            const auto kLateralAction =  GetWriterLateralAction();
            if (kLateralAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<LateralActionImpl>(kLateralAction)->Clone();
                auto clonedChildILateralAction = std::dynamic_pointer_cast<ILateralAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLateralAction(std::dynamic_pointer_cast<ILateralActionWriter>(clonedChildILateralAction));
            }
            const auto kVisibilityAction =  GetWriterVisibilityAction();
            if (kVisibilityAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<VisibilityActionImpl>(kVisibilityAction)->Clone();
                auto clonedChildIVisibilityAction = std::dynamic_pointer_cast<IVisibilityAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetVisibilityAction(std::dynamic_pointer_cast<IVisibilityActionWriter>(clonedChildIVisibilityAction));
            }
            const auto kSynchronizeAction =  GetWriterSynchronizeAction();
            if (kSynchronizeAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<SynchronizeActionImpl>(kSynchronizeAction)->Clone();
                auto clonedChildISynchronizeAction = std::dynamic_pointer_cast<ISynchronizeAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSynchronizeAction(std::dynamic_pointer_cast<ISynchronizeActionWriter>(clonedChildISynchronizeAction));
            }
            const auto kActivateControllerAction =  GetWriterActivateControllerAction();
            if (kActivateControllerAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<ActivateControllerActionImpl>(kActivateControllerAction)->Clone();
                auto clonedChildIActivateControllerAction = std::dynamic_pointer_cast<IActivateControllerAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetActivateControllerAction(std::dynamic_pointer_cast<IActivateControllerActionWriter>(clonedChildIActivateControllerAction));
            }
            const auto kControllerAction =  GetWriterControllerAction();
            if (kControllerAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<ControllerActionImpl>(kControllerAction)->Clone();
                auto clonedChildIControllerAction = std::dynamic_pointer_cast<IControllerAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetControllerAction(std::dynamic_pointer_cast<IControllerActionWriter>(clonedChildIControllerAction));
            }
            const auto kTeleportAction =  GetWriterTeleportAction();
            if (kTeleportAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<TeleportActionImpl>(kTeleportAction)->Clone();
                auto clonedChildITeleportAction = std::dynamic_pointer_cast<ITeleportAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTeleportAction(std::dynamic_pointer_cast<ITeleportActionWriter>(clonedChildITeleportAction));
            }
            const auto kRoutingAction =  GetWriterRoutingAction();
            if (kRoutingAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<RoutingActionImpl>(kRoutingAction)->Clone();
                auto clonedChildIRoutingAction = std::dynamic_pointer_cast<IRoutingAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRoutingAction(std::dynamic_pointer_cast<IRoutingActionWriter>(clonedChildIRoutingAction));
            }
            return clonedObject;
        }

        std::string PrivateActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PrivateActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LONGITUDINAL_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLongitudinalAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LATERAL_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLateralAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__VISIBILITY_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetVisibilityAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SYNCHRONIZE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSynchronizeAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ACTIVATE_CONTROLLER_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetActivateControllerAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CONTROLLER_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetControllerAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TELEPORT_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTeleportAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ROUTING_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRoutingAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PrivateActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PrivateActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PrivateActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        PropertiesImpl::PropertiesImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::vector<std::shared_ptr<IProperty>> PropertiesImpl::GetProperties() const
        {
            std::vector<std::shared_ptr<IProperty>> temp;
            for(auto&& elm: _properties)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IFile>> PropertiesImpl::GetFiles() const
        {
            std::vector<std::shared_ptr<IFile>> temp;
            for(auto&& elm: _files)
                temp.push_back(elm);
            return temp;
        }

        void PropertiesImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType PropertiesImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PropertiesImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto properties =  GetWriterProperties();
                if (!properties.empty())
                {
                    for(auto&& item : properties)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto files =  GetWriterFiles();
                if (!files.empty())
                {
                    for(auto&& item : files)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PropertiesImpl::Clone()
        {
            auto clonedObject = std::make_shared<PropertiesImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kProperties =  GetWriterProperties();
            if (!kProperties.empty())
            {
                std::vector<std::shared_ptr<IPropertyWriter>> clonedList;
                for(auto&& kItem : kProperties)
                {
                    auto clonedChild = std::dynamic_pointer_cast<PropertyImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IPropertyWriter>(clonedChild));
                }
                clonedObject->SetProperties(clonedList);
            }
            const auto kFiles =  GetWriterFiles();
            if (!kFiles.empty())
            {
                std::vector<std::shared_ptr<IFileWriter>> clonedList;
                for(auto&& kItem : kFiles)
                {
                    auto clonedChild = std::dynamic_pointer_cast<FileImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IFileWriter>(clonedChild));
                }
                clonedObject->SetFiles(clonedList);
            }
            return clonedObject;
        }

        std::string PropertiesImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PropertiesImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PropertiesImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__PROPERTY)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetProperties())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__FILE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetFiles())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PropertiesImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PropertiesImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        PropertyImpl::PropertyImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
        }

        std::string PropertyImpl::GetName() const
        {
            return _name;
        }
        std::string PropertyImpl::GetValue() const
        {
            return _value;
        }

        void PropertyImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType PropertyImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> PropertyImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> PropertyImpl::Clone()
        {
            auto clonedObject = std::make_shared<PropertyImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string PropertyImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PropertyImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> PropertyImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> PropertyImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string PropertyImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ReachPositionConditionImpl::ReachPositionConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TOLERANCE, SimpleType::DOUBLE);
        }

        double ReachPositionConditionImpl::GetTolerance() const
        {
            return _tolerance;
        }
        std::shared_ptr<IPosition> ReachPositionConditionImpl::GetPosition() const
        {
            return _position;
        }

        void ReachPositionConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TOLERANCE)
            {
                // Simple type
                _tolerance = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ReachPositionConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ReachPositionConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ReachPositionConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ReachPositionConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_tolerance = GetTolerance();
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            return clonedObject;
        }

        std::string ReachPositionConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ReachPositionConditionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ReachPositionConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ReachPositionConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ReachPositionConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        RelativeDistanceConditionImpl::RelativeDistanceConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FREESPACE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        std::shared_ptr<INamedReference<IEntity>> RelativeDistanceConditionImpl::GetEntityRef() const
        {
            return _entityRef;
        }
        bool RelativeDistanceConditionImpl::GetFreespace() const
        {
            return _freespace;
        }
        RelativeDistanceType RelativeDistanceConditionImpl::GetRelativeDistanceType() const
        {
            return _relativeDistanceType;
        }
        Rule RelativeDistanceConditionImpl::GetRule() const
        {
            return _rule;
        }
        double RelativeDistanceConditionImpl::GetValue() const
        {
            return _value;
        }

        void RelativeDistanceConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
            {
                // Simple type
                _freespace = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE)
            {
                // Enumeration Type
                const auto kResult = RelativeDistanceType::GetFromLiteral(parameterLiteralValue);
                if (kResult != RelativeDistanceType::UNKNOWN)
                {
                    _relativeDistanceType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeDistanceConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeDistanceConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeDistanceConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeDistanceConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Simple type
            clonedObject->_freespace = GetFreespace();
            // Enumeration Type
            const auto kRelativeDistanceType = GetRelativeDistanceType();
            if ( kRelativeDistanceType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_relativeDistanceType = RelativeDistanceType::GetFromLiteral(kRelativeDistanceType.GetLiteral());
            }
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string RelativeDistanceConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeDistanceConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeDistanceConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeDistanceConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string RelativeDistanceConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__RELATIVE_DISTANCE_TYPE)
            {
                auto relativeDistanceType = GetRelativeDistanceType();
                return relativeDistanceType.GetLiteral() != "UNKNOWN" ? relativeDistanceType.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        RelativeLanePositionImpl::RelativeLanePositionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__D_LANE, SimpleType::INT);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__OFFSET, SimpleType::DOUBLE);
        }

        int RelativeLanePositionImpl::GetDLane() const
        {
            return _dLane;
        }
        double RelativeLanePositionImpl::GetDs() const
        {
            return _ds;
        }
        std::shared_ptr<INamedReference<IEntity>> RelativeLanePositionImpl::GetEntityRef() const
        {
            return _entityRef;
        }
        double RelativeLanePositionImpl::GetOffset() const
        {
            return _offset;
        }
        std::shared_ptr<IOrientation> RelativeLanePositionImpl::GetOrientation() const
        {
            return _orientation;
        }

        void RelativeLanePositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__D_LANE)
            {
                // Simple type
                _dLane = ParserHelper::ParseInt(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DS)
            {
                // Simple type
                _ds = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__OFFSET)
            {
                // Simple type
                _offset = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeLanePositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeLanePositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kOrientation =  GetWriterOrientation();
                if (kOrientation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOrientation));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeLanePositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeLanePositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_dLane = GetDLane();
            // Simple type
            clonedObject->_ds = GetDs();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Simple type
            clonedObject->_offset = GetOffset();
            // clone children
            const auto kOrientation =  GetWriterOrientation();
            if (kOrientation)
            {
                auto clonedChild = std::dynamic_pointer_cast<OrientationImpl>(kOrientation)->Clone();
                auto clonedChildIOrientation = std::dynamic_pointer_cast<IOrientation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOrientation(std::dynamic_pointer_cast<IOrientationWriter>(clonedChildIOrientation));
            }
            return clonedObject;
        }

        std::string RelativeLanePositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeLanePositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ORIENTATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOrientation());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeLanePositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeLanePositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string RelativeLanePositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        RelativeObjectPositionImpl::RelativeObjectPositionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DX, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DY, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DZ, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
        }

        double RelativeObjectPositionImpl::GetDx() const
        {
            return _dx;
        }
        double RelativeObjectPositionImpl::GetDy() const
        {
            return _dy;
        }
        double RelativeObjectPositionImpl::GetDz() const
        {
            return _dz;
        }
        std::shared_ptr<INamedReference<IEntity>> RelativeObjectPositionImpl::GetEntityRef() const
        {
            return _entityRef;
        }
        std::shared_ptr<IOrientation> RelativeObjectPositionImpl::GetOrientation() const
        {
            return _orientation;
        }

        void RelativeObjectPositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DX)
            {
                // Simple type
                _dx = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DY)
            {
                // Simple type
                _dy = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DZ)
            {
                // Simple type
                _dz = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeObjectPositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeObjectPositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kOrientation =  GetWriterOrientation();
                if (kOrientation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOrientation));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeObjectPositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeObjectPositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_dx = GetDx();
            // Simple type
            clonedObject->_dy = GetDy();
            // Simple type
            clonedObject->_dz = GetDz();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // clone children
            const auto kOrientation =  GetWriterOrientation();
            if (kOrientation)
            {
                auto clonedChild = std::dynamic_pointer_cast<OrientationImpl>(kOrientation)->Clone();
                auto clonedChildIOrientation = std::dynamic_pointer_cast<IOrientation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOrientation(std::dynamic_pointer_cast<IOrientationWriter>(clonedChildIOrientation));
            }
            return clonedObject;
        }

        std::string RelativeObjectPositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeObjectPositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ORIENTATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOrientation());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeObjectPositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeObjectPositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string RelativeObjectPositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        RelativeRoadPositionImpl::RelativeRoadPositionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DT, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
        }

        double RelativeRoadPositionImpl::GetDs() const
        {
            return _ds;
        }
        double RelativeRoadPositionImpl::GetDt() const
        {
            return _dt;
        }
        std::shared_ptr<INamedReference<IEntity>> RelativeRoadPositionImpl::GetEntityRef() const
        {
            return _entityRef;
        }
        std::shared_ptr<IOrientation> RelativeRoadPositionImpl::GetOrientation() const
        {
            return _orientation;
        }

        void RelativeRoadPositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DS)
            {
                // Simple type
                _ds = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DT)
            {
                // Simple type
                _dt = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeRoadPositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeRoadPositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kOrientation =  GetWriterOrientation();
                if (kOrientation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOrientation));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeRoadPositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeRoadPositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_ds = GetDs();
            // Simple type
            clonedObject->_dt = GetDt();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // clone children
            const auto kOrientation =  GetWriterOrientation();
            if (kOrientation)
            {
                auto clonedChild = std::dynamic_pointer_cast<OrientationImpl>(kOrientation)->Clone();
                auto clonedChildIOrientation = std::dynamic_pointer_cast<IOrientation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOrientation(std::dynamic_pointer_cast<IOrientationWriter>(clonedChildIOrientation));
            }
            return clonedObject;
        }

        std::string RelativeRoadPositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeRoadPositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ORIENTATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOrientation());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeRoadPositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeRoadPositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string RelativeRoadPositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        RelativeSpeedConditionImpl::RelativeSpeedConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        std::shared_ptr<INamedReference<IEntity>> RelativeSpeedConditionImpl::GetEntityRef() const
        {
            return _entityRef;
        }
        Rule RelativeSpeedConditionImpl::GetRule() const
        {
            return _rule;
        }
        double RelativeSpeedConditionImpl::GetValue() const
        {
            return _value;
        }

        void RelativeSpeedConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeSpeedConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeSpeedConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeSpeedConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeSpeedConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string RelativeSpeedConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeSpeedConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeSpeedConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeSpeedConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string RelativeSpeedConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        RelativeSpeedToMasterImpl::RelativeSpeedToMasterImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        SpeedTargetValueType RelativeSpeedToMasterImpl::GetSpeedTargetValueType() const
        {
            return _speedTargetValueType;
        }
        double RelativeSpeedToMasterImpl::GetValue() const
        {
            return _value;
        }

        void RelativeSpeedToMasterImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE)
            {
                // Enumeration Type
                const auto kResult = SpeedTargetValueType::GetFromLiteral(parameterLiteralValue);
                if (kResult != SpeedTargetValueType::UNKNOWN)
                {
                    _speedTargetValueType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeSpeedToMasterImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeSpeedToMasterImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeSpeedToMasterImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeSpeedToMasterImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Enumeration Type
            const auto kSpeedTargetValueType = GetSpeedTargetValueType();
            if ( kSpeedTargetValueType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_speedTargetValueType = SpeedTargetValueType::GetFromLiteral(kSpeedTargetValueType.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string RelativeSpeedToMasterImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeSpeedToMasterImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeSpeedToMasterImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeSpeedToMasterImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RelativeSpeedToMasterImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE)
            {
                auto speedTargetValueType = GetSpeedTargetValueType();
                return speedTargetValueType.GetLiteral() != "UNKNOWN" ? speedTargetValueType.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        RelativeTargetLaneImpl::RelativeTargetLaneImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::INT);
        }

        std::shared_ptr<INamedReference<IEntity>> RelativeTargetLaneImpl::GetEntityRef() const
        {
            return _entityRef;
        }
        int RelativeTargetLaneImpl::GetValue() const
        {
            return _value;
        }

        void RelativeTargetLaneImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseInt(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeTargetLaneImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeTargetLaneImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeTargetLaneImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeTargetLaneImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string RelativeTargetLaneImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeTargetLaneImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeTargetLaneImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeTargetLaneImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string RelativeTargetLaneImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        RelativeTargetLaneOffsetImpl::RelativeTargetLaneOffsetImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        std::shared_ptr<INamedReference<IEntity>> RelativeTargetLaneOffsetImpl::GetEntityRef() const
        {
            return _entityRef;
        }
        double RelativeTargetLaneOffsetImpl::GetValue() const
        {
            return _value;
        }

        void RelativeTargetLaneOffsetImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeTargetLaneOffsetImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeTargetLaneOffsetImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeTargetLaneOffsetImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeTargetLaneOffsetImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string RelativeTargetLaneOffsetImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeTargetLaneOffsetImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeTargetLaneOffsetImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeTargetLaneOffsetImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string RelativeTargetLaneOffsetImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        RelativeTargetSpeedImpl::RelativeTargetSpeedImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        bool RelativeTargetSpeedImpl::GetContinuous() const
        {
            return _continuous;
        }
        std::shared_ptr<INamedReference<IEntity>> RelativeTargetSpeedImpl::GetEntityRef() const
        {
            return _entityRef;
        }
        SpeedTargetValueType RelativeTargetSpeedImpl::GetSpeedTargetValueType() const
        {
            return _speedTargetValueType;
        }
        double RelativeTargetSpeedImpl::GetValue() const
        {
            return _value;
        }

        void RelativeTargetSpeedImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CONTINUOUS)
            {
                // Simple type
                _continuous = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE)
            {
                // Enumeration Type
                const auto kResult = SpeedTargetValueType::GetFromLiteral(parameterLiteralValue);
                if (kResult != SpeedTargetValueType::UNKNOWN)
                {
                    _speedTargetValueType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeTargetSpeedImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeTargetSpeedImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeTargetSpeedImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeTargetSpeedImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_continuous = GetContinuous();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Enumeration Type
            const auto kSpeedTargetValueType = GetSpeedTargetValueType();
            if ( kSpeedTargetValueType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_speedTargetValueType = SpeedTargetValueType::GetFromLiteral(kSpeedTargetValueType.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string RelativeTargetSpeedImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeTargetSpeedImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeTargetSpeedImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeTargetSpeedImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string RelativeTargetSpeedImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__SPEED_TARGET_VALUE_TYPE)
            {
                auto speedTargetValueType = GetSpeedTargetValueType();
                return speedTargetValueType.GetLiteral() != "UNKNOWN" ? speedTargetValueType.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        RelativeWorldPositionImpl::RelativeWorldPositionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DX, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DY, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DZ, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
        }

        double RelativeWorldPositionImpl::GetDx() const
        {
            return _dx;
        }
        double RelativeWorldPositionImpl::GetDy() const
        {
            return _dy;
        }
        double RelativeWorldPositionImpl::GetDz() const
        {
            return _dz;
        }
        std::shared_ptr<INamedReference<IEntity>> RelativeWorldPositionImpl::GetEntityRef() const
        {
            return _entityRef;
        }
        std::shared_ptr<IOrientation> RelativeWorldPositionImpl::GetOrientation() const
        {
            return _orientation;
        }

        void RelativeWorldPositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DX)
            {
                // Simple type
                _dx = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DY)
            {
                // Simple type
                _dy = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DZ)
            {
                // Simple type
                _dz = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RelativeWorldPositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RelativeWorldPositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kOrientation =  GetWriterOrientation();
                if (kOrientation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOrientation));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RelativeWorldPositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RelativeWorldPositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_dx = GetDx();
            // Simple type
            clonedObject->_dy = GetDy();
            // Simple type
            clonedObject->_dz = GetDz();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // clone children
            const auto kOrientation =  GetWriterOrientation();
            if (kOrientation)
            {
                auto clonedChild = std::dynamic_pointer_cast<OrientationImpl>(kOrientation)->Clone();
                auto clonedChildIOrientation = std::dynamic_pointer_cast<IOrientation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOrientation(std::dynamic_pointer_cast<IOrientationWriter>(clonedChildIOrientation));
            }
            return clonedObject;
        }

        std::string RelativeWorldPositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeWorldPositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ORIENTATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOrientation());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RelativeWorldPositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RelativeWorldPositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string RelativeWorldPositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        RoadConditionImpl::RoadConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FRICTION_SCALE_FACTOR, SimpleType::DOUBLE);
        }

        double RoadConditionImpl::GetFrictionScaleFactor() const
        {
            return _frictionScaleFactor;
        }
        std::shared_ptr<IProperties> RoadConditionImpl::GetProperties() const
        {
            return _properties;
        }

        void RoadConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FRICTION_SCALE_FACTOR)
            {
                // Simple type
                _frictionScaleFactor = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RoadConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RoadConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kProperties =  GetWriterProperties();
                if (kProperties)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kProperties));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RoadConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RoadConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_frictionScaleFactor = GetFrictionScaleFactor();
            // clone children
            const auto kProperties =  GetWriterProperties();
            if (kProperties)
            {
                auto clonedChild = std::dynamic_pointer_cast<PropertiesImpl>(kProperties)->Clone();
                auto clonedChildIProperties = std::dynamic_pointer_cast<IProperties>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetProperties(std::dynamic_pointer_cast<IPropertiesWriter>(clonedChildIProperties));
            }
            return clonedObject;
        }

        std::string RoadConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoadConditionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PROPERTIES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetProperties());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RoadConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoadConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RoadConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        RoadNetworkImpl::RoadNetworkImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IFile> RoadNetworkImpl::GetLogicFile() const
        {
            return _logicFile;
        }
        std::shared_ptr<IFile> RoadNetworkImpl::GetSceneGraphFile() const
        {
            return _sceneGraphFile;
        }
        std::vector<std::shared_ptr<ITrafficSignalController>> RoadNetworkImpl::GetTrafficSignals() const
        {
            std::vector<std::shared_ptr<ITrafficSignalController>> temp;
            for(auto&& elm: _trafficSignals)
                temp.push_back(elm);
            return temp;
        }

        void RoadNetworkImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType RoadNetworkImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RoadNetworkImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kLogicFile =  GetWriterLogicFile();
                if (kLogicFile)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kLogicFile));
                }
                const auto kSceneGraphFile =  GetWriterSceneGraphFile();
                if (kSceneGraphFile)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSceneGraphFile));
                }
                auto trafficSignals =  GetWriterTrafficSignals();
                if (!trafficSignals.empty())
                {
                    for(auto&& item : trafficSignals)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RoadNetworkImpl::Clone()
        {
            auto clonedObject = std::make_shared<RoadNetworkImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kLogicFile =  GetWriterLogicFile();
            if (kLogicFile)
            {
                auto clonedChild = std::dynamic_pointer_cast<FileImpl>(kLogicFile)->Clone();
                auto clonedChildIFile = std::dynamic_pointer_cast<IFile>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetLogicFile(std::dynamic_pointer_cast<IFileWriter>(clonedChildIFile));
            }
            const auto kSceneGraphFile =  GetWriterSceneGraphFile();
            if (kSceneGraphFile)
            {
                auto clonedChild = std::dynamic_pointer_cast<FileImpl>(kSceneGraphFile)->Clone();
                auto clonedChildIFile = std::dynamic_pointer_cast<IFile>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSceneGraphFile(std::dynamic_pointer_cast<IFileWriter>(clonedChildIFile));
            }
            const auto kTrafficSignals =  GetWriterTrafficSignals();
            if (!kTrafficSignals.empty())
            {
                std::vector<std::shared_ptr<ITrafficSignalControllerWriter>> clonedList;
                for(auto&& kItem : kTrafficSignals)
                {
                    auto clonedChild = std::dynamic_pointer_cast<TrafficSignalControllerImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<ITrafficSignalControllerWriter>(clonedChild));
                }
                clonedObject->SetTrafficSignals(clonedList);
            }
            return clonedObject;
        }

        std::string RoadNetworkImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoadNetworkImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__LOGIC_FILE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetLogicFile());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SCENE_GRAPH_FILE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSceneGraphFile());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RoadNetworkImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SIGNAL_CONTROLLER)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetTrafficSignals())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoadNetworkImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RoadNetworkImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        RoadPositionImpl::RoadPositionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ROAD_ID, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__S, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__T, SimpleType::DOUBLE);
        }

        std::string RoadPositionImpl::GetRoadId() const
        {
            return _roadId;
        }
        double RoadPositionImpl::GetS() const
        {
            return _s;
        }
        double RoadPositionImpl::GetT() const
        {
            return _t;
        }
        std::shared_ptr<IOrientation> RoadPositionImpl::GetOrientation() const
        {
            return _orientation;
        }

        void RoadPositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ROAD_ID)
            {
                // Simple type
                _roadId = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__S)
            {
                // Simple type
                _s = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__T)
            {
                // Simple type
                _t = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RoadPositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RoadPositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kOrientation =  GetWriterOrientation();
                if (kOrientation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOrientation));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RoadPositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RoadPositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_roadId = GetRoadId();
            // Simple type
            clonedObject->_s = GetS();
            // Simple type
            clonedObject->_t = GetT();
            // clone children
            const auto kOrientation =  GetWriterOrientation();
            if (kOrientation)
            {
                auto clonedChild = std::dynamic_pointer_cast<OrientationImpl>(kOrientation)->Clone();
                auto clonedChildIOrientation = std::dynamic_pointer_cast<IOrientation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOrientation(std::dynamic_pointer_cast<IOrientationWriter>(clonedChildIOrientation));
            }
            return clonedObject;
        }

        std::string RoadPositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ROAD_ID)
            {
                return GetRoadId();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoadPositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ORIENTATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOrientation());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RoadPositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoadPositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RoadPositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        RouteImpl::RouteImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CLOSED, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        bool RouteImpl::GetClosed() const
        {
            return _closed;
        }
        std::string RouteImpl::GetName() const
        {
            return _name;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> RouteImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IWaypoint>> RouteImpl::GetWaypoints() const
        {
            std::vector<std::shared_ptr<IWaypoint>> temp;
            for(auto&& elm: _waypoints)
                temp.push_back(elm);
            return temp;
        }

        void RouteImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CLOSED)
            {
                // Simple type
                _closed = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType RouteImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool RouteImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> RouteImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RouteImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto waypoints =  GetWriterWaypoints();
                if (!waypoints.empty())
                {
                    for(auto&& item : waypoints)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RouteImpl::Clone()
        {
            auto clonedObject = std::make_shared<RouteImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_closed = GetClosed();
            // Simple type
            clonedObject->_name = GetName();
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kWaypoints =  GetWriterWaypoints();
            if (!kWaypoints.empty())
            {
                std::vector<std::shared_ptr<IWaypointWriter>> clonedList;
                for(auto&& kItem : kWaypoints)
                {
                    auto clonedChild = std::dynamic_pointer_cast<WaypointImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IWaypointWriter>(clonedChild));
                }
                clonedObject->SetWaypoints(clonedList);
            }
            return clonedObject;
        }

        std::string RouteImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RouteImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RouteImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__WAYPOINT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetWaypoints())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RouteImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RouteImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        RouteCatalogLocationImpl::RouteCatalogLocationImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IDirectory> RouteCatalogLocationImpl::GetDirectory() const
        {
            return _directory;
        }

        void RouteCatalogLocationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType RouteCatalogLocationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RouteCatalogLocationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDirectory =  GetWriterDirectory();
                if (kDirectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDirectory));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RouteCatalogLocationImpl::Clone()
        {
            auto clonedObject = std::make_shared<RouteCatalogLocationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kDirectory =  GetWriterDirectory();
            if (kDirectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<DirectoryImpl>(kDirectory)->Clone();
                auto clonedChildIDirectory = std::dynamic_pointer_cast<IDirectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDirectory(std::dynamic_pointer_cast<IDirectoryWriter>(clonedChildIDirectory));
            }
            return clonedObject;
        }

        std::string RouteCatalogLocationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RouteCatalogLocationImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIRECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDirectory());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RouteCatalogLocationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RouteCatalogLocationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RouteCatalogLocationImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        RoutePositionImpl::RoutePositionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IRouteRef> RoutePositionImpl::GetRouteRef() const
        {
            return _routeRef;
        }
        std::shared_ptr<IOrientation> RoutePositionImpl::GetOrientation() const
        {
            return _orientation;
        }
        std::shared_ptr<IInRoutePosition> RoutePositionImpl::GetInRoutePosition() const
        {
            return _inRoutePosition;
        }

        void RoutePositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType RoutePositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RoutePositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRouteRef =  GetWriterRouteRef();
                if (kRouteRef)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRouteRef));
                }
                const auto kOrientation =  GetWriterOrientation();
                if (kOrientation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kOrientation));
                }
                const auto kInRoutePosition =  GetWriterInRoutePosition();
                if (kInRoutePosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kInRoutePosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RoutePositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RoutePositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kRouteRef =  GetWriterRouteRef();
            if (kRouteRef)
            {
                auto clonedChild = std::dynamic_pointer_cast<RouteRefImpl>(kRouteRef)->Clone();
                auto clonedChildIRouteRef = std::dynamic_pointer_cast<IRouteRef>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRouteRef(std::dynamic_pointer_cast<IRouteRefWriter>(clonedChildIRouteRef));
            }
            const auto kOrientation =  GetWriterOrientation();
            if (kOrientation)
            {
                auto clonedChild = std::dynamic_pointer_cast<OrientationImpl>(kOrientation)->Clone();
                auto clonedChildIOrientation = std::dynamic_pointer_cast<IOrientation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetOrientation(std::dynamic_pointer_cast<IOrientationWriter>(clonedChildIOrientation));
            }
            const auto kInRoutePosition =  GetWriterInRoutePosition();
            if (kInRoutePosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<InRoutePositionImpl>(kInRoutePosition)->Clone();
                auto clonedChildIInRoutePosition = std::dynamic_pointer_cast<IInRoutePosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetInRoutePosition(std::dynamic_pointer_cast<IInRoutePositionWriter>(clonedChildIInRoutePosition));
            }
            return clonedObject;
        }

        std::string RoutePositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoutePositionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ROUTE_REF)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRouteRef());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ORIENTATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetOrientation());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__IN_ROUTE_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetInRoutePosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RoutePositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoutePositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RoutePositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        RouteRefImpl::RouteRefImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IRoute> RouteRefImpl::GetRoute() const
        {
            return _route;
        }
        std::shared_ptr<ICatalogReference> RouteRefImpl::GetCatalogReference() const
        {
            return _catalogReference;
        }

        void RouteRefImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType RouteRefImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RouteRefImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRoute =  GetWriterRoute();
                if (kRoute)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRoute));
                }
                const auto kCatalogReference =  GetWriterCatalogReference();
                if (kCatalogReference)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogReference));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RouteRefImpl::Clone()
        {
            auto clonedObject = std::make_shared<RouteRefImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kRoute =  GetWriterRoute();
            if (kRoute)
            {
                auto clonedChild = std::dynamic_pointer_cast<RouteImpl>(kRoute)->Clone();
                auto clonedChildIRoute = std::dynamic_pointer_cast<IRoute>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRoute(std::dynamic_pointer_cast<IRouteWriter>(clonedChildIRoute));
            }
            const auto kCatalogReference =  GetWriterCatalogReference();
            if (kCatalogReference)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogReferenceImpl>(kCatalogReference)->Clone();
                auto clonedChildICatalogReference = std::dynamic_pointer_cast<ICatalogReference>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogReference(std::dynamic_pointer_cast<ICatalogReferenceWriter>(clonedChildICatalogReference));
            }
            return clonedObject;
        }

        std::string RouteRefImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RouteRefImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ROUTE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRoute());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_REFERENCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogReference());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RouteRefImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RouteRefImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RouteRefImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        RoutingActionImpl::RoutingActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IAssignRouteAction> RoutingActionImpl::GetAssignRouteAction() const
        {
            return _assignRouteAction;
        }
        std::shared_ptr<IFollowTrajectoryAction> RoutingActionImpl::GetFollowTrajectoryAction() const
        {
            return _followTrajectoryAction;
        }
        std::shared_ptr<IAcquirePositionAction> RoutingActionImpl::GetAcquirePositionAction() const
        {
            return _acquirePositionAction;
        }

        void RoutingActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType RoutingActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> RoutingActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kAssignRouteAction =  GetWriterAssignRouteAction();
                if (kAssignRouteAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAssignRouteAction));
                }
                const auto kFollowTrajectoryAction =  GetWriterFollowTrajectoryAction();
                if (kFollowTrajectoryAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kFollowTrajectoryAction));
                }
                const auto kAcquirePositionAction =  GetWriterAcquirePositionAction();
                if (kAcquirePositionAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAcquirePositionAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> RoutingActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<RoutingActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kAssignRouteAction =  GetWriterAssignRouteAction();
            if (kAssignRouteAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<AssignRouteActionImpl>(kAssignRouteAction)->Clone();
                auto clonedChildIAssignRouteAction = std::dynamic_pointer_cast<IAssignRouteAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAssignRouteAction(std::dynamic_pointer_cast<IAssignRouteActionWriter>(clonedChildIAssignRouteAction));
            }
            const auto kFollowTrajectoryAction =  GetWriterFollowTrajectoryAction();
            if (kFollowTrajectoryAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<FollowTrajectoryActionImpl>(kFollowTrajectoryAction)->Clone();
                auto clonedChildIFollowTrajectoryAction = std::dynamic_pointer_cast<IFollowTrajectoryAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetFollowTrajectoryAction(std::dynamic_pointer_cast<IFollowTrajectoryActionWriter>(clonedChildIFollowTrajectoryAction));
            }
            const auto kAcquirePositionAction =  GetWriterAcquirePositionAction();
            if (kAcquirePositionAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<AcquirePositionActionImpl>(kAcquirePositionAction)->Clone();
                auto clonedChildIAcquirePositionAction = std::dynamic_pointer_cast<IAcquirePositionAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAcquirePositionAction(std::dynamic_pointer_cast<IAcquirePositionActionWriter>(clonedChildIAcquirePositionAction));
            }
            return clonedObject;
        }

        std::string RoutingActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoutingActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ASSIGN_ROUTE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAssignRouteAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__FOLLOW_TRAJECTORY_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetFollowTrajectoryAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ACQUIRE_POSITION_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAcquirePositionAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> RoutingActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> RoutingActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string RoutingActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ScenarioDefinitionImpl::ScenarioDefinitionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::vector<std::shared_ptr<IParameterDeclaration>> ScenarioDefinitionImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::shared_ptr<ICatalogLocations> ScenarioDefinitionImpl::GetCatalogLocations() const
        {
            return _catalogLocations;
        }
        std::shared_ptr<IRoadNetwork> ScenarioDefinitionImpl::GetRoadNetwork() const
        {
            return _roadNetwork;
        }
        std::shared_ptr<IEntities> ScenarioDefinitionImpl::GetEntities() const
        {
            return _entities;
        }
        std::shared_ptr<IStoryboard> ScenarioDefinitionImpl::GetStoryboard() const
        {
            return _storyboard;
        }

        void ScenarioDefinitionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ScenarioDefinitionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool ScenarioDefinitionImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> ScenarioDefinitionImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ScenarioDefinitionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kCatalogLocations =  GetWriterCatalogLocations();
                if (kCatalogLocations)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCatalogLocations));
                }
                const auto kRoadNetwork =  GetWriterRoadNetwork();
                if (kRoadNetwork)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRoadNetwork));
                }
                const auto kEntities =  GetWriterEntities();
                if (kEntities)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEntities));
                }
                const auto kStoryboard =  GetWriterStoryboard();
                if (kStoryboard)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kStoryboard));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ScenarioDefinitionImpl::Clone()
        {
            auto clonedObject = std::make_shared<ScenarioDefinitionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kCatalogLocations =  GetWriterCatalogLocations();
            if (kCatalogLocations)
            {
                auto clonedChild = std::dynamic_pointer_cast<CatalogLocationsImpl>(kCatalogLocations)->Clone();
                auto clonedChildICatalogLocations = std::dynamic_pointer_cast<ICatalogLocations>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCatalogLocations(std::dynamic_pointer_cast<ICatalogLocationsWriter>(clonedChildICatalogLocations));
            }
            const auto kRoadNetwork =  GetWriterRoadNetwork();
            if (kRoadNetwork)
            {
                auto clonedChild = std::dynamic_pointer_cast<RoadNetworkImpl>(kRoadNetwork)->Clone();
                auto clonedChildIRoadNetwork = std::dynamic_pointer_cast<IRoadNetwork>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRoadNetwork(std::dynamic_pointer_cast<IRoadNetworkWriter>(clonedChildIRoadNetwork));
            }
            const auto kEntities =  GetWriterEntities();
            if (kEntities)
            {
                auto clonedChild = std::dynamic_pointer_cast<EntitiesImpl>(kEntities)->Clone();
                auto clonedChildIEntities = std::dynamic_pointer_cast<IEntities>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEntities(std::dynamic_pointer_cast<IEntitiesWriter>(clonedChildIEntities));
            }
            const auto kStoryboard =  GetWriterStoryboard();
            if (kStoryboard)
            {
                auto clonedChild = std::dynamic_pointer_cast<StoryboardImpl>(kStoryboard)->Clone();
                auto clonedChildIStoryboard = std::dynamic_pointer_cast<IStoryboard>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetStoryboard(std::dynamic_pointer_cast<IStoryboardWriter>(clonedChildIStoryboard));
            }
            return clonedObject;
        }

        std::string ScenarioDefinitionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ScenarioDefinitionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CATALOG_LOCATIONS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCatalogLocations());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ROAD_NETWORK)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRoadNetwork());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ENTITIES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEntities());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__STORYBOARD)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetStoryboard());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ScenarioDefinitionImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ScenarioDefinitionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ScenarioDefinitionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ScenarioObjectImpl::ScenarioObjectImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        std::string ScenarioObjectImpl::GetName() const
        {
            return _name;
        }
        std::shared_ptr<IEntityObject> ScenarioObjectImpl::GetEntityObject() const
        {
            return _entityObject;
        }
        std::shared_ptr<IObjectController> ScenarioObjectImpl::GetObjectController() const
        {
            return _objectController;
        }

        void ScenarioObjectImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType ScenarioObjectImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ScenarioObjectImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kEntityObject =  GetWriterEntityObject();
                if (kEntityObject)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEntityObject));
                }
                const auto kObjectController =  GetWriterObjectController();
                if (kObjectController)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kObjectController));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ScenarioObjectImpl::Clone()
        {
            auto clonedObject = std::make_shared<ScenarioObjectImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone children
            const auto kEntityObject =  GetWriterEntityObject();
            if (kEntityObject)
            {
                auto clonedChild = std::dynamic_pointer_cast<EntityObjectImpl>(kEntityObject)->Clone();
                auto clonedChildIEntityObject = std::dynamic_pointer_cast<IEntityObject>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEntityObject(std::dynamic_pointer_cast<IEntityObjectWriter>(clonedChildIEntityObject));
            }
            const auto kObjectController =  GetWriterObjectController();
            if (kObjectController)
            {
                auto clonedChild = std::dynamic_pointer_cast<ObjectControllerImpl>(kObjectController)->Clone();
                auto clonedChildIObjectController = std::dynamic_pointer_cast<IObjectController>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetObjectController(std::dynamic_pointer_cast<IObjectControllerWriter>(clonedChildIObjectController));
            }
            return clonedObject;
        }

        std::string ScenarioObjectImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ScenarioObjectImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_OBJECT)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEntityObject());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__OBJECT_CONTROLLER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetObjectController());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ScenarioObjectImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ScenarioObjectImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ScenarioObjectImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        SelectedEntitiesImpl::SelectedEntitiesImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::vector<std::shared_ptr<IEntityRef>> SelectedEntitiesImpl::GetEntityRef() const
        {
            std::vector<std::shared_ptr<IEntityRef>> temp;
            for(auto&& elm: _entityRef)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IByType>> SelectedEntitiesImpl::GetByType() const
        {
            std::vector<std::shared_ptr<IByType>> temp;
            for(auto&& elm: _byType)
                temp.push_back(elm);
            return temp;
        }

        void SelectedEntitiesImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType SelectedEntitiesImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SelectedEntitiesImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto entityRef =  GetWriterEntityRef();
                if (!entityRef.empty())
                {
                    for(auto&& item : entityRef)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto byType =  GetWriterByType();
                if (!byType.empty())
                {
                    for(auto&& item : byType)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SelectedEntitiesImpl::Clone()
        {
            auto clonedObject = std::make_shared<SelectedEntitiesImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kEntityRef =  GetWriterEntityRef();
            if (!kEntityRef.empty())
            {
                std::vector<std::shared_ptr<IEntityRefWriter>> clonedList;
                for(auto&& kItem : kEntityRef)
                {
                    auto clonedChild = std::dynamic_pointer_cast<EntityRefImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IEntityRefWriter>(clonedChild));
                }
                clonedObject->SetEntityRef(clonedList);
            }
            const auto kByType =  GetWriterByType();
            if (!kByType.empty())
            {
                std::vector<std::shared_ptr<IByTypeWriter>> clonedList;
                for(auto&& kItem : kByType)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ByTypeImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IByTypeWriter>(clonedChild));
                }
                clonedObject->SetByType(clonedList);
            }
            return clonedObject;
        }

        std::string SelectedEntitiesImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SelectedEntitiesImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SelectedEntitiesImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_REF)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetEntityRef())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__BY_TYPE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetByType())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SelectedEntitiesImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string SelectedEntitiesImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        ShapeImpl::ShapeImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IPolyline> ShapeImpl::GetPolyline() const
        {
            return _polyline;
        }
        std::shared_ptr<IClothoid> ShapeImpl::GetClothoid() const
        {
            return _clothoid;
        }
        std::shared_ptr<INurbs> ShapeImpl::GetNurbs() const
        {
            return _nurbs;
        }

        void ShapeImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType ShapeImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> ShapeImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPolyline =  GetWriterPolyline();
                if (kPolyline)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPolyline));
                }
                const auto kClothoid =  GetWriterClothoid();
                if (kClothoid)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kClothoid));
                }
                const auto kNurbs =  GetWriterNurbs();
                if (kNurbs)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kNurbs));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> ShapeImpl::Clone()
        {
            auto clonedObject = std::make_shared<ShapeImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kPolyline =  GetWriterPolyline();
            if (kPolyline)
            {
                auto clonedChild = std::dynamic_pointer_cast<PolylineImpl>(kPolyline)->Clone();
                auto clonedChildIPolyline = std::dynamic_pointer_cast<IPolyline>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPolyline(std::dynamic_pointer_cast<IPolylineWriter>(clonedChildIPolyline));
            }
            const auto kClothoid =  GetWriterClothoid();
            if (kClothoid)
            {
                auto clonedChild = std::dynamic_pointer_cast<ClothoidImpl>(kClothoid)->Clone();
                auto clonedChildIClothoid = std::dynamic_pointer_cast<IClothoid>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetClothoid(std::dynamic_pointer_cast<IClothoidWriter>(clonedChildIClothoid));
            }
            const auto kNurbs =  GetWriterNurbs();
            if (kNurbs)
            {
                auto clonedChild = std::dynamic_pointer_cast<NurbsImpl>(kNurbs)->Clone();
                auto clonedChildINurbs = std::dynamic_pointer_cast<INurbs>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetNurbs(std::dynamic_pointer_cast<INurbsWriter>(clonedChildINurbs));
            }
            return clonedObject;
        }

        std::string ShapeImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ShapeImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POLYLINE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPolyline());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CLOTHOID)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetClothoid());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__NURBS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetNurbs());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> ShapeImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> ShapeImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string ShapeImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        SimulationTimeConditionImpl::SimulationTimeConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        Rule SimulationTimeConditionImpl::GetRule() const
        {
            return _rule;
        }
        double SimulationTimeConditionImpl::GetValue() const
        {
            return _value;
        }

        void SimulationTimeConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType SimulationTimeConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SimulationTimeConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SimulationTimeConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<SimulationTimeConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string SimulationTimeConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SimulationTimeConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SimulationTimeConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SimulationTimeConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string SimulationTimeConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        SpeedActionImpl::SpeedActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<ITransitionDynamics> SpeedActionImpl::GetSpeedActionDynamics() const
        {
            return _speedActionDynamics;
        }
        std::shared_ptr<ISpeedActionTarget> SpeedActionImpl::GetSpeedActionTarget() const
        {
            return _speedActionTarget;
        }

        void SpeedActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType SpeedActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SpeedActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kSpeedActionDynamics =  GetWriterSpeedActionDynamics();
                if (kSpeedActionDynamics)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSpeedActionDynamics));
                }
                const auto kSpeedActionTarget =  GetWriterSpeedActionTarget();
                if (kSpeedActionTarget)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSpeedActionTarget));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SpeedActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<SpeedActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kSpeedActionDynamics =  GetWriterSpeedActionDynamics();
            if (kSpeedActionDynamics)
            {
                auto clonedChild = std::dynamic_pointer_cast<TransitionDynamicsImpl>(kSpeedActionDynamics)->Clone();
                auto clonedChildITransitionDynamics = std::dynamic_pointer_cast<ITransitionDynamics>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSpeedActionDynamics(std::dynamic_pointer_cast<ITransitionDynamicsWriter>(clonedChildITransitionDynamics));
            }
            const auto kSpeedActionTarget =  GetWriterSpeedActionTarget();
            if (kSpeedActionTarget)
            {
                auto clonedChild = std::dynamic_pointer_cast<SpeedActionTargetImpl>(kSpeedActionTarget)->Clone();
                auto clonedChildISpeedActionTarget = std::dynamic_pointer_cast<ISpeedActionTarget>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSpeedActionTarget(std::dynamic_pointer_cast<ISpeedActionTargetWriter>(clonedChildISpeedActionTarget));
            }
            return clonedObject;
        }

        std::string SpeedActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SpeedActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SPEED_ACTION_DYNAMICS)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSpeedActionDynamics());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SPEED_ACTION_TARGET)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSpeedActionTarget());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SpeedActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SpeedActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string SpeedActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        SpeedActionTargetImpl::SpeedActionTargetImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IRelativeTargetSpeed> SpeedActionTargetImpl::GetRelativeTargetSpeed() const
        {
            return _relativeTargetSpeed;
        }
        std::shared_ptr<IAbsoluteTargetSpeed> SpeedActionTargetImpl::GetAbsoluteTargetSpeed() const
        {
            return _absoluteTargetSpeed;
        }

        void SpeedActionTargetImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType SpeedActionTargetImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SpeedActionTargetImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kRelativeTargetSpeed =  GetWriterRelativeTargetSpeed();
                if (kRelativeTargetSpeed)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kRelativeTargetSpeed));
                }
                const auto kAbsoluteTargetSpeed =  GetWriterAbsoluteTargetSpeed();
                if (kAbsoluteTargetSpeed)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAbsoluteTargetSpeed));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SpeedActionTargetImpl::Clone()
        {
            auto clonedObject = std::make_shared<SpeedActionTargetImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kRelativeTargetSpeed =  GetWriterRelativeTargetSpeed();
            if (kRelativeTargetSpeed)
            {
                auto clonedChild = std::dynamic_pointer_cast<RelativeTargetSpeedImpl>(kRelativeTargetSpeed)->Clone();
                auto clonedChildIRelativeTargetSpeed = std::dynamic_pointer_cast<IRelativeTargetSpeed>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetRelativeTargetSpeed(std::dynamic_pointer_cast<IRelativeTargetSpeedWriter>(clonedChildIRelativeTargetSpeed));
            }
            const auto kAbsoluteTargetSpeed =  GetWriterAbsoluteTargetSpeed();
            if (kAbsoluteTargetSpeed)
            {
                auto clonedChild = std::dynamic_pointer_cast<AbsoluteTargetSpeedImpl>(kAbsoluteTargetSpeed)->Clone();
                auto clonedChildIAbsoluteTargetSpeed = std::dynamic_pointer_cast<IAbsoluteTargetSpeed>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAbsoluteTargetSpeed(std::dynamic_pointer_cast<IAbsoluteTargetSpeedWriter>(clonedChildIAbsoluteTargetSpeed));
            }
            return clonedObject;
        }

        std::string SpeedActionTargetImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SpeedActionTargetImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__RELATIVE_TARGET_SPEED)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetRelativeTargetSpeed());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ABSOLUTE_TARGET_SPEED)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAbsoluteTargetSpeed());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SpeedActionTargetImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SpeedActionTargetImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string SpeedActionTargetImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        SpeedConditionImpl::SpeedConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        Rule SpeedConditionImpl::GetRule() const
        {
            return _rule;
        }
        double SpeedConditionImpl::GetValue() const
        {
            return _value;
        }

        void SpeedConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType SpeedConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SpeedConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SpeedConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<SpeedConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string SpeedConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SpeedConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SpeedConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SpeedConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string SpeedConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        StandStillConditionImpl::StandStillConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DURATION, SimpleType::DOUBLE);
        }

        double StandStillConditionImpl::GetDuration() const
        {
            return _duration;
        }

        void StandStillConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DURATION)
            {
                // Simple type
                _duration = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType StandStillConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> StandStillConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> StandStillConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<StandStillConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_duration = GetDuration();
            // clone children
            return clonedObject;
        }

        std::string StandStillConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StandStillConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> StandStillConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StandStillConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string StandStillConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        StoryImpl::StoryImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        std::string StoryImpl::GetName() const
        {
            return _name;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> StoryImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::vector<std::shared_ptr<IAct>> StoryImpl::GetActs() const
        {
            std::vector<std::shared_ptr<IAct>> temp;
            for(auto&& elm: _acts)
                temp.push_back(elm);
            return temp;
        }

        void StoryImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType StoryImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool StoryImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> StoryImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> StoryImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                auto acts =  GetWriterActs();
                if (!acts.empty())
                {
                    for(auto&& item : acts)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> StoryImpl::Clone()
        {
            auto clonedObject = std::make_shared<StoryImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kActs =  GetWriterActs();
            if (!kActs.empty())
            {
                std::vector<std::shared_ptr<IActWriter>> clonedList;
                for(auto&& kItem : kActs)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ActImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IActWriter>(clonedChild));
                }
                clonedObject->SetActs(clonedList);
            }
            return clonedObject;
        }

        std::string StoryImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StoryImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> StoryImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }                
            if (key == OSC_CONSTANTS::ELEMENT__ACT)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetActs())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StoryImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string StoryImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        StoryboardImpl::StoryboardImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IInit> StoryboardImpl::GetInit() const
        {
            return _init;
        }
        std::vector<std::shared_ptr<IStory>> StoryboardImpl::GetStories() const
        {
            std::vector<std::shared_ptr<IStory>> temp;
            for(auto&& elm: _stories)
                temp.push_back(elm);
            return temp;
        }
        std::shared_ptr<ITrigger> StoryboardImpl::GetStopTrigger() const
        {
            return _stopTrigger;
        }

        void StoryboardImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType StoryboardImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> StoryboardImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kInit =  GetWriterInit();
                if (kInit)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kInit));
                }
                auto stories =  GetWriterStories();
                if (!stories.empty())
                {
                    for(auto&& item : stories)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kStopTrigger =  GetWriterStopTrigger();
                if (kStopTrigger)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kStopTrigger));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> StoryboardImpl::Clone()
        {
            auto clonedObject = std::make_shared<StoryboardImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kInit =  GetWriterInit();
            if (kInit)
            {
                auto clonedChild = std::dynamic_pointer_cast<InitImpl>(kInit)->Clone();
                auto clonedChildIInit = std::dynamic_pointer_cast<IInit>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetInit(std::dynamic_pointer_cast<IInitWriter>(clonedChildIInit));
            }
            const auto kStories =  GetWriterStories();
            if (!kStories.empty())
            {
                std::vector<std::shared_ptr<IStoryWriter>> clonedList;
                for(auto&& kItem : kStories)
                {
                    auto clonedChild = std::dynamic_pointer_cast<StoryImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IStoryWriter>(clonedChild));
                }
                clonedObject->SetStories(clonedList);
            }
            const auto kStopTrigger =  GetWriterStopTrigger();
            if (kStopTrigger)
            {
                auto clonedChild = std::dynamic_pointer_cast<TriggerImpl>(kStopTrigger)->Clone();
                auto clonedChildITrigger = std::dynamic_pointer_cast<ITrigger>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetStopTrigger(std::dynamic_pointer_cast<ITriggerWriter>(clonedChildITrigger));
            }
            return clonedObject;
        }

        std::string StoryboardImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StoryboardImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__INIT)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetInit());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__STOP_TRIGGER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetStopTrigger());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> StoryboardImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__STORY)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetStories())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StoryboardImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string StoryboardImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        StoryboardElementStateConditionImpl::StoryboardElementStateConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__STATE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_TYPE, SimpleType::ENUM_TYPE);
        }

        StoryboardElementState StoryboardElementStateConditionImpl::GetState() const
        {
            return _state;
        }
        std::shared_ptr<INamedReference<IStoryboardElement>> StoryboardElementStateConditionImpl::GetStoryboardElementRef() const
        {
            return _storyboardElementRef;
        }
        StoryboardElementType StoryboardElementStateConditionImpl::GetStoryboardElementType() const
        {
            return _storyboardElementType;
        }

        void StoryboardElementStateConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                // Enumeration Type
                const auto kResult = StoryboardElementState::GetFromLiteral(parameterLiteralValue);
                if (kResult != StoryboardElementState::UNKNOWN)
                {
                    _state = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IStoryboardElement>>(parameterLiteralValue);
                _storyboardElementRef = std::dynamic_pointer_cast<INamedReference<IStoryboardElement>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_TYPE)
            {
                // Enumeration Type
                const auto kResult = StoryboardElementType::GetFromLiteral(parameterLiteralValue);
                if (kResult != StoryboardElementType::UNKNOWN)
                {
                    _storyboardElementType = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType StoryboardElementStateConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> StoryboardElementStateConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> StoryboardElementStateConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<StoryboardElementStateConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Enumeration Type
            const auto kState = GetState();
            if ( kState.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_state = StoryboardElementState::GetFromLiteral(kState.GetLiteral());
            }
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IStoryboardElement>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IStoryboardElement>>(GetStoryboardElementRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_storyboardElementRef = proxy;
            
            // Enumeration Type
            const auto kStoryboardElementType = GetStoryboardElementType();
            if ( kStoryboardElementType.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_storyboardElementType = StoryboardElementType::GetFromLiteral(kStoryboardElementType.GetLiteral());
            }
            // clone children
            return clonedObject;
        }

        std::string StoryboardElementStateConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_REF)
            {
                // Get the Proxy
                auto storyboardElementRef = GetStoryboardElementRef();
                return storyboardElementRef!= nullptr ? storyboardElementRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StoryboardElementStateConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> StoryboardElementStateConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> StoryboardElementStateConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_REF)
            {
                // Get the Proxy
                auto storyboardElementRef = GetStoryboardElementRef();
                return storyboardElementRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(storyboardElementRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string StoryboardElementStateConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                auto state = GetState();
                return state.GetLiteral() != "UNKNOWN" ? state.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__STORYBOARD_ELEMENT_TYPE)
            {
                auto storyboardElementType = GetStoryboardElementType();
                return storyboardElementType.GetLiteral() != "UNKNOWN" ? storyboardElementType.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        SunImpl::SunImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__AZIMUTH, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ELEVATION, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__INTENSITY, SimpleType::DOUBLE);
        }

        double SunImpl::GetAzimuth() const
        {
            return _azimuth;
        }
        double SunImpl::GetElevation() const
        {
            return _elevation;
        }
        double SunImpl::GetIntensity() const
        {
            return _intensity;
        }

        void SunImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__AZIMUTH)
            {
                // Simple type
                _azimuth = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ELEVATION)
            {
                // Simple type
                _elevation = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__INTENSITY)
            {
                // Simple type
                _intensity = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType SunImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SunImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SunImpl::Clone()
        {
            auto clonedObject = std::make_shared<SunImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_azimuth = GetAzimuth();
            // Simple type
            clonedObject->_elevation = GetElevation();
            // Simple type
            clonedObject->_intensity = GetIntensity();
            // clone children
            return clonedObject;
        }

        std::string SunImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SunImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SunImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SunImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string SunImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        SynchronizeActionImpl::SynchronizeActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__MASTER_ENTITY_REF, SimpleType::STRING);
        }

        std::shared_ptr<INamedReference<IEntity>> SynchronizeActionImpl::GetMasterEntityRef() const
        {
            return _masterEntityRef;
        }
        std::shared_ptr<IPosition> SynchronizeActionImpl::GetTargetPositionMaster() const
        {
            return _targetPositionMaster;
        }
        std::shared_ptr<IPosition> SynchronizeActionImpl::GetTargetPosition() const
        {
            return _targetPosition;
        }
        std::shared_ptr<IFinalSpeed> SynchronizeActionImpl::GetFinalSpeed() const
        {
            return _finalSpeed;
        }

        void SynchronizeActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__MASTER_ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _masterEntityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType SynchronizeActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> SynchronizeActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kTargetPositionMaster =  GetWriterTargetPositionMaster();
                if (kTargetPositionMaster)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTargetPositionMaster));
                }
                const auto kTargetPosition =  GetWriterTargetPosition();
                if (kTargetPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTargetPosition));
                }
                const auto kFinalSpeed =  GetWriterFinalSpeed();
                if (kFinalSpeed)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kFinalSpeed));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> SynchronizeActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<SynchronizeActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetMasterEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_masterEntityRef = proxy;
            
            // clone children
            const auto kTargetPositionMaster =  GetWriterTargetPositionMaster();
            if (kTargetPositionMaster)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kTargetPositionMaster)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTargetPositionMaster(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            const auto kTargetPosition =  GetWriterTargetPosition();
            if (kTargetPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kTargetPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTargetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            const auto kFinalSpeed =  GetWriterFinalSpeed();
            if (kFinalSpeed)
            {
                auto clonedChild = std::dynamic_pointer_cast<FinalSpeedImpl>(kFinalSpeed)->Clone();
                auto clonedChildIFinalSpeed = std::dynamic_pointer_cast<IFinalSpeed>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetFinalSpeed(std::dynamic_pointer_cast<IFinalSpeedWriter>(clonedChildIFinalSpeed));
            }
            return clonedObject;
        }

        std::string SynchronizeActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__MASTER_ENTITY_REF)
            {
                // Get the Proxy
                auto masterEntityRef = GetMasterEntityRef();
                return masterEntityRef!= nullptr ? masterEntityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SynchronizeActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TARGET_POSITION_MASTER)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTargetPositionMaster());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TARGET_POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTargetPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__FINAL_SPEED)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetFinalSpeed());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> SynchronizeActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> SynchronizeActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__MASTER_ENTITY_REF)
            {
                // Get the Proxy
                auto masterEntityRef = GetMasterEntityRef();
                return masterEntityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(masterEntityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string SynchronizeActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TeleportActionImpl::TeleportActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IPosition> TeleportActionImpl::GetPosition() const
        {
            return _position;
        }

        void TeleportActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType TeleportActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TeleportActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TeleportActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TeleportActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            return clonedObject;
        }

        std::string TeleportActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TeleportActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TeleportActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TeleportActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TeleportActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TimeHeadwayConditionImpl::TimeHeadwayConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FREESPACE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        bool TimeHeadwayConditionImpl::GetAlongRoute() const
        {
            return _alongRoute;
        }
        std::shared_ptr<INamedReference<IEntity>> TimeHeadwayConditionImpl::GetEntityRef() const
        {
            return _entityRef;
        }
        bool TimeHeadwayConditionImpl::GetFreespace() const
        {
            return _freespace;
        }
        Rule TimeHeadwayConditionImpl::GetRule() const
        {
            return _rule;
        }
        double TimeHeadwayConditionImpl::GetValue() const
        {
            return _value;
        }

        void TimeHeadwayConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE)
            {
                // Simple type
                _alongRoute = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<IEntity>>(parameterLiteralValue);
                _entityRef = std::dynamic_pointer_cast<INamedReference<IEntity>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
            {
                // Simple type
                _freespace = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TimeHeadwayConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TimeHeadwayConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TimeHeadwayConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TimeHeadwayConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_alongRoute = GetAlongRoute();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<IEntity>>(*std::dynamic_pointer_cast<NamedReferenceProxy<IEntity>>(GetEntityRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_entityRef = proxy;
            
            // Simple type
            clonedObject->_freespace = GetFreespace();
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string TimeHeadwayConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef!= nullptr ? entityRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeHeadwayConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TimeHeadwayConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeHeadwayConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__ENTITY_REF)
            {
                // Get the Proxy
                auto entityRef = GetEntityRef();
                return entityRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(entityRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string TimeHeadwayConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        TimeOfDayImpl::TimeOfDayImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ANIMATION, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DATE_TIME, SimpleType::DATE_TIME);
        }

        bool TimeOfDayImpl::GetAnimation() const
        {
            return _animation;
        }
        DateTime TimeOfDayImpl::GetDateTime() const
        {
            return _dateTime;
        }

        void TimeOfDayImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ANIMATION)
            {
                // Simple type
                _animation = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DATE_TIME)
            {
                // Simple type
                _dateTime = ParserHelper::ParseDateTime(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TimeOfDayImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TimeOfDayImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TimeOfDayImpl::Clone()
        {
            auto clonedObject = std::make_shared<TimeOfDayImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_animation = GetAnimation();
            // Simple type
            clonedObject->_dateTime = GetDateTime();
            // clone children
            return clonedObject;
        }

        std::string TimeOfDayImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeOfDayImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TimeOfDayImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeOfDayImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TimeOfDayImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TimeOfDayConditionImpl::TimeOfDayConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DATE_TIME, SimpleType::DATE_TIME);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
        }

        DateTime TimeOfDayConditionImpl::GetDateTime() const
        {
            return _dateTime;
        }
        Rule TimeOfDayConditionImpl::GetRule() const
        {
            return _rule;
        }

        void TimeOfDayConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DATE_TIME)
            {
                // Simple type
                _dateTime = ParserHelper::ParseDateTime(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType TimeOfDayConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TimeOfDayConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TimeOfDayConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TimeOfDayConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_dateTime = GetDateTime();
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // clone children
            return clonedObject;
        }

        std::string TimeOfDayConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeOfDayConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TimeOfDayConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeOfDayConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TimeOfDayConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        TimeReferenceImpl::TimeReferenceImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<INone> TimeReferenceImpl::GetNone() const
        {
            return _none;
        }
        std::shared_ptr<ITiming> TimeReferenceImpl::GetTiming() const
        {
            return _timing;
        }

        void TimeReferenceImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType TimeReferenceImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TimeReferenceImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kNone =  GetWriterNone();
                if (kNone)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kNone));
                }
                const auto kTiming =  GetWriterTiming();
                if (kTiming)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTiming));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TimeReferenceImpl::Clone()
        {
            auto clonedObject = std::make_shared<TimeReferenceImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kNone =  GetWriterNone();
            if (kNone)
            {
                auto clonedChild = std::dynamic_pointer_cast<NoneImpl>(kNone)->Clone();
                auto clonedChildINone = std::dynamic_pointer_cast<INone>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetNone(std::dynamic_pointer_cast<INoneWriter>(clonedChildINone));
            }
            const auto kTiming =  GetWriterTiming();
            if (kTiming)
            {
                auto clonedChild = std::dynamic_pointer_cast<TimingImpl>(kTiming)->Clone();
                auto clonedChildITiming = std::dynamic_pointer_cast<ITiming>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTiming(std::dynamic_pointer_cast<ITimingWriter>(clonedChildITiming));
            }
            return clonedObject;
        }

        std::string TimeReferenceImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeReferenceImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__NONE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetNone());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TIMING)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTiming());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TimeReferenceImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeReferenceImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TimeReferenceImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TimeToCollisionConditionImpl::TimeToCollisionConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FREESPACE, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        bool TimeToCollisionConditionImpl::GetAlongRoute() const
        {
            return _alongRoute;
        }
        bool TimeToCollisionConditionImpl::GetFreespace() const
        {
            return _freespace;
        }
        Rule TimeToCollisionConditionImpl::GetRule() const
        {
            return _rule;
        }
        double TimeToCollisionConditionImpl::GetValue() const
        {
            return _value;
        }
        std::shared_ptr<ITimeToCollisionConditionTarget> TimeToCollisionConditionImpl::GetTimeToCollisionConditionTarget() const
        {
            return _timeToCollisionConditionTarget;
        }

        void TimeToCollisionConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ALONG_ROUTE)
            {
                // Simple type
                _alongRoute = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FREESPACE)
            {
                // Simple type
                _freespace = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TimeToCollisionConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TimeToCollisionConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kTimeToCollisionConditionTarget =  GetWriterTimeToCollisionConditionTarget();
                if (kTimeToCollisionConditionTarget)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTimeToCollisionConditionTarget));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TimeToCollisionConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TimeToCollisionConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_alongRoute = GetAlongRoute();
            // Simple type
            clonedObject->_freespace = GetFreespace();
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            const auto kTimeToCollisionConditionTarget =  GetWriterTimeToCollisionConditionTarget();
            if (kTimeToCollisionConditionTarget)
            {
                auto clonedChild = std::dynamic_pointer_cast<TimeToCollisionConditionTargetImpl>(kTimeToCollisionConditionTarget)->Clone();
                auto clonedChildITimeToCollisionConditionTarget = std::dynamic_pointer_cast<ITimeToCollisionConditionTarget>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTimeToCollisionConditionTarget(std::dynamic_pointer_cast<ITimeToCollisionConditionTargetWriter>(clonedChildITimeToCollisionConditionTarget));
            }
            return clonedObject;
        }

        std::string TimeToCollisionConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeToCollisionConditionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TIME_TO_COLLISION_CONDITION_TARGET)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTimeToCollisionConditionTarget());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TimeToCollisionConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeToCollisionConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TimeToCollisionConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        TimeToCollisionConditionTargetImpl::TimeToCollisionConditionTargetImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IPosition> TimeToCollisionConditionTargetImpl::GetPosition() const
        {
            return _position;
        }
        std::shared_ptr<IEntityRef> TimeToCollisionConditionTargetImpl::GetEntityRef() const
        {
            return _entityRef;
        }

        void TimeToCollisionConditionTargetImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType TimeToCollisionConditionTargetImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TimeToCollisionConditionTargetImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
                const auto kEntityRef =  GetWriterEntityRef();
                if (kEntityRef)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kEntityRef));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TimeToCollisionConditionTargetImpl::Clone()
        {
            auto clonedObject = std::make_shared<TimeToCollisionConditionTargetImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            const auto kEntityRef =  GetWriterEntityRef();
            if (kEntityRef)
            {
                auto clonedChild = std::dynamic_pointer_cast<EntityRefImpl>(kEntityRef)->Clone();
                auto clonedChildIEntityRef = std::dynamic_pointer_cast<IEntityRef>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetEntityRef(std::dynamic_pointer_cast<IEntityRefWriter>(clonedChildIEntityRef));
            }
            return clonedObject;
        }

        std::string TimeToCollisionConditionTargetImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeToCollisionConditionTargetImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_REF)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetEntityRef());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TimeToCollisionConditionTargetImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimeToCollisionConditionTargetImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TimeToCollisionConditionTargetImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TimingImpl::TimingImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DOMAIN_ABSOLUTE_RELATIVE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__OFFSET, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SCALE, SimpleType::DOUBLE);
        }

        ReferenceContext TimingImpl::GetDomainAbsoluteRelative() const
        {
            return _domainAbsoluteRelative;
        }
        double TimingImpl::GetOffset() const
        {
            return _offset;
        }
        double TimingImpl::GetScale() const
        {
            return _scale;
        }

        void TimingImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DOMAIN_ABSOLUTE_RELATIVE)
            {
                // Enumeration Type
                const auto kResult = ReferenceContext::GetFromLiteral(parameterLiteralValue);
                if (kResult != ReferenceContext::UNKNOWN)
                {
                    _domainAbsoluteRelative = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__OFFSET)
            {
                // Simple type
                _offset = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SCALE)
            {
                // Simple type
                _scale = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TimingImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TimingImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TimingImpl::Clone()
        {
            auto clonedObject = std::make_shared<TimingImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Enumeration Type
            const auto kDomainAbsoluteRelative = GetDomainAbsoluteRelative();
            if ( kDomainAbsoluteRelative.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_domainAbsoluteRelative = ReferenceContext::GetFromLiteral(kDomainAbsoluteRelative.GetLiteral());
            }
            // Simple type
            clonedObject->_offset = GetOffset();
            // Simple type
            clonedObject->_scale = GetScale();
            // clone children
            return clonedObject;
        }

        std::string TimingImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimingImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TimingImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TimingImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TimingImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__DOMAIN_ABSOLUTE_RELATIVE)
            {
                auto domainAbsoluteRelative = GetDomainAbsoluteRelative();
                return domainAbsoluteRelative.GetLiteral() != "UNKNOWN" ? domainAbsoluteRelative.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        TrafficActionImpl::TrafficActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<ITrafficSourceAction> TrafficActionImpl::GetTrafficSourceAction() const
        {
            return _trafficSourceAction;
        }
        std::shared_ptr<ITrafficSinkAction> TrafficActionImpl::GetTrafficSinkAction() const
        {
            return _trafficSinkAction;
        }
        std::shared_ptr<ITrafficSwarmAction> TrafficActionImpl::GetTrafficSwarmAction() const
        {
            return _trafficSwarmAction;
        }

        void TrafficActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType TrafficActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kTrafficSourceAction =  GetWriterTrafficSourceAction();
                if (kTrafficSourceAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficSourceAction));
                }
                const auto kTrafficSinkAction =  GetWriterTrafficSinkAction();
                if (kTrafficSinkAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficSinkAction));
                }
                const auto kTrafficSwarmAction =  GetWriterTrafficSwarmAction();
                if (kTrafficSwarmAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficSwarmAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kTrafficSourceAction =  GetWriterTrafficSourceAction();
            if (kTrafficSourceAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficSourceActionImpl>(kTrafficSourceAction)->Clone();
                auto clonedChildITrafficSourceAction = std::dynamic_pointer_cast<ITrafficSourceAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficSourceAction(std::dynamic_pointer_cast<ITrafficSourceActionWriter>(clonedChildITrafficSourceAction));
            }
            const auto kTrafficSinkAction =  GetWriterTrafficSinkAction();
            if (kTrafficSinkAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficSinkActionImpl>(kTrafficSinkAction)->Clone();
                auto clonedChildITrafficSinkAction = std::dynamic_pointer_cast<ITrafficSinkAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficSinkAction(std::dynamic_pointer_cast<ITrafficSinkActionWriter>(clonedChildITrafficSinkAction));
            }
            const auto kTrafficSwarmAction =  GetWriterTrafficSwarmAction();
            if (kTrafficSwarmAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficSwarmActionImpl>(kTrafficSwarmAction)->Clone();
                auto clonedChildITrafficSwarmAction = std::dynamic_pointer_cast<ITrafficSwarmAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficSwarmAction(std::dynamic_pointer_cast<ITrafficSwarmActionWriter>(clonedChildITrafficSwarmAction));
            }
            return clonedObject;
        }

        std::string TrafficActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SOURCE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficSourceAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SINK_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficSinkAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SWARM_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficSwarmAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TrafficDefinitionImpl::TrafficDefinitionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        std::string TrafficDefinitionImpl::GetName() const
        {
            return _name;
        }
        std::shared_ptr<IVehicleCategoryDistribution> TrafficDefinitionImpl::GetVehicleCategoryDistribution() const
        {
            return _vehicleCategoryDistribution;
        }
        std::shared_ptr<IControllerDistribution> TrafficDefinitionImpl::GetControllerDistribution() const
        {
            return _controllerDistribution;
        }

        void TrafficDefinitionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficDefinitionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficDefinitionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kVehicleCategoryDistribution =  GetWriterVehicleCategoryDistribution();
                if (kVehicleCategoryDistribution)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kVehicleCategoryDistribution));
                }
                const auto kControllerDistribution =  GetWriterControllerDistribution();
                if (kControllerDistribution)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kControllerDistribution));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficDefinitionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficDefinitionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // clone children
            const auto kVehicleCategoryDistribution =  GetWriterVehicleCategoryDistribution();
            if (kVehicleCategoryDistribution)
            {
                auto clonedChild = std::dynamic_pointer_cast<VehicleCategoryDistributionImpl>(kVehicleCategoryDistribution)->Clone();
                auto clonedChildIVehicleCategoryDistribution = std::dynamic_pointer_cast<IVehicleCategoryDistribution>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetVehicleCategoryDistribution(std::dynamic_pointer_cast<IVehicleCategoryDistributionWriter>(clonedChildIVehicleCategoryDistribution));
            }
            const auto kControllerDistribution =  GetWriterControllerDistribution();
            if (kControllerDistribution)
            {
                auto clonedChild = std::dynamic_pointer_cast<ControllerDistributionImpl>(kControllerDistribution)->Clone();
                auto clonedChildIControllerDistribution = std::dynamic_pointer_cast<IControllerDistribution>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetControllerDistribution(std::dynamic_pointer_cast<IControllerDistributionWriter>(clonedChildIControllerDistribution));
            }
            return clonedObject;
        }

        std::string TrafficDefinitionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficDefinitionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__VEHICLE_CATEGORY_DISTRIBUTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetVehicleCategoryDistribution());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CONTROLLER_DISTRIBUTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetControllerDistribution());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficDefinitionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficDefinitionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficDefinitionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TrafficSignalActionImpl::TrafficSignalActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<ITrafficSignalControllerAction> TrafficSignalActionImpl::GetTrafficSignalControllerAction() const
        {
            return _trafficSignalControllerAction;
        }
        std::shared_ptr<ITrafficSignalStateAction> TrafficSignalActionImpl::GetTrafficSignalStateAction() const
        {
            return _trafficSignalStateAction;
        }

        void TrafficSignalActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType TrafficSignalActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSignalActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kTrafficSignalControllerAction =  GetWriterTrafficSignalControllerAction();
                if (kTrafficSignalControllerAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficSignalControllerAction));
                }
                const auto kTrafficSignalStateAction =  GetWriterTrafficSignalStateAction();
                if (kTrafficSignalStateAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficSignalStateAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSignalActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSignalActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kTrafficSignalControllerAction =  GetWriterTrafficSignalControllerAction();
            if (kTrafficSignalControllerAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficSignalControllerActionImpl>(kTrafficSignalControllerAction)->Clone();
                auto clonedChildITrafficSignalControllerAction = std::dynamic_pointer_cast<ITrafficSignalControllerAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficSignalControllerAction(std::dynamic_pointer_cast<ITrafficSignalControllerActionWriter>(clonedChildITrafficSignalControllerAction));
            }
            const auto kTrafficSignalStateAction =  GetWriterTrafficSignalStateAction();
            if (kTrafficSignalStateAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficSignalStateActionImpl>(kTrafficSignalStateAction)->Clone();
                auto clonedChildITrafficSignalStateAction = std::dynamic_pointer_cast<ITrafficSignalStateAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficSignalStateAction(std::dynamic_pointer_cast<ITrafficSignalStateActionWriter>(clonedChildITrafficSignalStateAction));
            }
            return clonedObject;
        }

        std::string TrafficSignalActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SIGNAL_CONTROLLER_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficSignalControllerAction());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_SIGNAL_STATE_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficSignalStateAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSignalActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficSignalActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TrafficSignalConditionImpl::TrafficSignalConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__STATE, SimpleType::STRING);
        }

        std::string TrafficSignalConditionImpl::GetName() const
        {
            return _name;
        }
        std::string TrafficSignalConditionImpl::GetState() const
        {
            return _state;
        }

        void TrafficSignalConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                // Simple type
                _state = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSignalConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSignalConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSignalConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSignalConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // Simple type
            clonedObject->_state = GetState();
            // clone children
            return clonedObject;
        }

        std::string TrafficSignalConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                return GetState();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSignalConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficSignalConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TrafficSignalControllerImpl::TrafficSignalControllerImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DELAY, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__REFERENCE, SimpleType::STRING);
        }

        double TrafficSignalControllerImpl::GetDelay() const
        {
            return _delay;
        }
        std::string TrafficSignalControllerImpl::GetName() const
        {
            return _name;
        }
        std::string TrafficSignalControllerImpl::GetReference() const
        {
            return _reference;
        }
        std::vector<std::shared_ptr<IPhase>> TrafficSignalControllerImpl::GetPhases() const
        {
            std::vector<std::shared_ptr<IPhase>> temp;
            for(auto&& elm: _phases)
                temp.push_back(elm);
            return temp;
        }

        void TrafficSignalControllerImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DELAY)
            {
                // Simple type
                _delay = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__REFERENCE)
            {
                // Simple type
                _reference = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSignalControllerImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSignalControllerImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto phases =  GetWriterPhases();
                if (!phases.empty())
                {
                    for(auto&& item : phases)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSignalControllerImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSignalControllerImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_delay = GetDelay();
            // Simple type
            clonedObject->_name = GetName();
            // Simple type
            clonedObject->_reference = GetReference();
            // clone children
            const auto kPhases =  GetWriterPhases();
            if (!kPhases.empty())
            {
                std::vector<std::shared_ptr<IPhaseWriter>> clonedList;
                for(auto&& kItem : kPhases)
                {
                    auto clonedChild = std::dynamic_pointer_cast<PhaseImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IPhaseWriter>(clonedChild));
                }
                clonedObject->SetPhases(clonedList);
            }
            return clonedObject;
        }

        std::string TrafficSignalControllerImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__REFERENCE)
            {
                return GetReference();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalControllerImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSignalControllerImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__PHASE)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetPhases())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalControllerImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficSignalControllerImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TrafficSignalControllerActionImpl::TrafficSignalControllerActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PHASE, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF, SimpleType::STRING);
        }

        std::string TrafficSignalControllerActionImpl::GetPhase() const
        {
            return _phase;
        }
        std::shared_ptr<INamedReference<ITrafficSignalController>> TrafficSignalControllerActionImpl::GetTrafficSignalControllerRef() const
        {
            return _trafficSignalControllerRef;
        }
        std::vector<std::shared_ptr<IPhase>> TrafficSignalControllerActionImpl::GetPhaseRef() const
        {
            std::vector<std::shared_ptr<IPhase>> temp;
            for(auto&& elm: _phaseRef)
                temp.push_back(elm);
            return temp;
        }

        void TrafficSignalControllerActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PHASE)
            {
                // Simple type
                _phase = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<ITrafficSignalController>>(parameterLiteralValue);
                _trafficSignalControllerRef = std::dynamic_pointer_cast<INamedReference<ITrafficSignalController>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSignalControllerActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSignalControllerActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSignalControllerActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSignalControllerActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_phase = GetPhase();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<ITrafficSignalController>>(*std::dynamic_pointer_cast<NamedReferenceProxy<ITrafficSignalController>>(GetTrafficSignalControllerRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_trafficSignalControllerRef = proxy;
            
            // clone children
            return clonedObject;
        }

        std::string TrafficSignalControllerActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PHASE)
            {
                return GetPhase();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF)
            {
                // Get the Proxy
                auto trafficSignalControllerRef = GetTrafficSignalControllerRef();
                return trafficSignalControllerRef!= nullptr ? trafficSignalControllerRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalControllerActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSignalControllerActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalControllerActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF)
            {
                // Get the Proxy
                auto trafficSignalControllerRef = GetTrafficSignalControllerRef();
                return trafficSignalControllerRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(trafficSignalControllerRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string TrafficSignalControllerActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TrafficSignalControllerConditionImpl::TrafficSignalControllerConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__PHASE, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF, SimpleType::STRING);
        }

        std::string TrafficSignalControllerConditionImpl::GetPhase() const
        {
            return _phase;
        }
        std::shared_ptr<INamedReference<ITrafficSignalController>> TrafficSignalControllerConditionImpl::GetTrafficSignalControllerRef() const
        {
            return _trafficSignalControllerRef;
        }
        std::vector<std::shared_ptr<IPhase>> TrafficSignalControllerConditionImpl::GetPhaseRef() const
        {
            std::vector<std::shared_ptr<IPhase>> temp;
            for(auto&& elm: _phaseRef)
                temp.push_back(elm);
            return temp;
        }

        void TrafficSignalControllerConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__PHASE)
            {
                // Simple type
                _phase = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF)
            {
                // Proxy
                const auto kProxy = std::make_shared<NamedReferenceProxy<ITrafficSignalController>>(parameterLiteralValue);
                _trafficSignalControllerRef = std::dynamic_pointer_cast<INamedReference<ITrafficSignalController>>(kProxy);
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSignalControllerConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSignalControllerConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSignalControllerConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSignalControllerConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_phase = GetPhase();
            // Proxy
            auto proxy = std::make_shared<NamedReferenceProxy<ITrafficSignalController>>(*std::dynamic_pointer_cast<NamedReferenceProxy<ITrafficSignalController>>(GetTrafficSignalControllerRef()));
            proxy->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
            clonedObject->_trafficSignalControllerRef = proxy;
            
            // clone children
            return clonedObject;
        }

        std::string TrafficSignalControllerConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__PHASE)
            {
                return GetPhase();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF)
            {
                // Get the Proxy
                auto trafficSignalControllerRef = GetTrafficSignalControllerRef();
                return trafficSignalControllerRef!= nullptr ? trafficSignalControllerRef->GetNameRef() : "";
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalControllerConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSignalControllerConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalControllerConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_CONTROLLER_REF)
            {
                // Get the Proxy
                auto trafficSignalControllerRef = GetTrafficSignalControllerRef();
                return trafficSignalControllerRef != nullptr ? std::dynamic_pointer_cast<IOpenScenarioFlexElement>(trafficSignalControllerRef->GetTargetObject()) : nullptr;
            }
            throw KeyNotSupportedException();
        }

        std::string TrafficSignalControllerConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TrafficSignalStateImpl::TrafficSignalStateImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__STATE, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_ID, SimpleType::STRING);
        }

        std::string TrafficSignalStateImpl::GetState() const
        {
            return _state;
        }
        std::string TrafficSignalStateImpl::GetTrafficSignalId() const
        {
            return _trafficSignalId;
        }

        void TrafficSignalStateImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                // Simple type
                _state = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_ID)
            {
                // Simple type
                _trafficSignalId = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSignalStateImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSignalStateImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSignalStateImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSignalStateImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_state = GetState();
            // Simple type
            clonedObject->_trafficSignalId = GetTrafficSignalId();
            // clone children
            return clonedObject;
        }

        std::string TrafficSignalStateImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                return GetState();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC_SIGNAL_ID)
            {
                return GetTrafficSignalId();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalStateImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSignalStateImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalStateImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficSignalStateImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TrafficSignalStateActionImpl::TrafficSignalStateActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__STATE, SimpleType::STRING);
        }

        std::string TrafficSignalStateActionImpl::GetName() const
        {
            return _name;
        }
        std::string TrafficSignalStateActionImpl::GetState() const
        {
            return _state;
        }

        void TrafficSignalStateActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                // Simple type
                _state = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSignalStateActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSignalStateActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSignalStateActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSignalStateActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // Simple type
            clonedObject->_state = GetState();
            // clone children
            return clonedObject;
        }

        std::string TrafficSignalStateActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__STATE)
            {
                return GetState();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalStateActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSignalStateActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSignalStateActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficSignalStateActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TrafficSinkActionImpl::TrafficSinkActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RADIUS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RATE, SimpleType::DOUBLE);
        }

        double TrafficSinkActionImpl::GetRadius() const
        {
            return _radius;
        }
        double TrafficSinkActionImpl::GetRate() const
        {
            return _rate;
        }
        std::shared_ptr<IPosition> TrafficSinkActionImpl::GetPosition() const
        {
            return _position;
        }
        std::shared_ptr<ITrafficDefinition> TrafficSinkActionImpl::GetTrafficDefinition() const
        {
            return _trafficDefinition;
        }

        void TrafficSinkActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RADIUS)
            {
                // Simple type
                _radius = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RATE)
            {
                // Simple type
                _rate = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSinkActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSinkActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
                const auto kTrafficDefinition =  GetWriterTrafficDefinition();
                if (kTrafficDefinition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficDefinition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSinkActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSinkActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_radius = GetRadius();
            // Simple type
            clonedObject->_rate = GetRate();
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            const auto kTrafficDefinition =  GetWriterTrafficDefinition();
            if (kTrafficDefinition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficDefinitionImpl>(kTrafficDefinition)->Clone();
                auto clonedChildITrafficDefinition = std::dynamic_pointer_cast<ITrafficDefinition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficDefinition(std::dynamic_pointer_cast<ITrafficDefinitionWriter>(clonedChildITrafficDefinition));
            }
            return clonedObject;
        }

        std::string TrafficSinkActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSinkActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_DEFINITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficDefinition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSinkActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSinkActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficSinkActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TrafficSourceActionImpl::TrafficSourceActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RADIUS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RATE, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VELOCITY, SimpleType::DOUBLE);
        }

        double TrafficSourceActionImpl::GetRadius() const
        {
            return _radius;
        }
        double TrafficSourceActionImpl::GetRate() const
        {
            return _rate;
        }
        double TrafficSourceActionImpl::GetVelocity() const
        {
            return _velocity;
        }
        std::shared_ptr<IPosition> TrafficSourceActionImpl::GetPosition() const
        {
            return _position;
        }
        std::shared_ptr<ITrafficDefinition> TrafficSourceActionImpl::GetTrafficDefinition() const
        {
            return _trafficDefinition;
        }

        void TrafficSourceActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RADIUS)
            {
                // Simple type
                _radius = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RATE)
            {
                // Simple type
                _rate = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VELOCITY)
            {
                // Simple type
                _velocity = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSourceActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSourceActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
                const auto kTrafficDefinition =  GetWriterTrafficDefinition();
                if (kTrafficDefinition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficDefinition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSourceActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSourceActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_radius = GetRadius();
            // Simple type
            clonedObject->_rate = GetRate();
            // Simple type
            clonedObject->_velocity = GetVelocity();
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            const auto kTrafficDefinition =  GetWriterTrafficDefinition();
            if (kTrafficDefinition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficDefinitionImpl>(kTrafficDefinition)->Clone();
                auto clonedChildITrafficDefinition = std::dynamic_pointer_cast<ITrafficDefinition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficDefinition(std::dynamic_pointer_cast<ITrafficDefinitionWriter>(clonedChildITrafficDefinition));
            }
            return clonedObject;
        }

        std::string TrafficSourceActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSourceActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_DEFINITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficDefinition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSourceActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSourceActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficSourceActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TrafficSwarmActionImpl::TrafficSwarmActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__INNER_RADIUS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NUMBER_OF_VEHICLES, SimpleType::UNSIGNED_INT);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__OFFSET, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SEMI_MAJOR_AXIS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SEMI_MINOR_AXIS, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VELOCITY, SimpleType::DOUBLE);
        }

        double TrafficSwarmActionImpl::GetInnerRadius() const
        {
            return _innerRadius;
        }
        uint32_t TrafficSwarmActionImpl::GetNumberOfVehicles() const
        {
            return _numberOfVehicles;
        }
        double TrafficSwarmActionImpl::GetOffset() const
        {
            return _offset;
        }
        double TrafficSwarmActionImpl::GetSemiMajorAxis() const
        {
            return _semiMajorAxis;
        }
        double TrafficSwarmActionImpl::GetSemiMinorAxis() const
        {
            return _semiMinorAxis;
        }
        double TrafficSwarmActionImpl::GetVelocity() const
        {
            return _velocity;
        }
        std::shared_ptr<ICentralSwarmObject> TrafficSwarmActionImpl::GetCentralObject() const
        {
            return _centralObject;
        }
        std::shared_ptr<ITrafficDefinition> TrafficSwarmActionImpl::GetTrafficDefinition() const
        {
            return _trafficDefinition;
        }

        void TrafficSwarmActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__INNER_RADIUS)
            {
                // Simple type
                _innerRadius = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NUMBER_OF_VEHICLES)
            {
                // Simple type
                _numberOfVehicles = ParserHelper::ParseUnsignedInt(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__OFFSET)
            {
                // Simple type
                _offset = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SEMI_MAJOR_AXIS)
            {
                // Simple type
                _semiMajorAxis = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SEMI_MINOR_AXIS)
            {
                // Simple type
                _semiMinorAxis = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VELOCITY)
            {
                // Simple type
                _velocity = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrafficSwarmActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrafficSwarmActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kCentralObject =  GetWriterCentralObject();
                if (kCentralObject)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCentralObject));
                }
                const auto kTrafficDefinition =  GetWriterTrafficDefinition();
                if (kTrafficDefinition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kTrafficDefinition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrafficSwarmActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrafficSwarmActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_innerRadius = GetInnerRadius();
            // Simple type
            clonedObject->_numberOfVehicles = GetNumberOfVehicles();
            // Simple type
            clonedObject->_offset = GetOffset();
            // Simple type
            clonedObject->_semiMajorAxis = GetSemiMajorAxis();
            // Simple type
            clonedObject->_semiMinorAxis = GetSemiMinorAxis();
            // Simple type
            clonedObject->_velocity = GetVelocity();
            // clone children
            const auto kCentralObject =  GetWriterCentralObject();
            if (kCentralObject)
            {
                auto clonedChild = std::dynamic_pointer_cast<CentralSwarmObjectImpl>(kCentralObject)->Clone();
                auto clonedChildICentralSwarmObject = std::dynamic_pointer_cast<ICentralSwarmObject>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCentralObject(std::dynamic_pointer_cast<ICentralSwarmObjectWriter>(clonedChildICentralSwarmObject));
            }
            const auto kTrafficDefinition =  GetWriterTrafficDefinition();
            if (kTrafficDefinition)
            {
                auto clonedChild = std::dynamic_pointer_cast<TrafficDefinitionImpl>(kTrafficDefinition)->Clone();
                auto clonedChildITrafficDefinition = std::dynamic_pointer_cast<ITrafficDefinition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetTrafficDefinition(std::dynamic_pointer_cast<ITrafficDefinitionWriter>(clonedChildITrafficDefinition));
            }
            return clonedObject;
        }

        std::string TrafficSwarmActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSwarmActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CENTRAL_OBJECT)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCentralObject());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__TRAFFIC_DEFINITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetTrafficDefinition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrafficSwarmActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrafficSwarmActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrafficSwarmActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TrajectoryImpl::TrajectoryImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CLOSED, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
        }

        bool TrajectoryImpl::GetClosed() const
        {
            return _closed;
        }
        std::string TrajectoryImpl::GetName() const
        {
            return _name;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> TrajectoryImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::shared_ptr<IShape> TrajectoryImpl::GetShape() const
        {
            return _shape;
        }

        void TrajectoryImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CLOSED)
            {
                // Simple type
                _closed = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TrajectoryImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool TrajectoryImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> TrajectoryImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrajectoryImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kShape =  GetWriterShape();
                if (kShape)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kShape));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrajectoryImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrajectoryImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_closed = GetClosed();
            // Simple type
            clonedObject->_name = GetName();
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kShape =  GetWriterShape();
            if (kShape)
            {
                auto clonedChild = std::dynamic_pointer_cast<ShapeImpl>(kShape)->Clone();
                auto clonedChildIShape = std::dynamic_pointer_cast<IShape>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetShape(std::dynamic_pointer_cast<IShapeWriter>(clonedChildIShape));
            }
            return clonedObject;
        }

        std::string TrajectoryImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrajectoryImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SHAPE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetShape());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrajectoryImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrajectoryImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrajectoryImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TrajectoryCatalogLocationImpl::TrajectoryCatalogLocationImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IDirectory> TrajectoryCatalogLocationImpl::GetDirectory() const
        {
            return _directory;
        }

        void TrajectoryCatalogLocationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType TrajectoryCatalogLocationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrajectoryCatalogLocationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDirectory =  GetWriterDirectory();
                if (kDirectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDirectory));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrajectoryCatalogLocationImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrajectoryCatalogLocationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kDirectory =  GetWriterDirectory();
            if (kDirectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<DirectoryImpl>(kDirectory)->Clone();
                auto clonedChildIDirectory = std::dynamic_pointer_cast<IDirectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDirectory(std::dynamic_pointer_cast<IDirectoryWriter>(clonedChildIDirectory));
            }
            return clonedObject;
        }

        std::string TrajectoryCatalogLocationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrajectoryCatalogLocationImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIRECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDirectory());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrajectoryCatalogLocationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrajectoryCatalogLocationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrajectoryCatalogLocationImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TrajectoryFollowingModeImpl::TrajectoryFollowingModeImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE, SimpleType::ENUM_TYPE);
        }

        FollowingMode TrajectoryFollowingModeImpl::GetFollowingMode() const
        {
            return _followingMode;
        }

        void TrajectoryFollowingModeImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE)
            {
                // Enumeration Type
                const auto kResult = FollowingMode::GetFromLiteral(parameterLiteralValue);
                if (kResult != FollowingMode::UNKNOWN)
                {
                    _followingMode = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType TrajectoryFollowingModeImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TrajectoryFollowingModeImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TrajectoryFollowingModeImpl::Clone()
        {
            auto clonedObject = std::make_shared<TrajectoryFollowingModeImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Enumeration Type
            const auto kFollowingMode = GetFollowingMode();
            if ( kFollowingMode.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_followingMode = FollowingMode::GetFromLiteral(kFollowingMode.GetLiteral());
            }
            // clone children
            return clonedObject;
        }

        std::string TrajectoryFollowingModeImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrajectoryFollowingModeImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TrajectoryFollowingModeImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TrajectoryFollowingModeImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TrajectoryFollowingModeImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__FOLLOWING_MODE)
            {
                auto followingMode = GetFollowingMode();
                return followingMode.GetLiteral() != "UNKNOWN" ? followingMode.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        TransitionDynamicsImpl::TransitionDynamicsImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_DIMENSION, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        DynamicsDimension TransitionDynamicsImpl::GetDynamicsDimension() const
        {
            return _dynamicsDimension;
        }
        DynamicsShape TransitionDynamicsImpl::GetDynamicsShape() const
        {
            return _dynamicsShape;
        }
        double TransitionDynamicsImpl::GetValue() const
        {
            return _value;
        }

        void TransitionDynamicsImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_DIMENSION)
            {
                // Enumeration Type
                const auto kResult = DynamicsDimension::GetFromLiteral(parameterLiteralValue);
                if (kResult != DynamicsDimension::UNKNOWN)
                {
                    _dynamicsDimension = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE)
            {
                // Enumeration Type
                const auto kResult = DynamicsShape::GetFromLiteral(parameterLiteralValue);
                if (kResult != DynamicsShape::UNKNOWN)
                {
                    _dynamicsShape = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TransitionDynamicsImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TransitionDynamicsImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TransitionDynamicsImpl::Clone()
        {
            auto clonedObject = std::make_shared<TransitionDynamicsImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Enumeration Type
            const auto kDynamicsDimension = GetDynamicsDimension();
            if ( kDynamicsDimension.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_dynamicsDimension = DynamicsDimension::GetFromLiteral(kDynamicsDimension.GetLiteral());
            }
            // Enumeration Type
            const auto kDynamicsShape = GetDynamicsShape();
            if ( kDynamicsShape.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_dynamicsShape = DynamicsShape::GetFromLiteral(kDynamicsShape.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string TransitionDynamicsImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TransitionDynamicsImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TransitionDynamicsImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TransitionDynamicsImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TransitionDynamicsImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_DIMENSION)
            {
                auto dynamicsDimension = GetDynamicsDimension();
                return dynamicsDimension.GetLiteral() != "UNKNOWN" ? dynamicsDimension.GetLiteral() : "";
            }            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__DYNAMICS_SHAPE)
            {
                auto dynamicsShape = GetDynamicsShape();
                return dynamicsShape.GetLiteral() != "UNKNOWN" ? dynamicsShape.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        TraveledDistanceConditionImpl::TraveledDistanceConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::DOUBLE);
        }

        double TraveledDistanceConditionImpl::GetValue() const
        {
            return _value;
        }

        void TraveledDistanceConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType TraveledDistanceConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TraveledDistanceConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TraveledDistanceConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<TraveledDistanceConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string TraveledDistanceConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TraveledDistanceConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TraveledDistanceConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TraveledDistanceConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TraveledDistanceConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TriggerImpl::TriggerImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::vector<std::shared_ptr<IConditionGroup>> TriggerImpl::GetConditionGroups() const
        {
            std::vector<std::shared_ptr<IConditionGroup>> temp;
            for(auto&& elm: _conditionGroups)
                temp.push_back(elm);
            return temp;
        }

        void TriggerImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType TriggerImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TriggerImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto conditionGroups =  GetWriterConditionGroups();
                if (!conditionGroups.empty())
                {
                    for(auto&& item : conditionGroups)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TriggerImpl::Clone()
        {
            auto clonedObject = std::make_shared<TriggerImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kConditionGroups =  GetWriterConditionGroups();
            if (!kConditionGroups.empty())
            {
                std::vector<std::shared_ptr<IConditionGroupWriter>> clonedList;
                for(auto&& kItem : kConditionGroups)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ConditionGroupImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IConditionGroupWriter>(clonedChild));
                }
                clonedObject->SetConditionGroups(clonedList);
            }
            return clonedObject;
        }

        std::string TriggerImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TriggerImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TriggerImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__CONDITION_GROUP)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetConditionGroups())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TriggerImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TriggerImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        TriggeringEntitiesImpl::TriggeringEntitiesImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TRIGGERING_ENTITIES_RULE, SimpleType::ENUM_TYPE);
        }

        TriggeringEntitiesRule TriggeringEntitiesImpl::GetTriggeringEntitiesRule() const
        {
            return _triggeringEntitiesRule;
        }
        std::vector<std::shared_ptr<IEntityRef>> TriggeringEntitiesImpl::GetEntityRefs() const
        {
            std::vector<std::shared_ptr<IEntityRef>> temp;
            for(auto&& elm: _entityRefs)
                temp.push_back(elm);
            return temp;
        }

        void TriggeringEntitiesImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRIGGERING_ENTITIES_RULE)
            {
                // Enumeration Type
                const auto kResult = TriggeringEntitiesRule::GetFromLiteral(parameterLiteralValue);
                if (kResult != TriggeringEntitiesRule::UNKNOWN)
                {
                    _triggeringEntitiesRule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType TriggeringEntitiesImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> TriggeringEntitiesImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto entityRefs =  GetWriterEntityRefs();
                if (!entityRefs.empty())
                {
                    for(auto&& item : entityRefs)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> TriggeringEntitiesImpl::Clone()
        {
            auto clonedObject = std::make_shared<TriggeringEntitiesImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Enumeration Type
            const auto kTriggeringEntitiesRule = GetTriggeringEntitiesRule();
            if ( kTriggeringEntitiesRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_triggeringEntitiesRule = TriggeringEntitiesRule::GetFromLiteral(kTriggeringEntitiesRule.GetLiteral());
            }
            // clone children
            const auto kEntityRefs =  GetWriterEntityRefs();
            if (!kEntityRefs.empty())
            {
                std::vector<std::shared_ptr<IEntityRefWriter>> clonedList;
                for(auto&& kItem : kEntityRefs)
                {
                    auto clonedChild = std::dynamic_pointer_cast<EntityRefImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IEntityRefWriter>(clonedChild));
                }
                clonedObject->SetEntityRefs(clonedList);
            }
            return clonedObject;
        }

        std::string TriggeringEntitiesImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TriggeringEntitiesImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> TriggeringEntitiesImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__ENTITY_REF)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetEntityRefs())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> TriggeringEntitiesImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string TriggeringEntitiesImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__TRIGGERING_ENTITIES_RULE)
            {
                auto triggeringEntitiesRule = GetTriggeringEntitiesRule();
                return triggeringEntitiesRule.GetLiteral() != "UNKNOWN" ? triggeringEntitiesRule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        UserDefinedActionImpl::UserDefinedActionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<ICustomCommandAction> UserDefinedActionImpl::GetCustomCommandAction() const
        {
            return _customCommandAction;
        }

        void UserDefinedActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType UserDefinedActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> UserDefinedActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kCustomCommandAction =  GetWriterCustomCommandAction();
                if (kCustomCommandAction)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kCustomCommandAction));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> UserDefinedActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<UserDefinedActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kCustomCommandAction =  GetWriterCustomCommandAction();
            if (kCustomCommandAction)
            {
                auto clonedChild = std::dynamic_pointer_cast<CustomCommandActionImpl>(kCustomCommandAction)->Clone();
                auto clonedChildICustomCommandAction = std::dynamic_pointer_cast<ICustomCommandAction>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetCustomCommandAction(std::dynamic_pointer_cast<ICustomCommandActionWriter>(clonedChildICustomCommandAction));
            }
            return clonedObject;
        }

        std::string UserDefinedActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UserDefinedActionImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__CUSTOM_COMMAND_ACTION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetCustomCommandAction());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> UserDefinedActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UserDefinedActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string UserDefinedActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        UserDefinedValueConditionImpl::UserDefinedValueConditionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__RULE, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VALUE, SimpleType::STRING);
        }

        std::string UserDefinedValueConditionImpl::GetName() const
        {
            return _name;
        }
        Rule UserDefinedValueConditionImpl::GetRule() const
        {
            return _rule;
        }
        std::string UserDefinedValueConditionImpl::GetValue() const
        {
            return _value;
        }

        void UserDefinedValueConditionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                // Enumeration Type
                const auto kResult = Rule::GetFromLiteral(parameterLiteralValue);
                if (kResult != Rule::UNKNOWN)
                {
                    _rule = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                // Simple type
                _value = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType UserDefinedValueConditionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> UserDefinedValueConditionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> UserDefinedValueConditionImpl::Clone()
        {
            auto clonedObject = std::make_shared<UserDefinedValueConditionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // Enumeration Type
            const auto kRule = GetRule();
            if ( kRule.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_rule = Rule::GetFromLiteral(kRule.GetLiteral());
            }
            // Simple type
            clonedObject->_value = GetValue();
            // clone children
            return clonedObject;
        }

        std::string UserDefinedValueConditionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            else 
            if (key == OSC_CONSTANTS::ATTRIBUTE__VALUE)
            {
                return GetValue();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UserDefinedValueConditionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> UserDefinedValueConditionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> UserDefinedValueConditionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string UserDefinedValueConditionImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__RULE)
            {
                auto rule = GetRule();
                return rule.GetLiteral() != "UNKNOWN" ? rule.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        VehicleImpl::VehicleImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__NAME, SimpleType::STRING);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__VEHICLE_CATEGORY, SimpleType::ENUM_TYPE);
        }

        std::string VehicleImpl::GetName() const
        {
            return _name;
        }
        VehicleCategory VehicleImpl::GetVehicleCategory() const
        {
            return _vehicleCategory;
        }
        std::vector<std::shared_ptr<IParameterDeclaration>> VehicleImpl::GetParameterDeclarations() const
        {
            std::vector<std::shared_ptr<IParameterDeclaration>> temp;
            for(auto&& elm: _parameterDeclarations)
                temp.push_back(elm);
            return temp;
        }
        std::shared_ptr<IBoundingBox> VehicleImpl::GetBoundingBox() const
        {
            return _boundingBox;
        }
        std::shared_ptr<IPerformance> VehicleImpl::GetPerformance() const
        {
            return _performance;
        }
        std::shared_ptr<IAxles> VehicleImpl::GetAxles() const
        {
            return _axles;
        }
        std::shared_ptr<IProperties> VehicleImpl::GetProperties() const
        {
            return _properties;
        }

        void VehicleImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                // Simple type
                _name = ParserHelper::ParseString(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__VEHICLE_CATEGORY)
            {
                // Enumeration Type
                const auto kResult = VehicleCategory::GetFromLiteral(parameterLiteralValue);
                if (kResult != VehicleCategory::UNKNOWN)
                {
                    _vehicleCategory = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType VehicleImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        bool VehicleImpl::HasParameterDefinitions() 
        {
            return true;
        }

        std::vector<std::shared_ptr<ParameterValue>> VehicleImpl::GetParameterDefinitions() const
        {
            std::vector<std::shared_ptr<ParameterValue>> result;
            if (!_parameterDeclarations.empty())
            {
                for (auto&& parameterDeclaration :_parameterDeclarations)
                {
                    auto parameterType = parameterDeclaration->GetParameterType().GetLiteral();
                    auto parameterValue = std::make_shared<ParameterValue>(parameterDeclaration->GetName(), GetParameterType(parameterType), parameterDeclaration->GetValue());
                    result.push_back(parameterValue);
                }
            }
            return result;
        }

        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VehicleImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto parameterDeclarations =  GetWriterParameterDeclarations();
                if (!parameterDeclarations.empty())
                {
                    for(auto&& item : parameterDeclarations)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
                const auto kBoundingBox =  GetWriterBoundingBox();
                if (kBoundingBox)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kBoundingBox));
                }
                const auto kPerformance =  GetWriterPerformance();
                if (kPerformance)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPerformance));
                }
                const auto kAxles =  GetWriterAxles();
                if (kAxles)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kAxles));
                }
                const auto kProperties =  GetWriterProperties();
                if (kProperties)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kProperties));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VehicleImpl::Clone()
        {
            auto clonedObject = std::make_shared<VehicleImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_name = GetName();
            // Enumeration Type
            const auto kVehicleCategory = GetVehicleCategory();
            if ( kVehicleCategory.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_vehicleCategory = VehicleCategory::GetFromLiteral(kVehicleCategory.GetLiteral());
            }
            // clone children
            const auto kParameterDeclarations =  GetWriterParameterDeclarations();
            if (!kParameterDeclarations.empty())
            {
                std::vector<std::shared_ptr<IParameterDeclarationWriter>> clonedList;
                for(auto&& kItem : kParameterDeclarations)
                {
                    auto clonedChild = std::dynamic_pointer_cast<ParameterDeclarationImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IParameterDeclarationWriter>(clonedChild));
                }
                clonedObject->SetParameterDeclarations(clonedList);
            }
            const auto kBoundingBox =  GetWriterBoundingBox();
            if (kBoundingBox)
            {
                auto clonedChild = std::dynamic_pointer_cast<BoundingBoxImpl>(kBoundingBox)->Clone();
                auto clonedChildIBoundingBox = std::dynamic_pointer_cast<IBoundingBox>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetBoundingBox(std::dynamic_pointer_cast<IBoundingBoxWriter>(clonedChildIBoundingBox));
            }
            const auto kPerformance =  GetWriterPerformance();
            if (kPerformance)
            {
                auto clonedChild = std::dynamic_pointer_cast<PerformanceImpl>(kPerformance)->Clone();
                auto clonedChildIPerformance = std::dynamic_pointer_cast<IPerformance>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPerformance(std::dynamic_pointer_cast<IPerformanceWriter>(clonedChildIPerformance));
            }
            const auto kAxles =  GetWriterAxles();
            if (kAxles)
            {
                auto clonedChild = std::dynamic_pointer_cast<AxlesImpl>(kAxles)->Clone();
                auto clonedChildIAxles = std::dynamic_pointer_cast<IAxles>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetAxles(std::dynamic_pointer_cast<IAxlesWriter>(clonedChildIAxles));
            }
            const auto kProperties =  GetWriterProperties();
            if (kProperties)
            {
                auto clonedChild = std::dynamic_pointer_cast<PropertiesImpl>(kProperties)->Clone();
                auto clonedChildIProperties = std::dynamic_pointer_cast<IProperties>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetProperties(std::dynamic_pointer_cast<IPropertiesWriter>(clonedChildIProperties));
            }
            return clonedObject;
        }

        std::string VehicleImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__NAME)
            {
                return GetName();
            } 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__BOUNDING_BOX)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetBoundingBox());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PERFORMANCE)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPerformance());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__AXLES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetAxles());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PROPERTIES)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetProperties());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VehicleImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            if (key == OSC_CONSTANTS::ELEMENT__PARAMETER_DECLARATION)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetParameterDeclarations())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VehicleImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__VEHICLE_CATEGORY)
            {
                auto vehicleCategory = GetVehicleCategory();
                return vehicleCategory.GetLiteral() != "UNKNOWN" ? vehicleCategory.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        VehicleCatalogLocationImpl::VehicleCatalogLocationImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::shared_ptr<IDirectory> VehicleCatalogLocationImpl::GetDirectory() const
        {
            return _directory;
        }

        void VehicleCatalogLocationImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType VehicleCatalogLocationImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VehicleCatalogLocationImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kDirectory =  GetWriterDirectory();
                if (kDirectory)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kDirectory));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VehicleCatalogLocationImpl::Clone()
        {
            auto clonedObject = std::make_shared<VehicleCatalogLocationImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kDirectory =  GetWriterDirectory();
            if (kDirectory)
            {
                auto clonedChild = std::dynamic_pointer_cast<DirectoryImpl>(kDirectory)->Clone();
                auto clonedChildIDirectory = std::dynamic_pointer_cast<IDirectory>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetDirectory(std::dynamic_pointer_cast<IDirectoryWriter>(clonedChildIDirectory));
            }
            return clonedObject;
        }

        std::string VehicleCatalogLocationImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleCatalogLocationImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__DIRECTORY)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetDirectory());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VehicleCatalogLocationImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleCatalogLocationImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VehicleCatalogLocationImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        VehicleCategoryDistributionImpl::VehicleCategoryDistributionImpl()
        {
            /**
            * Filling the property to type map
            */
        }

        std::vector<std::shared_ptr<IVehicleCategoryDistributionEntry>> VehicleCategoryDistributionImpl::GetVehicleCategoryDistributionEntries() const
        {
            std::vector<std::shared_ptr<IVehicleCategoryDistributionEntry>> temp;
            for(auto&& elm: _vehicleCategoryDistributionEntries)
                temp.push_back(elm);
            return temp;
        }

        void VehicleCategoryDistributionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
        }

        SimpleType VehicleCategoryDistributionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VehicleCategoryDistributionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                auto vehicleCategoryDistributionEntries =  GetWriterVehicleCategoryDistributionEntries();
                if (!vehicleCategoryDistributionEntries.empty())
                {
                    for(auto&& item : vehicleCategoryDistributionEntries)
                    {
                        result.push_back(std::dynamic_pointer_cast<BaseImpl>(item) );
                    }
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VehicleCategoryDistributionImpl::Clone()
        {
            auto clonedObject = std::make_shared<VehicleCategoryDistributionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // clone children
            const auto kVehicleCategoryDistributionEntries =  GetWriterVehicleCategoryDistributionEntries();
            if (!kVehicleCategoryDistributionEntries.empty())
            {
                std::vector<std::shared_ptr<IVehicleCategoryDistributionEntryWriter>> clonedList;
                for(auto&& kItem : kVehicleCategoryDistributionEntries)
                {
                    auto clonedChild = std::dynamic_pointer_cast<VehicleCategoryDistributionEntryImpl>(kItem)->Clone();
                    clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                    clonedList.push_back(std::dynamic_pointer_cast<IVehicleCategoryDistributionEntryWriter>(clonedChild));
                }
                clonedObject->SetVehicleCategoryDistributionEntries(clonedList);
            }
            return clonedObject;
        }

        std::string VehicleCategoryDistributionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleCategoryDistributionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VehicleCategoryDistributionImpl::GetListChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
                
            if (key == OSC_CONSTANTS::ELEMENT__VEHICLE_CATEGORY_DISTRIBUTION_ENTRY)
            {
                std::vector<std::shared_ptr<IOpenScenarioFlexElement>> vect;
                for (auto&& elem : GetVehicleCategoryDistributionEntries())
                    vect.push_back(std::dynamic_pointer_cast<IOpenScenarioFlexElement>(elem));
                return vect;

            }
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleCategoryDistributionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VehicleCategoryDistributionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        VehicleCategoryDistributionEntryImpl::VehicleCategoryDistributionEntryImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CATEGORY, SimpleType::ENUM_TYPE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__WEIGHT, SimpleType::DOUBLE);
        }

        VehicleCategory VehicleCategoryDistributionEntryImpl::GetCategory() const
        {
            return _category;
        }
        double VehicleCategoryDistributionEntryImpl::GetWeight() const
        {
            return _weight;
        }

        void VehicleCategoryDistributionEntryImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CATEGORY)
            {
                // Enumeration Type
                const auto kResult = VehicleCategory::GetFromLiteral(parameterLiteralValue);
                if (kResult != VehicleCategory::UNKNOWN)
                {
                    _category = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__WEIGHT)
            {
                // Simple type
                _weight = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType VehicleCategoryDistributionEntryImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VehicleCategoryDistributionEntryImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VehicleCategoryDistributionEntryImpl::Clone()
        {
            auto clonedObject = std::make_shared<VehicleCategoryDistributionEntryImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Enumeration Type
            const auto kCategory = GetCategory();
            if ( kCategory.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_category = VehicleCategory::GetFromLiteral(kCategory.GetLiteral());
            }
            // Simple type
            clonedObject->_weight = GetWeight();
            // clone children
            return clonedObject;
        }

        std::string VehicleCategoryDistributionEntryImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleCategoryDistributionEntryImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VehicleCategoryDistributionEntryImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VehicleCategoryDistributionEntryImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VehicleCategoryDistributionEntryImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__CATEGORY)
            {
                auto category = GetCategory();
                return category.GetLiteral() != "UNKNOWN" ? category.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        VertexImpl::VertexImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TIME, SimpleType::DOUBLE);
        }

        double VertexImpl::GetTime() const
        {
            return _time;
        }
        std::shared_ptr<IPosition> VertexImpl::GetPosition() const
        {
            return _position;
        }

        void VertexImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TIME)
            {
                // Simple type
                _time = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType VertexImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VertexImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VertexImpl::Clone()
        {
            auto clonedObject = std::make_shared<VertexImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_time = GetTime();
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            return clonedObject;
        }

        std::string VertexImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VertexImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VertexImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VertexImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VertexImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        VisibilityActionImpl::VisibilityActionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__GRAPHICS, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__SENSORS, SimpleType::BOOLEAN);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__TRAFFIC, SimpleType::BOOLEAN);
        }

        bool VisibilityActionImpl::GetGraphics() const
        {
            return _graphics;
        }
        bool VisibilityActionImpl::GetSensors() const
        {
            return _sensors;
        }
        bool VisibilityActionImpl::GetTraffic() const
        {
            return _traffic;
        }

        void VisibilityActionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__GRAPHICS)
            {
                // Simple type
                _graphics = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__SENSORS)
            {
                // Simple type
                _sensors = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__TRAFFIC)
            {
                // Simple type
                _traffic = ParserHelper::ParseBoolean(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType VisibilityActionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> VisibilityActionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> VisibilityActionImpl::Clone()
        {
            auto clonedObject = std::make_shared<VisibilityActionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_graphics = GetGraphics();
            // Simple type
            clonedObject->_sensors = GetSensors();
            // Simple type
            clonedObject->_traffic = GetTraffic();
            // clone children
            return clonedObject;
        }

        std::string VisibilityActionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VisibilityActionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> VisibilityActionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> VisibilityActionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string VisibilityActionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }


        WaypointImpl::WaypointImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__ROUTE_STRATEGY, SimpleType::ENUM_TYPE);
        }

        RouteStrategy WaypointImpl::GetRouteStrategy() const
        {
            return _routeStrategy;
        }
        std::shared_ptr<IPosition> WaypointImpl::GetPosition() const
        {
            return _position;
        }

        void WaypointImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__ROUTE_STRATEGY)
            {
                // Enumeration Type
                const auto kResult = RouteStrategy::GetFromLiteral(parameterLiteralValue);
                if (kResult != RouteStrategy::UNKNOWN)
                {
                    _routeStrategy = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType WaypointImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> WaypointImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kPosition =  GetWriterPosition();
                if (kPosition)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPosition));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> WaypointImpl::Clone()
        {
            auto clonedObject = std::make_shared<WaypointImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Enumeration Type
            const auto kRouteStrategy = GetRouteStrategy();
            if ( kRouteStrategy.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_routeStrategy = RouteStrategy::GetFromLiteral(kRouteStrategy.GetLiteral());
            }
            // clone children
            const auto kPosition =  GetWriterPosition();
            if (kPosition)
            {
                auto clonedChild = std::dynamic_pointer_cast<PositionImpl>(kPosition)->Clone();
                auto clonedChildIPosition = std::dynamic_pointer_cast<IPosition>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPosition(std::dynamic_pointer_cast<IPositionWriter>(clonedChildIPosition));
            }
            return clonedObject;
        }

        std::string WaypointImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> WaypointImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__POSITION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPosition());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> WaypointImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> WaypointImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string WaypointImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__ROUTE_STRATEGY)
            {
                auto routeStrategy = GetRouteStrategy();
                return routeStrategy.GetLiteral() != "UNKNOWN" ? routeStrategy.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        WeatherImpl::WeatherImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__CLOUD_STATE, SimpleType::ENUM_TYPE);
        }

        CloudState WeatherImpl::GetCloudState() const
        {
            return _cloudState;
        }
        std::shared_ptr<ISun> WeatherImpl::GetSun() const
        {
            return _sun;
        }
        std::shared_ptr<IFog> WeatherImpl::GetFog() const
        {
            return _fog;
        }
        std::shared_ptr<IPrecipitation> WeatherImpl::GetPrecipitation() const
        {
            return _precipitation;
        }

        void WeatherImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__CLOUD_STATE)
            {
                // Enumeration Type
                const auto kResult = CloudState::GetFromLiteral(parameterLiteralValue);
                if (kResult != CloudState::UNKNOWN)
                {
                    _cloudState = kResult;
                    AddResolvedParameter(attributeKey);
                }
                else
                {
                    auto msg = FileContentMessage("Value '" + parameterLiteralValue + "' is not allowed.", ERROR, *GetTextmarker(attributeKey));
                    logger.LogMessage(msg );
                }
            }
        }

        SimpleType WeatherImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> WeatherImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

                const auto kSun =  GetWriterSun();
                if (kSun)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kSun));
                }
                const auto kFog =  GetWriterFog();
                if (kFog)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kFog));
                }
                const auto kPrecipitation =  GetWriterPrecipitation();
                if (kPrecipitation)
                {
                    result.push_back(std::dynamic_pointer_cast<BaseImpl>(kPrecipitation));
                }
            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> WeatherImpl::Clone()
        {
            auto clonedObject = std::make_shared<WeatherImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Enumeration Type
            const auto kCloudState = GetCloudState();
            if ( kCloudState.GetLiteral() != "UNKNOWN" )
            {
                clonedObject->_cloudState = CloudState::GetFromLiteral(kCloudState.GetLiteral());
            }
            // clone children
            const auto kSun =  GetWriterSun();
            if (kSun)
            {
                auto clonedChild = std::dynamic_pointer_cast<SunImpl>(kSun)->Clone();
                auto clonedChildISun = std::dynamic_pointer_cast<ISun>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetSun(std::dynamic_pointer_cast<ISunWriter>(clonedChildISun));
            }
            const auto kFog =  GetWriterFog();
            if (kFog)
            {
                auto clonedChild = std::dynamic_pointer_cast<FogImpl>(kFog)->Clone();
                auto clonedChildIFog = std::dynamic_pointer_cast<IFog>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetFog(std::dynamic_pointer_cast<IFogWriter>(clonedChildIFog));
            }
            const auto kPrecipitation =  GetWriterPrecipitation();
            if (kPrecipitation)
            {
                auto clonedChild = std::dynamic_pointer_cast<PrecipitationImpl>(kPrecipitation)->Clone();
                auto clonedChildIPrecipitation = std::dynamic_pointer_cast<IPrecipitation>(clonedChild);
                clonedChild->SetParent(std::static_pointer_cast<IOpenScenarioModelElement>(clonedObject));
                clonedObject->SetPrecipitation(std::dynamic_pointer_cast<IPrecipitationWriter>(clonedChildIPrecipitation));
            }
            return clonedObject;
        }

        std::string WeatherImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> WeatherImpl::GetChildElement(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__SUN)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetSun());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__FOG)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetFog());
            }
            
            if (key == OSC_CONSTANTS::ELEMENT__PRECIPITATION)
            {
                return std::dynamic_pointer_cast<IOpenScenarioFlexElement>(GetPrecipitation());
            }
            throw  KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> WeatherImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> WeatherImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string WeatherImpl::GetEnumerationLiteral(std::string key) const
        {
            if (key.empty())
            {
                throw KeyNotSupportedException();
            }
             
            if (key == OSC_CONSTANTS::ATTRIBUTE__CLOUD_STATE)
            {
                auto cloudState = GetCloudState();
                return cloudState.GetLiteral() != "UNKNOWN" ? cloudState.GetLiteral() : "";
            }
            throw KeyNotSupportedException();
        }


        WorldPositionImpl::WorldPositionImpl()
        {
            /**
            * Filling the property to type map
            */
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__H, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__P, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__R, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__X, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__Y, SimpleType::DOUBLE);
            _propertyToType.emplace(OSC_CONSTANTS::ATTRIBUTE__Z, SimpleType::DOUBLE);
        }

        double WorldPositionImpl::GetH() const
        {
            return _h;
        }
        double WorldPositionImpl::GetP() const
        {
            return _p;
        }
        double WorldPositionImpl::GetR() const
        {
            return _r;
        }
        double WorldPositionImpl::GetX() const
        {
            return _x;
        }
        double WorldPositionImpl::GetY() const
        {
            return _y;
        }
        double WorldPositionImpl::GetZ() const
        {
            return _z;
        }

        void WorldPositionImpl::ResolveParameterInternal(IParserMessageLogger& logger, std::string& attributeKey, std::string& parameterLiteralValue)
        {
            if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__H)
            {
                // Simple type
                _h = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__P)
            {
                // Simple type
                _p = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__R)
            {
                // Simple type
                _r = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__X)
            {
                // Simple type
                _x = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__Y)
            {
                // Simple type
                _y = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
            else if (attributeKey == OSC_CONSTANTS::ATTRIBUTE__Z)
            {
                // Simple type
                _z = ParserHelper::ParseDouble(logger, parameterLiteralValue, *GetTextmarker(attributeKey));
                AddResolvedParameter(attributeKey);
            }
        }

        SimpleType WorldPositionImpl::GetTypeFromAttributeName(std::string& attributeKey) const
        {
            const auto kIt = _propertyToType.find(attributeKey);
            if (kIt != _propertyToType.end())
                return kIt->second;
            return SimpleType::UNKNOWN;
        }


        /**
        * A list of all aggregated children (lists are flattened). This may be used for applying a specific 
        * method for any child.
        * @return a list with all children (as BaseImpl)
        */
        std::vector<std::shared_ptr<BaseImpl>> WorldPositionImpl::GetChildren() const
        {
            std::vector<std::shared_ptr<BaseImpl>> result;

            return result;
        }

        /**
        * Making a (deep) clone this object. This is useful and used for importing elements from catalogs.
        * @return a deep copy of the object.
        */
        std::shared_ptr<BaseImpl> WorldPositionImpl::Clone()
        {
            auto clonedObject = std::make_shared<WorldPositionImpl>();
            CloneStartMarker(*clonedObject);
            CloneEndMarker(*clonedObject);
            CloneAttributeKeyToStartMarker(*clonedObject);
            CloneAttributeKeyToEndMarker(*clonedObject);
            CloneAttributeKeyToParameterNameMap(*clonedObject);

            // clone attributes;
            // Simple type
            clonedObject->_h = GetH();
            // Simple type
            clonedObject->_p = GetP();
            // Simple type
            clonedObject->_r = GetR();
            // Simple type
            clonedObject->_x = GetX();
            // Simple type
            clonedObject->_y = GetY();
            // Simple type
            clonedObject->_z = GetZ();
            // clone children
            return clonedObject;
        }

        std::string WorldPositionImpl::GetStringProperty(std::string key) const
        {
            // proxies and string attributes 
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> WorldPositionImpl::GetChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::vector<std::shared_ptr<IOpenScenarioFlexElement>> WorldPositionImpl::GetListChildElement(std::string key) const
        {
            throw KeyNotSupportedException();
        }

        std::shared_ptr<IOpenScenarioFlexElement> WorldPositionImpl::GetReferencedElement(std::string key, std::string name) const
        {
            throw KeyNotSupportedException();
        }

        std::string WorldPositionImpl::GetEnumerationLiteral(std::string key) const
        {
            throw KeyNotSupportedException();
        }

    }
}
