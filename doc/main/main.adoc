:levelToBaseDir: ../..
:levelToDocDir: ..
:toc:
:toc-placement: left
:toclevels: 4
:showtitle:

= OpenSCENARIO API - Documentation

== Getting started on Java
A great source of how to start using the API might be the link:{levelToBaseDir}/java/src/test/java[test sources].

Generally there are two major use cases for using the library.

* *As astandalone checker*. A command line application that is called to validate an OpenSCENARIO file. 
* *As an embedded library*. Embedding the programming interface and add read capability to our own programs.

=== Standalone checker

To use the library as a standalone program we would typically use the self-contained package

`net.asam.openscenario.v1_0.reader-X.Y.Z-jar-with-dependencies.jar`. 

See the link:{levelToBaseDir}/README.md[README.MD] file in the project root for building instructions.

The main class (net.asam.openscenario.v1_0.main.OpenScenarioChecker) isalready set. Start with:

```
java -jar net.asam.openscenario.v1_0.reader-X.Y.Z-jar-with-dependencies.ja
```

``` 
****************************************  
* ASAM OpenSCENARIO 1.0 Checker (2020) *  
****************************************  
Usage: [[-i <filename> [-p <paramfilename>]] | -v]
Options:
-i  <filename> file to be validated
-p  <paramfilename> a file with name/value pairs. One line per name/value pair. tab separated
-v  print program version
``` 

==== Checking a file

See link:{levelToDocDir}/examples/simpleExample[simpleExample]

```
java -jar net.asam.openscenario.v1_0.reader-X.Y.Z-jar-with-dependencies.jar -i ./ScenarioExample.xosc`
```

```
****************************************  
* ASAM OpenSCENARIO 1.0 Checker (2020) *  
****************************************  
Checking c:\temp\ScenarioExample.xosc  
Validation succeeded with 0 errors and 0 warnings.  
```

A failing validation See link:{levelToDocDir}/examples/defectExample[defectExample]

```
java -jar net.asam.openscenario.v1_0.reader-X.Y.Z-jar-with-dependencies.jar -i ./DefectExample.xosc`
```

```
****************************************  
* ASAM OpenSCENARIO 1.0 Checker (2020) *  
****************************************  
Checking c:/temp/DefectExample.xosc  
ERROR: Cannot resolve parameter 'DefectParameter' (41,53)
Validation failed with 2 errors and 0 warnings.
```

==== Injecting parameters

See
    link:{levelToDocDir}/examples/injectedParamsExample[injectedParamsExample]

It is possible to inject parameters into the ASAM OpenSCENARIO checker.
Use `-paramsfile`to specify a filename for the parameters.

```
java -jar net.asam.openscenario.v1_0.reader-X.Y.Z-jar-with-dependencies.jar -i ./InjectedParamsExample.xosc -p params.conf
```

In the parameter file (here `params.conf`) we define name/value pairs.
One line per definition. We use tab as a delimiter between name and
value:

```
# Switch host vehicle and target vehicle
# HostVehicle -  Was: "car_white" override: "car_red"
# TargetVehicle -  Was: "car_red override: "car_white"

HostVehicle car_red
TargetVehicle   car_white

# Overriding ego start speed (EgoStartS):
# EgoStartS -  Was: 50 override: 60
EgoStartS   60
```

Use # for comments.

```
****************************************
* ASAM OpenSCENARIO 1.0 Checker (2020) *
****************************************
Used Parameters:
        EgoStartS       60
        HostVehicle     car_red
        TargetVehicle   car_white
Checking '\InjectedParamsExample.xosc'
Validation succeeded with 0 errors and 0 warnings.
```

==== Showing the program version

`java -jar net.asam.openscenario.v1_0.reader-X.Y.Z-jar-with-dependencies.jar -v`

```
****************************************  
* ASAM OpenSCENARIO 1.0 Checker (2020) *  
****************************************  
Program version 1.0.0
```

=== Embedding the library


To use the OpenSCENARIO as an embedded library we would typically use the compiled package that has third party dependencies.

```
net.asam.openscenario.v1_0.reader-X.Y.Z.jar
```

See the link:{levelToBaseDir}/README.md[README.MD] file in the project root for building instructions. 
In this case we might want to manage the dependencies to third-party-libraries within
our enclosing project. 
Please see link:{levelToBaseDir}/java/pom.xml[maven pom.xml] for third-party-dependencies.


==== Example: checking a single file

When checking a single file with no catalog implications, use the `XmlScenarioLoaderFactory` to create a loader.


```java
// Creating a message Logger to pick up the messages
SimpleMessageLogger messageLogger = new SimpleMessageLogger(ErrorLevel.INFO);
      
// Instantiating the factory
IScenarioLoaderFactory loaderFactory =
    new XmlScenarioLoaderFactory(getResourceFile("DoubleLaneChanger.xosc").getAbsolutePath());

// Creating the loader with a file resource locator (we are reading directly from a file system)
IScenarioLoader loader = loaderFactory.createLoader(new FileResourceLocator());
  
// Loading the scenario
IOpenScenario openScenario = (IOpenScenario)  loader.load(messageLogger).getAdapter(IOpenScenario.class);
  
// Check for errors
if (!messageLogger.getMessagesFilteredByWorseOrEqualToErrorLevel(ErrorLevel.ERROR).isEmpty())
{
    // Browse through the results
    IFileHeader fileHeader = openScenario.getFileHeader();
    System.out.println( "Major Revision :" + fileHeader.getRevMajor());
    System.out.println( "Minor Revision :" + fileHeader.getRevMinor());
}
```


==== Example: checking a file and resolve the imports from catalogs

When checking a file and resolve its imports from catalog, use the `XmlScenarioImportLoaderFactory` to create a loader. 
Then the catalog references are resolved and the errors and warnings from the catalog
files are picked up in a separate logger.

[source,java]
----
// Creating a message logger to pick up the messages
SimpleMessageLogger messageLogger = new SimpleMessageLogger(ErrorLevel.INFO);

// create another message logger for picking up the messages that occur from imported files
SimpleMessageLogger catalogMessageLogger = new SimpleMessageLogger(ErrorLevel.INFO);

// Instantiating the factory
IScenarioLoaderFactory loaderFactory = new XmlScenarioImportLoaderFactory(
  catalogMessageLogger,getResourceFile("simpleImport/simpleImport.xosc").getAbsolutePath());

// Creating the loader with a file resource locator (we are reading directly from a file system)
IScenarioLoader loader = loaderFactory.createLoader(new FileResourceLocator());

// Loading the scenario
IOpenScenario openScenario = (IOpenScenario)  loader.load(messageLogger).getAdapter(IOpenScenario.class);

// Get the list of scenario objects
List<IScenarioObject> scenarioObjects = openScenario.
                                        getOpenScenarioCategory().
                                        getScenarioDefinition().
                                        getEntities().
                                        getScenarioObjects();


for (IScenarioObject scenarioObject: scenarioObjects)
{
  // Access the object that is imported from a catalog with the name "Ego"
  if (scenarioObject.getName().equals("Ego"))
  {
      // Get the catalog reference
      ICatalogReference catalogReference = scenarioObject.getEntityObject().getCatalogReference();
      
      if (catalogReference != null && catalogReference.getEntryName().equals("car_white"))
      {
          // Now check the type.
          if (CatalogHelper.isVehicle(catalogReference.getRef()))
          {
            IVehicle vehicle = CatalogHelper.asVehicle(catalogReference.getRef());
            // Now we can access the resolved vehicle
            IAxles axles = vehicle.getAxles();
            // get the additonal axles
            List<IAxle> additionalAxles = axles.getAdditionalAxles();
            if (additionalAxles == null || additionalAxles.size() == 0)
            {
              System.out.println("Ego has 2 axles (front, rear)");
            }else
            {
              System.out.println("Ego has "+ 
                                             (2+additionalAxles.size()) +
                                             " axles (front, rear and " +
                                             additionalAxles.size() +
                                             " addtional axles"
                                            );
            }
          }
      }
  }
}
----


==== Example: checking a file and inject parameter values from outside

OpenSCENARIO provide a mechanism to declare global parameters , right
after the `FileHeader` element:

[source,xml]
----
<OpenSCENARIO>  
  <FileHeader revMajor="1" revMinor="0" date="2020-07-24T10:00:00" description="Sample Scenario - parameter" author="ASAM"/>
  <ParameterDeclarations>
      <ParameterDeclaration name="testBoolean" value="false" parameterType="boolean"/>
      <ParameterDeclaration name="testInteger" value="1" parameterType="integer"/>
      <ParameterDeclaration name="testUnsignedInt" value="1" parameterType="unsignedInt"/>
      <ParameterDeclaration name="testString" value="testString" parameterType="string"/>
      <ParameterDeclaration name="testDateTime" value="2017-02-24T10:00:00" parameterType="dateTime"/>
      <ParameterDeclaration name="testUnsignedShort" value="5" parameterType="unsignedShort"/>
      <ParameterDeclaration name="testDouble" value="1.1" parameterType="double"/>
  </ParameterDeclarations>
</OpenSCENARIO>
----

When loading a scenario, the API allows to override the default values from outside. We use a name value map and hand it over as an argument to the `load` method.

[source,java]
----
Hashtable<String, String> injectedParameters = new Hashtable<String, String>();
injectedParameters.put("testBoolean", "true");
injectedParameters.put("testInteger", "2");
injectedParameters.put("testUnsignedInt", "2");
injectedParameters.put("testString", "injected");
injectedParameters.put("testDateTime", "2018-02-24T10:00:00");
injectedParameters.put("testUnsignedShort", "2");
injectedParameters.put("testDouble", "2.0");

// Creating the loader
IScenarioLoader loader = loaderFactory.createLoader(new FileResourceLocator());
// Load the scenario with the injected parameters
loader.load(messageLogger, injectedParameters);
----

The injected parameter values override the default values in the scenario file.

Please be aware of the following restrictions 

* The injected parameters must be declared globally. Otherwise a warning is issued. 
* The values must be convertible to the target datatype of the declared parameter.
The format must follow the format for XSD datatypes (as in the XML). 
* If conversion fails, an error is issued. 
* Only scenario definitionsdeclare global parameters. It is not useful to declare them for catalogs.

Please see
link:{levelToBaseDir}/java/src/test/java/net/asam/openscenario/v1_0/test/TestInjectedParameters.java[TestInjectedParameters.java] for detailed tests on error handling.

== Getting started on C++
A great source of how to start using the API are the test sources
link:{levelToBaseDir}/cpp/applications/openScenarioTester/V_1_0/src[test sources].

Generally there are two major use cases for using the library. 

* *As a standalone checker*. A command line application that is called to
validate an OpenSCENARIO file. 
* *As an embedded library*. Embedding the programming interface and add read capability to our own application.

=== Standalone checker

To use the library as a standalone program we would typically use the
compiled C++ binary

`/cpp/build/output/Linux/Release/OpenScenarioReaderV_1_0`. 

See the link:{levelToBaseDir}/README.md[README.MD] file in the project root for building instructions.

For example the binary is located in the following directory, dependent
on your development platform: 

* Linux: `./cpp/build/output/Linux/Release/OpenScenarioReaderV_1_0` 
* Windows `./cpp/build/output/x64/Release/OpenScenarioReaderV_1_0`

Navigate your command shell to the appropriate folder above and first
execute the following command on Linux once to tell the runtime system
where to find the dependent libraries:

[source,bash]
----
$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.
----

Then start the OpenScenarioReaderV_1_0 with:

[source,bash]
----
$ ./OpenScenarioReaderV_1_0
----

This will generate the following output:

```
****************************************
* ASAM OpenSCENARIO 1.0 Checker (2020) *
****************************************
OpenScenarioChecker [[{-i <filename>|-d <dirname>} [-p <paramfilename>]] | -v]
Options:
-i  <filename> file to be validated
-d      <directory> directory to be validated
-p  <paramfilename> a file with name/value pairs. One line per name/value pair. tab separated
-v  print program version
```


==== Checking a file

See link:{levelToDocDir}/examples/simpleExample[simpleExample] To test a particular file, e.g. `DoubleLaneChanger.xosc` execute the following command:

[source,bash]
----
$ ./OpenScenarioReaderV_1_0 -i examples/simpleExample/SimpleExample.xosc
----

Result:

```
****************************************
* ASAM OpenSCENARIO 1.0 Checker (2020) *
****************************************
Checking 'examples/simpleExample/SimpleExample.xosc'
Validation succeeded with 0 errors and 0 warnings.
```

A failing validation See link:{levelToDocDir}/examples/defectExample[defectExample]

[source,bash]
----
$ ./OpenScenarioReaderV_1_0 -i examples/defectExample/DefectExample.xosc
----

Result:

```
****************************************
* ASAM OpenSCENARIO 1.0 Checker (2020) *
****************************************
Checking 'examples/defectExample/DefectExample.xosc'
ERROR: Cannot resolve parameter 'DefectParameter' (41,53)
Validation failed with 1 errors and 0 warnings.
```


==== Injecting parameters
~~~~~~~~~~~~~~~~~~~~

It is possible to inject parameters into the ASAM OpenSCENARIO checker.
Use `-p` to specify a filename for the parameters. See
link:{levelToDocDir}/examples/injectedParamsExample[doc/examples/injectedParamsExample]

[source,bash]
----
$ ./OpenScenarioReaderV_1_0 -i examples/injectedParamsExample/InjectedParamsExample.xosc -p examples/injectedParamsExample/params.conf
----

In the parameter file (here `params.conf`) we define name/value pairs.
One line per definition. '#' is used for comments. We use tab as a delimiter between name and value:

```
****************************************
* ASAM OpenSCENARIO 1.0 Checker (2020) *
****************************************
Used Parameters:
    EgoStartS   60
    HostVehicle car_red
    TargetVehicle   car_white
Checking 'examples/injectedParamsExample/InjectedParamsExample.xosc'
Validation succeeded with 0 errors and 0 warnings.
```

[[showing-the-program-version]]
==== Showing the program version

[source,bash]
----
$ ./OpenScenarioReaderV_1_0 -v
----

Result:

```
****************************************
* ASAM OpenSCENARIO 1.0 Checker (2020) *
****************************************
Program version 0.9.0
```

Telling us that this version supports OpenSCENARIO standard 1.0 and the version of the implementation is 0.9.0 . 

=== Embedding the Library 
To use the OpenSCENARIO as an embedded library we use the compiled library `libOpenScenarioLibV_1_0` on Linux and on Windows. Both libraries on Linux as well as on Windows have third party dependencies. 
See the link:{levelToBaseDir}/README.md[README.MD] file in the project root for building instructions. We have the choice to either use the __static version__ or the __shared version__.

* *static version* includes all third party libraries in one monolithic library file
`libOpenScenarioV_1_0.a` on Linux and `libOpenScenarioV_1_0.lib` on
Windows or we build the 
* *shared version* results in shared versions of the third party libraries which have to be linked to
the project, too. Currently these are the two files
`libOpenScenarioV_1_0.so.0.9.0` and `libantlr4-runtime.so.4.8` on Linux
and `libOpenScenarioV_1_0.dll` and `libantlr4-runtime.dll` on Windows.

For both, static and shared version `CMakeLists.txt` template files are already generated. The zip-file `openScenarioV_1_0.zip` contains templates for static and shared builds for both Linux and Windows.

==== Example: checking a single file

When checking a single file with no catalog implications, use the
`XmlScenarioLoaderFactory` to create a loader.

[source,c++]
----
// Creating a message logger to pick up the messages
auto msgLogger = std::dynamic_pointer_cast<NET_ASAM_OPENSCENARIO::IParserMessageLogger>(_messageLogger);
const auto kMessageLogger = std::make_shared<NET_ASAM_OPENSCENARIO::MessageLoggerDecorator>(msgLogger);

// Instantiating the factory
std::string fileName = _executablePath + "/" + kInputDir + "DoubleLaneChanger.xosc";
auto loaderFactory = NET_ASAM_OPENSCENARIO::V_1_0::XmlScenarioLoaderFactory(fileName);

// Creating the loader
auto loader = loaderFactory.CreateLoader(std::make_shared<NET_ASAM_OPENSCENARIO::FileResourceLocator>());

// Loading 
auto openScenario = std::static_pointer_cast<NET_ASAM_OPENSCENARIO::V_1_0::IOpenScenario>
    (loader->Load(kMessageLogger)->GetAdapter(typeid(NET_ASAM_OPENSCENARIO::V_1_0::IOpenScenario).name()));

//Check for errors
if (!kMessageLogger->HasErrors())
{
    // Browse through the results
    auto fileHeader = openScenario->GetFileHeader();
    std::cout << "Major Revision :" << fileHeader->GetRevMajor() << std::endl;
    std::cout << "Minor Revision :" << fileHeader->GetRevMinor() << std::endl;
}
----

==== Example: checking a file and resolve the imports from catalogs

When checking a file and resolve its imports from catalog, use the `XmlScenarioImportLoaderFactory` to create a loader. 
Then the catalog references are resolved and the errors and warnings from the catalog files are picked up in a separate logger.

[source,c++]
----
// Creating a message Logger to pick up the messages
auto messageLogger = std::make_shared<NET_ASAM_OPENSCENARIO::SimpleMessageLogger>(NET_ASAM_OPENSCENARIO::ErrorLevel::INFO);

// create another messageLogger for logging the messages that occur from imported files
auto catalogMessageLogger = std::make_shared<NET_ASAM_OPENSCENARIO::SimpleMessageLogger>(NET_ASAM_OPENSCENARIO::ErrorLevel::INFO);

// Instantiating the factory
NET_ASAM_OPENSCENARIO::V_1_0::XmlScenarioImportLoaderFactory
    loaderFactory(catalogMessageLogger, _executablePath + "/" + kInputDir +
    "simpleImport/simpleImport.xosc");

// Creating the loader with a file resource locator (we are reading directly from a file system)
auto loader = loaderFactory.CreateLoader(std::make_shared<NET_ASAM_OPENSCENARIO::FileResourceLocator>());

// Loading the scenario
auto openScenario = std::static_pointer_cast<NET_ASAM_OPENSCENARIO::V_1_0::OpenScenarioImpl>(loader->Load(messageLogger)
    ->GetAdapter(typeid(NET_ASAM_OPENSCENARIO::V_1_0::OpenScenarioImpl).name()));

// Get the list of scenario objects
auto scenarioObjects = openScenario->GetOpenScenarioCategory()->GetScenarioDefinition()
    ->GetEntities()->GetScenarioObjects();

for (auto&& scenarioObject : scenarioObjects) 
{
    // Access the object that is imported from a catalog with the name "Ego"
    if (scenarioObject->GetName() == "Ego") 
    {
        // Get the catalog reference
        auto catalogReference = scenarioObject->GetEntityObject()->GetCatalogReference();

        if (catalogReference && catalogReference->GetEntryName() == "car_white")
        {
            auto catalogRef = catalogReference->GetRef();
            // Now check the type.
            if ( NET_ASAM_OPENSCENARIO::V_1_0::CatalogHelper::IsVehicle(catalogRef))
            {
                auto vehicle = NET_ASAM_OPENSCENARIO::V_1_0::CatalogHelper::AsVehicle(catalogRef);
                // Now you can access the resolved vehicle
                auto axles = vehicle->GetAxles();
                // get the additonal axles
                auto additionalAxles = axles->GetAdditionalAxles();
                if (additionalAxles.empty()) 
                {
                    std::cout << "Ego has 2 axles (front, rear)";
                }
                else 
                {
                    std::cout << "Ego has " << 2 + additionalAxles.size()
                        << " axles (front, rear and "
                        << additionalAxles.size()
                        << " addtional axles";
                }
            }
        }
    }
}
----

==== Example: checking a file and inject parameter values from outside

OpenSCENARIO provide a mechanism to declare global parameters , right after the `FileHeader` element:

[source,xml]
----
<OpenSCENARIO>  
  <FileHeader revMajor="1" revMinor="0" date="2020-07-24T10:00:00" description="Sample Scenario - parameter" author="ASAM"/>
  <ParameterDeclarations>
      <ParameterDeclaration name="testBoolean" value="false" parameterType="boolean"/>
      <ParameterDeclaration name="testInteger" value="1" parameterType="integer"/>
      <ParameterDeclaration name="testUnsignedInt" value="1" parameterType="unsignedInt"/>
      <ParameterDeclaration name="testString" value="testString" parameterType="string"/>
      <ParameterDeclaration name="testDateTime" value="2017-02-24T10:00:00" parameterType="dateTime"/>
      <ParameterDeclaration name="testUnsignedShort" value="5" parameterType="unsignedShort"/>
      <ParameterDeclaration name="testDouble" value="1.1" parameterType="double"/>
  </ParameterDeclarations>
</OpenSCENARIO>
----

When loading a scenario, the API allows to override the default values from outside. We use a name value map and hand it over as an argument to the `load` method.

[source,c++]
----
std::map<std::string, std::string> injectedParamters;
injectedParamters.emplace("testBoolean", "true");
injectedParamters.emplace("testInteger", "2");
injectedParamters.emplace("testUnsignedInt", "2");
injectedParamters.emplace("testString", "injected");
injectedParamters.emplace("testDateTime", "2018-02-24T10:00:00");
injectedParamters.emplace("testUnsignedShort", "2");
injectedParamters.emplace("testDouble", "2.0");

// Creating the loader with a file resource locator and the injected parameters
auto loaderFactory = NET_ASAM_OPENSCENARIO::V_1_0::XmlScenarioLoaderFactory(filename);
auto loader = loaderFactory.CreateLoader(std::make_shared<NET_ASAM_OPENSCENARIO::FileResourceLocator>());
auto ptr = loader->Load(_messageLogger, injectedProperties);
----

The injected parameter values override the default values in the scenario file.

Please be aware of the following restrictions 

* The injected parameters must be declared globally. Otherwise a warning is issued. 
* The values must be convertible to the target datatype of the declared parameter. The format must follow the format for XSD datatypes (as in the XML). 
* If conversion fails, an error is issued. 
* Only scenario definitions declare global parameters. It is not useful to declare them for catalogs.

Please see link:{levelToBaseDir}/cpp/applications/openScenarioTester/v_1_0/src/TestInjectedParameters.h[TestInjectedParameters.h] for detailed tests on error handling.

== General archtiectural aspects
This article is about some fundamental aspects in the API's artchitecture. It may help to understand the intention behind the design decisions and also gives you a entry point in coding and integration
issues.

=== Generative approach
The backbone of the OpenSCENARIO API is represented by classes, enumerations and interfaces generated from a released OpenSCENARIO model. Therefore, the API is tightly coupled to the model.

This paradigm makes the API highly consistent to the UML model. If we have a class in the UML model called `LaneChangeTarget` we will find a corresponding interface `ILaneChangeTarget` in the package `net.asam.openscenario.v1_0.api`. If this class has a property called `relativeTargetLane`, we can be sure that there is a corresponding getter in the interface which is called `getRelativeTargetLane`. Consistently, if this model property `relativeTargetLane` is of the model type `RelativeTargetLane` the getter will return a result of `IRelativeTargetLane`.

As an example: `ILaneChangeTarget`

[source,java]
----
/**
 * This is a automatic generated file according to the OpenSCENARIO specification version 1.0
 * <p>
 * From OpenSCENARIO class model specification:
 * Defines the target lane of the LaneChangeAction.
 * 
 * @author RA Consulting OpenSCENARIO generation facility
*/
public interface ILaneChangeTarget {

    /**
     * From OpenSCENARIO class model specification:
     * Lane change direction relative to entity's lane.
     * @return value of model property relativeTargetLane
    */
    public IRelativeTargetLane getRelativeTargetLane();

    /**
     * From OpenSCENARIO class model specification:
     * Lane change target lane number.
     * @return value of model property absoluteTargetLane
    */
    public IAbsoluteTargetLane getAbsoluteTargetLane();
}
----

This pattern is is applied to all classes, interfaces and enumerations of the model. Not even that, also the descriptions in the classes, interfaces, enumerations and properties are consistent with the model annotations from UML. The documentation in the javadoc is fully in synch with the annotations in the UML model. So, the generative approach offers great consistency with a single point of truth in the UML model rather than an imaginary 'copy and paste' consistency.

This leads to great efficiency and a clean architecture where more than 95% of the source code is automatically generated. This elevates productivity with about 80,000 lines of code created for the java project and allows transfer to other platforms like C++. Transfer comes with a fair amount of initial work as well as for keeping the platforms in synch over time.


=== Don't-edit-generated-files policy
All generated files are located in the `generated` folder. These files must not be edited manually. Moreover it is recommended to see RA Consulting GmbH or ASAM e.V. for changes in the generated code.

=== Generative approach and product dimensions

Product dimensions can lead to a high amount of work for creating and maintaining product lines. For example a dimension could be the _programming platform_. In order to provide a product for different programming platforms, there might be a need for a single source of code and additional adapters to other platforms. Java and C++ might be coupled through JNI etc. Practically, this is often very painful. Java is not the #1 platform on desktop UI systems whereas C++ is often not allowed to run on backend servers. Using integrated java code in a C++ environment or using C++ in a java environment often feels unhandy and end up in the worst from both world: Our code is dependent on a java VM as well as on the binary platform. One solution is to maintain a common architecture with a single model and generators that take minimal amount to deploy the architecture to the different platforms. This is exactly where a generative approach has its strengh and an efficient workflow is able to produce and to maintain source code. Other product dimensions are _versions_ (1.0, 1.1, 2.0 etc.), operating systems (Linux, Mac, Windows), deployment platforms (Server, desktop, embedded) etc. In these multidimensional space (e.g. providing a native lib for mac and version 1.0) a generative approach is one way to manage dependencies and minimize the amount of work.

=== Versioning as a product dimension

When supporting a standard, versioning is a product dimension that should be supported. Since we cannot look in the future and foresee the changes, we still can be sure that changes happen. So, the worst case is not to be faced with incompatible changes of a new version, but a dead-end standard that does suffer from a bad change management. Therefore, even when our world is "version 1.0 only" right at that moment, we better have strategies for versioning, migration etc.. Change management is considered an important architectural aspect.

=== Providing compile time support

As described above, if code is generated consistently with the UML model, we have everything ready when using the API at compile time. We can use the classes, the interfaces and the methods that are provided right off-the-shelf. We may make use of the documentation, code completion and the compiler detects misspellings and inconsistencies right before we are able to run a error prone program. So, when we follow the paradigm that costs for error detection and fixes rise extremely along the development cycle of a software, it is best to detect our errors as soon as we write it (low fixing costs) rather than after having the software delivered to the customer (high fixing costs). In this sense, generating concrete artifacts, like classes, enumerations, interfaces and methods is not only consistent with the UMl model (single source of domain knowledge) but also a great way for managing quality and costs. So, let the compiler be you friend.

=== Version management and namespaces

As said `versioning` is a dimension in our software product line and we better have strategies to support different versions of the standard with our software. Since we cannot rely on downward compatibility, there are different aspects when providing compatibility to multiple versions. E.g. to declare artifacts as _deprecated_ or we transparently map new versions to older versions. The OpenSCENARIO API relies heavily on namespaces for different versions. They provide maximum separation among the different version of the standard. In many cases data structures change. For example an `EntityAction` in version 1.0 might have some other semantic as `EntityAction` in version 2.0 (as said: we cannot foresee it). The OpenSCENARIO API's policy is that the complete set of artefacts (interfaces, classes, enumerations) are created for every single version. This means, that there is a `net.asam.openscenario.v1_0.api.IEntityAction` and another interface `net.asam.openscenario.v2_0.api.IEntityAction`. So, every version specific set of classes, enumeration and interfaces provided by the API is self-containted and completely independent from other versions. This has benefits and drawbacks. A benefit, as said, is that the different versions are greatly decoupled. Old versions are very stable and do not change over time. E.g. once released, `net.asam.openscenario.v1_0.api.IEntityAction` will not change. This means the domain knowledge, models and the API itself are snapshots of a released standard. As the domain knowledge evolves, this explicitly results in a new version of the standard, a new version of the model, and a new version of the API.


=== Drawback of separating versions

The drawback is that with every new version, we have to deal with a complete new set of artefacts. Once we have used `net.asam.openscenario.v1_0.api.IEntityAction` in our program and the semantics have not changed for version 2.0, we don't wanna integrate `net.asam.openscenario.v2_0.api.IEntityAction` in the same way. And it's even worse when we have a new set of 200+ interfaces. As we expect that there *are only a few semantic changes*, let's say in 10% of the classes, integrating a complete set of new classes might be an effort that does not justify the amount of work.


=== Compile time support and generic Interface

As said, the API propagates a clean separation of versions which results in different set of artefacts (classes, enumerations, interfaces) for each version. On the other hand, the API respects the need on being flexible at runtime and clearly identifies the extra amount of work that might result from integrating a whole new set of version dependent artefacts. Therefore, every class additionally supports the interface `IOpenScenarioFlexElement`. This interface itself is independent from a version and might be used when dealing with different version dependent sets is unhandy or inappropriate. The functions of these interface are usually used with version dependent keys which might be still supported in the future. If this is the case, they imply a minimum amount of work for integrating a new version. Especially, when only a few changes are made from version to version. This, of course, comes on the expense of compile time support and can easily lead to runtime errors. So, using this interface, we should pay extra attention to changes because the compiler can't.

The example shows the usage of the interface: This first line uses the compile time and type-safe interface `IFileHeader`

[source,java]
----
net.asam.openscenario.v1_0.api.IFileHeader fileHeader = openScenario.getFileHeader();
----

The next line uses the flexible interface.

[source,java]
----
IOpenScenarioFlexElement flexElement=((IOpenScenarioFlexElement) openScenario).getChildElement(OscConstants.ELEMENT__FILE_HEADER);
----

So, these two methods deliver the exact same object instance when applied to the same parent object. The main and important difference is that the second example could also return a `net.asam.openscenario.v1_2.api.IFileHeader` in the future, if `OscConstants.ELEMENT__FILE_HEADER` is still supported for version 1.2.

The next lines of code are still valid when the uml class `FileHeader` does not change from version 1.0 to version 1.2.

[source,java]
----
IOpenScenarioFlexElement flexElement= openScenario.getOpenScenarioFlexElement().getChildElement(OscConstants.ELEMENT__FILE_HEADER);
Date date  = flexElement.getDateTimeProperty(OscConstants.ATTRIBUTE__DATE);
Integer minorRef = flexElement.getUnsignedShortProperty(OscConstants.ATTRIBUTE__REV_MINOR);
Integer majorRef = flexElement.getUnsignedShortProperty(OscConstants.ATTRIBUTE__REV_MAJOR);    
String description = flexElement.getStringProperty(OscConstants.ATTRIBUTE__DESCRIPTION);    
----

=== Alternatives for version management
Consider to use the https://en.wikipedia.org/wiki/Adapter_pattern[Adapter-pattern] before you integrate the API in your source code. As an alternative, contibute a set of adapters to the project in the future and make the adopters available for all OpenSCENARIO programmers.

== Tutorial on checker rules
This tutorial assists when implementing our own checker rules and apply
them to a loaded tree. It applies to the java platform and shows the
overall principles. It can easily be transferred to other supported
programming platform. 

=== Checker rules 
Checker rules are constraints on model object instances that are either defined implicitly in the standard or can be adopted to our own needs. Whenever we want to ensure authoring rules and guidelines that apply for our company or our partners, the checker rules API is a good choice to implement our own validation. With a minimal effort, we will implement our own checker rules, add it to a checker and start the validation of our loaded tree. A message logger will pick up any violation to our given rules with the exact location pointing to the original file. This tutorial will show how to write our own checker rules.

=== Checker rules API

The backbone of the checker rules API is the interface `ICheckerRule`. By implementing this interface we write our own checker rules:

[source,java]
----
/**
 * This represents a rule that can be applied to any model object instance.
 * It implements the command pattern. The rule is added to the type and applyRule 
 * is executed during runtime.
 * 
 * @author Andreas Hege - RA Consulting
 * @param <T> An object type that is validated
 *
 */
public interface ICheckerRule<T extends IOpenScenarioModelElement > {
   /**
   * Applies validation to a specific type.
   * @param messageLogger logger to pick up the violations
   * @param object that will be subject of validation
   */
   public void applyRule(IParserMessageLogger messageLogger, T object);
}
----

==== First example

Our first example will show, how to ensure that the major revision is always 1 and the minor revision is always 0. If this rule is violated, a warning is issued.

===== Implementing the ICheckerRule interface

The first step is to define a class `VersionCheckerRule` that implements the `ICheckerRule` with the generic type `IFileHeader`. `IFileHeader` is the model type where to access the `majorRev` and the `minorRev`property.

As we want to use this class for any combination of expected major revisions and minor revisions, we hand over the expectes major revison and the expected minor revision to the constructor and store them in the instance.

[source,java]
----
public class VersionCheckerRule implements ICheckerRule<IFileHeader>
{
  private int majorRev;
  private int minorRev;
  
  /**
   * @param majorRev The expected major revision
   * @param minorRev The expected minor revision
   */
  public VersionCheckerRule(int majorRev, int minorRev)
  {
    super();
    this.majorRev = majorRev;
    this.minorRev = minorRev;
  }
  ```
}
----

The class must implement the `applyRule` method. Please note that the generic parameter type of object is now realized with the type `IFileHeader`.

[source,java]
----
@Override
public void applyRule(IParserMessageLogger messageLogger, IFileHeader object)
{
...
}
----

At this point, we are ready to implement our checks. First, let's get the major revision and the minor revision from the `object` and store them in local variables:

[source,java]
----
@Override
public void applyRule(IParserMessageLogger messageLogger, IFileHeader object)
{
    Integer revMajor = object.getRevMajor();
    Integer revMinor = object.getRevMinor();
    ...
}
----

Now compare them with the expected values:

[source,java]
----
@Override
public void applyRule(IParserMessageLogger messageLogger, IFileHeader object)
{
    Integer revMajor = object.getRevMajor();
    Integer revMinor = object.getRevMinor();

    if (revMajor == null  || 
        revMinor == null || 
        revMajor.intValue() != this.majorRev || 
        revMinor.intValue() != this.minorRev)
    {
      ...
      // Issue a warning here

    }
}
----

When we issue a warning, we have the great possibility to add locations. The user can then trace the warning back to a line and to a column of the original file. So let's get the location from the `object`. We do this by requesting an `ILocator` adapter from the `object`. If an `ILocator` adapter is supported, we would get an instance of `ILocator`.1

[source,java]
----
public void applyRule(IParserMessageLogger messageLogger, IFileHeader object)
{
    Integer revMajor = object.getRevMajor();
    Integer revMinor = object.getRevMinor();

    if (revMajor == null  || revMinor == null || revMajor.intValue() != this.majorRev || revMinor.intValue() != this.minorRev)
    {
      ...
      ILocator locator = (ILocator) object.getAdapter(ILocator.class);
      Textmarker textmarker = null;
      
      if (locator != null)
      {
          textmarker = locator.getStartMarker();
          
      }
      // Issue a warning here
     }
}
----

1Please note, there might be objects that do not support the `ILocator` adapter. E.g. when the scenario is loaded from a binary file instead of an XML file. In this case, no text line information and no column information would be available. If we are loading our files from XML, we do not have to pay attention to this fact.

The only thing that we are still missing is the warning to be issued. We are adding an instance of a `FileContentMessage` with a message, an error level and a textmarker.

[source,java]
----
public void applyRule(IParserMessageLogger messageLogger, IFileHeader object)
{
    Integer revMajor = object.getRevMajor();
    Integer revMinor = object.getRevMinor();

    if (revMajor == null  || revMinor == null || revMajor.intValue() != this.majorRev || revMinor.intValue() != this.minorRev)
    {
      ...
      ILocator locator = (ILocator) object.getAdapter(ILocator.class);
      Textmarker textmarker = null;
      
      if (locator != null)
      {
          textmarker = locator.getStartMarker();
          
      }
      // Issue a warning here
      messageLogger.logMessage(new FileContentMessage("Major revision and minor revision are expected to be "+majorRev+" and "+minorRev ,                        
                                                       ErrorLevel.WARNING, 
                                                       textmarker
                                                      ));
     }
}
----

That's it. Our checker is now ready to be used.

===== How to apply rules during runtime

With our checker ready to be used, we can apply the checker rule to a loaded `IOpenScenario` tree. Please see <<Getting started on Java>> on how a tree is loaded from a file.

[source,java]
----
// the root of the tree is available in the IOpenScenario openScenario variable
// Instantiate a checker now
ScenarioCheckerImpl scenarioChecker = new ScenarioCheckerImpl();

// The scenario checker provided a method for every model type (here IFileHeader) to add CheckerRule       
scenarioChecker.addFileHeaderCheckerRule(new VersionCheckerRule(1, 0));

// Create a message logger to pick up the messages
SimpleMessageLogger simpleMessageLogger = new SimpleMessageLogger(ErrorLevel.INFO);

// Now call the checkScenario method to check the tree
scenarioChecker.checkScenario(simpleMessageLogger, openScenario);

// Now check the picked up messages
for (FileContentMessage message : simpleMessageLogger.getMessages())
{
  // do something with the messages that are picked up during the check
}
----

We do not need to traverse through the tree and search for instances. The scenario checker sequentially applies the rule to any instance of the designated type we realized in our checker rule (here `IFileHeader`). In our example it is obvious that only one instance of `IFileHeader` exists in the tree. For other types like `IAct`, `IEvent` etc. many instances may available in the tree and every instance is checked.

==== Example: ensure "Ego" is defined in the scenario.

This example shows how to ensure that a scenario object with the name "Ego" is defined. Otherwise an error is issued. There is definitly a little bit more work to do here, but it should be straight forward after completing the example above. Obviously `IEntities` (with its instances of `IScenarioObject`) is the right type to check.

[source,java]
----
public class EgoCheckerRule implements ICheckerRule<IEntities>
{
...
}
----

The `applyRule` looks like this:

[source,java]
----
@Override
 public void applyRule(IParserMessageLogger messageLogger, IEntities object)
 {
    boolean isEgoDefined = false;

    // We are adding the validation code here
    List<IScenarioObject> scenarioObjects = object.getScenarioObjects();
    if (scenarioObjects != null && !scenarioObjects.isEmpty())
    {
      for (IScenarioObject scenarioObject : scenarioObjects)
      {
        if (scenarioObject.getName().toLowerCase().contentEquals("ego"))
        {
          isEgoDefined = true;
          break;
        }
      }
    }

    if (!isEgoDefined)
    {
      ILocator locator = (ILocator) object.getAdapter(ILocator.class);
      Textmarker textmarker = null;

      if (locator != null)
      {
        textmarker = locator.getStartMarker();

      }
      messageLogger.logMessage(new FileContentMessage("No ego vehicle defined", ErrorLevel.ERROR, textmarker));
    }
}
----

The rule is added by

[source,java]
----
scenarioChecker.addEntitiesCheckerRule(new EgoCheckerRule());
----


=== Further checker rules

As we've seen in the examples, many useful checkings may apply to an OpenSCENARIO model instance. Unfortunately, OpenSCENARIO defines relatively few constraints in the model or in the user guide (repectively there is no explicit checker rule concept but a lot of implicit constraints in the user guide). Nevertheless, some checkings are essential and the checker rule API is the tool to ensure these rules.

Some examples: - Ensure a naming convention for the object names (e.g. ensure camel-case notation) - Ensure unique naming in a list of objects (e.g. unique names for scenario objects, so "ego" cannot be defined twice. Unique names of evens in a maneuver, etc.) - Other constraints that are not exlicitly defined in the standard but reduce ambiguity. 

=== Range checker rules - Built-in validation for ranges 
Defining a primitive datatype like `unsigned int` or `double` does already represent an important constraint when a property of a class is defined. Many properties have further range constraints that are documented in the annotations of the properties e.g. the property `delay` in the model class `Condition` must be zero or greater than zero. The annotation says about the property `delay` that is of type `double`: 'Time elapsed after the edge condition is verified, until the condition returns true to the scenario. Unit: s; Range: [0..inf[.' The OpenSCENARIO API defines all the range properties as built-in checker rules that can be applied by any user of the library.

Please see these corresponding classes if you are interested in the details:

* net.asam.openscenario.v1_0.checker.range.RangeCheckerHelper;
* net.asam.openscenario.v1_0.test.TestRangeChecker

== Continuous integration
These sections concern __Continuous Integration__ (CI)

* <<Continuous integration checker features>>
* <<Adding a github action>>

=== Continuous integration checker features

Like in code projects, testing the validity, the quality and the integrity of scenario file regularly and automatically is a great idea. Continuous Integration (CI) features of the ASAM OpenSCENARIO API support the customized and automated testing of OpenSCENARIO files.

OpenSCENARIO API CI features support different and various aspected of validation and automation. The core consists of a customized executable that is able to check directories for scenario files. This executable may be integrated in various CI environments like:

* Github actions
* Jenkins integrations
* docker containers
* ...


==== Running the checker
`net.asam.openscenario.v1_0.main.OpenScenarioCiChecker`is an executable java class for continuous integration checks. It basically checks a set of directories and exits with a code that is unequal to zero, when the validation of any checked file fails.

(This example is for the Windows command line, please use linux specific
  commands when running from linux)

* Follow the link:{levelToBaseDir}/README.md#java[Building the Sources] instructions.
* Change to the `target` folder of the project:
+
```
d:\clonedProjectFolder\java>cd target
```

* Add the installed jar file to the classpath.
+
```
d:\clonedProjectFolder\java\target>set CLASSPATH=net.asam.openscenario.v1_0.reader-X.Y.Z-jar-with-dependencies.jar
```
* Start the executable
+
Start executing the checker without any command line argument.
+
```
d:>java net.asam.openscenario.v1_0.main.OpenScenarioCiChecker 

*******************************************
* ASAM OpenSCENARIO 1.0 CI Checker (2020) _
_****************************************** Usage: [[-conf -d ]| -v]
Options: 
-conf configuration file 
-d base directory for checks 
-v print program version 
``` 
+
This gives you an idea about the expected program
arguments
+ 
**-conf ** The name of the configuration file, where you specify subdirectories,
suffixes of the files to be checked, injected parameters and customer
defined checker rules.
+
**-d ** The base directory to be checked.
+
**-v** Printing out the version.

===== Exit codes


The following exit codes are issued: 0 - Success, Every check was
successful. +
1 - Error occured, either errors with any configuration or validation
failed for any of the tested files. +
2 - Empty command line. +
3 - Version printed (-v argument).

==== Configuration parameters

The configuration is specified in a yaml formatted file. The following parameters are expected:

*directoryList* +
A list of directories that hold the sceanrio files to check. Each directory must be a sub-directory of the base directory specified in the command line parameter `-d <basedir>`. Default value when omitted: All files in the base directory are checked recursively.

Example:

[source,yaml]
----
directoryList:
  - directoryToCheck
----

*suffixList* +
A list of suffixes to filter the scenario files to be checked. Default value when omitted: all files are included

Example:

[source,yaml]
----
suffixList:
  - xosc
  - osc
----

*parameterMap* +
A list of name value pairs that define the parameters that are injected in scenario files (not used for catalogs, see <<Injecting parameters>>. Default value when omitted: No parameter is injected.

Example:

[source,yaml]
----
parameterMap:
  exampleBoolean: true
  exampleInteger: 2
  exampleUnsignedInt: 2
  exampleString: injected
  exampleDateTime: 2018-02-24T10:00:00
  exampleUnsignedShort: 2
  exampleDouble: 2.0
----

*checkerRuleFactoryClassName* +
The class name of the `IScenarioCheckerFactory` implementation to load
at runtime. The created checker is applied to the loaded scenario.
Default value when omitted: No customized checker is involved.

Example:

[source,yaml]
----
checkerRuleFactoryClassName: net.asam.openscenario.checker.ExampleScenarioCheckerFactory
----

*handleWarningsAsErrors* 
If this flag set to `true` warnings will result in exit code 1 which indicates an error. Otherwise, warnings will not automatically lead to validation errors. Default value when omitted: false

Example:

[source,yaml]
----
handleWarningsAsErrors: true
----

==== Simple example
A simple example is listed link:{levelToDocDir}\examples\ciExampleSimple[here]. It contains a simple configuration file and a directory to be checked. The directory has one scenario and a couple of catalogs in its sub-dircetories.

This is the file structure of the example.

```
|-ciExampleSimple
  |- directoryToCheck
    |- Catalogs
      |- DriverCatalog.xosc
      |- RouteCatalog.xosc
      |- VehicleCatalog.xosc
    |- OpenSCENARIO.xsd
    |- simpleImport.xosc
  |- conf.yml
```

This is the configuraton file:

[source,yaml]
----
directoryList:
  - directoryToCheck

suffixList:
  - xosc
  - osc
 
parameterMap:
  exampleBoolean: true
  exampleInteger: 2
  exampleUnsignedInt: 2
  exampleString: injected
  exampleDateTime: 2018-02-24T10:00:00
  exampleUnsignedShort: 2
  exampleDouble: 2.0
----

===== Running the example

(This is shown using the windows command line).

* Follow the
link:{levelToBaseDir}/README.md#java[Building the Sources] instructions.
* Change to the `target` folder of the project:
+
```
d:\clonedProjectFolder\java>cd target
```
* Add the installed jar file to the classpath.
+
```
d:\clonedProjectFolder\java\target>set CLASSPATH=net.asam.openscenario.v1_0.reader-X.Y.Z-jar-with-dependencies.jar
```
* Start the executable
+
```
d:\clonedProjectFolder\java\target>java net.asam.openscenario.v1_0.main.OpenScenarioCiChecker  -conf "../../doc/examples/ciExampleSimple/conf.yml" -d "../../doc/examples/ciExampleSimple"
```
+
This will give you the following output: 
```
*******************************************
* ASAM OpenSCENARIO 1.0 CI Checker (2020) 
****************************************** 
Used Parameters:
exampleBoolean true 
exampleDateTime 2018-02-24T10:00:00 
exampleDouble 2.0 
exampleInteger 2 
exampleString injected 
exampleUnsignedInt 2
exampleUnsignedShort 2 

Checking '..\..\doc\examples\ciExampleSimple\directoryToCheck\Catalogs\DriverCatalog.xosc' 
Validation succeeded with 0 errors and 0 warnings.

Checking '..\..\doc\examples\ciExampleSimple\directoryToCheck\Catalogs\RouteCatalog.xosc' 
Validation succeeded with 0 errors and 0 warnings.

Checking '..\..\doc\examples\ciExampleSimple\directoryToCheck\Catalogs\VehicleCatalog.xosc' 
Validation succeeded with 0 errors and 0 warnings.

Checking '..\..\doc\examples\ciExampleSimple\directoryToCheck\simpleImport.xosc'
Validation succeeded with 0 errors and 0 warnings

Exit code: 0

```
==== Advanced example: Adding customized checker rules
An advanced example is listed link:{levelToDocDir}\examples\ciExampleSimple[here]

This is the file structure of the example (Like the simple example added src/net/asam/opensceanrio/checker/ExampleScenarioCheckerFactory.java).

```
|-ciExampleSimple
  |- directoryToCheck
    |- Catalogs
      |- DriverCatalog.xosc
      |- RouteCatalog.xosc
      |- VehicleCatalog.xosc
    |- OpenSCENARIO.xsd
    |- simpleImport.xosc
  |- src
    |- net
      |- asam
        |- openscenario
          |- checker
            |- ExampleScenarioCheckerFactory.java
    |- OpenSCENARIO.xsd
    |- simpleImport.xosc
  |- conf.yml
```

This is the configuraton file. We added the `checkerRuleFactoryClassName` 

[source,yaml]
----
directoryList:
  - directoryToCheck

suffixList:
  - xosc
  - osc
 
parameterMap:
  exampleBoolean: true
  exampleInteger: 2
  exampleUnsignedInt: 2
  exampleString: injected
  exampleDateTime: 2018-02-24T10:00:00
  exampleUnsignedShort: 2
  exampleDouble: 2.0

checkerRuleFactoryClassName: net.asam.openscenario.checker.ExampleScenarioCheckerFactory
handleWarningsAsErrors: true
----

===== Implementation

The implementation is very easy. You have to implement the `IScenarioCheckerFactory` interface and populate the `create()` method:

[source,java]
----
package net.asam.openscenario.checker;

import net.asam.openscenario.v1_0.checker.IScenarioChecker;
import net.asam.openscenario.v1_0.checker.IScenarioCheckerFactory;

public class ExampleScenarioCheckerFactory implements IScenarioCheckerFactory{

  @Override
  public IScenarioChecker create() {
    return null;
  }

}
----

First, add an instance of `ScenarioCheckerImpl`

[source,java]
----
public class ExampleScenarioCheckerFactory implements IScenarioCheckerFactory{

  @Override
  public IScenarioChecker create() {
    ScenarioCheckerImpl scenarioCheckerImpl = new ScenarioCheckerImpl();
    return scenarioCheckerImpl;
  }

}
----

Now, we add a customer defined checker. We are using the example `VersionChecker` that is part of the delivery and explained in <<Tutorial on checker rules>>. It simply checks the minor revision and the major revision of the
standard.

[source,java]
----
public class ExampleScenarioCheckerFactory implements IScenarioCheckerFactory{

  @Override
  public IScenarioChecker create() {
    ScenarioCheckerImpl scenarioCheckerImpl = new ScenarioCheckerImpl();
    scenarioCheckerImpl.addFileHeaderCheckerRule(new VersionCheckerRule(1, 0));
    return scenarioCheckerImpl;
  }

}
----
===== Running the example
(This is shown using the windows command line).

* Follow the link:{levelToBaseDir}/README.md#java[Building Sources] instructions.
* Change to the `target` folder of the project:
+
```
d:\clonedProjectFolder\java>cd target
```
* Make a directory for the compiled code
+
```
mkdir "..\..\doc\examples\ciExampleCustomChecker\classes"
```
* Add the installed jar file to the classpath.
+
```
d:\clonedProjectFolder\java\target>set CLASSPATH=net.asam.openscenario.v1_0.reader-X.Y.Z-jar-with-dependencies.jar
```
* Compile the code
+
```
javac  ..\..\doc\examples\ciExampleCustomChecker\src\net\asam\openscenario\checker\ExampleScenarioCheckerFactory.java -d ..\..\doc\examples\ciExampleCustomChecker\classes
```
* Add the compiled class to the classpath
+
```
set CLASSPATH=%CLASSPATH%;..\..\doc\examples\ciExampleCustomChecker\classes
```
* Start the executable
+
```
d:\clonedProjectFolder\java\target>java net.asam.openscenario.v1_0.main.OpenScenarioCiChecker  -conf "../../doc/examples/ciExampleCustomChecker/conf.yml" -d "../../doc/examples/ciExampleCustomChecker"
```
+
Now see the checker included in your validation:

```
*******************************************
* ASAM OpenSCENARIO 1.0 CI Checker (2020) *
*******************************************
Used Parameters:
        exampleBoolean  true
        exampleDateTime 2018-02-24T10:00:00
        exampleDouble   2.0
        exampleInteger  2
        exampleString   injected
        exampleUnsignedInt      2
        exampleUnsignedShort    2
Checking '..\..\doc\examples\ciExampleCustomChecker\directoryToCheck\Catalogs\DriverCatalog.xosc'
WARNING: Major revision and minor revision are expected to be 1 and 0 (19,2)
Validation succeeded with 0 errors and 1 warnings.

Checking '..\..\doc\examples\ciExampleCustomChecker\directoryToCheck\Catalogs\RouteCatalog.xosc'
WARNING: Major revision and minor revision are expected to be 1 and 0 (19,2)
Validation succeeded with 0 errors and 1 warnings.

Checking '..\..\doc\examples\ciExampleCustomChecker\directoryToCheck\Catalogs\VehicleCatalog.xosc'
WARNING: Major revision and minor revision are expected to be 1 and 0 (19,2)
Validation succeeded with 0 errors and 1 warnings.

Checking '..\..\doc\examples\ciExampleCustomChecker\directoryToCheck\simpleImport.xosc'
WARNING: Major revision and minor revision are expected to be 1 and 0 (19,2)
Validation succeeded with 0 errors and 1 warnings.

Exit code: 1
```

For all the files the checker detects a warning:

```
Major revision and minor revision are expected to be 1 and 0 (19,2)
```

due to the outdated version 0.9 that is still defined in the files:

[source,xml]
----
<FileHeader revMajor="0" revMinor="9" date="2017-06-09T10:00:00" description="Cut-in" author="SimS"/>
  
----

This is the result of the included customized checker.

Please mention that the exit code is 1, as we defined
`handleWarningsAsErrors: true` in the configuration file.


=== Adding a github action

* A github action based on version OpenSCENARIO API 0.9.0 is available
on the
https://github.com/marketplace/actions/openscenario-checker-action[github
marketplace]
* Follow the instructions on the
https://github.com/marketplace/actions/openscenario-checker-action[github
marketplace]
* Start integration with this
https://github.com/ahege/opensceanrio.ci.example.test[template
repository].
* See
https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-from-a-template[more
on template repositories]

== Konwn issues
A provided list with the known issues and possible enhancements. 

* *I18n* Currently, the messages that are issued are hardcoded on the
basis of the english language. A i18n concept could outsource the
messages to provide support for different languages. 
* *Resolving object references* Though the framework is ready for that, the objects
referenced from other objects are not resolved yet. This has two
reasons. The first one is simply the time to invest. For any of the
types a seperate resolution strategy must be implemented. Second, the
general resolving strategy is still a little bit unclear. See '3.1.2
Naming' in the 'OpenSCENARIO User-Guide 1.0'. With unresolved
references, the method `getTargetObject` of the interface
`INamedReference` will always return `null`. Of cource, you can still
use the name that represents the reference when calling `getNameRef`. 
* *Supporting more programming platforms* As writing this, the C++ has
just been added. We think it is good idea to add further platforms like
Python. 
* *Reading from zipped files* Though the standard does not
explicitely mention this, we think it is a great idea to pack the
scenario file and its dependendent catalogs in a self-contained
zip-archive. The API allows great support for that by providing the
`IResourceLocator` interface. The
`net.asam.openscenario.loader.ZipResourceLocator` is in a incubation
status.
